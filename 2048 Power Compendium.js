/* There are secrets hidden in the Compendium. If you want to find those secrets legitimately, I'd recommend not looking
 at the code. If you don't know whether you've found all the secrets yet, then you have not. */

//Opening setup (the code that executes on its own)
let width = 4; let height = 4; let min_dim = 2; //width and height are the dimensions of the grid, min_dim doesn't really do anything other than set defaults for certain modifiers
let hexagonal = false; //If this is true, the grid is hexagonal instead of square
let TileNumAmount = 1;
let TileTypes = [[[0], 1, "#ffffff", "#776e65"], [[1], 2, "#f9eee3", "#776e65"], [[2], 4, "#ede0c8", "#776e65"], [[3], 8, "#f2b179", "#f9f6f2"],
[[4], 16, "#f59563", "#f9f6f2"], [[5], 32, "#f67c5f", "#f9f6f2"], [[6], 64, "#f65e3b", "#f9f6f2"], [[7], 128, "#edcf72", "#f9f6f2"],
[[8], 256, "#edcc61", "#f9f6f2"], [[9], 512, "#edc850", "#f9f6f2"], [[10], 1024, "#edc53f", "#f9f6f2"], [[11], 2048, "#edc22e", "#f9f6f2"],
[[12], 4096, "#f29eff", "#f9f6f2"], [[13], 8192, "#eb75fd", "#f9f6f2"], [[14], 16384, "#e53bff", "#f9f6f2"], [[15], 32768, "#bd00db", "#f9f6f2"],
[[16], 65536, "#770089", "#f9f6f2"], [[17], 131072, "#534de8", "#f9f6f2"], [[18], 262144, "#2922e1", "#f9f6f2"], [[19], 524288, "#0a05b6", "#f9f6f2"],
[true, [2, "^", "@This 0"], ["@HSLA", [-15, "*", "@This 0", "+", 520], 100, [0.9, "^", ["@This 0", "-", 20], "*", 36], 1], "#f9f6f2"]];
    /*
    Tiles are stored as arrays of numbers. For example, in 2048, tiles are arrays containing a single number, which is log2 of the tile's number, so a 4 is [2] and
    a 32 is [5]. In many of the main modes, the tiles are stored as two numbers, and the tile number of [a, b] is x^a * b, where x is the power number of the mode,
    so [4, 2] in 2187 is a 3^4 * 2 = 162 tile, while [1, 3] in 4096 is a 8^1 * 3 = 24 tile. TileNumAmount is the amount of entries in such an array for the current
    gamemode. TileTypes is an array where each entry corresponds one type of tile; within each entry, the 0th entry is either the array of that tile or a CalcArray
    expression that, if it evaluates to true, indicates that the tile should use that entry of TileTypes, the 1st entry is the text on the tile, the 2nd entry
    is the color of the tile, and the third entry is the color of the text.
    */
let MergeRules = [[2, ["@Next 1 0", "=", "@This 0"], true, [[["@This 0", "+", 1]]], [2, "^", ["@This 0", "+", 1]], [false, true]]];
    /* MergeRules, like TileTypes, is an array where each entry corresponds to one merge rule. The 0th entry is the amount of tiles in that merge, the 1st entry
    is a CalcArray expression that must evaluate to true for those tiles to merge, the 2nd entry is whether those tiles need to be in order or not, the third entry
    is an array containing the tile(s) that result from the merge, the fourth entry is how much the score increases from this merge, and the fifth entry is
    whether each resulting tile counts as having "used up" its merge that turn. Some modes have merge rules with more than six entries; these rules can scale
    to multiple lengths. For these multi-length rules, the 0th entry now means the minimum merge length, the 6th entry is what the length of the merge rule as given
    is, the 7th entry is what to increase each "@Next"'s first number by on each merge length increase (so if the 7th entry is [1, 2, 0], then any strings that were
    originally "@This 0" become "@Next 1 0", then "@Next 2 0", and so on, any strings that were originally "@Next 1 0" become "@Next 3 0", then "@Next 5 0", and
    so on, and any strings that were originally "@Next 2 0" are unchanged, as are any that were originally "@Next 3" or higher since the 7th entry doesn't go
    that far), the 8th entry is how much to increase the merge length by on each merge length increase, and the 9th entry is the maximum merge length. */
let startTileSpawns = [[[0], 85], [[1], 12], [[2], 3]]; //TileSpawns is reset to its starting value when a new round starts
let TileSpawns = [[[0], 85], [[1], 12], [[2], 3]];
    /* TileSpawns contains the tiles that can spawn between each move. The 0th entry of each entry of TileSpawns is the tile being spawned, the 1st entry of each
    entry of TileSpawns is the likelihood that that tile type is the one that spawns. */
let spawnConditions = true; //Tiles only spawn on a turn where spawnConditions is true
let winConditions = [[11]]; //Which tiles count as "winning"?
let winRequirement = 1; //How many "winning" tiles you need to win
let loseConditions = []; //Which tiles count as "losing"?
let loseRequirement = false; //How many "losing tiles" you need to immediately lose; if this is false, instant loss is not in play
let winPriority = true; //If this is true, if you win and lose from conditions on the same turn, you win. If this is false, you lose in that situation.
let multiMerge = false; //Can tiles merge multiple times in one turn?
let spawnLocation = "All"; //Where do new tiles spawn?
let startTileAmount = 2; //How many tiles spawn at the beginning of the game
let randomTileAmount = 1; //How many tiles spawn after each move
let hiddenTileText = false;
let modifiers = [Infinity, 1, 2, false, "All", "Square", 0, 0, 0, 0, "Orthogonal", false, false, "None", 0, "Regular", 1, 0, 0, 1, false, false, 1, 1, false, 0, 1, 1, 0];
    /*
    modifiers[0] corresponds to SlideAmount, modifiers[1] corresponds to randomTileAmount, modifiers[2] corresponds to startTileAmount, modifiers[3] corresponds
    to multiMerge, and modifiers[4] corresponds to spawnLocation. modifiers[5] changes the shape of the grid, and modifiers[6] through modifiers[9] are used as size
    variables for alternate grid shapes. modifiers[10] controls the available directions, modifiers[11] is whether you can stay still as a move, modifiers[12] is the
    toggle for Garbage 0s, modifiers[13] is the toggle for Negative Tiles, modifiers[14] corresponds to nextTiles, modifiers[15] is the toggle for SimpleSpawns,
    modifiers[16] is the animation speed, modifiers[17] adds holes to the grid, modifiers[18] adds box tiles to the grid, modifiers[19] changes how many turns
    there are between each tile spawning (which is done by changing spawnConditions), modifiers[20] is whether it takes two moves in the same direction to merge,
    modifiers[21] corresponds to hiddenTileText, modifiers[22] and modifiers[23] are the ratio of positive to negative tile spawn chances when Negative Tiles is on,
    modifiers[24] is the toggle for Tricolor Tiles, modifiers[25], modifiers[26], and modifiers[27] are the amount per spawn, interval between spawns, and lifespan (respectively) of Temporary Holes,
    and modifiers[28] adds slippery tiles to the grid.
    */
let gamemode = 0; //Which mode are we in? 2048 is gamemode 1, 2187 is gamemode 2, 1024 is gamemode 3, and so on. Save codes use gamemode 0 to alert StartGame to not go through some of the starting steps.
let mode_vars = []; //Used by a couple gamemodes
let nextTiles = 0; //How many next-to-spawn tiles are visible to the player?
document.documentElement.style.setProperty("--background-color", "#fff5da");
document.documentElement.style.setProperty("--grid-color", "#c7bea7");
document.documentElement.style.setProperty("--tile-color", "#ece0c2");
document.documentElement.style.setProperty("--text-color", "#524c46");
displayRules("rules_text", ["h2", "Powers of 2"], ["h1", "2048"], ["p", "Merges occur between two tiles of the same number. Get to the 2048 tile to win!"],
["p", "Spawning tiles: 1 (85%), 2 (12%), 4 (3%)"]);
let directions = [
    /*
    An array where each entry is one movement direction. The 0th entry of each entry contains the movement magnitudes: directions[x][0][0] is the vertical
    magnitude, directions[x][0][1] is the horizontal magnitude. The 1st entry of each entry is the text on the arrow button, the 2nd entry of each entry is the
    size of the button, the 3rd entry of each entry is the font size, the 4th entry of each entry is the vertical position, the 5th entry of each entry is the
    horizontal position, the 6th entry of each entry is the keyboard keys associated with that direction, and the 7th entry of each entry is the rotation of the
    text on the button. Positive vertical is downwards, positive horizontal is rightwards. The top-left tile of the grid is at position [0, 0].
    */
    [[-1, 0, Infinity, 0, [1, true, true, true]], "&#8593;", 5/33, 5/33, 3/33, 6/33, 14/33, ["ArrowUp", "KeyW"], 0],
    [[1, 0, Infinity, 0, [1, true, true, true]], "&#8595;", 5/33, 5/33, 3/33, 22/33, 14/33, ["ArrowDown", "KeyS"], 0],
    [[0, -1, Infinity, 0, [1, true, true, true]], "&#8592;", 5/33, 5/33, 3/33, 14/33, 6/33, ["ArrowLeft", "KeyA"], 0],
    [[0, 1, Infinity, 0, [1, true, true, true]], "&#8594;", 5/33, 5/33, 3/33, 14/33, 22/33, ["ArrowRight", "KeyD"], 0],
];
let directionsAvailable = [true, true, true, true]; //Which directions can currently be moved in? The game ends once all entries are false.
let score = 0;
let won = 0; //This is a positive number if you've discovered any winning tiles but haven't won yet, and it's -1 if you've won the game
let moves_so_far = 0;
let manual_moves_so_far = 0;
let merges_so_far = 0;
let moves_where_merged = 0; //How many moves did a merge occur on
let merges_before_now = 0; //merges_so_far, but it only updates at the end of each move
let discoveredTiles = [];
let discoveredWinning = [];
let discoveredLosing = [];
let SpawnBoxes = []; //In modes like 3072 that have spawn boxes, this is where those are stored
let spawnConveyor = ["@Empty"]; //The next spawning tiles are stored here
let game_vars = []; //Variables that can be accessed by TileTypes and MergeRules
let modifier_vars = []; //These are like game_vars, but assigned automatically by modifiers rather than by gamemodes
let start_game_vars = []; //game_vars is set to this at the beginning of each game
let start_modifier_vars = []; //modifier_vars is set to this at the beginning of each game
let scripts = [];
/*
A list of CalcArray expressions that can be executed at different times. Each entry of this array is an array of two elements: the first is the CalcArray
expression, the second is the type of the script, which determines when it should be executed. Note that nothing is done with the return values of the CalcArray
expressions, so scripts are mainly there for the purpose of editing the gamemode variables.
*/
let possibleOverChecked = false; //Checks whether the "about to be game over" scripts have been run yet
let movementParameters = ["@VDir", "@HDir", "@SlideAmount"]; //What are the ACTUAL movement stats for each tile? CalcArray expressions can be used here to make different tiles move in different ways.
let postgameAllowed = true; //If this is false, you can't continue after winning
let auto_directions = []; // Like directions, but used for automatic moves
let forcedSpawns = [];
/*
Each entry of this array consists of a CalcArray expression, a string, a boolean, and one or more tile arrays.
If the CalcArray expression is true this turn, then all of the tiles in this entry will be spawned this turn, either before or after the random spawns
depending on the string. If there aren't enough spaces on the grid to spawn them all and the boolean is true, then you immediately lose.
*/

// These next two combined are a list of already-discovered tile displays that can be copied onto new tiles, so displayTile doesn't have to be run as many times
let knownTileDisplayArrays = []; // Each entry is a pair: the array that is the tile being displayed, and the "type" of its display (Grid, NextTile, Score, etc.)
let knownTileDisplayNodes = []; // Each entry is an HTML object: a displayed tile.
let tileDisplayKnownLevel = 3;
/* 
0 means that knownTileDisplay is not used at all, 1 means that knownTileDisplay is only used on a per-turn basis, 2 means that knownTileDisplay retains any tiles currently on the board but gets rid of ones that aren't on the board anymore, and 3 means that knownTileDisplay retains all tiles from throughout the game.
3 by default, but if there's any circumstance that would cause the same tile (i.e. the same array as a tile) to be displayed differently at different points in the game, this must be set to 0 or 1 (if the display can change within a single turn, it must be 0)
*/
// Similar to the above, but for remembering merge results
let knownMergeResultInputs = []; // Each entry is a triple: the array of input tiles, the NextNEs before them, and the Nexts after them. The latter two will be needed if the mode's merges require some checking back.
let knownMergeResultOutputs = []; // Each entry is a quadruple: the length of the merge that succeeded (-1 if it failed), array of output tiles, the amount the score increases by, and whether each resulting tile can merge again or not
let knownMergeMaxLength = 2; // Maximum merge length of the mode, which needs to be known when knownMergeResults is being used
let knownMergeLookbackDistance = 0; // How far back into the NextNE tiles could a merge have to look?
let mergeResultKnownLevel = 2;
/*
0 means that knownMergeResults is not used at all, 1 means that knownMergeResults is only used on a per-turn basis, 2 means that knownMergeResults retains merges whose inputs are all tiles currently on the board but gets rid of the ones that aren't on the board anymore, and 3 means that knownMergeResults retains all merge results from throughout the game.
2 by default, but if the merge rules change over the course of the game (like in 2592 and 2295), this must be set to 0 or 1 (if the merge rules can change within a single turn, it must be 0)
*/


let Grid = [];
let startingGrid = [];
let tsize = 0; //This is used by CreateGrid and DisplayGrid
let GridTiles; let visibleNextTiles; let customGridTiles; //These will be HTMLCollections
let statBoxes = [["Score", "@Score"]]; // Which stats are visible on the screen; the first entry of each entry is the text in that box, the second is a CalcArray that returns the box's value. If the third entry is true, the box appears on the bottom of the screen instead of the top.

// These arrays are used to keep track of Custom Mode things
let customSpawningTiles = [];
let customMerges = [];
let customGeneratedTiles = [];
let customColors = [];
let customBackground = [];
let customWins = [];
let customLosses = [];
let customRulesText = [];

//These lists of operators are used by CalcArrayConvert
let any_operators = ["=", "!=", ">", "<", ">=", "<=", "max", "min", "1st", "first", "2nd", "second", "Number", "String", "Boolean", "Array", "BigInt", "GaussianBigInt", "typeof", "output", "console.log", "CalcArrayParent", "evaluateColor", "customDIVESeedUnlock", "defaultAbbrevAny"];
let number_operators = ["+", "-", "*", "/", "%", "mod", "^", "**", "log", "round", "floor", "ceil", "ceiling", "trunc", "abs", "sign", "sin", "cos", "tan", "gcd", "lcm", "factorial", "prime", "expomod", "bit&", "bit|", "bit~", "bit^", "bit<<", "bit>>", "bit>>>", "rand_int", "rand_float", "defaultAbbrev", "mergeRuleApplies", "mergeRuleApplies_nonRecursive"];
let string_operators = ["str_char", "str_concat", "str_concat_front", "str_length", "str_slice", "str_substr", "str_replace", "str_indexOf", "str_lastIndexOf", "str_indexOfFrom", "str_lastIndexOfFrom", "str_includes", "str_splice", "str_toUpperCase", "str_toLowerCase", "str_split"];
let boolean_operators = ["&&", "||", "!", "&&nsc", "||nsc"];
let array_operators = ["arr_copy", "arr_elem", "arr_edit_elem", "arr_length", "arr_push", "arr_pop", "arr_shift", "arr_unshift", "arr_concat", "arr_concat_front", "arr_flat", "arr_splice", "arr_slice", "arr_indexOf", "arr_lastIndexOf", "arr_indexOfFrom", "arr_lastIndexOfFrom", "arr_includes", "arr_reverse", "arr_sort", "arr_map", "arr_filter", "arr_reduce", "arr_reduceRight", "arr_binarySearch", "arr_binaryInsert", "arr_eqRearrange", "CalcArray", "primeDefactorizeB"];
let bigint_operators = ["+B", "-B", "*B", "/B", "%B", "modB", "^B", "**B", "rootB", "logB", "roundB", "floorB", "ceilB", "ceilingB", "absB", "signB", "gcdB", "lcmB", "factorialB", "primeB", "expomodB", "primeFactorizeB", "factorAmountB", "factorListB", "bit&B", "bit|B", "bit~B", "bit^B", "bit<<B", "bit>>B", "bit>>>B", "basebit&B", "basebit|B", "basebit~B", "basebit^B", "rand_bigint", "defaultAbbrevB", "perfectPowerFormB", "DIVESeedUnlock", "ipowGB", "gaussian_prime"];
let gaussianbigint_operators = ["reGB", "imGB", "+GB", "-GB", "*GB", "/GB", "/mGB", "modGB", "^GB", "**GB", "normGB", "normGGB", "negGB", "rot90GB", "rot270GB", "conjGB", "toFirstQuadrantGB", "firstQuadrantUnitGB", "gcdGB", "lcmGB", "expomodGB", "defaultAbbrevGB", "GaussianDIVESeedUnlock", "gaussianSort"];
let bigrational_operators = ["numeratorBR", "denominatorBR", "+BR", "-BR", "*BR", "/BR", "modBR", "^BR", "**BR", "roundBR", "floorBR", "ceilBR", "ceilingBR", "negBR", "recipBR", "absBR", "signBR", "gcdBR", "lcmBR", "expomodBR", "defaultAbbrevBR", "perfectPowerFormBR"];
let pop_1_operators = ["abs", "absB", "sign", "signB", "reGB", "imGB", "normGB", "normGGB", "negGB", "rot90GB", "rot270GB", "conjGB", "toFirstQuadrantGB", "firstQuadrantUnitGB", "ipowGB", "numeratorBR", "denominatorBR", "negBR", "recipBR", "absBR", "signBR", "sin", "cos", "tan", "!", "factorial", "factorialB", "prime", "primeB", "primeGB", "factorAmountB", "factorListB", "defaultAbbrev", "defaultAbbrevB", "defaultAbbrevGB", "defaultAbbrevBR", "defaultAbbrevAny", "bit~", "bit~B", "str_length", "str_toUpperCase", "str_toLowerCase", "arr_copy", "arr_length", "arr_pop", "arr_shift", "arr_reverse", "Number", "String", "Boolean", "Array", "BigInt", "GaussianBigInt", "BigRational", "typeof"]; //CalcArray, the operator, also only takes 1 input, but it's a special case so it's not in this list. Same goes for evaluateColor.

let primes = [2n, 3n, 5n]; // Some modes need a list of prime numbers. The primesUpdate function extends this list to however far is necessary.
let gaussian_primes = [new GaussianBigInt(1n, 1n), new GaussianBigInt(2n, 1n), new GaussianBigInt(1n, 2n), new GaussianBigInt(3n, 0n)];
let factorsFor3307 = [ // This array is used for the color scheme for 3307
    [13n,1n,3n,9n],[19n,4n,6n,9n],[31n,1n,-6n,36n],[37n,9n,12n,16n],[43n,1n,6n,36n],[61n,16n,-36n,81n],[67n,4n,14n,49n],[73n,1n,8n,64n],[79n,9n,21n,49n],[93n,16n,28n,49n],[97n,9n,24n,64n],[103n,4n,18n,81n],[109n,49n,-84n,144n],[127n,36n,42n,49n],[139n,9n,-39n,169n],[151n,81n,-126n,196n],[157n,1n,12n,144n],[163n,9n,-42n,196n],[183n,1n,13n,169n],[193n,49n,63n,81n],[199n,4n,26n,169n],[211n,1n,14n,196n],[217n,9n,39n,169n],[241n,1n,-16n,256n],[271n,81n,-171n,361n],
    [277n,49n,84n,144n],[283n,36n,78n,169n],[307n,1n,-18n,324n],[313n,9n,48n,256n],[337n,64n,104n,169n],[367n,81n,117n,169n],[373n,16n,-84n,441n],[403n,4n,38n,361n],[417n,49n,112n,256n],[421n,1n,-21n,441n],[427n,9n,57n,361n],[433n,169n,-312n,576n],[453n,16n,76n,361n],[457n,49n,-168n,576n],[463n,1n,21n,441n],[487n,4n,42n,441n],[499n,49n,126n,324n],[523n,81n,-234n,676n],[541n,16n,84n,441n],[543n,49n,133n,361n],[547n,169n,182n,196n],[571n,441n,-546n,676n],[577n,64n,152n,361n],
    [601n,1n,24n,576n],[607n,9n,-78n,676n],[613n,81n,171n,361n],[673n,64n,168n,441n],[709n,9n,-84n,784n],[727n,169n,234n,324n],[733n,144n,228n,361n],[751n,441n,-651n,961n],[757n,1n,27n,729n],[763n,9n,78n,676n],[787n,4n,54n,729n],[793n,49n,168n,576n],[811n,36n,-186n,961n],[813n,1n,28n,784n],[823n,196n,266n,361n],[853n,16n,108n,729n],[877n,9n,84n,784n],[883n,169n,273n,441n],[907n,49n,182n,676n],[921n,256n,304n,361n],[937n,9n,-96n,1024n],[967n,49n,189n,729n],[991n,81n,234n,676n],[993n,1n,31n,961n],[997n,169n,-468n,1296n],
    [1009n,64n,216n,729n],[1033n,256n,336n,441n],[1047n,196n,-518n,1369n],[1057n,1n,32n,1024n],[1063n,9n,93n,961n],[1069n,144n,-444n,1369n],[1087n,441n,-798n,1444n],[1093n,49n,-252n,1296n],[1117n,81n,252n,784n],[1129n,9n,96n,1024n],[1137n,64n,-296n,1369n],[1153n,256n,-624n,1521n],[1171n,196n,-546n,1521n],[1201n,361n,399n,441n],[1213n,784n,-1092n,1521n],[1227n,49n,217n,961n],[1237n,16n,-148n,1369n],[1249n,169n,351n,729n],[1267n,9n,-111n,1369n],[1297n,49n,224n,1024n],[1303n,196n,378n,729n],[1317n,169n,364n,784n],
    [1321n,81n,279n,961n],[1327n,361n,-798n,1764n],[1333n,1n,36n,1296n],[1381n,16n,-156n,1521n],[1399n,324n,-774n,1849n],[1417n,256n,432n,729n],[1423n,961n,-1302n,1764n],[1429n,784n,-1204n,1849n],[1447n,4n,74n,1369n],[1459n,169n,-559n,1849n],[1483n,1n,38n,1444n],[1489n,9n,111n,1369n],[1531n,361n,494n,676n],[1543n,81n,-387n,1849n],[1561n,1n,39n,1521n],[1567n,9n,114n,1444n],[1579n,1369n,-1554n,1764n],[1597n,49n,252n,1296n],[1603n,4n,78n,1521n],[1609n,169n,416n,1024n],[1627n,36n,222n,1369n],[1663n,441n,546n,676n],
    [1693n,16n,156n,1521n],[1723n,1n,-42n,1764n],[1753n,361n,-912n,2304n],[1759n,49n,266n,1444n],[1777n,961n,-1488n,2304n],[1783n,81n,333n,1369n],[1801n,576n,-1176n,2401n],[1807n,1n,42n,1764n],[1831n,361n,-931n,2401n],[1857n,1024n,-1568n,2401n],[1867n,81n,342n,1444n],[1873n,256n,-784n,2401n],[1893n,1n,43n,1849n],[1897n,64n,312n,1521n],[1933n,169n,468n,1296n],[1983n,1444n,-1862n,2401n],[1987n,9n,129n,1849n],[1993n,361n,608n,1024n],[2011n,1521n,-1911n,2401n],[2017n,49n,-336n,2304n],[2029n,729n,-1404n,2704n],
    [2053n,441n,651n,961n],[2073n,64n,-392n,2401n],[2083n,196n,518n,1369n],[2089n,1849n,-2064n,2304n],[2137n,441n,672n,1024n],[2143n,36n,258n,1849n],[2203n,961n,-1674n,2916n],[2217n,256n,592n,1369n],[2221n,16n,-196n,2401n],[2251n,361n,-1026n,2916n],[2257n,64n,344n,1849n],[2263n,196n,546n,1521n],[2269n,729n,756n,784n],[2281n,576n,744n,961n],[2287n,1369n,-1998n,2916n],[2307n,4n,-98n,2401n],[2317n,81n,387n,1849n],[2341n,361n,684n,1296n],[2353n,1n,48n,2304n],[2383n,169n,-702n,2916n],[2389n,49n,-364n,2704n],
    [2433n,361n,703n,1369n],[2437n,784n,-1596n,3249n],[2443n,676n,806n,961n],[2473n,1521n,-2184n,3136n],[2503n,4n,98n,2401n],[2557n,9n,147n,2401n],[2577n,169n,559n,1849n],[2593n,256n,-912n,3249n],[2617n,729n,864n,1024n],[2623n,361n,741n,1521n],[2647n,196n,602n,1849n],[2653n,1n,-52n,2704n],[2671n,2401n,-2646n,2916n],[2677n,169n,-741n,3249n],[2683n,441n,798n,1444n],[2689n,49n,336n,2304n],[2713n,81n,-504n,3136n],[2731n,36n,294n,2401n],[2757n,1n,52n,2704n],[2791n,961n,-1891n,3721n],[2797n,784n,-1708n,3721n],
    [2803n,729n,-1647n,3721n],[2833n,576n,888n,1369n],[2857n,64n,392n,2401n],[2863n,1521n,-2379n,3721n],[2869n,9n,156n,2704n],[2899n,729n,-1674n,3844n],[2947n,324n,774n,1849n],[2971n,1n,54n,2916n],[2977n,1024n,-2016n,3969n],[3001n,256n,-976n,3721n],[3007n,676n,962n,1369n],[3019n,1444n,-2394n,3969n],[3037n,16n,-228n,3249n],[3063n,196n,-854n,3721n],[3073n,961n,-1984n,4096n],[3097n,169n,624n,2304n],[3109n,1849n,-2709n,3969n],[3117n,49n,364n,2704n],[3121n,1521n,-2496n,4096n],[3133n,144n,588n,2401n],[3189n,784n,1036n,1369n],
    [3193n,1n,56n,3136n],[3199n,729n,1026n,1444n],[3207n,169n,637n,2401n],[3217n,256n,-1008n,3969n],[3253n,81n,468n,2704n],[3307n,1n,57n,3249n],[3313n,9n,168n,3136n],[3319n,169n,-819n,3969n],[3343n,49n,378n,2916n],[3361n,2401n,-3136n,4096n],[3369n,1024n,-2144n,4489n],[3373n,961n,1116n,1296n],[3391n,36n,-366n,3721n],[3433n,169n,-832n,4096n],[3439n,1764n,-2814n,4489n],[3457n,576n,1032n,1849n],[3529n,64n,-504n,3969n],[3547n,9n,-183n,3721n],[3559n,3249n,-3534n,3844n],[3583n,961n,1178n,1444n],[3607n,324n,882n,2401n],
    [3643n,676n,1118n,1849n],[3673n,256n,-1072n,4489n],[3691n,961n,1209n,1521n],[3693n,361n,931n,2401n],[3697n,49n,399n,3249n],[3709n,2704n,-3484n,4489n],[3721n,81n,504n,3136n],[3733n,16n,-252n,3969n],[3739n,729n,1161n,1849n],[3769n,64n,456n,3249n],[3793n,1024n,1248n,1521n],[3837n,784n,1204n,1849n],[3847n,4n,122n,3721n],[3873n,3136n,-3752n,4489n],[3889n,1369n,-2664n,5184n],[3907n,1n,62n,3844n],[3919n,3249n,-3819n,4489n],[3967n,81n,-603n,4489n],[3997n,1296n,1332n,1369n],
    [4003n,1521n,-2847n,5329n],[4027n,961n,1302n,1764n],[4033n,1n,63n,3969n],[4057n,2401n,-3528n,5184n],[4099n,4n,126n,3969n],[4111n,1521n,-2886n,5476n],[4129n,2304n,-3504n,5329n],[4153n,576n,1176n,2401n],[4159n,169n,741n,3249n],[4177n,361n,-1368n,5184n],[4197n,49n,427n,3721n],[4219n,1369n,1406n,1444n],[4237n,16n,252n,3969n],[4243n,196n,798n,3249n],[4249n,1024n,1376n,1849n],[4273n,64n,488n,3721n],[4297n,9n,192n,4096n],
    [4303n,361n,1026n,2916n],[4327n,49n,434n,3844n],[4333n,1369n,1443n,1521n],[4339n,324n,-1314n,5329n],[4351n,81n,549n,3721n],[4357n,1849n,-3268n,5776n],[4359n,4n,-134n,4489n],[4363n,441n,-1554n,5476n],[4417n,256n,912n,3249n],[4423n,1n,-67n,4489n],[4447n,1444n,1482n,1521n],[4453n,729n,1323n,2401n],[4483n,81n,558n,3844n],[4507n,3249n,-4218n,5476n],[4513n,3721n,-4392n,5184n],[4537n,64n,504n,3969n],[4549n,169n,-949n,5329n],[4561n,361n,1064n,3136n],[4567n,1369n,-2886n,6084n],[4597n,144n,732n,3721n],
    [4621n,441n,-1596n,5776n],[4627n,4n,134n,4489n],[4647n,3844n,-4526n,5329n],[4663n,2401n,-3822n,6084n],[4687n,1369n,1554n,1764n],[4729n,49n,-504n,5184n],[4783n,3969n,-4662n,5476n],[4813n,784n,-2212n,6241n],[4837n,729n,1404n,2704n],[4861n,3721n,-4636n,5776n],[4863n,676n,-2054n,6241n],[4927n,36n,402n,4489n],[4933n,1369n,-2997n,6561n],[4957n,169n,819n,3969n],[4987n,3249n,-4503n,6241n],[4993n,1024n,1568n,2401n],
    [5007n,49n,469n,4489n],[5011n,961n,-2511n,6561n],[5023n,441n,-1659n,6241n],[5077n,784n,-2268n,6561n],[5097n,169n,832n,4096n],[5101n,361n,-1501n,6241n],[5113n,1n,-72n,5184n],[5119n,9n,-219n,5329n],[5143n,324n,1098n,3721n],[5161n,3136n,-4536n,6561n],[5173n,81n,603n,4489n],[5233n,256n,1008n,3969n],[5241n,361n,1159n,3721n],[5257n,1n,72n,5184n],[5281n,4096n,-5056n,6241n],[5317n,1369n,-3108n,7056n],[5347n,4489n,-5226n,6084n],[5383n,361n,1178n,3844n],
    [5403n,1n,73n,5329n],[5407n,676n,1482n,3249n],[5413n,961n,-2604n,7056n],[5419n,1764n,1806n,1849n],[5437n,144n,804n,4489n],[5443n,441n,1281n,3721n],[5449n,1369n,1776n,2304n],[5479n,4n,146n,5329n],[5521n,256n,-1296n,6561n],[5527n,361n,1197n,3969n],[5557n,9n,219n,5329n],[5563n,1521n,-3354n,7396n],[5583n,1369n,1813n,2401n],[5611n,81n,-711n,6241n],[5623n,196n,938n,4489n],[5629n,784n,1596n,3249n],[5637n,16n,292n,5329n],[5653n,3721n,-5124n,7056n],
    [5673n,361n,1216n,4096n],[5701n,1n,-76n,5776n],[5707n,9n,222n,5476n],[5737n,49n,504n,5184n],[5743n,3249n,-4902n,7396n],[5803n,36n,438n,5329n],[5821n,361n,-1596n,7056n],[5833n,1521n,1911n,2401n],[5853n,1n,76n,5776n],[5881n,441n,1344n,4096n],[5977n,64n,584n,5329n],[5983n,676n,1586n,3721n],[5997n,1369n,1924n,2704n],[6007n,1n,-78n,6084n],[6013n,9n,228n,5776n],[6043n,49n,518n,5476n],[6067n,81n,657n,5329n],[6133n,169n,-1092n,7056n],[6163n,1n,78n,6084n],
    [6213n,784n,1708n,3721n],[6217n,1849n,2064n,2304n],[6247n,729n,1674n,3844n],[6283n,676n,1638n,3969n],[6289n,169n,936n,5184n],[6301n,1296n,-3276n,8281n],[6337n,441n,1407n,4489n],[6343n,3249n,-5187n,8281n],[6357n,49n,532n,5776n],[6393n,1024n,-2912n,8281n],[6421n,961n,-2821n,8281n],[6451n,3721n,-5551n,8281n],[6481n,1n,-81n,6561n],[6483n,3844n,-5642n,8281n],[6541n,81n,684n,5776n],[6547n,196n,1022n,5329n],[6553n,729n,1728n,4096n],[6577n,1369n,2072n,3136n],
    [6607n,169n,962n,5476n],[6661n,6241n,-6636n,7056n],[6673n,576n,1608n,4489n],[6679n,49n,546n,6084n],[6697n,1024n,1952n,3721n],[6703n,81n,-774n,7396n],[6727n,4n,162n,6561n],[6753n,256n,1168n,5329n],[6793n,4096n,-5952n,8649n],[6829n,784n,-2604n,8649n],[6841n,1521n,2184n,3136n],[6843n,49n,553n,6241n],[6883n,961n,1953n,3969n],[6907n,676n,1742n,4489n],[6913n,361n,1368n,5184n],[6933n,169n,988n,5776n],[6967n,324n,1314n,5329n],[6991n,6561n,-6966n,7396n],
    [7009n,1024n,2016n,3969n],[7027n,729n,1809n,4489n],[7041n,961n,1984n,4096n],[7057n,2304n,2352n,2401n],[7069n,2704n,-5044n,9409n],[7087n,1849n,2322n,2916n],[7099n,1764n,-4074n,9409n],[7113n,3136n,-5432n,9409n],[7129n,3249n,-5529n,9409n],[7147n,1521n,-3783n,9409n],[7149n,784n,1876n,4489n],[7177n,49n,567n,6561n],[7201n,961n,-2976n,9216n],[7213n,1296n,2196n,3721n],[7243n,361n,1406n,5476n],[7273n,64n,648n,6561n],[7297n,4096n,-6208n,9409n],
    [7303n,441n,1533n,5329n],[7333n,144n,948n,6241n],[7357n,5776n,-7068n,8649n],[7393n,1849n,2408n,3136n],[7417n,256n,-1488n,8649n],[7441n,63n,651n,6727n],[7471n,441n,1554n,5476n],[7477n,784n,-2716n,9409n],[7483n,1n,86n,7396n],[7507n,1369n,2294n,3844n],[7537n,5329n,-7008n,9216n],[7543n,196n,1106n,6241n],[7549n,1849n,2451n,3249n],[7563n,676n,-2522n,9409n],[7617n,64n,-728n,8281n],[7621n,1521n,2379n,3721n],[7653n,2401n,2548n,2704n],[7669n,1369n,2331n,3969n],[7687n,729n,-2646n,9604n],
    [7753n,361n,-1824n,9216n],[7771n,36n,-546n,8281n],[7783n,169n,1053n,6561n],[7833n,1369n,2368n,4096n],[7873n,6241n,-7584n,9216n],[7891n,196n,1134n,6561n],[7927n,361n,1482n,6084n],[7933n,16n,-364n,8281n],[7963n,2401n,2646n,2916n],[7977n,3136n,-5768n,10609n],[7987n,324n,1422n,6241n],[8017n,9n,-273n,8281n],[8047n,49n,602n,7396n],[8089n,3969n,-6489n,10609n],[8121n,2401n,-5096n,10816n],[8157n,784n,2044n,5329n],[8167n,1369n,-3811n,10609n],[8191n,1n,-91n,8281n],
    [8197n,1296n,2412n,4489n],[8203n,729n,1998n,5476n],[8233n,3969n,-6552n,10816n],[8247n,196n,-1358n,9409n],[8251n,81n,774n,7396n],[8293n,16n,-372n,8649n],[8317n,169n,1092n,7056n],[8337n,1369n,2479n,4489n],[8341n,441n,1659n,6241n],[8359n,1849n,2666n,3844n],[8373n,1n,91n,8281n],[8377n,961n,2232n,5184n],[8389n,144n,-1164n,9409n],[8419n,5329n,-7519n,10609n],[8443n,2401n,2793n,3249n],[8461n,361n,1539n,6561n],[8467n,4n,182n,8281n],[8479n,1444n,2546n,4489n],
    [8527n,1849n,2709n,3969n],[8553n,961n,2263n,5329n],[8563n,9n,273n,8281n],[8589n,343n,1519n,6727n],[8593n,49n,-672n,9216n],[8617n,81n,-873n,9409n],[8623n,1521n,2613n,4489n],[8661n,16n,364n,8281n],[8683n,169n,1118n,7396n],[8689n,1024n,2336n,5329n],[8697n,1849n,2752n,4096n],[8713n,576n,1896n,6241n],[8731n,961n,2294n,5476n],[8737n,729n,-2808n,10816n],[8761n,8281n,-8736n,9216n],[8779n,49n,-679n,9409n],[8803n,81n,-882n,9604n],[8839n,4n,186n,8649n],
    [8863n,36n,546n,8281n],[8887n,441n,-2163n,10609n],[8917n,2704n,2964n,3249n],[8937n,9n,279n,8649n],[8941n,2401n,-5341n,11881n],[8953n,2304n,2928n,3721n],[8971n,676n,2054n,6241n],[8983n,3969n,-6867n,11881n],[9001n,4096n,-6976n,11881n],[9013n,361n,1596n,7056n],[9037n,16n,372n,8649n],[9043n,1849n,-4687n,11881n],[9067n,1764n,2814n,4489n],[9103n,729n,2133n,6241n],[9109n,5329n,-7884n,11664n],[9111n,2401n,2989n,3721n],[9127n,9n,-291n,9409n],
    [9147n,7396n,-8858n,10609n],[9151n,1521n,-4251n,11881n],[9181n,81n,819n,8281n],[9183n,1444n,-4142n,11881n],[9201n,361n,-1976n,10816n],[9217n,1369n,2664n,5184n],[9237n,784n,2212n,6241n],[9241n,3136n,-6216n,12321n],[9247n,567n,1953n,6727n],[9277n,961n,-3348n,11664n],[9283n,2401n,3038n,3844n],[9313n,1n,96n,9216n],[9319n,9n,-294n,9604n],[9343n,676n,2106n,6561n],[9349n,49n,651n,8649n],[9391n,361n,1634n,7396n],[9397n,1849n,-4773n,12321n],
    [9433n,3721n,-6832n,12544n],[9439n,169n,-1339n,10609n],[9463n,961n,2418n,6084n],[9507n,1n,97n,9409n],[9511n,6241n,-8611n,11881n],[9517n,144n,1092n,8281n],[9547n,1444n,2774n,5329n],[9577n,3136n,3192n,3249n],[9607n,4n,194n,9409n],[9613n,784n,2268n,6561n],[9643n,441n,1806n,7396n],[9661n,5776n,-8436n,12321n],[9679n,8649n,-9579n,10609n],[9697n,1521n,2847n,5329n],[9703n,1n,98n,9604n],[9769n,1369n,-4144n,12544n],[9781n,7056n,-9156n,11881n],
    [9793n,1024n,2528n,6241n],[9811n,2401n,-5586n,12996n],[9813n,16n,388n,9409n],[9847n,4489n,-7638n,12996n],[9883n,1521n,2886n,5476n],[9903n,7396n,-9374n,11881n],[9907n,9n,294n,9604n],[9931n,2916n,3294n,3721n],[9937n,49n,672n,9216n],[9949n,2704n,3276n,3969n],[9957n,1369n,2812n,5776n],[9973n,361n,-2052n,11664n],[9993n,256n,1456n,8281n],[9997n,784n,-3108n,12321n],[10009n,2304n,3216n,4489n],[10027n,36n,582n,9409n],[10111n,676n,-2886n,12321n],[10137n,49n,679n,9409n],
    [10147n,196n,1302n,8649n],[10159n,1764n,3066n,5329n],[10171n,361n,-2071n,11881n],[10173n,2401n,3283n,4489n],[10177n,1024n,2592n,6561n],[10243n,324n,1638n,8281n],[10261n,1521n,2964n,5776n],[10273n,3136n,3416n,3721n],[10297n,4096n,-7488n,13689n],[10357n,2401n,-5733n,13689n],[10363n,81n,873n,9409n],[10407n,4n,-206n,10609n],[10429n,169n,-1404n,11664n],[10447n,729n,2322n,7396n],[10477n,5329n,-8541n,13689n],[10501n,8281n,-10101n,12321n],[10513n,9n,-312n,10816n],
    [10533n,1369n,2923n,6241n],[10551n,196n,-1526n,11881n],[10567n,81n,882n,9604n],[10597n,9409n,-10476n,11664n],[10627n,3249n,3534n,3844n],[10677n,2704n,3484n,4489n],[10687n,1444n,3002n,6241n],[10713n,1n,103n,10609n],[10729n,1369n,-4329n,13689n],[10777n,361n,1767n,8649n],[10819n,4n,206n,10609n],[10839n,169n,1261n,9409n],[10843n,1521n,3081n,6241n],[10893n,1849n,3268n,5776n],[10903n,8281n,-10374n,12996n],[10921n,1n,104n,10816n],[10957n,49n,-756n,11664n],[10993n,3249n,3648n,4096n],
    [11023n,2916n,3618n,4489n],[11041n,576n,2184n,8281n],[11043n,441n,1953n,8649n],[11047n,169n,1274n,9604n],[11083n,1444n,3078n,6561n],[11113n,2401n,3528n,5184n],[11149n,10609n,-11124n,11664n],[11167n,49n,-763n,11881n],[11197n,784n,-3276n,13689n],[11257n,169n,-1456n,12544n],[11287n,1849n,3354n,6084n],[11347n,3721n,3782n,3844n],[11377n,3136n,3752n,4489n],[11467n,729n,2457n,8281n],[11497n,64n,824n,10609n],[11503n,2401n,3626n,5476n],[11533n,1369n,3108n,7056n],[11541n,12n,366n,11163n],
    [11593n,49n,728n,10816n],[11617n,81n,927n,10609n],[11683n,169n,-1482n,12996n],[11701n,2401n,-6076n,15376n],[11719n,3844n,3906n,3969n],[11743n,676n,2418n,8649n],[11749n,9409n,-11349n,13689n],[11773n,1n,108n,11664n],[11821n,6241n,-9796n,15376n],[11827n,361n,1862n,9604n],[11829n,2704n,3796n,5329n],[11833n,81n,936n,10816n],[11863n,10609n,-11742n,12996n],[11887n,441n,2037n,9409n],[11889n,729n,2511n,8649n],[11893n,1849n,3483n,6561n],[11901n,2401n,3724n,5776n],[11923n,4489n,-8442n,15876n],
    [11943n,48n,732n,11163n],[11947n,1369n,3182n,7396n],[11989n,144n,1236n,10609n],[12007n,5329n,-9198n,15876n],[12037n,784n,2604n,8649n],[12063n,961n,2821n,8281n],[12073n,256n,-1872n,13689n],[12097n,3969n,4032n,4096n],[12109n,4489n,-8509n,16129n],[12153n,3136n,-7112n,16129n],[12157n,1369n,-4588n,15376n],[12163n,6241n,-9954n,15876n],[12187n,2916n,3942n,5329n],[12211n,1n,-111n,12321n],[12217n,1024n,2912n,8281n],[12229n,2704n,-6604n,16129n],[12247n,196n,1442n,10609n],
    [12253n,5776n,-9652n,16129n],[12271n,1521n,3354n,7396n],[12289n,3969n,-8064n,16384n],[12307n,2401n,3822n,6084n],[12373n,8281n,-11284n,15376n],[12433n,1n,111n,12321n],[12487n,3844n,4154n,4489n],[12517n,1849n,3612n,7056n],[12547n,4n,222n,12321n],[12553n,3136n,4088n,5329n],[12559n,1764n,-5334n,16129n],[12577n,6561n,-10368n,16384n],[12583n,1369n,-4662n,15876n],[12603n,7396n,-10922n,16129n],[12607n,676n,2522n,9409n],[12679n,3969n,4221n,4489n],[12693n,49n,763n,11881n],
    [12697n,1521n,-4953n,16129n],[12739n,3249n,4161n,5329n],[12757n,729n,2619n,9409n],[12763n,441n,-2562n,14884n],[12781n,16n,444n,12321n],[12799n,1369n,-4699n,16129n],[12819n,192n,1464n,11163n],[12853n,1296n,3276n,8281n],[12889n,9n,336n,12544n],[12913n,1521n,-4992n,16384n],[12919n,49n,-819n,13689n],[12927n,361n,1957n,10609n],[12967n,8649n,-11811n,16129n],[12979n,729n,2646n,9604n],[13017n,1369n,3367n,8281n],[13063n,9409n,-12222n,15876n],[13111n,1n,114n,12996n],
    [13129n,8649n,-11904n,16384n],[13147n,49n,777n,12321n],[13153n,361n,1976n,10816n],[13183n,1444n,3458n,8281n],[13213n,441n,2163n,10609n],[13219n,9409n,-12319n,16129n],[13237n,169n,1404n,11664n],[13273n,64n,888n,12321n],[13297n,3721n,4392n,5184n],[13381n,361n,-2356n,15376n],[13423n,2916n,4266n,6241n],[13441n,441n,2184n,10816n],[13477n,2704n,4212n,6561n],[13503n,3721n,4453n,5329n],[13507n,10609n,-12978n,15876n],[13537n,1024n,3104n,9409n],[13603n,196n,1526n,11881n],
    [13627n,1444n,3534n,8649n],[13633n,81n,1008n,12544n],[13657n,576n,2472n,10609n],[13663n,12321n,-13542n,14884n],[13711n,3721n,4514n,5476n],[13801n,3136n,4424n,6241n],[13807n,1n,117n,13689n],[13809n,10609n,-13184n,16384n],[13819n,117n,1209n,12493n],[13843n,49n,798n,12996n],[13897n,3969n,4599n,5329n],[13903n,441n,-2667n,16129n],[13933n,169n,1443n,12321n],[13963n,676n,2678n,10609n],[13993n,3249n,4503n,6241n],[14011n,2401n,4214n,7396n],[14023n,11881n,-13734n,15876n],
    [14043n,1849n,3913n,8281n],[14071n,196n,1554n,12321n],[14077n,361n,2052n,11664n],[14107n,3969n,4662n,5476n],[14119n,729n,2781n,10609n],[14169n,169n,1456n,12544n],[14173n,16n,468n,13689n],[14197n,1296n,3492n,9409n],[14233n,3136n,4536n,6561n],[14277n,784n,2884n,10609n],[14299n,13689n,-14274n,14884n],[14341n,81n,-1116n,15376n],[14353n,256n,1776n,12321n],[14367n,1369n,3589n,9409n],[14371n,3087n,4557n,6727n],[14407n,169n,-1638n,15876n],[14449n,12544n,-14224n,16129n],[14533n,3969n,4788n,5776n],
    [14557n,49n,819n,13689n],[14563n,3721n,4758n,6084n],[14599n,1369n,3626n,9604n],[14611n,441n,2289n,11881n],[14647n,169n,1482n,12996n],[14689n,64n,936n,13689n],[14709n,4489n,4891n,5329n],[14713n,1521n,3783n,9409n],[14791n,361n,2109n,12321n],[14923n,4489n,4958n,5476n],[14929n,1024n,3296n,10609n],[14947n,1521n,3822n,9604n],[14983n,3844n,4898n,6241n],[15007n,1n,122n,14884n],[15013n,9n,-372n,15376n],[15033n,361n,2128n,12544n],[15073n,576n,2616n,11881n],[15177n,64n,-1016n,16129n],[15187n,3969n,4977n,6241n],
    [15193n,1849n,4128n,9216n],[15223n,3721n,4941n,6561n],[15253n,1n,-124n,15376n],[15259n,9n,366n,14884n],[15289n,49n,-889n,16129n],[15313n,81n,-1152n,16384n],[15357n,4489n,5092n,5776n],[15391n,676n,2834n,11881n],[15417n,2304n,4464n,8649n],[15427n,3844n,5022n,6561n],[15501n,1n,124n,15376n],[15537n,49n,-896n,16384n],[15547n,3249n,4902n,7396n],[15607n,2401n,4557n,8649n],[15667n,1849n,4214n,9604n],[15723n,1083n,3477n,11163n],[15751n,1n,-126n,15876n],[15769n,5184n,5256n,5329n],[15787n,49n,854n,14884n],
    [15817n,256n,1872n,13689n],[15901n,3721n,5124n,7056n],[15951n,637n,2821n,12493n],[15967n,1444n,3914n,10609n],[15973n,961n,3348n,11664n],[16003n,1n,126n,15876n],[16033n,1369n,3848n,10816n],[16063n,81n,1098n,14884n],[16111n,2916n,4914n,8281n],[16147n,1521n,4017n,10609n],[16189n,2704n,4836n,8649n],[16213n,784n,3108n,12321n],[16273n,361n,2223n,13689n],[16293n,49n,868n,15376n],[16297n,729n,3024n,12544n],[16321n,2401n,4704n,9216n],[16363n,3721n,5246n,7396n],[16369n,2304n,4656n,9409n],[16477n,4489n,5427n,6561n]
]

//Bunch of event listeners
document.getElementById("menu_extra").addEventListener("click", function(){
    if (subScreen == 4) otherSecretStats[4]++;
    switchScreen("Menu", subScreen % 4 + 1);
});
document.getElementById("menu_import").addEventListener("click", function(){
    switchScreen("SaveCode", "Import");
});
document.getElementById("menu_to_modifiers").addEventListener("click", function(){
    switchScreen("Modifiers", 1);
});
document.getElementById("menu_to_guide").addEventListener("click", function(){
    switchScreen("Guide", "Regular");
});
document.getElementById("menu_to_custom").addEventListener("click", function(){
    switchScreen("CustomMode", "Opening");
});
document.getElementById("menu_to_homepage").addEventListener("click", function(){
    window.open("https://mathcookie17.github.io/", "_self")
});
document.getElementById("gm_width_minus").addEventListener("click", function(){
    width--;
    gmDisplayVars();
});
document.getElementById("gm_width_plus").addEventListener("click", function(){
    width++;
    gmDisplayVars();
});
document.getElementById("gm_height_minus").addEventListener("click", function(){
    height--;
    gmDisplayVars();
});
document.getElementById("gm_height_plus").addEventListener("click", function(){
    height++;
    gmDisplayVars();
});
document.getElementById("gm_return").addEventListener("click", function(){
    switchScreen("Menu", Math.max(Math.floor(modes_order.indexOf(Math.floor(gamemode)) / 25), 0) + 1)
});
document.getElementById("return_button").addEventListener("click", function(){
    if (gamemode == 0) {
        if (modifiers[5] == "Hexagon" || modifiers[5] == "HexaTriangle") hexagonal = true;
        else if (modifiers[5] != "Custom") hexagonal = false;
        else {
            createCustomGrid();
            createCustomArrows();
        }
    }
    switchScreen("Menu", 1);
});
document.getElementById("new_game_button").addEventListener("click", function(){
    PlayAgain();
});
document.getElementById("2048_spawn_button").addEventListener("click", function(){
    mode_vars[0] = !(mode_vars[0]);
    mode_vars[1]++;
    gmDisplayVars();
});
document.getElementById("3125_3-1_button").addEventListener("click", function(){
    mode_vars[0] = !(mode_vars[0]);
    gmDisplayVars();
});
document.getElementById("XXXX_min_plus").addEventListener("click", function(){
    mode_vars[0]++;
    if (mode_vars[1] < mode_vars[0]) mode_vars[1] = mode_vars[0];
    gmDisplayVars();
});
document.getElementById("XXXX_min_minus").addEventListener("click", function(){
    mode_vars[0]--;
    gmDisplayVars();
});
document.getElementById("XXXX_max_plus").addEventListener("click", function(){
    if (mode_vars[1] == Infinity) mode_vars[1] = Math.max(mode_vars[0], 3);
    else mode_vars[1]++;
    gmDisplayVars();
});
document.getElementById("XXXX_max_minus").addEventListener("click", function(){
    if (mode_vars[1] == Math.max(mode_vars[0], 3)) mode_vars[1] = Infinity;
    else mode_vars[1]--;
    gmDisplayVars();
});
document.getElementById("2584_previousNegative_button").addEventListener("click", function(){
    mode_vars[0] = (mode_vars[0] + 1) % 3;
    gmDisplayVars();
});
document.getElementById("Isotopic256_halfLife_change").addEventListener("change", function() {
    let v = Number(this.value);
    if (isFinite(v) && v > 0) mode_vars[0] = v;
    else mode_vars[0] = 0.75;
    gmDisplayVars();
});
document.getElementById("ThreeHalves_mode_button").addEventListener("click", function(){
    mode_vars[0] = (mode_vars[0] + 1) % 3;
    loadGridSize(37, mode_vars);
    gmDisplayVars();
});
document.getElementById("ThreeHalves_partialModeMerges_button").addEventListener("click", function(){
    mode_vars[1] = (mode_vars[1] + 1) % 3;
    gmDisplayVars();
});
document.getElementById("180_length_button").addEventListener("click", function(){
    mode_vars[0] = (mode_vars[0] + 1) % 3;
    gmDisplayVars();
});
document.getElementById("180_randomGoals_button").addEventListener("click", function(){
    mode_vars[1] = (mode_vars[1] + 1) % 3;
    gmDisplayVars();
});
document.getElementById("180_firstGoalMinimum_change").addEventListener("change", function() {
    let v = Number(this.value);
    if (!isFinite(v) || v < 2) v = 2;
    mode_vars[2] = v;
    gmDisplayVars();
});
document.getElementById("2592_switch_button").addEventListener("click", function(){
    mode_vars[0] = (mode_vars[0] + 1) % 3;
    gmDisplayVars();
});
document.getElementById("2592_randomGoals_button").addEventListener("click", function(){
    mode_vars[1] = (mode_vars[1] + 1) % 3;
    gmDisplayVars();
});
document.getElementById("2592_firstGoalMinimum_change").addEventListener("change", function() {
    let v = Number(this.value);
    if (!isFinite(v) || v < 2) v = 2;
    mode_vars[2] = v;
    gmDisplayVars();
});
document.getElementById("Wildcard2048_add_button").addEventListener("click", function(){
    mode_vars[0] = (mode_vars[0] + 1) % 3;
    gmDisplayVars();
});
document.getElementById("Wildcard2048_chaosSpawns_button").addEventListener("click", function(){
    mode_vars[1] = !(mode_vars[1]);
    gmDisplayVars();
});
document.getElementById("XpowY_pow_plus").addEventListener("click", function(){
    let primes = [2n, 3n, 5n, 7n, 11n, 13n, 17n, 19n, 23n, 29n, 31n, 37n, 41n, 43n, 47n, 2n**1024n];
    let p = primes.indexOf(mode_vars[0]);
    mode_vars[0] = primes[mod((p + 1), 16)];
    gmDisplayVars();
});
document.getElementById("XpowY_pow_minus").addEventListener("click", function(){
    let primes = [2n, 3n, 5n, 7n, 11n, 13n, 17n, 19n, 23n, 29n, 31n, 37n, 41n, 43n, 47n, 2n**1024n];
    let p = primes.indexOf(mode_vars[0]);
    mode_vars[0] = primes[mod((p - 1), 16)];
    gmDisplayVars();
});
document.getElementById("XpowY_merge_plus").addEventListener("click", function(){
    mode_vars[1]++;
    gmDisplayVars();
});
document.getElementById("XpowY_merge_minus").addEventListener("click", function(){
    mode_vars[1]--;
    gmDisplayVars();
});
document.getElementById("1321_evensOnly_button").addEventListener("click", function(){
    mode_vars[0] = !(mode_vars[0]);
    gmDisplayVars();
});
document.getElementById("1321_randomGoals_button").addEventListener("click", function(){
    mode_vars[1] = (mode_vars[1] + 1) % 3;
    gmDisplayVars();
});
document.getElementById("1321_firstGoalMinimum_plus").addEventListener("click", function(){
    mode_vars[2]++;
    gmDisplayVars();
});
document.getElementById("1321_firstGoalMinimum_minus").addEventListener("click", function(){
    mode_vars[2]--;
    gmDisplayVars();
});
document.getElementById("2100_difficulty_decrease").addEventListener("click", function(){
    mode_vars[0] -= 1;
    gmDisplayVars();
});
document.getElementById("2100_difficulty_increase").addEventListener("click", function(){
    mode_vars[0] += 1;
    gmDisplayVars();
});
document.getElementById("378_goal_button").addEventListener("click", function(){
    mode_vars[0] = !(mode_vars[0]);
    gmDisplayVars();
});
document.getElementById("378_merge_plus").addEventListener("click", function(){
    mode_vars[1]++;
    gmDisplayVars();
});
document.getElementById("378_merge_minus").addEventListener("click", function(){
    mode_vars[1]--;
    gmDisplayVars();
});
document.getElementById("DIVE_seeds_button").addEventListener("click", function(){
    if (mode_vars[0] == 0) mode_vars[0] = -1;
    else if (mode_vars[0] == -1) mode_vars[0] = 4;
    else mode_vars[0] = 0;
    gmDisplayVars();
});
document.getElementById("DIVE_primeSpawns_change").addEventListener("change", function() {
    let v = Number(this.value);
    if (isFinite(v) && v > 0 && v % 1 == 0) mode_vars[0] = v;
    else mode_vars[0] = 4;
    gmDisplayVars();
});
document.getElementById("DIVE_primeSpawns_button").addEventListener("click", function(){
    mode_vars[0] = 0;
    gmDisplayVars();
});
document.getElementById("DIVE_1s_button").addEventListener("click", function(){
    mode_vars[1] = !(mode_vars[1]);
    gmDisplayVars();
});
document.getElementById("DIVE_unlockRules_button").addEventListener("click", function(){
    mode_vars[2] = (mode_vars[2] + 1) % 4;
    gmDisplayVars();
});
document.getElementById("DIVE_randomGoals_button").addEventListener("click", function(){
    mode_vars[3] = (mode_vars[3] + 1) % 3;
    gmDisplayVars();
});
document.getElementById("DIVE_firstGoalMinimum_change").addEventListener("change", function() {
    let v;
    try {
        v = BigInt(this.value);
    }
    catch {
        v = 0n;
    }
    if (v < 4n) v = 4n;
    mode_vars[4] = v;
    gmDisplayVars();
});
document.getElementById("3888_randomGoals_button").addEventListener("click", function(){
    mode_vars[0] = (mode_vars[0] + 1) % 3;
    gmDisplayVars();
});
document.getElementById("3888_firstGoalMinimum_change").addEventListener("change", function() {
    let v = Number(this.value);
    if (!isFinite(v) || v < 16) v = 16;
    mode_vars[1] = v;
    gmDisplayVars();
});
document.getElementById("2000_randomGoals_button").addEventListener("click", function(){
    mode_vars[0] = (mode_vars[0] + 1) % 3;
    gmDisplayVars();
});
document.getElementById("2000_firstGoalMinimum_change").addEventListener("change", function() {
    let v = Number(this.value);
    if (!isFinite(v) || v < 25) v = 25;
    mode_vars[1] = v;
    gmDisplayVars();
});
document.getElementById("3645_randomGoals_button").addEventListener("click", function(){
    mode_vars[0] = (mode_vars[0] + 1) % 3;
    gmDisplayVars();
});
document.getElementById("3645_firstGoalMinimum_change").addEventListener("change", function() {
    let v = Number(this.value);
    if (!isFinite(v) || v < 75) v = 75;
    mode_vars[1] = v;
    gmDisplayVars();
});
document.getElementById("2700_level_decrease").addEventListener("click", function(){
    mode_vars[0] -= 1;
    loadGridSize(57, mode_vars);
    gmDisplayVars();
});
document.getElementById("2700_level_increase").addEventListener("click", function(){
    mode_vars[0] += 1;
    loadGridSize(57, mode_vars);
    gmDisplayVars();
});
document.getElementById("2700_level3Merges_button").addEventListener("click", function(){
    mode_vars[1] += 1;
    if (mode_vars[1] > 3) mode_vars[1] = 1;
    gmDisplayVars();
});
document.getElementById("2205_level_decrease").addEventListener("click", function(){
    mode_vars[0] -= 1;
    gmDisplayVars();
});
document.getElementById("2205_level_increase").addEventListener("click", function(){
    mode_vars[0] += 1;
    gmDisplayVars();
});
document.getElementById("1825_randomGoals_button").addEventListener("click", function(){
    mode_vars[0] = (mode_vars[0] + 1) % 3;
    gmDisplayVars();
});
document.getElementById("1825_firstGoalMinimum_plus").addEventListener("click", function(){
    mode_vars[1]++;
    gmDisplayVars();
});
document.getElementById("1825_firstGoalMinimum_minus").addEventListener("click", function(){
    mode_vars[1]--;
    gmDisplayVars();
});
document.getElementById("3069_randomGoals_button").addEventListener("click", function(){
    mode_vars[0] = (mode_vars[0] + 1) % 3;
    gmDisplayVars();
});
document.getElementById("3069_firstGoalMinimum_change").addEventListener("change", function() {
    let v;
    try {
        v = BigInt(this.value);
    }
    catch {
        v = 0n;
    }
    if (v < 4n) v = 4n;
    mode_vars[1] = v;
    gmDisplayVars();
});
document.getElementById("3069_oddsOnly_button").addEventListener("click", function(){
    mode_vars[2] = !mode_vars[2];
    loadGridSize(61, mode_vars);
    gmDisplayVars();
});
document.getElementById("1762_randomGoals_button").addEventListener("click", function(){
    mode_vars[0] = (mode_vars[0] + 1) % 3;
    gmDisplayVars();
});
document.getElementById("1762_firstGoalMinimum_plus").addEventListener("click", function(){
    mode_vars[1]++;
    gmDisplayVars();
});
document.getElementById("1762_firstGoalMinimum_minus").addEventListener("click", function(){
    mode_vars[1]--;
    gmDisplayVars();
});
document.getElementById("3188646_multiplyMiddle_button").addEventListener("click", function(){
    mode_vars[0] = !(mode_vars[0]);
    gmDisplayVars();
});
document.getElementById("3026_allMerges_button").addEventListener("click", function(){
    mode_vars[0] = !(mode_vars[0]);
    gmDisplayVars();
});
document.getElementById("3026_randomGoals_button").addEventListener("click", function(){
    mode_vars[1] = (mode_vars[1] + 1) % 3;
    gmDisplayVars();
});
document.getElementById("3026_firstGoalMinimum_plus").addEventListener("click", function(){
    mode_vars[2]++;
    gmDisplayVars();
});
document.getElementById("3026_firstGoalMinimum_minus").addEventListener("click", function(){
    mode_vars[2]--;
    gmDisplayVars();
});
document.getElementById("SQUART_randomGoals_button").addEventListener("click", function(){
    mode_vars[0] = (mode_vars[0] + 1) % 4;
    gmDisplayVars();
});
document.getElementById("SQUART_firstGoalMinimum_change").addEventListener("change", function() {
    let v;
    try {
        v = BigInt(this.value);
    }
    catch {
        v = 0n;
    }
    if (v < 6n) v = 6n;
    mode_vars[1] = v;
    gmDisplayVars();
});
document.getElementById("Turatin_interval_minus").addEventListener("click", function(){
    mode_vars[0] -= 1;
    gmDisplayVars();
});
document.getElementById("Turatin_interval_plus").addEventListener("click", function(){
    mode_vars[0] += 1;
    gmDisplayVars();
});
document.getElementById("Turatin_nonIntegerRatio_button").addEventListener("click", function(){
    mode_vars[1] = !(mode_vars[1]);
    gmDisplayVars();
});
document.getElementById("Turatin_switch_button").addEventListener("click", function(){
    mode_vars[2] = (mode_vars[2] + 1) % 3;
    gmDisplayVars();
});
document.getElementById("3307_equalVariant_button").addEventListener("click", function(){
    mode_vars[0] = (mode_vars[0] + 1) % 3;
    gmDisplayVars();
});
document.getElementById("1668_randomGoals_button").addEventListener("click", function(){
    mode_vars[0] = (mode_vars[0] + 1) % 3;
    gmDisplayVars();
});
document.getElementById("1668_firstGoalMinimum_plus").addEventListener("click", function(){
    mode_vars[1]++;
    gmDisplayVars();
});
document.getElementById("1668_firstGoalMinimum_minus").addEventListener("click", function(){
    mode_vars[1]--;
    gmDisplayVars();
});
document.getElementById("1847_randomGoals_button").addEventListener("click", function(){
    mode_vars[0] = (mode_vars[0] + 1) % 3;
    gmDisplayVars();
});
document.getElementById("1847_firstGoalMinimum_plus").addEventListener("click", function(){
    mode_vars[1]++;
    gmDisplayVars();
});
document.getElementById("1847_firstGoalMinimum_minus").addEventListener("click", function(){
    mode_vars[1]--;
    gmDisplayVars();
});
document.getElementById("1429_randomGoals_button").addEventListener("click", function(){
    mode_vars[0] = (mode_vars[0] + 1) % 3;
    gmDisplayVars();
});
document.getElementById("1429_firstGoalMinimum_plus").addEventListener("click", function(){
    mode_vars[1]++;
    gmDisplayVars();
});
document.getElementById("1429_firstGoalMinimum_minus").addEventListener("click", function(){
    mode_vars[1]--;
    gmDisplayVars();
});
document.getElementById("2058_powRequired_minus").addEventListener("click", function(){
    mode_vars[0] -= 1;
    gmDisplayVars();
});
document.getElementById("2058_powRequired_plus").addEventListener("click", function(){
    mode_vars[0] += 1;
    gmDisplayVars();
});
document.getElementById("2058_startMaxNum_minus").addEventListener("click", function(){
    mode_vars[1] -= 1;
    gmDisplayVars();
});
document.getElementById("2058_startMaxNum_plus").addEventListener("click", function(){
    mode_vars[1] += 1;
    gmDisplayVars();
});
document.getElementById("1716_equalDisappear_button").addEventListener("click", function(){
    mode_vars[0] = !(mode_vars[0]);
    gmDisplayVars();
});
document.getElementById("2669_randomGoals_button").addEventListener("click", function(){
    mode_vars[0] = (mode_vars[0] + 1) % 3;
    gmDisplayVars();
});
document.getElementById("2669_firstGoalMinimum_change").addEventListener("change", function() {
    let v;
    try {
        v = BigInt(this.value);
    }
    catch {
        v = 0n;
    }
    if (v < 7n) v = 7n;
    mode_vars[1] = v;
    gmDisplayVars();
});
document.getElementById("FACTUP_crazy_button").addEventListener("click", function(){
    mode_vars[0] = !(mode_vars[0]);
    gmDisplayVars();
});
document.getElementById("FACTUP_randomGoals_button").addEventListener("click", function(){
    mode_vars[1] = (mode_vars[1] + 1) % 4;
    gmDisplayVars();
});
document.getElementById("FACTUP_firstGoalMinimum_change").addEventListener("change", function() {
    let v;
    try {
        v = BigInt(this.value);
    }
    catch {
        v = 0n;
    }
    if (v < 3n) v = 3n;
    mode_vars[2] = v;
    gmDisplayVars();
});
document.getElementById("2496_randomGoals_button").addEventListener("click", function(){
    mode_vars[0] = (mode_vars[0] + 1) % 3;
    gmDisplayVars();
});
document.getElementById("2496_firstGoalMinimum_plus").addEventListener("click", function(){
    mode_vars[1]++;
    gmDisplayVars();
});
document.getElementById("2496_firstGoalMinimum_minus").addEventListener("click", function(){
    mode_vars[1]--;
    gmDisplayVars();
});
document.getElementById("1845_randomGoals_button").addEventListener("click", function(){
    mode_vars[0] = (mode_vars[0] + 1) % 3;
    gmDisplayVars();
});
document.getElementById("1845_firstGoalMinimum_change").addEventListener("change", function() {
    let v;
    try {
        v = BigInt(this.value);
    }
    catch {
        v = 0n;
    }
    if (v < 3n) v = 3n;
    mode_vars[1] = v;
    gmDisplayVars();
});
document.getElementById("SCAPRIM_randomGoals_button").addEventListener("click", function(){
    mode_vars[0] = (mode_vars[0] + 1) % 2;
    gmDisplayVars();
});
document.getElementById("SCAPRIM_firstGoalMinimum_change").addEventListener("change", function() {
    let v;
    try {
        v = BigInt(this.value);
    }
    catch {
        v = 0n;
    }
    if (v < 3n) v = 3n;
    mode_vars[1] = v;
    gmDisplayVars();
});
document.getElementById("TRIGAT_randomGoals_button").addEventListener("click", function(){
    mode_vars[0] = (mode_vars[0] + 1) % 4;
    gmDisplayVars();
});
document.getElementById("TRIGAT_firstGoalMinimum_change").addEventListener("change", function() {
    let v;
    try {
        v = BigInt(this.value);
    }
    catch {
        v = 0n;
    }
    if (v < 9n) v = 9n;
    mode_vars[1] = v;
    gmDisplayVars();
});
document.getElementById("LOCEF_Extended_button").addEventListener("click", function(){
    mode_vars[0] = !(mode_vars[0]);
    gmDisplayVars();
});
document.getElementById("LOCEF_randomGoals_button").addEventListener("click", function(){
    mode_vars[1] = (mode_vars[1] + 1) % 4;
    gmDisplayVars();
});
document.getElementById("LOCEF_firstGoalMinimum_change").addEventListener("change", function() {
    let v;
    try {
        v = BigInt(this.value);
    }
    catch {
        v = 0n;
    }
    if (v < 7n) v = 7n;
    mode_vars[2] = v;
    gmDisplayVars();
});
document.getElementById("Alternate5040_baseFactorials_button").addEventListener("click", function(){
    mode_vars[1] = 2n;
    gmDisplayVars();
});
document.getElementById("Alternate5040_base_change").addEventListener("change", function() {
    try {
        v = BigInt(this.value);
    }
    catch {
        if (mode_vars[0] == 4) {
            v = new BigRational(this.value);
            if (v.lt(0)) v = v.abs();
            if (v.lt(1)) v = v.recip();
            if (v.gt(1) && v.isFinite()) {
                mode_vars[1] = v;
                secretsFound[2] = true;
            }
            gmDisplayVars();
            return;
        }
        else v = 0n;
    }
    if (v > 1n) mode_vars[1] = v;
    gmDisplayVars();
});
document.getElementById("Alternate5040_base_button").addEventListener("click", function(){
    mode_vars[1] = true;
    gmDisplayVars();
});
document.getElementById("Alternate5040_baseRational_numerator_change").addEventListener("change", function() {
    try {
        v = new BigRational(BigInt(this.value), BigInt(mode_vars[1].denominator));
        if (v.lt(0)) v = v.abs();
        if (v.lt(1)) v = v.recip();
        if (v.gt(1) && v.isFinite()) mode_vars[1] = v;
    }
    catch {}
    gmDisplayVars();
});
document.getElementById("Alternate5040_baseRational_denominator_change").addEventListener("change", function() {
    try {
        v = new BigRational(BigInt(mode_vars[1].numerator), BigInt(this.value));
        if (v.lt(0)) v = v.abs();
        if (v.lt(1)) v = v.recip();
        if (v.gt(1) && v.isFinite()) mode_vars[1] = v;
    }
    catch {}
    gmDisplayVars();
});
document.getElementById("Alternate5040_baseRational_button").addEventListener("click", function(){
    mode_vars[1] = true;
    gmDisplayVars();
});
document.getElementById("Alternate5040_variant_button").addEventListener("click", function(){
    mode_vars[0] = (mode_vars[0] + 1) % 5;
    if (mode_vars[1] instanceof BigRational) mode_vars[1] = 2n;
    loadGridSize(100, mode_vars);
    gmDisplayVars();
});
document.getElementById("GaussianDIVE_startSeeds_button").addEventListener("click", function(){
    mode_vars[0] = (mode_vars[0] + 1) % 6;
    gmDisplayVars();
});
document.getElementById("GaussianDIVE_unlocks_button").addEventListener("click", function(){
    mode_vars[1] = !mode_vars[1]
    gmDisplayVars();
});
document.getElementById("GaussianDIVE_seedsFirstQuadrant_button").addEventListener("click", function(){
    mode_vars[2] = !mode_vars[2]
    gmDisplayVars();
});
document.getElementById("GaussianDIVE_unlockRules_button").addEventListener("click", function(){
    mode_vars[4] = (mode_vars[4] + 1) % 4;
    gmDisplayVars();
});
document.getElementById("GaussianDIVE_quadrant0SpawnRatio_change").addEventListener("change", function() {
    let v = Number(this.value);
    if (isFinite(v)) mode_vars[3][0] = Math.abs(v);
    if (eqPrimArrays(mode_vars[3], [0, 0, 0, 0])) {
        mode_vars[3] = [1, 0, 0, 0]
    }
    gmDisplayVars();
});
document.getElementById("GaussianDIVE_quadrant1SpawnRatio_change").addEventListener("change", function() {
    let v = Number(this.value);
    if (isFinite(v)) mode_vars[3][1] = Math.abs(v);
    if (eqPrimArrays(mode_vars[3], [0, 0, 0, 0])) {
        mode_vars[3] = [1, 0, 0, 0]
    }
    gmDisplayVars();
});
document.getElementById("GaussianDIVE_quadrant2SpawnRatio_change").addEventListener("change", function() {
    let v = Number(this.value);
    if (isFinite(v)) mode_vars[3][2] = Math.abs(v);
    if (eqPrimArrays(mode_vars[3], [0, 0, 0, 0])) {
        mode_vars[3] = [1, 0, 0, 0]
    }
    gmDisplayVars();
});
document.getElementById("GaussianDIVE_quadrant3SpawnRatio_change").addEventListener("change", function() {
    let v = Number(this.value);
    if (isFinite(v)) mode_vars[3][3] = Math.abs(v);
    if (eqPrimArrays(mode_vars[3], [0, 0, 0, 0])) {
        mode_vars[3] = [1, 0, 0, 0]
    }
    gmDisplayVars();
});
document.getElementById("start_game").addEventListener("click", startGame);
document.addEventListener("keydown", (event) => {
    if (!inputAvailable || (currentScreen != "Gameplay" && !(currentScreen == "Modifiers" && subScreen == 3.2))) return;
    let directionUsed = -1;
    directionFinder : {
        for (let d = 0; d < directions.length; d++) {
            for (let k = 0; k < directions[d][7].length; k++) {
                if (directions[d][7][k] == event.code) {directionUsed = d; break directionFinder;}
            }
        }
    }
    if (currentScreen == "Gameplay" && directionUsed >= 0 && directionsAvailable[directionUsed]) MoveHandler(directionUsed);
    if (currentScreen == "Modifiers" && subScreen == 3.2) {
        if (directionUsed == -1) directions[screenVars[0]][7].push(event.code);
        inputAvailable = false;
        displayModifiers(3.2);
    }
});
window.addEventListener("resize", function(){
    if (currentScreen == "Menu") {
        if ((window.screen.width / window.screen.height) <= 3/4) document.getElementById("menu_extra").innerHTML = "Switch Pages (" + subScreen + " / 4)" 
        else document.getElementById("menu_extra").innerHTML = "Switch Pages<br>(" + subScreen + " / 4)"; 
    }
    if (currentScreen == "Gameplay" && inputAvailable) {
        displayGrid();
    }
})
document.getElementById("go_again").addEventListener("click", function(){
    if (!inputAvailable) return;
    PlayAgain();
});
document.getElementById("win_again").addEventListener("click", function(){
    if (!inputAvailable) return;
    PlayAgain();
});
document.getElementById("lone_win_again").addEventListener("click", function(){
    if (!inputAvailable) return;
    PlayAgain();
});
document.getElementById("win_continue").addEventListener("click", function(){
    if (!inputAvailable) return;
    document.getElementById("win_screen").style.setProperty("opacity", 0);
    document.getElementById("win_screen").style.setProperty("display", "none");
    won = -1;
    currentScreen = "Gameplay";
    displayButtons(true);
    inputAvailable = true;
});
document.getElementById("gp_export_button").addEventListener("click", function(){
    exportSave(true);
    switchScreen("SaveCode", "Export");
});
document.getElementById("save_code_import").addEventListener("click", function(){
    if (document.getElementById("save_code_box").value == "View Color Schemes") {
        screenVars = [2n, true, true];
        switchScreen("Tile Viewer", "Wildcard 2048");
    }
    else importSave(document.getElementById("save_code_box").value);
});
document.getElementById("save_code_return_game").addEventListener("click", function(){
    switchScreen("Gameplay", "Main");
});
document.getElementById("save_code_return_menu").addEventListener("click", function(){
    if (subScreen == "Import") switchScreen("Menu", 1);
    else if (subScreen == "CustomImport") switchScreen("CustomMode", "Opening");
    else if (subScreen == "Modifiers") switchScreen("Modifiers", 1)
});
document.getElementById("save_code_type").addEventListener("click", function(){
    screenVars[0] = (screenVars[0] + 1) % 2;
    displaySaveCodeMode("Save Code", screenVars[0])
    exportSave(screenVars[0] == 0);
});
document.getElementById("modifiers_return").addEventListener("click", function(){
    switchScreen("Menu", 1);
});
document.getElementById("modifiers_save_code").addEventListener("click", function(){
    exportModifiersSave();
    switchScreen("SaveCode", "Modifiers");
});
document.getElementById("modifiers_previous_page").addEventListener("click", function(){
    if (modifiers[5] == "Custom") {
        if (subScreen == 1) switchScreen("Modifiers", 6);
        else if (subScreen == 4) switchScreen("Modifiers", 3.2);
        else if (subScreen == 3.2) switchScreen("Modifiers", 3.1);
        else if (subScreen == 3.1) switchScreen("Modifiers", 2);
        else switchScreen("Modifiers", subScreen - 1);
    }
    else {
        if (subScreen == 1) switchScreen("Modifiers", 6);
        else switchScreen("Modifiers", subScreen - 1);
    }
});
document.getElementById("modifiers_next_page").addEventListener("click", function(){
    if (modifiers[5] == "Custom") {
        if (subScreen == 6) switchScreen("Modifiers", 1);
        else if (subScreen == 2) switchScreen("Modifiers", 3.1);
        else if (subScreen == 3.1) switchScreen("Modifiers", 3.2);
        else if (subScreen == 3.2) switchScreen("Modifiers", 4);
        else switchScreen("Modifiers", subScreen + 1);
    }
    else {
        if (subScreen == 6) switchScreen("Modifiers", 1);
        else switchScreen("Modifiers", subScreen + 1);
    }
});
document.getElementById("modifiers_animationSpeed_change").addEventListener("change", function() {
    let v = Number(this.value);
    if (isFinite(v) && v >= 0) modifiers[16] = v;
    else mode_vars[0] = 1;
    displayModifiers(1);
});
document.getElementById("modifiers_slideAmount_minus").addEventListener("click", function(){
    if (modifiers[0] == 1) modifiers[0] = Infinity;
    else modifiers[0]--;
    displayModifiers(1);
});
document.getElementById("modifiers_slideAmount_plus").addEventListener("click", function(){
    if (modifiers[0] == Infinity) modifiers[0] = 1;
    else modifiers[0]++;
    displayModifiers(1);
});
document.getElementById("modifiers_randomTileAmount_plus").addEventListener("click", function(){
    if (modifiers[1] == Infinity) modifiers[1] = 1;
    else modifiers[1]++;
    displayModifiers(1);
});
document.getElementById("modifiers_randomTileAmount_minus").addEventListener("click", function(){
    if (modifiers[1] == 1) modifiers[1] = Infinity;
    else modifiers[1]--;
    displayModifiers(1);
});
document.getElementById("modifiers_startTileAmount_plus").addEventListener("click", function(){
    if (modifiers[2] == Infinity) modifiers[2] = 1;
    else modifiers[2]++;
    displayModifiers(1);
});
document.getElementById("modifiers_startTileAmount_minus").addEventListener("click", function(){
    if (modifiers[2] == 1) modifiers[2] = Infinity;
    else modifiers[2]--;
    displayModifiers(1);
});
document.getElementById("modifiers_nextTiles_plus").addEventListener("click", function(){
    modifiers[14]++;
    displayModifiers(1);
});
document.getElementById("modifiers_nextTiles_minus").addEventListener("click", function(){
    modifiers[14]--;
    displayModifiers(1);
});
document.getElementById("modifiers_randomVoid_plus").addEventListener("click", function(){
    modifiers[17]++;
    displayModifiers(1);
});
document.getElementById("modifiers_randomVoid_minus").addEventListener("click", function(){
    modifiers[17]--;
    displayModifiers(1);
});
document.getElementById("modifiers_randomBlackBox_plus").addEventListener("click", function(){
    modifiers[18]++;
    displayModifiers(1);
});
document.getElementById("modifiers_randomBlackBox_minus").addEventListener("click", function(){
    modifiers[18]--;
    displayModifiers(1);
});
document.getElementById("modifiers_randomSlippery_plus").addEventListener("click", function(){
    modifiers[28]++;
    displayModifiers(1);
});
document.getElementById("modifiers_randomSlippery_minus").addEventListener("click", function(){
    modifiers[28]--;
    displayModifiers(1);
});
document.getElementById("modifiers_spawnInterval_plus").addEventListener("click", function(){
    modifiers[19]++;
    displayModifiers(1);
});
document.getElementById("modifiers_spawnInterval_minus").addEventListener("click", function(){
    modifiers[19]--;
    displayModifiers(1);
});
document.getElementById("modifiers_multiMerge_button").addEventListener("click", function(){
    modifiers[3] = !(modifiers[3])
    displayModifiers(2);
});
document.getElementById("modifiers_spawnLocation_button").addEventListener("click", function(){
    if (modifiers[4] == "All") modifiers[4] = "Edge";
    else modifiers[4] = "All";
    displayModifiers(2);
});
document.getElementById("modifiers_twoMoveMerge_button").addEventListener("click", function(){
    modifiers[20] = !(modifiers[20]);
    displayModifiers(2);
});
document.getElementById("modifiers_gridShape_button").addEventListener("click", function(){
    hexagonal = false;
    if (modifiers[5] == "Square") modifiers[5] = "Diamond";
    else if (modifiers[5] == "Diamond") modifiers[5] = "Checkerboard";
    else if (modifiers[5] == "Checkerboard") {modifiers[5] = "Hexagon";  hexagonal = true; auto_directions = [];}
    else if (modifiers[5] == "Hexagon") {modifiers[5] = "HexaTriangle";  hexagonal = true;}
    else if (modifiers[5] == "HexaTriangle") {modifiers[5] = "4D"; modifiers[10] = "Orthogonal"; modifiers[4] = "All"; auto_directions = [];}
    else modifiers[5] = "Square";
    displayModifiers(3);
});
document.getElementById("gm_diamond_minus").addEventListener("click", function(){
    modifiers[6]--;
    gmDisplayVars();
});
document.getElementById("gm_diamond_plus").addEventListener("click", function(){
    modifiers[6]++;
    gmDisplayVars();
});
document.getElementById("gm_4D_width_minus").addEventListener("click", function(){
    modifiers[6]--;
    gmDisplayVars();
});
document.getElementById("gm_4D_width_plus").addEventListener("click", function(){
    modifiers[6]++;
    gmDisplayVars();
});
document.getElementById("gm_4D_height_minus").addEventListener("click", function(){
    modifiers[7]--;
    gmDisplayVars();
});
document.getElementById("gm_4D_height_plus").addEventListener("click", function(){
    modifiers[7]++;
    gmDisplayVars();
});
document.getElementById("gm_4D_length_minus").addEventListener("click", function(){
    modifiers[8]--;
    gmDisplayVars();
});
document.getElementById("gm_4D_length_plus").addEventListener("click", function(){
    modifiers[8]++;
    gmDisplayVars();
});
document.getElementById("gm_4D_depth_minus").addEventListener("click", function(){
    modifiers[9]--;
    gmDisplayVars();
});
document.getElementById("gm_4D_depth_plus").addEventListener("click", function(){
    modifiers[9]++;
    gmDisplayVars();
});
document.getElementById("modifiers_directions_button").addEventListener("click", function(){
    if (modifiers[10] == "Orthogonal") modifiers[10] = "Both";
    else if (modifiers[10] == "Both") modifiers[10] = "Diagonal";
    else modifiers[10] = "Orthogonal";
    displayModifiers(3);
});
document.getElementById("modifiers_stayStill_button").addEventListener("click", function(){
    modifiers[11] = !(modifiers[11])
    displayModifiers(3);
});
document.getElementById("modifiers_simpleSpawns_button").addEventListener("click", function(){
    if (modifiers[15] == "Regular") modifiers[15] = "Simple";
    else if (modifiers[15] == "Simple") modifiers[15] = "Equal";
    else modifiers[15] = "Regular";
    displayModifiers(2);
});
document.getElementById("modifiers_garbage0_button").addEventListener("click", function(){
    modifiers[12] = !(modifiers[12])
    displayModifiers(4);
});
document.getElementById("modifiers_negativetiles_button").addEventListener("click", function(){
    if (modifiers[13] == "None") modifiers[13] = "Non-Interacting";
    else if (modifiers[13] == "Non-Interacting") modifiers[13] = "Interacting";
    else modifiers[13] = "None";
    displayModifiers(4);
});
document.getElementById("modifiers_negativetiles_positiveSpawnRatio_change").addEventListener("change", function() {
    let v = Number(this.value);
    if (isFinite(v)) modifiers[22] = Math.abs(v);
    if (modifiers[22] == 0 && modifiers[23] == 0) {
        modifiers[22] = 1; modifiers[23] = 1;
    }
    displayModifiers(4);
});
document.getElementById("modifiers_negativetiles_negativeSpawnRatio_change").addEventListener("change", function() {
    let v = Number(this.value);
    if (isFinite(v)) modifiers[23] = Math.abs(v);
    if (modifiers[22] == 0 && modifiers[23] == 0) {
        modifiers[22] = 1; modifiers[23] = 1;
    }
    displayModifiers(4);
});
document.getElementById("modifiers_hiddenTileText_button").addEventListener("click", function(){
    modifiers[21] = !(modifiers[21])
    displayModifiers(4);
});
document.getElementById("modifiers_tricolortiles_button").addEventListener("click", function(){
    modifiers[24] = !(modifiers[24])
    displayModifiers(5);
});
document.getElementById("modifiers_temporaryHoles_amount_plus").addEventListener("click", function(){
    modifiers[25]++;
    displayModifiers(5);
});
document.getElementById("modifiers_temporaryHoles_amount_minus").addEventListener("click", function(){
    modifiers[25]--;
    displayModifiers(5);
});
document.getElementById("modifiers_temporaryHoles_interval_plus").addEventListener("click", function(){
    modifiers[26]++;
    displayModifiers(5);
});
document.getElementById("modifiers_temporaryHoles_interval_minus").addEventListener("click", function(){
    modifiers[26]--;
    displayModifiers(5);
});
document.getElementById("modifiers_temporaryHoles_lifespan_plus").addEventListener("click", function(){
    modifiers[27]++;
    displayModifiers(5);
});
document.getElementById("modifiers_temporaryHoles_lifespan_minus").addEventListener("click", function(){
    modifiers[27]--;
    displayModifiers(5);
});
document.getElementById("modifiers_customGridActivate").addEventListener("click", function() {
    modifiers[5] = "Custom";
    if (hexagonal) auto_directions = [];
    hexagonal = false;
    width = 4;
    height = 4;
    directions = [
        [[-1, 0, modifiers[0], 0, [1, true, true, true]], "&#8593;", 5/33, 5/33, 3/33, 6/33, 14/33, ["ArrowUp", "KeyW"], 0],
        [[1, 0, modifiers[0], 0, [1, true, true, true]], "&#8595;", 5/33, 5/33, 3/33, 22/33, 14/33, ["ArrowDown", "KeyS"], 0],
        [[0, -1, modifiers[0], 0, [1, true, true, true]], "&#8592;", 5/33, 5/33, 3/33, 14/33, 6/33, ["ArrowLeft", "KeyA"], 0],
        [[0, 1, modifiers[0], 0, [1, true, true, true]], "&#8594;", 5/33, 5/33, 3/33, 14/33, 22/33, ["ArrowRight", "KeyD"], 0],
    ];
    directionsAvailable = [true, true, true, true];
    createCustomGrid();
    switchScreen("Modifiers", 3.1);
});
document.getElementById("modifiers_customGridDeactivate").addEventListener("click", function() {
    if (hexagonal) auto_directions = [];
    modifiers[5] = "Square";
    modifiers[10] = "Orthogonal";
    modifiers[11] = false;
    hexagonal = false;
    switchScreen("Modifiers", 3);
});
document.getElementById("modifiers_customGridShape_Square").addEventListener("click", function() {
    hexagonal = true;
    auto_directions = [];
    width = 9;
    height = 5;
    directions = [
        [[-1, -1, modifiers[0], 0, [1, true, true, true]], "&#8592;", 5/33, 5/33, 3/33, 6/33, 9/33, ["KeyQ"], 60],
        [[-1, 1, modifiers[0], 0, [1, true, true, true]], "&#8593;", 5/33, 5/33, 3/33, 6/33, 19/33, ["KeyW"], 30],
        [[1, -1, modifiers[0], 0, [1, true, true, true]], "&#8595;", 5/33, 5/33, 3/33, 22/33, 9/33, ["KeyZ"], 30],
        [[1, 1, modifiers[0], 0, [1, true, true, true]], "&#8594;", 5/33, 5/33, 3/33, 22/33, 19/33, ["KeyX"], 60],
        [[0, -2, modifiers[0], 0, [1, true, true, true]], "&#8592;", 5/33, 5/33, 3/33, 14/33, 4/33, ["KeyA"], 0],
        [[0, 2, modifiers[0], 0, [1, true, true, true]], "&#8594;", 5/33, 5/33, 3/33, 14/33, 24/33, ["KeyS"], 0]
    ];
    directionsAvailable = [true, true, true, true, true, true];
    createCustomGrid();
    switchScreen("Modifiers", 3.1);
});
document.getElementById("modifiers_customGridShape_Hexagonal").addEventListener("click", function() {
    hexagonal = false;
    auto_directions = [];
    width = 4;
    height = 4;
    directions = [
        [[-1, 0, modifiers[0], 0, [1, true, true, true]], "&#8593;", 5/33, 5/33, 3/33, 6/33, 14/33, ["ArrowUp", "KeyW"], 0],
        [[1, 0, modifiers[0], 0, [1, true, true, true]], "&#8595;", 5/33, 5/33, 3/33, 22/33, 14/33, ["ArrowDown", "KeyS"], 0],
        [[0, -1, modifiers[0], 0, [1, true, true, true]], "&#8592;", 5/33, 5/33, 3/33, 14/33, 6/33, ["ArrowLeft", "KeyA"], 0],
        [[0, 1, modifiers[0], 0, [1, true, true, true]], "&#8594;", 5/33, 5/33, 3/33, 14/33, 22/33, ["ArrowRight", "KeyD"], 0],
    ];
    directionsAvailable = [true, true, true, true];
    createCustomGrid();
    switchScreen("Modifiers", 3.1);
});
document.getElementById("modifiers_customGridWidth_minus").addEventListener("click", function() {
    width--;
    createCustomGrid();
    displayModifiers(3.1);
});
document.getElementById("modifiers_customGridWidth_plus").addEventListener("click", function() {
    width++;
    createCustomGrid();
    displayModifiers(3.1);
});
document.getElementById("modifiers_customGridHeight_minus").addEventListener("click", function() {
    height--;
    createCustomGrid();
    displayModifiers(3.1);
});
document.getElementById("modifiers_customGridHeight_plus").addEventListener("click", function() {
    height++;
    createCustomGrid();
    displayModifiers(3.1);
});
document.getElementById("modifiers_customGridSize_minus").addEventListener("click", function() {
    if (hexagonal) {
        width -= 4;
        height -= 2;
    };
    createCustomGrid();
    displayModifiers(3.1);
});
document.getElementById("modifiers_customGridSize_plus").addEventListener("click", function() {
    if (hexagonal) {
        width += 4;
        height += 2;
    };
    createCustomGrid();
    displayModifiers(3.1);
});
document.getElementById("modifiers_customArrow_vdir_plus").addEventListener("click", function() {
    if (hexagonal) {
        directions[screenVars[0]][0][0]++;
        directions[screenVars[0]][0][1]++;
    }
    else {
        directions[screenVars[0]][0][0]++;
    }
    displayModifiers(3.2);
});
document.getElementById("modifiers_customArrow_vdir_minus").addEventListener("click", function() {
    if (hexagonal) {
        directions[screenVars[0]][0][0]--;
        directions[screenVars[0]][0][1]--;
    }
    else {
        directions[screenVars[0]][0][0]--;
    }
    displayModifiers(3.2);
});
document.getElementById("modifiers_customArrow_hdir_plus").addEventListener("click", function() {
    if (hexagonal) {
        directions[screenVars[0]][0][0]--;
        directions[screenVars[0]][0][1]++;
    }
    else {
        directions[screenVars[0]][0][1]++;
    }
    displayModifiers(3.2);
});
document.getElementById("modifiers_customArrow_hdir_minus").addEventListener("click", function() {
    if (hexagonal) {
        directions[screenVars[0]][0][0]++;
        directions[screenVars[0]][0][1]--;
    }
    else {
        directions[screenVars[0]][0][1]--;
    }
    displayModifiers(3.2);
});
document.getElementById("modifiers_customArrow_slideAmount_plus").addEventListener("click", function() {
    if (directions[screenVars[0]][0][2] == Infinity) directions[screenVars[0]][0][2] = 1;
    else directions[screenVars[0]][0][2]++;
    displayModifiers(3.2);
});
document.getElementById("modifiers_customArrow_slideAmount_minus").addEventListener("click", function() {
    if (directions[screenVars[0]][0][2] == 1) directions[screenVars[0]][0][2] = Infinity;
    else directions[screenVars[0]][0][2]--;
    displayModifiers(3.2);
});
document.getElementById("modifiers_customArrow_text_change").addEventListener("change", function() {
    directions[screenVars[0]][1] = he.encode(this.value);
    displayModifiers(3.2);
});
document.getElementById("modifiers_customArrow_width_change").addEventListener("change", function() {
    let v = Number(this.value);
    if (isNaN(v)) v = 0;
    if (v < 0) v = 0;
    if (v > 100) v = 100;
    directions[screenVars[0]][2] = v / 100;
    displayModifiers(3.2);
});
document.getElementById("modifiers_customArrow_height_change").addEventListener("change", function() {
    let v = Number(this.value);
    if (isNaN(v)) v = 0;
    if (v < 0) v = 0;
    if (v > 100) v = 100;
    directions[screenVars[0]][2] = v / 100;
    displayModifiers(3.2);
});
document.getElementById("modifiers_customArrow_fontsize_change").addEventListener("change", function() {
    let v = Number(this.value);
    if (isNaN(v)) v = 0;
    if (v < 0) v = 0;
    if (v > 100) v = 100;
    directions[screenVars[0]][4] = v / 100;
    displayModifiers(3.2);
});
document.getElementById("modifiers_customArrow_vpos_change").addEventListener("change", function() {
    let v = Number(this.value);
    if (isNaN(v)) v = 0;
    if (v < 0) v = 0;
    if (v > 100) v = 100;
    directions[screenVars[0]][5] = v / 100;
    displayModifiers(3.2);
});
document.getElementById("modifiers_customArrow_hpos_change").addEventListener("change", function() {
    let v = Number(this.value);
    if (isNaN(v)) v = 0;
    if (v < 0) v = 0;
    if (v > 100) v = 100;
    directions[screenVars[0]][6] = v / 100;
    displayModifiers(3.2);
});
document.getElementById("modifiers_customArrow_rotation_change").addEventListener("change", function() {
    let v = Number(this.value);
    if (isNaN(v)) v = 0;
    v = mod(v, 360);
    directions[screenVars[0]][8] = v;
    displayModifiers(3.2);
});
document.getElementById("modifiers_customArrow_removeKey").addEventListener("click", function() {
    directions[screenVars[0]][7].pop();
    displayModifiers(3.2);
});
document.getElementById("modifiers_customArrow_addKey").addEventListener("click", function() {
    inputAvailable = !inputAvailable;
    displayModifiers(3.2);
});
document.getElementById("modifiers_customArrow_removeDirection").addEventListener("click", function() {
    if (screenVars[0] > -1) directions.splice(screenVars[0], 1);
    screenVars[0] = -1;
    displayModifiers(3.2);
});
document.getElementById("modifiers_customArrow_addDirection").addEventListener("click", function() {
    directions.push([[0, 0, modifiers[0], 0, [1, true, true, true], 100], "&#8226;", 5/33, 5/33, 3/33, 14/33, 14/33, [], 0]);
    screenVars[0] = directions.length - 1;
    displayModifiers(3.2);
});
document.getElementById("modifiers_emptyAutoMoves_button").addEventListener("click", function() {
    if (hexagonal) auto_directions.push([[1, 1, Infinity, -1, [-1, true, false, false], 100], "Between", [1, 0, "@end_vars", ["@var_retain", "@Moves", "-", "@Var 1", "%", "@Var 0", "=", 0], "&&", ["@var_retain", "@Moves", ">=", "@Var 1"]]]);
    else auto_directions.push([[1, 0, Infinity, -1, [-1, true, false, false], 100], "Between", [1, 0, "@end_vars", ["@var_retain", "@Moves", "-", "@Var 1", "%", "@Var 0", "=", 0], "&&", ["@var_retain", "@Moves", ">=", "@Var 1"]]]);
    screenVars[0] = 0;
    displayModifiers(6);
});
document.getElementById("modifiers_AutoMoves_add").addEventListener("click", function() {
    if (hexagonal) auto_directions.push([[1, 1, Infinity, -1, [-1, true, false, false], 100], "Between", [1, 0, "@end_vars", ["@var_retain", "@Moves", "-", "@Var 1", "%", "@Var 0", "=", 0], "&&", ["@var_retain", "@Moves", ">=", "@Var 1"]]]);
    else auto_directions.push([[1, 0, Infinity, -1, [-1, true, false, false], 100], "Between", [1, 0, "@end_vars", ["@var_retain", "@Moves", "-", "@Var 1", "%", "@Var 0", "=", 0], "&&", ["@var_retain", "@Moves", ">=", "@Var 1"]]]);
    screenVars[0] = auto_directions.length - 1;
    displayModifiers(6);
});
document.getElementById("modifiers_AutoMoves_remove").addEventListener("click", function() {
    auto_directions.splice(screenVars[0], 1);
    if (auto_directions.length == 0) screenVars[0] = -1;
    else if (screenVars[0] >= auto_directions.length) screenVars[0] = auto_directions.length - 1;
    displayModifiers(6);
});
document.getElementById("modifiers_AutoMoves_previous").addEventListener("click", function() {
    if (screenVars[0] == 0) screenVars[0] = auto_directions.length - 1;
    else screenVars[0]--;
    displayModifiers(6);
});
document.getElementById("modifiers_AutoMoves_next").addEventListener("click", function() {
    if (screenVars[0] == auto_directions.length - 1) screenVars[0] = 0;
    else screenVars[0]++;
    displayModifiers(6);
});
document.getElementById("modifiers_AutoMoves_vdir_plus").addEventListener("click", function() {
    if (hexagonal) {
        auto_directions[screenVars[0]][0][0]++;
        auto_directions[screenVars[0]][0][1]++;
    }
    else auto_directions[screenVars[0]][0][0]++;
    displayModifiers(6);
});
document.getElementById("modifiers_AutoMoves_vdir_minus").addEventListener("click", function() {
    if (hexagonal) {
        auto_directions[screenVars[0]][0][0]--;
        auto_directions[screenVars[0]][0][1]--;
    }
    else auto_directions[screenVars[0]][0][0]--;
    displayModifiers(6);
});
document.getElementById("modifiers_AutoMoves_hdir_plus").addEventListener("click", function() {
    if (hexagonal) {
        auto_directions[screenVars[0]][0][0]--;
        auto_directions[screenVars[0]][0][1]++;
    }
    else auto_directions[screenVars[0]][0][1]++;
    displayModifiers(6);
});
document.getElementById("modifiers_AutoMoves_hdir_minus").addEventListener("click", function() {
    if (hexagonal) {
        auto_directions[screenVars[0]][0][0]++;
        auto_directions[screenVars[0]][0][1]--;
    }
    else auto_directions[screenVars[0]][0][1]--;
    displayModifiers(6);
});
document.getElementById("modifiers_AutoMoves_slideAmount_plus").addEventListener("click", function() {
    if (auto_directions[screenVars[0]][0][2] == Infinity) auto_directions[screenVars[0]][0][2] = 1;
    else auto_directions[screenVars[0]][0][2]++;
    displayModifiers(6);
});
document.getElementById("modifiers_AutoMoves_slideAmount_minus").addEventListener("click", function() {
    if (auto_directions[screenVars[0]][0][2] == 1) auto_directions[screenVars[0]][0][2] = Infinity;
    else auto_directions[screenVars[0]][0][2]--;
    displayModifiers(6);
});
document.getElementById("modifiers_AutoMoves_frequency_plus").addEventListener("click", function() {
    if (auto_directions[screenVars[0]][2][0] == Infinity) auto_directions[screenVars[0]][2][0] = 1;
    else auto_directions[screenVars[0]][2][0]++;
    displayModifiers(6);
});
document.getElementById("modifiers_AutoMoves_frequency_minus").addEventListener("click", function() {
    if (auto_directions[screenVars[0]][2][0] == 1) auto_directions[screenVars[0]][2][0] = Infinity;
    else auto_directions[screenVars[0]][2][0]--;
    displayModifiers(6);
});
document.getElementById("modifiers_AutoMoves_firstTurn_plus").addEventListener("click", function() {
    auto_directions[screenVars[0]][2][1]++;
    displayModifiers(6);
});
document.getElementById("modifiers_AutoMoves_firstTurn_minus").addEventListener("click", function() {
    auto_directions[screenVars[0]][2][1]--;
    displayModifiers(6);
});
document.getElementById("modifiers_AutoMoves_manualStrength_button").addEventListener("click", function(){
    if (auto_directions[screenVars[0]][0][4][0] == 0) {
        auto_directions[screenVars[0]][0][4][0] = -1;
        auto_directions[screenVars[0]][0][4][2] = false;
        auto_directions[screenVars[0]][0][4][3] = false;
    }
    else {
        auto_directions[screenVars[0]][0][4][0] = 0;
        auto_directions[screenVars[0]][0][4][2] = true;
        auto_directions[screenVars[0]][0][4][3] = true;
    }
    displayModifiers(6);
});
document.getElementById("modifiers_AutoMoves_merges_button").addEventListener("click", function(){
    auto_directions[screenVars[0]][0][4][1] = !(auto_directions[screenVars[0]][0][4][1]);
    displayModifiers(6);
});
document.getElementById("modifiers_AutoMoves_timing_button").addEventListener("click", function(){
    if (auto_directions[screenVars[0]][1] == "Between") auto_directions[screenVars[0]][1] = "Before";
    else if (auto_directions[screenVars[0]][1] == "Before") auto_directions[screenVars[0]][1] = "After";
    else auto_directions[screenVars[0]][1] = "Between";
    displayModifiers(6);
});
document.getElementById("modifiers_AutoMoves_probability_change").addEventListener("change", function() {
    let v = Number(this.value);
    if (isNaN(v)) v = 0;
    if (v < 0) v = 0;
    if (v > 100) v = 100;
    auto_directions[screenVars[0]][0][5] = v;
    displayModifiers(6);
});
document.getElementById("customMode_return").addEventListener("click", function(){
    switchScreen("Menu", 1);
});
document.getElementById("customMode_quit").addEventListener("click", function(){
    switchScreen("CustomMode", "Opening");
});
document.getElementById("customMode_start").addEventListener("click", function(){
    // document.documentElement.style.setProperty("background-image", "radial-gradient(#ffc400 0%, #fff 150%)");
    // document.documentElement.style.setProperty("--background-color", "#fff5da");
    // document.documentElement.style.setProperty("--grid-color", "#c7bea7");
    // document.documentElement.style.setProperty("--tile-color", "#ece0c2");
    // document.documentElement.style.setProperty("--text-color", "#524c46");
    customSpawningTiles = [false, [1, 1]];
    customMerges = [[1, [1, Infinity, 0, 1], [[true, 0]], [[true, 1]], false]];
    customGeneratedTiles = [];
    customColors = [[1, [1, Infinity, 0, 1], [["@HSLA", 0, 100, 50, 1, 1, false, 30, 0, true, 0, 0.975, true, 100, 0.95, false, 0, 0]], [0], ["@linear-gradient", 180], ["@HSLA", 0, 100, 0, 1, 1, false, 0, 0, false, 0, 0, false, 0, 0, false, 0, 0]]];
    customBackground = [["@linear-gradient", 180, [0], [["@HSLA", 44, 100, 93, 1]]], ["@radial-gradient", 0, [0, 150], [["@HSLA", 46, 100, 50, 1], ["@HSLA", 0, 100, 100, 1]]], ["@linear-gradient", 180, [0], [["@HSLA", 43, 22, 72, 1]]], ["@linear-gradient", 180, [0], [["@HSLA", 43, 53, 84, 1]]], ["@linear-gradient", 180, [0], [["@HSLA", 30, 8, 30, 1]]]];
    customWins = [0];
    customLosses = [0];
    customRulesText = ["", "Custom Mode", "No description has been provided.", 0]
    switchScreen("CustomMode", "SpawningTiles");
});
document.getElementById("customMode_import").addEventListener("click", function(){
    switchScreen("SaveCode", "CustomImport");
});
document.getElementById("customMode_guide").addEventListener("click", function(){
    switchScreen("Guide", "CustomMode");
});
document.getElementById("customMode_previousPage").addEventListener("click", function(){
    if (subScreen == "Merges") {
        switchScreen("CustomMode", "SpawningTiles");
    }
    else if (subScreen == "ConsistencyCheck") {
        switchScreen("CustomMode", "Merges")
    }
    else if (subScreen == "Colors") {
        switchScreen("CustomMode", "ConsistencyCheck");
    }
    else if (subScreen == "Background") {
        switchScreen("CustomMode", "Colors");
    }
    else if (subScreen == "Other") {
        switchScreen("CustomMode", "Background");
    }
});
document.getElementById("customMode_nextPage").addEventListener("click", function(){
    if (subScreen == "SpawningTiles") {
        let nonzeroFound = false;
        for (let s = 1; s < customSpawningTiles.length; s++) {
            if (customSpawningTiles[s][1] > 0) {
                nonzeroFound = true; break;
            }
        }
        if (nonzeroFound) switchScreen("CustomMode", "Merges");
        else {
            document.getElementById("customError").style.setProperty("display", "block");
            if (customSpawningTiles.length == 1) document.getElementById("customError").innerHTML = "There must be at least one spawning tile!"
            else document.getElementById("customError").innerHTML = "There must be at least one spawning tile with a nonzero chance to spawn!"
        }
    }
    else if (subScreen == "Merges") {
        switchScreen("CustomMode", "ConsistencyCheck");
    }
    else if (subScreen == "ConsistencyCheck") {
        switchScreen("CustomMode", "Colors");
    }
    else if (subScreen == "Colors") {
        switchScreen("CustomMode", "Background");
    }
    else if (subScreen == "Background") {
        switchScreen("CustomMode", "Other");
    }
    else if (subScreen == "Other") {
        switchScreen("SaveCode", "CustomExport");
        exportCustomSave();
    }
});
document.getElementById("customAddSpawnButton").addEventListener("click", function(){
    customSpawningTiles.push([2**(customSpawningTiles.length - 1), 1]);
    displayCustomMode("SpawningTiles", screenVars);
});
document.getElementById("customBoxSpawnOff").addEventListener("click", function(){
    customSpawningTiles[0] = !customSpawningTiles[0];
    for (let s = 1; s < customSpawningTiles.length; s++) customSpawningTiles[s][1] = Math.round(customSpawningTiles[s][1]);
    displayCustomMode("SpawningTiles", screenVars);
});
document.getElementById("customBoxSpawnOn").addEventListener("click", function(){
    customSpawningTiles[0] = !customSpawningTiles[0];
    displayCustomMode("SpawningTiles", screenVars);
});
document.getElementById("customMerges_selection_previous").addEventListener("click", function(){
    screenVars[0] -= 1;
    if (screenVars[0] < 0) screenVars[0] = customMerges.length - 1;
    displayCustomMode("Merges", screenVars);
});
document.getElementById("customMerges_selection_next").addEventListener("click", function(){
    screenVars[0] += 1;
    if (screenVars[0] >= customMerges.length) screenVars[0] = 0;
    displayCustomMode("Merges", screenVars);
});
document.getElementById("customMerges_addMerge").addEventListener("click", function(){
    customMerges.push([1, [1, Infinity, 0, 1], [[true, 0]], [[true, 1]], false]);
    screenVars[0] = customMerges.length - 1;
    displayCustomMode("Merges", screenVars);
});
document.getElementById("customMerges_removeMerge").addEventListener("click", function(){
    customMerges.splice(screenVars[0], 1)
    if (screenVars[0] >= customMerges.length) screenVars[0]--;
    displayCustomMode("Merges", screenVars);
});
document.getElementById("customMerges_changeRestrictionForm").addEventListener("click", function(){
    if (customMerges[screenVars[0]][0] == 1) {
        customMerges[screenVars[0]][0] = 0;
        customMerges[screenVars[0]][1] = [1];
    }
    else {
        customMerges[screenVars[0]][0] = 1;
        customMerges[screenVars[0]][1] = [1, Infinity, 0, 1];
    }
    displayCustomMode("Merges", screenVars);
});
document.getElementById("customMerges_minimumInput").addEventListener("change", function(){
    let v = Number(this.value);
    if (this.value === "") v = NaN;
    if (v % 1 == 0 && isFinite(v)) customMerges[screenVars[0]][1][0] = v;
    else customMerges[screenVars[0]][1][0] = -Infinity;
    if (customMerges[screenVars[0]][1][0] > customMerges[screenVars[0]][1][1]) {
        temp = customMerges[screenVars[0]][1][0];
        customMerges[screenVars[0]][1][0] = customMerges[screenVars[0]][1][1];
        customMerges[screenVars[0]][1][1] = temp;
    }
    displayCustomMode("Merges", screenVars);
});
document.getElementById("customMerges_maximumInput").addEventListener("change", function(){
    let v = Number(this.value);
    if (this.value === "") v = NaN;
    if (v % 1 == 0 && isFinite(v)) customMerges[screenVars[0]][1][1] = v;
    else customMerges[screenVars[0]][1][1] = Infinity
    if (customMerges[screenVars[0]][1][0] > customMerges[screenVars[0]][1][1]) {
        temp = customMerges[screenVars[0]][0];
        customMerges[screenVars[0]][1][0] = customMerges[screenVars[0]][1][1];
        customMerges[screenVars[0]][1][1] = temp;
    }
    displayCustomMode("Merges", screenVars);
});
document.getElementById("customMerges_moduloInput1").addEventListener("change", function(){
    let v = Number(this.value);
    if (v % 1 == 0 && isFinite(v)) customMerges[screenVars[0]][1][2] = v;
    customMerges[screenVars[0]][1][2] = mod(customMerges[screenVars[0]][1][2], customMerges[screenVars[0]][1][3]);
    displayCustomMode("Merges", screenVars);
});
document.getElementById("customMerges_moduloInput2").addEventListener("change", function(){
    let v = Number(this.value);
    if (v > 0 && v % 1 == 0 && isFinite(v)) customMerges[screenVars[0]][1][3] = v;
    customMerges[screenVars[0]][1][2] = mod(customMerges[screenVars[0]][1][2], customMerges[screenVars[0]][1][3]);
    displayCustomMode("Merges", screenVars);
});
document.getElementById("customMerges_addInputTile").addEventListener("click", function(){
    customMerges[screenVars[0]][2].push([true, 0]);
    displayCustomMode("Merges", screenVars);
});
document.getElementById("customMerges_output_minus").addEventListener("click", function(){
    if (getComputedStyle(this).getPropertyValue("opacity") != 0) customMerges[screenVars[0]][3][0][1]--;
    displayCustomMode("Merges", screenVars);
});
document.getElementById("customMerges_output_plus").addEventListener("click", function(){
    if (getComputedStyle(this).getPropertyValue("opacity") != 0) customMerges[screenVars[0]][3][0][1]++;
    displayCustomMode("Merges", screenVars);
});
document.getElementById("customMerges_changeOutputForm").addEventListener("click", function(){
    customMerges[screenVars[0]][3][0][0] = !customMerges[screenVars[0]][3][0][0];
    customMerges[screenVars[0]][3][0][1] = Math.max(Math.abs(customMerges[screenVars[0]][3][0][1]), 1) * (customMerges[screenVars[0]][3][0][0] ? -1 : 1)
    displayCustomMode("Merges", screenVars);
});
document.getElementById("customMerges_removeOutput").addEventListener("click", function(){
    customMerges[screenVars[0]][3] = [];
    displayCustomMode("Merges", screenVars);
});
document.getElementById("customMerges_addOutputTile").addEventListener("click", function(){
    customMerges[screenVars[0]][3] = [[true, 0]];
    displayCustomMode("Merges", screenVars);
});
document.getElementById("customMerges_orderedMergeOff").addEventListener("click", function(){
    customMerges[screenVars[0]][4] = !customMerges[screenVars[0]][4];
    displayCustomMode("Merges", screenVars);
});
document.getElementById("customMerges_orderedMergeOn").addEventListener("click", function(){
    customMerges[screenVars[0]][4] = !customMerges[screenVars[0]][4];
    displayCustomMode("Merges", screenVars);
});
document.getElementById("customMode_consistencyTiles_input").addEventListener("change", function(){
    let v = Number(this.value);
    if (v > 0 && v % 1 == 0 && isFinite(v)) screenVars[2] = v;
    displayCustomMode("ConsistencyCheck", screenVars);
})
document.getElementById("customMode_consistencySize_input").addEventListener("change", function(){
    let v = Number(this.value);
    if (v > 0 && isFinite(v)) screenVars[3] = v;
    else screenVars[3] = Infinity;
    displayCustomMode("ConsistencyCheck", screenVars);
});
document.getElementById("customMode_consistencyRun").addEventListener("click", async function(){
    screenVars[1] = true;
    await displayCustomMode("ConsistencyCheck", screenVars);
    await delay(0);
    await customConsistencyCheck();
    screenVars[1] = false;
    screenVars[7] = false;
    displayCustomMode("ConsistencyCheck", screenVars);
});
document.getElementById("customMode_consistencyView").addEventListener("click", function(){
    screenVars[7] = !screenVars[7];
    displayCustomMode("ConsistencyCheck", screenVars);
});
document.getElementById("customColors_selection_previous").addEventListener("click", function(){
    screenVars[0] -= 1;
    if (screenVars[0] < 0) screenVars[0] = customColors.length - 1;
    screenVars[1] = 0;
    displayCustomMode("Colors", screenVars);
});
document.getElementById("customColors_selection_next").addEventListener("click", function(){
    screenVars[0] += 1;
    if (screenVars[0] >= customColors.length) screenVars[0] = 0;
    screenVars[1] = 0;
    displayCustomMode("Colors", screenVars);
});
document.getElementById("customColors_addColorRule").addEventListener("click", function(){
    if (customColors.length == 0) customColors.push([1, [1, Infinity, 0, 1], [["@HSLA", 0, 100, 50, 1, 1, false, 30, 0, true, 0, 0.975, true, 100, 0.95, false, 0, 0]], [0], ["@linear-gradient", 180], ["@HSLA", 0, 100, 0, 1, 1, false, 0, 0, false, 0, 0, false, 0, 0, false, 0, 0]]);
    else customColors.push(compendiumStructuredClone(customColors[screenVars[0]]));
    screenVars[0] = customColors.length - 1;
    screenVars[1] = 0;
    displayCustomMode("Colors", screenVars);
});
document.getElementById("customColors_removeColorRule").addEventListener("click", function(){
    customColors.splice(screenVars[0], 1)
    if (screenVars[0] >= customColors.length) screenVars[0]--;
    screenVars[1] = 0;
    displayCustomMode("Colors", screenVars);
});
document.getElementById("customColors_changeRestrictionForm").addEventListener("click", function(){
    if (customColors[screenVars[0]][0] == 1) {
        customColors[screenVars[0]][0] = 0;
        customColors[screenVars[0]][1] = [1];
    }
    else {
        customColors[screenVars[0]][0] = 1;
        customColors[screenVars[0]][1] = [1, Infinity, 0, 1];
    }
    displayCustomMode("Colors", screenVars);
});
document.getElementById("customColors_minimumInput").addEventListener("change", function(){
    let v = Number(this.value);
    if (this.value === "") v = NaN;
    if (v % 1 == 0 && isFinite(v)) customColors[screenVars[0]][1][0] = v;
    else customColors[screenVars[0]][1][0] = -Infinity;
    if (customColors[screenVars[0]][1][0] > customColors[screenVars[0]][1][1]) {
        temp = customColors[screenVars[0]][1][0];
        customColors[screenVars[0]][1][0] = customColors[screenVars[0]][1][1];
        customColors[screenVars[0]][1][1] = temp;
    }
    displayCustomMode("Colors", screenVars);
});
document.getElementById("customColors_maximumInput").addEventListener("change", function(){
    let v = Number(this.value);
    if (this.value === "") v = NaN;
    if (v % 1 == 0 && isFinite(v)) customColors[screenVars[0]][1][1] = v;
    else customColors[screenVars[0]][1][1] = Infinity
    if (customColors[screenVars[0]][1][0] > customColors[screenVars[0]][1][1]) {
        temp = customColors[screenVars[0]][0];
        customColors[screenVars[0]][1][0] = customColors[screenVars[0]][1][1];
        customColors[screenVars[0]][1][1] = temp;
    }
    displayCustomMode("Colors", screenVars);
});
document.getElementById("customColors_moduloInput1").addEventListener("change", function(){
    let v = Number(this.value);
    if (v % 1 == 0 && isFinite(v)) customColors[screenVars[0]][1][2] = v;
    customColors[screenVars[0]][1][2] = mod(customColors[screenVars[0]][1][2], customColors[screenVars[0]][1][3]);
    displayCustomMode("Colors", screenVars);
});
document.getElementById("customColors_moduloInput2").addEventListener("change", function(){
    let v = Number(this.value);
    if (v > 0 && v % 1 == 0 && isFinite(v)) customColors[screenVars[0]][1][3] = v;
    customColors[screenVars[0]][1][2] = mod(customColors[screenVars[0]][1][2], customColors[screenVars[0]][1][3]);
    displayCustomMode("Colors", screenVars);
});
document.getElementById("customColors_gradientType").addEventListener("click", function(){
    if (customColors[screenVars[0]][4][0] == "@linear-gradient") {
        customColors[screenVars[0]][4] = ["@radial-gradient"]
    }
    else if (customColors[screenVars[0]][4][0] == "@radial-gradient") {
        customColors[screenVars[0]][4] = ["@conic-gradient", 0]
        for (let p = 0; p < customColors[screenVars[0]][3].length; p++) {
            customColors[screenVars[0]][3][p] *= 3.6;
        }
    }
    else {
        customColors[screenVars[0]][4] = ["@linear-gradient", 180]
        for (let p = 0; p < customColors[screenVars[0]][3].length; p++) {
            customColors[screenVars[0]][3][p] /= 3.6;
        }
    }
    displayCustomMode("Colors", screenVars);
});
document.getElementById("customColors_gradientDirectionInput").addEventListener("change", function(){
    let v = Number(this.value);
    if (isFinite(v)) customColors[screenVars[0]][4][1] = v;
    displayCustomMode("Colors", screenVars);
});
document.getElementById("customColors_gradientSelection_previous").addEventListener("click", function(){
    screenVars[1] -= 1;
    if (screenVars[1] < 0) screenVars[1] = customColors[screenVars[0]][2].length - 1;
    displayCustomMode("Colors", screenVars);
});
document.getElementById("customColors_gradientSelection_next").addEventListener("click", function(){
    screenVars[1] += 1;
    if (screenVars[1] >= customColors[screenVars[0]][2].length) screenVars[1] = 0;
    displayCustomMode("Colors", screenVars);
});
document.getElementById("customColors_addGradientEntry").addEventListener("click", function(){
    for (let p = 0; p < customColors[screenVars[0]][3].length; p++) customColors[screenVars[0]][3][p] *= ((customColors[screenVars[0]][3].length - 1) / (customColors[screenVars[0]][3].length));
    customColors[screenVars[0]][2].push(compendiumStructuredClone(customColors[screenVars[0]][2][screenVars[1]]));
    customColors[screenVars[0]][3].push(100);
    screenVars[1] = customColors[screenVars[0]][2].length - 1;
    displayCustomMode("Colors", screenVars);
});
document.getElementById("customColors_removeGradientEntry").addEventListener("click", function(){
    customColors[screenVars[0]][2].splice(screenVars[1], 1)
    customColors[screenVars[0]][3].splice(screenVars[1], 1)
    if (screenVars[1] >= customColors[screenVars[0]][2].length) screenVars[1]--;
    displayCustomMode("Colors", screenVars);
});
document.getElementById("customColors_gradientPositionInput").addEventListener("change", function(){
    let v = Number(this.value);
    if (isFinite(v)) customColors[screenVars[0]][3][screenVars[1]] = v;
    displayCustomMode("Colors", screenVars);
});
document.getElementById("customColors_changeColorSystem").addEventListener("click", function(){
    if (customColors[screenVars[0]][2][screenVars[1]][0] == "@HSLA") {
        customColors[screenVars[0]][2][screenVars[1]] = ["@HSVA", 0, 100, 100, 1, 1, false, 30, 0, true, 0, 0.95, true, 0, 0.95, false, 0, 0];
    }
    else if (customColors[screenVars[0]][2][screenVars[1]][0] == "@HSVA") {
        customColors[screenVars[0]][2][screenVars[1]] = ["@RGBA", 255, 0, 0, 1, 1, true, 0, 1, true, 255, 0.95, true, 255, 0.95, false, 0, 0];
    }
    else {
        customColors[screenVars[0]][2][screenVars[1]] = ["@HSLA", 0, 100, 50, 1, 1, false, 30, 0, true, 0, 0.95, true, 100, 0.9, false, 0, 0];
    }
    displayCustomMode("Colors", screenVars);
});
document.getElementById("customColors_hexFormInput").addEventListener("change", function(){
    let str = this.value;
    while (str[0] == " ") str = str.slice(1);
    if (str[0] == "#") str = str.slice(1);
    str = str.toLowerCase();
    let finalStr = "";
    let allowed = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "a", "b", "c", "d", "e", "f"];
    for (let s = 0; s < str.length; s++) {
        if (allowed.indexOf(str[s]) != -1) finalStr += str[s];
        else if (str[s] != " ") {
            finalStr = "";
            break;
        }
    }
    if (finalStr.length == 3 || finalStr.length == 6) {
        let color = convertColor("#" + finalStr, customColors[screenVars[0]][2][screenVars[1]][0]);
        customColors[screenVars[0]][2][screenVars[1]] = color.concat(customColors[screenVars[0]][2][screenVars[1]].slice(5));
    }
    displayCustomMode("Colors", screenVars);
});
document.getElementById("customColors_startTileInput").addEventListener("change", function(){
    let v = Number(this.value);
    if (v % 1 == 0 && isFinite(v)) customColors[screenVars[0]][2][screenVars[1]][5] = v;
    displayCustomMode("Colors", screenVars);
});
document.getElementById("customColors_startColor1Input").addEventListener("change", function(){
    let v = Number(this.value);
    if (isFinite(v)) customColors[screenVars[0]][2][screenVars[1]][1] = v;
    displayCustomMode("Colors", screenVars);
});
document.getElementById("customColors_startColor2Input").addEventListener("change", function(){
    let v = Number(this.value);
    if (isFinite(v)) customColors[screenVars[0]][2][screenVars[1]][2] = v;
    displayCustomMode("Colors", screenVars);
});
document.getElementById("customColors_startColor3Input").addEventListener("change", function(){
    let v = Number(this.value);
    if (isFinite(v)) customColors[screenVars[0]][2][screenVars[1]][3] = v;
    displayCustomMode("Colors", screenVars);
});
document.getElementById("customColors_increment1ChangeForm").addEventListener("click", function(){
    if (customColors[screenVars[0]][2][screenVars[1]][6]) {
        customColors[screenVars[0]][2][screenVars[1]][6] = false;
        customColors[screenVars[0]][2][screenVars[1]][7] = 30;
    }
    else {
        customColors[screenVars[0]][2][screenVars[1]][6] = true;
        customColors[screenVars[0]][2][screenVars[1]][7] = 0;
        customColors[screenVars[0]][2][screenVars[1]][8] = 0.95;
    }
    displayCustomMode("Colors", screenVars);
});
document.getElementById("customColors_increment2ChangeForm").addEventListener("click", function(){
    if (customColors[screenVars[0]][2][screenVars[1]][9]) {
        customColors[screenVars[0]][2][screenVars[1]][9] = false;
        customColors[screenVars[0]][2][screenVars[1]][10] = 30;
    }
    else {
        customColors[screenVars[0]][2][screenVars[1]][9] = true;
        customColors[screenVars[0]][2][screenVars[1]][10] = 0;
        customColors[screenVars[0]][2][screenVars[1]][11] = 0.95;
    }
    displayCustomMode("Colors", screenVars);
});
document.getElementById("customColors_increment3ChangeForm").addEventListener("click", function(){
    if (customColors[screenVars[0]][2][screenVars[1]][12]) {
        customColors[screenVars[0]][2][screenVars[1]][12] = false;
        customColors[screenVars[0]][2][screenVars[1]][13] = 30;
    }
    else {
        customColors[screenVars[0]][2][screenVars[1]][12] = true;
        customColors[screenVars[0]][2][screenVars[1]][13] = 0;
        customColors[screenVars[0]][2][screenVars[1]][14] = 0.95;
    }
    displayCustomMode("Colors", screenVars);
});
document.getElementById("customColors_increment1_1Input").addEventListener("change", function(){
    let v = Number(this.value);
    if (isFinite(v)) customColors[screenVars[0]][2][screenVars[1]][7] = v;
    displayCustomMode("Colors", screenVars);
});
document.getElementById("customColors_increment1_2Input").addEventListener("change", function(){
    let v = Number(this.value);
    if (v > 0 && isFinite(v)) customColors[screenVars[0]][2][screenVars[1]][8] = v;
    displayCustomMode("Colors", screenVars);
});
document.getElementById("customColors_increment2_1Input").addEventListener("change", function(){
    let v = Number(this.value);
    if (isFinite(v)) customColors[screenVars[0]][2][screenVars[1]][10] = v;
    displayCustomMode("Colors", screenVars);
});
document.getElementById("customColors_increment2_2Input").addEventListener("change", function(){
    let v = Number(this.value);
    if (v > 0 && isFinite(v)) customColors[screenVars[0]][2][screenVars[1]][11] = v;
    displayCustomMode("Colors", screenVars);
});
document.getElementById("customColors_increment3_1Input").addEventListener("change", function(){
    let v = Number(this.value);
    if (isFinite(v)) customColors[screenVars[0]][2][screenVars[1]][13] = v;
    displayCustomMode("Colors", screenVars);
});
document.getElementById("customColors_increment3_2Input").addEventListener("change", function(){
    let v = Number(this.value);
    if (v > 0 && isFinite(v)) customColors[screenVars[0]][2][screenVars[1]][14] = v;
    displayCustomMode("Colors", screenVars);
});
document.getElementById("customColors_changeColorSystemText").addEventListener("click", function(){
    if (customColors[screenVars[0]][5][0] == "@HSLA") {
        customColors[screenVars[0]][5] = ["@HSVA", 0, 100, 100, 1, 1, false, 30, 0, true, 0, 0.95, true, 0, 0.95, false, 0, 0];
    }
    else if (customColors[screenVars[0]][5][0] == "@HSVA") {
        customColors[screenVars[0]][5] = ["@RGBA", 255, 0, 0, 1, 1, true, 0, 1, true, 255, 0.95, true, 255, 0.95, false, 0, 0];
    }
    else {
        customColors[screenVars[0]][5] = ["@HSLA", 0, 100, 50, 1, 1, false, 30, 0, true, 0, 0.95, true, 100, 0.9, false, 0, 0];
    }
    displayCustomMode("Colors", screenVars);
});
document.getElementById("customColors_hexFormInputText").addEventListener("change", function(){
    let str = this.value;
    while (str[0] == " ") str = str.slice(1);
    if (str[0] == "#") str = str.slice(1);
    str = str.toLowerCase();
    let finalStr = "";
    let allowed = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "a", "b", "c", "d", "e", "f"];
    for (let s = 0; s < str.length; s++) {
        if (allowed.indexOf(str[s]) != -1) finalStr += str[s];
        else if (str[s] != " ") {
            finalStr = "";
            break;
        }
    }
    if (finalStr.length == 3 || finalStr.length == 6 || finalStr.length == 4 || finalStr.length == 8) {
        let color = convertColor("#" + finalStr, customColors[screenVars[0]][5][0]);
        customColors[screenVars[0]][5] = color.concat(customColors[screenVars[0]][5].slice(5));
    }
    displayCustomMode("Colors", screenVars);
});
document.getElementById("customColors_startTileInputText").addEventListener("change", function(){
    let v = Number(this.value);
    if (v % 1 == 0 && isFinite(v)) customColors[screenVars[0]][5][5] = v;
    displayCustomMode("Colors", screenVars);
});
document.getElementById("customColors_startColor1InputText").addEventListener("change", function(){
    let v = Number(this.value);
    if (isFinite(v)) customColors[screenVars[0]][5][1] = v;
    displayCustomMode("Colors", screenVars);
});
document.getElementById("customColors_startColor2InputText").addEventListener("change", function(){
    let v = Number(this.value);
    if (isFinite(v)) customColors[screenVars[0]][5][2] = v;
    displayCustomMode("Colors", screenVars);
});
document.getElementById("customColors_startColor3InputText").addEventListener("change", function(){
    let v = Number(this.value);
    if (isFinite(v)) customColors[screenVars[0]][5][3] = v;
    displayCustomMode("Colors", screenVars);
});
document.getElementById("customColors_startColor4InputText").addEventListener("change", function(){
    let v = Number(this.value);
    if (isFinite(v)) customColors[screenVars[0]][5][4] = v;
    displayCustomMode("Colors", screenVars);
});
document.getElementById("customColors_increment1ChangeFormText").addEventListener("click", function(){
    if (customColors[screenVars[0]][5][6]) {
        customColors[screenVars[0]][5][6] = false;
        customColors[screenVars[0]][5][7] = 30;
    }
    else {
        customColors[screenVars[0]][5][6] = true;
        customColors[screenVars[0]][5][7] = 0;
        customColors[screenVars[0]][5][8] = 0.95;
    }
    displayCustomMode("Colors", screenVars);
});
document.getElementById("customColors_increment2ChangeFormText").addEventListener("click", function(){
    if (customColors[screenVars[0]][5][9]) {
        customColors[screenVars[0]][5][9] = false;
        customColors[screenVars[0]][5][10] = 30;
    }
    else {
        customColors[screenVars[0]][5][9] = true;
        customColors[screenVars[0]][5][10] = 0;
        customColors[screenVars[0]][5][11] = 0.95;
    }
    displayCustomMode("Colors", screenVars);
});
document.getElementById("customColors_increment3ChangeFormText").addEventListener("click", function(){
    if (customColors[screenVars[0]][5][12]) {
        customColors[screenVars[0]][5][12] = false;
        customColors[screenVars[0]][5][13] = 30;
    }
    else {
        customColors[screenVars[0]][5][12] = true;
        customColors[screenVars[0]][5][13] = 0;
        customColors[screenVars[0]][5][14] = 0.95;
    }
    displayCustomMode("Colors", screenVars);
});
document.getElementById("customColors_increment4ChangeFormText").addEventListener("click", function(){
    if (customColors[screenVars[0]][5][15]) {
        customColors[screenVars[0]][5][15] = false;
        customColors[screenVars[0]][5][16] = 30;
    }
    else {
        customColors[screenVars[0]][5][15] = true;
        customColors[screenVars[0]][5][16] = 0;
        customColors[screenVars[0]][5][17] = 0.95;
    }
    displayCustomMode("Colors", screenVars);
});
document.getElementById("customColors_increment1_1InputText").addEventListener("change", function(){
    let v = Number(this.value);
    if (isFinite(v)) customColors[screenVars[0]][5][7] = v;
    displayCustomMode("Colors", screenVars);
});
document.getElementById("customColors_increment1_2InputText").addEventListener("change", function(){
    let v = Number(this.value);
    if (v > 0 && isFinite(v)) customColors[screenVars[0]][5][8] = v;
    displayCustomMode("Colors", screenVars);
});
document.getElementById("customColors_increment2_1InputText").addEventListener("change", function(){
    let v = Number(this.value);
    if (isFinite(v)) customColors[screenVars[0]][5][10] = v;
    displayCustomMode("Colors", screenVars);
});
document.getElementById("customColors_increment2_2InputText").addEventListener("change", function(){
    let v = Number(this.value);
    if (v > 0 && isFinite(v)) customColors[screenVars[0]][5][11] = v;
    displayCustomMode("Colors", screenVars);
});
document.getElementById("customColors_increment3_1InputText").addEventListener("change", function(){
    let v = Number(this.value);
    if (isFinite(v)) customColors[screenVars[0]][5][13] = v;
    displayCustomMode("Colors", screenVars);
});
document.getElementById("customColors_increment3_2InputText").addEventListener("change", function(){
    let v = Number(this.value);
    if (v > 0 && isFinite(v)) customColors[screenVars[0]][5][14] = v;
    displayCustomMode("Colors", screenVars);
});
document.getElementById("customColors_increment4_1InputText").addEventListener("change", function(){
    let v = Number(this.value);
    if (isFinite(v)) customColors[screenVars[0]][5][16] = v;
    displayCustomMode("Colors", screenVars);
});
document.getElementById("customColors_increment4_2InputText").addEventListener("change", function(){
    let v = Number(this.value);
    if (v > 0 && isFinite(v)) customColors[screenVars[0]][5][17] = v;
    displayCustomMode("Colors", screenVars);
});
document.getElementById("customBackground_selection_previous").addEventListener("click", function(){
    screenVars[0] = mod(screenVars[0] - 1, 5);
    screenVars[1] = 0;
    displayCustomMode("Background", screenVars);
});
document.getElementById("customBackground_selection_next").addEventListener("click", function(){
    screenVars[0] = mod(screenVars[0] + 1, 5);
    screenVars[1] = 0;
    displayCustomMode("Background", screenVars);
});
document.getElementById("customBackground_gradientType").addEventListener("click", function(){
    if (customBackground[screenVars[0]][0] == "@linear-gradient") {
        customBackground[screenVars[0]][0] = "@radial-gradient"
    }
    else if (customBackground[screenVars[0]][0] == "@radial-gradient") {
        customBackground[screenVars[0]][0] = "@conic-gradient"
        customBackground[screenVars[0]][1] = 0;
        for (let p = 0; p < customBackground[screenVars[0]][2].length; p++) {
            customBackground[screenVars[0]][2][p] *= 3.6;
        }
    }
    else {
        customBackground[screenVars[0]][0] = "@linear-gradient"
        customBackground[screenVars[0]][1] = 180;
        for (let p = 0; p < customBackground[screenVars[0]][2].length; p++) {
            customBackground[screenVars[0]][2][p] /= 3.6;
        }
    }
    displayCustomMode("Background", screenVars);
});
document.getElementById("customBackground_gradientDirectionInput").addEventListener("change", function(){
    let v = Number(this.value);
    if (isFinite(v)) customBackground[screenVars[0]][1] = v;
    displayCustomMode("Background", screenVars);
});
document.getElementById("customBackground_gradientSelection_previous").addEventListener("click", function(){
    screenVars[1] -= 1;
    if (screenVars[1] < 0) screenVars[1] = customBackground[screenVars[0]][2].length - 1;
    displayCustomMode("Background", screenVars);
});
document.getElementById("customBackground_gradientSelection_next").addEventListener("click", function(){
    screenVars[1] += 1;
    if (screenVars[1] >= customBackground[screenVars[0]][2].length) screenVars[1] = 0;
    displayCustomMode("Background", screenVars);
});
document.getElementById("customBackground_addGradientEntry").addEventListener("click", function(){
    for (let p = 0; p < customBackground[screenVars[0]][2].length; p++) customBackground[screenVars[0]][2][p] *= ((customBackground[screenVars[0]][2].length - 1) / (customBackground[screenVars[0]][2].length));
    customBackground[screenVars[0]][3].push(compendiumStructuredClone(customBackground[screenVars[0]][3][screenVars[1]]));
    customBackground[screenVars[0]][2].push(100);
    screenVars[1] = customBackground[screenVars[0]][2].length - 1;
    displayCustomMode("Background", screenVars);
});
document.getElementById("customBackground_removeGradientEntry").addEventListener("click", function(){
    customBackground[screenVars[0]][2].splice(screenVars[1], 1)
    customBackground[screenVars[0]][3].splice(screenVars[1], 1)
    if (screenVars[1] >= customBackground[screenVars[0]][2].length) screenVars[1]--;
    displayCustomMode("Background", screenVars);
});
document.getElementById("customBackground_gradientPositionInput").addEventListener("change", function(){
    let v = Number(this.value);
    if (isFinite(v)) customBackground[screenVars[0]][2][screenVars[1]] = v;
    displayCustomMode("Background", screenVars);
});
document.getElementById("customBackground_changeColorSystem").addEventListener("click", function(){
    if (customBackground[screenVars[0]][3][screenVars[1]][0] == "@HSLA") {
        customBackground[screenVars[0]][3][screenVars[1]] = ["@HSVA", 0, 100, 100, 1];
    }
    else if (customBackground[screenVars[0]][3][screenVars[1]][0] == "@HSVA") {
        customBackground[screenVars[0]][3][screenVars[1]] = ["@RGBA", 255, 0, 0, 1];
    }
    else {
        customBackground[screenVars[0]][3][screenVars[1]] = ["@HSLA", 0, 100, 50, 1];
    }
    displayCustomMode("Background", screenVars);
});
document.getElementById("customBackground_hexFormInput").addEventListener("change", function(){
    let str = this.value;
    while (str[0] == " ") str = str.slice(1);
    if (str[0] == "#") str = str.slice(1);
    str = str.toLowerCase();
    let finalStr = "";
    let allowed = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "a", "b", "c", "d", "e", "f"];
    for (let s = 0; s < str.length; s++) {
        if (allowed.indexOf(str[s]) != -1) finalStr += str[s];
        else if (str[s] != " ") {
            finalStr = "";
            break;
        }
    }
    if (finalStr.length == 3 || finalStr.length == 6) {
        let color = convertColor("#" + finalStr, customBackground[screenVars[0]][3][screenVars[1]][0]);
        customBackground[screenVars[0]][3][screenVars[1]] = color;
    }
    displayCustomMode("Background", screenVars);
});
document.getElementById("customBackground_startColor1Input").addEventListener("change", function(){
    let v = Number(this.value);
    if (isFinite(v)) customBackground[screenVars[0]][3][screenVars[1]][1] = v;
    displayCustomMode("Background", screenVars);
});
document.getElementById("customBackground_startColor2Input").addEventListener("change", function(){
    let v = Number(this.value);
    if (isFinite(v)) customBackground[screenVars[0]][3][screenVars[1]][2] = v;
    displayCustomMode("Background", screenVars);
});
document.getElementById("customBackground_startColor3Input").addEventListener("change", function(){
    let v = Number(this.value);
    if (isFinite(v)) customBackground[screenVars[0]][3][screenVars[1]][3] = v;
    displayCustomMode("Background", screenVars);
});
document.getElementById("customOther_winConditionAmount_minus").addEventListener("click", function(){
    customWins[0]--;
    displayCustomMode("Other", screenVars);
});
document.getElementById("customOther_winConditionAmount_plus").addEventListener("click", function(){
    customWins[0]++;
    displayCustomMode("Other", screenVars);
});
document.getElementById("customOther_loseConditionAmount_minus").addEventListener("click", function(){
    customLosses[0]--;
    displayCustomMode("Other", screenVars);
});
document.getElementById("customOther_loseConditionAmount_plus").addEventListener("click", function(){
    customLosses[0]++;
    displayCustomMode("Other", screenVars);
});
document.getElementById("customOther_rulesHeadingInput").addEventListener("change", function() {
    customRulesText[0] = he.encode(this.value);
    displayCustomMode("Other", screenVars);
});
document.getElementById("customOther_rulesTitleInput").addEventListener("change", function() {
    customRulesText[1] = he.encode(this.value);
    displayCustomMode("Other", screenVars);
});
document.getElementById("customOther_rulesDescriptionInput").addEventListener("change", function() {
    customRulesText[2] = he.encode(this.value);
    displayCustomMode("Other", screenVars);
});
document.getElementById("customOther_defaultSize_minus").addEventListener("click", function(){
    customRulesText[3]--;
    displayCustomMode("Other", screenVars);
});
document.getElementById("customOther_defaultSize_plus").addEventListener("click", function(){
    customRulesText[3]++;
    displayCustomMode("Other", screenVars);
});
document.getElementById("save_code_customPrevious").addEventListener("click", function(){
    switchScreen("CustomMode", "Other");
});
document.getElementById("save_code_customPlay").addEventListener("click", function(){
    loadMode(-1);
});
document.getElementById("save_code_customRestart").addEventListener("click", function(){
    switchScreen("CustomMode", "SpawningTiles");
});
document.getElementById("regularGuide_return").addEventListener("click", function(){
    switchScreen("Menu", 1);
});
document.getElementById("customGuide_return").addEventListener("click", function(){
    switchScreen("CustomMode", "Opening");
});
for (let c of document.getElementsByClassName("customGuide_exampleReveal")) {
    c.addEventListener("click", function(){
        let d = c.parentElement;
        d = d.children[d.children.length - 1];
        if (getComputedStyle(d).getPropertyValue("display") == "none") {
            d.style.setProperty("display", "block");
            c.innerHTML = "Hide Save Code";
        }
        else {
            d.style.setProperty("display", "none");
            c.innerHTML = "Show Save Code";
        }
    })
};
let secretsFound = [false, false, false, false, false, false, false];
let otherSecretStats = [false, false, 0, 0, 0]; // 0th entry is whether the office saves on reload. 1st, 2nd, and 3rd entries relate to secret 3. 4th entry relates to secret 4.
if (SCparse(localStorage.getItem("2048PowerCompendium_secretsStored")) === true) {
    otherSecretStats[0] = true;
    if (localStorage.getItem("2048PowerCompendium_secretsFound")) secretsFound = SCparse(localStorage.getItem("2048PowerCompendium_secretsFound"));
}
while (secretsFound.length < 7) secretsFound.push(false);
document.getElementById("titleZero").addEventListener("click", function(){
    secretsFound[0] = true;
    switchScreen("Guide", "SecretOffice");
});
document.getElementById("secretOffice_return").addEventListener("click", function(){
    switchScreen("Menu", 1);
});
document.getElementById("secretOffice_trackingOff").addEventListener("click", function(){
    otherSecretStats[0] = true;
    switchScreen("Guide", "SecretOffice");
});
document.getElementById("secretOffice_trackingOn").addEventListener("click", function(){
    otherSecretStats[0] = false;
    switchScreen("Guide", "SecretOffice");
});
document.getElementById("tile_viewer_return").addEventListener("click", function(){
    switchScreen("Menu", 1);
});
document.getElementById("tile_viewer_return").addEventListener("click", function(){
    switchScreen("Menu", 1);
});
document.getElementById("tile_viewer_next").addEventListener("click", function(){
    changeViewerScheme(1);
});
document.getElementById("tile_viewer_previous").addEventListener("click", function(){
    changeViewerScheme(-1);
});
document.getElementById("viewer_number_change").addEventListener("change", function() {
    try {
        let v = BigInt(this.value);
        screenVars[0] = v;
    }
    catch {
        screenVars[0] = 0n;
    }
    displayViewerTile();
});
document.getElementById("viewer_gaussian_real_change").addEventListener("change", function() {
    try {
        let v = BigInt(this.value);
        screenVars[0].real = v;
    }
    catch {
        screenVars[0].real = 0n;
    }
    displayViewerTile();
});
document.getElementById("viewer_gaussian_imaginary_change").addEventListener("change", function() {
    try {
        let v = BigInt(this.value);
        screenVars[0].imaginary = v;
    }
    catch {
        screenVars[0].imaginary = 0n;
    }
    displayViewerTile();
});
document.getElementById("viewer_primes_change").addEventListener("change", function() {
    let v = Number(this.value);
    if (isFinite(v) && v > 0 && v % 1 == 0) screenVars[1] = v;
    else screenVars[1] = Infinity;
    displayViewerTile();
});
document.getElementById("viewer_WildcardText_button").addEventListener("click", function() {
    screenVars[1] = !screenVars[1];
    displayViewerTile();
});
document.getElementById("viewer_base_change").addEventListener("change", function() {
    let v = Number(this.value);
    if (isFinite(v) && v > 1 && v % 1 == 0) screenVars[1] = v;
    displayViewerTile();
});
document.getElementById("viewer_hideNumber").addEventListener("click", function() {
    screenVars[2] = !screenVars[2];
    displayViewerTile();
});
for (f of document.getElementsByTagName("form")) {
    f.addEventListener("submit", function(e){
        e.preventDefault();
    });
}

let currentScreen = "Menu";
let subScreen = 1;
let screenVars = [];
switchScreen("Menu", 1);
let modes_order = [
    1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25,
    26, 27, 28, 46, 52, 33, 76, 63, 53, 30, 64, 65, 66, 32, 42, 29, 47, 51, 48, 87, 83, 84, 90, 94, 38,
    54, 55, 56, 57, 68, 67, 77, 78, 80, 86, 89, 72, 61, 79, 91, 73, 88, 93, 95, 75, 85, 96, 92, 58, 41,
    31, 49, 81, 82, 40, 43, 59, 70, 69, 97, 34, 35, 36, 98, 62, 37, 71, 39, 60, 99, 45, 74, 50, 44, 100
]
for (let t = 1; t <= modes_order.length; t++) { //Adding event listeners to the main mode tiles on the menu
    let mtile = document.getElementById("menu_grid_storage").firstElementChild;
    let position = modes_order.indexOf(t);
    document.getElementById("menu_grid_" + (Math.floor(position/25) + 1)).appendChild(mtile);
    mtile.style.setProperty("left", "calc(var(--menu_grid_size) * " + ((position % 5) * 14.75 + 1.25) + " / 75)");
    mtile.style.setProperty("top", "calc(var(--menu_grid_size) * " + ((Math.floor((position % 25) / 5)) * 14.75 + 1.25) + " / 75)");
    mtile.id = "menu_tile_" + t;
    if (mtile.innerHTML != "TBA" && t != 37 && t != 71) {
        mtile.addEventListener("click", function(){
            loadMode(t);
            document.getElementById("gm_big_tile").style.setProperty("display", "flex");
            document.getElementById("gm_big_tile").style.setProperty("background-color", getComputedStyle(this).getPropertyValue("background-color"));
            document.getElementById("gm_big_tile").innerHTML = this.innerHTML;
            document.getElementById("gm_big_tile").style.setProperty("background-image", getComputedStyle(this).getPropertyValue("background-image"));
            document.getElementById("gm_big_tile").style.setProperty("--gm_tfs", getComputedStyle(this).getPropertyValue("--tile_font_size") * 1.25);
            OSTDEUpdate(0);
        });
        mtile.addEventListener("mouseenter", function(){
            OSTDEUpdate(0);
        });
    }
}
document.getElementById("menu_tile_37").addEventListener("click", function(){
    if (otherSecretStats[1]) loadMode(37.71);
    else loadMode(37);
    document.getElementById("gm_big_tile").style.setProperty("display", "flex");
    document.getElementById("gm_big_tile").style.setProperty("background-color", getComputedStyle(this).getPropertyValue("background-color"));
    document.getElementById("gm_big_tile").innerHTML = this.innerHTML;
    document.getElementById("gm_big_tile").style.setProperty("background-image", getComputedStyle(this).getPropertyValue("background-image"));
    document.getElementById("gm_big_tile").style.setProperty("--gm_tfs", getComputedStyle(this).getPropertyValue("--tile_font_size") * 1.25);
});
document.getElementById("menu_tile_71").addEventListener("click", function(){
    if (otherSecretStats[1]) loadMode(71.37);
    else loadMode(71);
    document.getElementById("gm_big_tile").style.setProperty("display", "flex");
    document.getElementById("gm_big_tile").style.setProperty("background-color", getComputedStyle(this).getPropertyValue("background-color"));
    document.getElementById("gm_big_tile").innerHTML = this.innerHTML;
    document.getElementById("gm_big_tile").style.setProperty("background-image", getComputedStyle(this).getPropertyValue("background-image"));
    document.getElementById("gm_big_tile").style.setProperty("--gm_tfs", getComputedStyle(this).getPropertyValue("--tile_font_size") * 1.25);
});
document.getElementById("menu_tile_37").addEventListener("mouseenter", function(){
    OSTDEUpdate(2);
});
document.getElementById("menu_tile_71").addEventListener("mouseenter", function(){
    OSTDEUpdate(1);
});
document.getElementById("GaussianDIVE_enter_button").addEventListener("click", function(){
    loadMode(50.1);
    document.getElementById("gm_big_tile").style.setProperty("display", "flex");
    document.getElementById("gm_big_tile").innerHTML = "Gaussian DIVE";
    document.getElementById("gm_big_tile").style.setProperty("background-image", "conic-gradient(at 50% -10%, #0000 0% 35%, #0004 40% 45%, #fff4 47.5% 52.5%, #0004 55% 60%, #0000 65%), conic-gradient(from 180deg at 50% 110%, #0000 0% 35%, #0004 40% 45%, #fff4 47.5% 52.5%, #0004 55% 60%, #0000 65%), conic-gradient(from 90deg at 110% 50%, #0000 0% 35%, #0004 40% 45%, #fff4 47.5% 52.5%, #0004 55% 60%, #0000 65%), conic-gradient(from 270deg at -10% 50%, #0000 0% 35%, #0004 40% 45%, #fff4 47.5% 52.5%, #0004 55% 60%, #0000 65%), linear-gradient(#333c55, #333c55, #5e6644, #5e6644)");
    document.getElementById("gm_big_tile").style.setProperty("--gm_tfs", 2.8 * 1.25);
    secretsFound[1] = true;
});
document.getElementById("MergeOverflow256_enter_button").addEventListener("click", function(){
    loadMode(3.24);
    document.getElementById("gm_big_tile").style.setProperty("display", "flex");
    document.getElementById("gm_big_tile").innerHTML = "Merge Overflow 256";
    document.getElementById("gm_big_tile").style.setProperty("background-image", "linear-gradient(#0000, #0000, #fffe, #0000, #0000), linear-gradient(#ff8c8c 0% 50%,#990000 50% 100%)");
    document.getElementById("gm_big_tile").style.setProperty("--gm_tfs", 3 * 1.25);
    secretsFound[4] = true;
});
document.getElementById("reciprocal512_enter_button").addEventListener("click", function(){
    loadMode(1.5);
    document.getElementById("gm_big_tile").style.setProperty("display", "flex");
    document.getElementById("gm_big_tile").innerHTML = "1/512";
    document.getElementById("gm_big_tile").style.setProperty("background-image", "linear-gradient(135deg,#edc850,#dc44e4)");
    document.getElementById("gm_big_tile").style.setProperty("--gm_tfs", 4.5 * 1.25);
    secretsFound[5] = true;
});
document.getElementById("PA19683_enter_button").addEventListener("click", function(){
    loadMode(34.39);
    document.getElementById("gm_big_tile").style.setProperty("display", "flex");
    document.getElementById("gm_big_tile").innerHTML = "Partial Absorb 19,683";
    document.getElementById("gm_big_tile").style.setProperty("background-image", "linear-gradient(#670f66 0% 50%,#ffa8d8 50% 100%)");
    document.getElementById("gm_big_tile").style.setProperty("--gm_tfs", 3.2 * 1.25);
    secretsFound[6] = true;
});
let inputAvailable = true;

// window.addEventListener('keydown', (e) => {
//     if (e.key == "g" && currentScreen == "Gameplay") {
//         output(Grid);
//     }
// }
// )
// window.addEventListener('keydown', (e) => {
//     if (e.key == "v" && currentScreen == "Gameplay") {
//         output(game_vars);
//     }
// }
// )
// window.addEventListener('keydown', (e) => {
//     if (e.key == "t" && currentScreen == "Gameplay") {
//         output(TileTypes);
//     }
// }
// )
// window.addEventListener('keydown', (e) => {
//     if (e.key == "m" && currentScreen == "Gameplay") {
//         output(MergeRules);
//     }
// }
// )
// window.addEventListener('keydown', (e) => {
//     if (e.key == "p" && currentScreen == "Gameplay") {
//         output(TileSpawns);
//     }
// }
// )
// window.addEventListener('keydown', (e) => {
//     if (e.key == "o" && currentScreen == "Gameplay") {
//         output(mode_vars);
//     }
// }
// )
// window.addEventListener('keydown', (e) => {
//     if (currentScreen == "CustomMode") {
//         if (e.key == "s") {
//             output(customSpawningTiles);
//         }
//         else if (e.key == "m") {
//             output(customMerges);
//         }
//         else if (e.key == "g") {
//             output(customGeneratedTiles);
//         }
//         else if (e.key == "c") {
//             output(customColors);
//         }
//         else if (e.key == "b") {
//             output(customBackground);
//         }
//         else if (e.key == "w") {
//             output(customWins);
//         }
//         else if (e.key == "l") {
//             output(customLosses);
//         }
//         else if (e.key == "r") {
//             output(customRulesText);
//         }
//     }
// })

// loadMode(80);
// width = 6; height = 6;
// startGame();
// for (let h = 0; h < height; h++) {
//     for (let w = 0; w < width; w++) {
//         let g = h * width + w;
//         let cycle = [2, 4];
//         Grid[h][w] = [2n**BigInt(g + 1) - 1n, 1n];
//     }
// }
// displayGrid();

//Basic functions
function eqPrimArrays(a1, a2) { //"Equal Primitive Arrays"; tests if two arrays are equal. Only works if the arrays being compared do not contain non-array objects themselves (though exceptions have been made to allow GaussianBigInts and BigRationals), but works on nested arrays.
    if (!(Array.isArray(a1) && Array.isArray(a2))) {
        if (a1 instanceof GaussianBigInt && a2 instanceof GaussianBigInt) return GaussianBigInt.eq(a1, a2);
        else if (a1 instanceof GaussianBigInt || a2 instanceof GaussianBigInt) return false;
        if (a1 instanceof BigRational && a2 instanceof BigRational) return BigRational.eq(a1, a2);
        else if (a1 instanceof BigRational || a2 instanceof BigRational) return false;
        else return (a1 === a2);
    }
    else if (a1.length != a2.length) return false;
    else for (let i = 0; i < a1.length; i++) {
        if (!eqPrimArrays(a1[i], a2[i])) return false;
    }
    return true;
}

function indexOfPrimArray(inner, outer) {//Checks for the index of inner within outer; works even when inner is itself an array, and can be used on other things with a length property (like strings)
    if (!("length" in outer) || outer.length == 0) return -1;
    let from = 0;
    if (arguments.length > 2) from = arguments[2];
    for (let i = 0; i < outer.length; i++) {
        if (eqPrimArrays(outer[i], inner)) return i;
    }
    return -1;
}

function lastIndexOfPrimArray(inner, outer) {//Checks for the index of inner within outer; works even when inner is itself an array, and can be used on other things with a length property (like strings)
    if (!("length" in outer) || outer.length == 0) return -1;
    let from = outer.length - 1;
    if (arguments.length > 2) from = arguments[2];
    for (let i = outer.length - 1; i >= 0; i--) {
        if (eqPrimArrays(outer[i], inner)) return i;
    }
    return -1;
}

function indexOfNestedPrimArray(inner, outer) {//Checks for the index of inner within outer; works even when inner is itself an array, and can be used on other things with a length property (like strings). Can find indexes of subarrays; for example, if inner is outer[1][5], then this function will return [1, 5]
    if (!("length" in outer) || outer.length == 0) return -1;
    for (let i = 0; i < outer.length; i++) {
        if (eqPrimArrays(outer[i], inner)) return i;
    }
    for (let i = 0; i < outer.length; i++) {
        let index = -1;
        if (Array.isArray(outer[i])) index = indexOfNestedPrimArray(inner, outer[i]);
        if (index != -1) {
            if (typeof index == "number") return [i, index];
            else {
                let arr = [i]
                return arr.concat(index);
            }
        }
    }
    return -1;
}

function eqRearrangeArrays(a1, a2) { // Like eqPrimArrays, but two arrays count as equal if they're rearrangements of each other
    if (!Array.isArray(a1) || !Array.isArray(a2)) return eqPrimArrays(a1, a2);
    a1 = compendiumStructuredClone(a1);
    a2 = compendiumStructuredClone(a2);
    while (a2.length > 0) {
        let index = indexOfPrimArray(a2[a2.length - 1], a1);
        if (index == -1) return false;
        a1.splice(index, 1); a2.pop();
    }
    return true;
}

function getRndInteger(min, max) { //Taken from W3Schools; returns a random integer between min and max (inclusive).
    if (max < min) return getRndInteger(max, min);
    return Math.floor(Math.random() * (max - min + 1) ) + min;
}

function getRndFloat(min, max) {
    if (max < min) return getRndFloat(max, min);
    return Math.random() * (max - min) + min;
}

function getRndBigInt(min, max) {
    min = BigInt(min);
    max = BigInt(max);
    if (max < min) return getRndBigInt(max, min);
    // Cut the interval in half each time
    let midpoint;
    while (max - min > 1n) {
        midpoint = (max + min) / 2n;
        if (Math.random() > 0.5) max = midpoint;
        else min = midpoint;
    }
    if (Math.random() > 0.5) return max;
    else return min;
}

function weightedRandomArrayEntry(entries, weights) { // Returns a random entry from the first array, where the second array is a list of the weight of each entry in the randomizer
    while (weights.length < entries.length) weights.push(0);
    if (entries.length < weights.length) entries = entries.slice(0, weights.length);
    let total = 0;
    for (let w of weights) total += w;
    let rand = Math.random() * total;
    let e = 0;
    for (e = 0; e < entries.length; e++) {
        rand -= weights[e];
        if (rand <= 0) break;
    }
    if (e >= entries.length) e = entries.length - 1 // Floating point imprecision precaution
    return entries[e];
}

function delay(milliseconds){ //Taken from Alvaro Trigo, only works in an async function
    return new Promise(resolve => {
        setTimeout(resolve, milliseconds);
    });
}

function orders(num) { //Returns an array containing every permutation of "num" numbers
    if (num == 1) return [[0]];
    let prev = orders(num - 1);
    let result = [];
    for (let pos = num - 1; pos >= 0; pos--) {
        for (let e = 0; e < prev.length; e++) {
            let entry = compendiumStructuredClone(prev[e]);
            entry.splice(pos, 0, num - 1);
            result.push(entry);
        }
    }
    return result;
}

function max(a, b) {//This exists so CalcArray can use max on strings
    if (b > a) return b;
    else return a;
}

function min(a, b) {
    if (b < a) return b;
    else return a;
}

function abs(a) {
    if (a >= 0) return a;
    else if (a < 0 && typeof a == "number") return a * -1;
    else if (a < 0 && typeof a == "bigint") return a * -1n;
    else throw new Error("Invalid argument.");
}

function sign(a) {
    if (typeof a == "number") {
        if (a > 0) return 1;
        else if (a < 0) return -1;
        else if (a == 0) return 0;
        else return NaN;
    }
    else if (typeof a == "bigint") {
        if (a > 0n) return 1n;
        else if (a < 0n) return -1n;
        else if (a == 0n) return 0n;
        else throw new Error("Invalid bigint.")
    }
    else throw new Error("Invalid argument.")
}

function gcd(a, b) {
    if (b == 0) {
      return a;
    }

    return gcd(b, a % b);
}

function lcm(a, b) {
    return a * b / gcd(a, b);
}

function mod(n, m) { //mod(-1, 8) is 7 rather than -1. Taken from https://stackoverflow.com/questions/4467539/javascript-modulo-gives-a-negative-result-for-negative-numbers
    if (m == 0) { // Avoids errors
        if (typeof n == "bigint") return 0n;
        else return 0;
    }
    return ((n % m) + m) % m;
}

function modularDistance(n1, n2, m) {
    return Math.min(Math.abs(mod(n1, m) - mod(n2, m)), Math.abs(mod(n1, m) - mod(n2, m) - m), Math.abs(mod(n1, m) - mod(n2, m) + m));
}

function arrayTypes(arr) { //Returns all the types of the entries in the array: an array of all numbers will return ["number"], an array of numbers and strings will return ["number", "string"] or ["string", "number"] depending on which type shows up first, an array of arrays of numbers will return [["number"]]
    if (!(Array.isArray(arr))) return (typeof arr);
    let typeslist = [];
    for (let i = 0; i < arr.length; i++) {
        let entry_type = typeof arr[i];
        if (Array.isArray(arr[i])) entry_type = arrayTypes(arr[i]);
        if (indexOfPrimArray(entry_type, typeslist) == -1) typeslist.push(entry_type);
    }
    return typeslist;
}

function primesUpdate(max) {
    if (primes[primes.length - 1] >= max) return;
    try {
        max = BigInt(max);
        while (primes[primes.length - 1] ** 2n < max) primesUpdate(primes[primes.length - 1] ** 2n - 1n);
        let arr = Array(Number(max) + 1).fill(true);
        arr[0] = false; arr[1] = false;
        for (let p = 0; p < primes.length && primes[p] ** 2n <= max; p++) {
            for (let i = Number(primes[p]) * 2; i < arr.length; i += Number(primes[p])) {
                arr[i] = false;
            }
        }
        let newprimes = [];
        for (let a = 0; a < arr.length; a++) {
            if (arr[a]) newprimes.push(BigInt(a));
        }
        primes = newprimes;
    }
    catch {
        return;
    }
}

function gaussianSort(a, b) {
    //Sort by norm
    if (a.norm() > b.norm()) return 1;
    if (a.norm() < b.norm()) return -1;
    // If norms are equal, sort by quadrant
    if (a.quadrant() > b.quadrant()) return 1;
    if (a.quadrant() < b.quadrant()) return -1;
    //If quadrants are also equal, sort by taxicab distance
    if (a.real + a.imaginary > b.real + b.imaginary) return 1;
    if (a.real + a.imaginary < b.real + b.imaginary) return -1;
    //If that's equal too, we're looking at a+bi and b+ai. Sort by imaginary part, because I want 2+i to come before 1+2i
    if (a.imaginary > b.imaginary) return 1;
    if (a.imaginary < b.imaginary) return -1;
    //If those are equal then the two numbers are equal.
    return 0;
}

function gaussianPrimesUpdate(maxNorm) {
    while (gaussian_primes[gaussian_primes.length - 1].norm()**2n < maxNorm) gaussianPrimesUpdate(gaussian_primes[gaussian_primes.length - 1].norm() ** 2n - 1n);
    let arr = [];
    for (let r = 0; r <= maxNorm; r++) {
        arr.push([]);
        for (let i = 0; r**2 + i**2 <= maxNorm; i++) arr[r].push(true);
    }
    arr[0][0] = false;
    arr[1][0] = false;
    arr[0][1] = false;
    for (let p = 0n; p < gaussian_primes.length && gaussian_primes[p].norm() <= maxNorm; p++) {
        let gp = gaussian_primes[p];
        let thisnorm = gp.norm();
        for (let r = 1n; r * gp.real < arr.length; r++) {
            for (let i = (r == 1n) ? 1n : 0n; (r**2n + i**2n) * thisnorm <= maxNorm; i++) {
                let [fr, fi] = gp.mul([r, i]).toFirstQuadrant().toArrayPair().map(Number)
                if (arr[fr] === undefined || arr[fr][fi] === undefined) continue;
                arr[fr][fi] = false;
            }
        }
    }
    let newprimes = [];
    // Start at r = 1 so 3i isn't counted as a separate prime
    for (let r = 1; r < arr.length; r++) {
        for (let i = 0; arr[r][i] !== undefined; i++) {
            if (arr[r][i]) {
                newprimes.push(new GaussianBigInt(BigInt(r), BigInt(i)));
            }
        }
    }
    gaussian_primes = newprimes.sort(gaussianSort);
}

function prime(n) {//Returns the nth prime; uses numbers or BigInts depending on the type of the input. prime(-n) is the negative of the nth prime.
    while (primes.length < n) primesUpdate(primes[primes.length - 1] * 2n);
    if ((typeof n == "number") && (n % 1 != 0)) return undefined;
    let an = Math.abs(Number(n));
    let answer = 0n;
    if (n == 0) answer = 1n;
    else answer = primes[an - 1];
    if (n < 0) answer *= -1n;
    if (typeof n == "bigint") return answer;
    else if (typeof n == "number") return Number(answer);
    else return undefined;
}

function gaussian_prime(n) {//Returns the nth gaussian prime.
    while (primes.length < n) gaussianPrimesUpdate(gaussian_primes[gaussian_primes.length - 1].norm() * 2n);
    if ((typeof n == "number") && (n % 1 != 0)) return undefined;
    let an = Math.abs(Number(n));
    let answer = 0n;
    if (n < 0) return undefined;
    if (n == 0) answer = new GaussianBigInt(1n, 0n);
    else answer = gaussian_primes[an - 1];
    return answer;
}

function expomod(n, m) { //How many factors of m are in n? 7 expomod 2 is 0, 6 expomod 2 is 1, 12 expomod 2 is 2, 1250 expomod 5 is 4, and so on. Returns -1 for invalid inputs. Works on numbers and bigints; n and m must have matching types. Only works on whole numbers.
    if (typeof n != typeof m || (typeof n != "number" && typeof n != "bigint")) return -1;
    if (typeof n == "number" && (n % 1 != 0 || m % 1 != 0)) return -1;
    if (typeof n == "number" && (n == 0 || m == 1)) return Infinity;
    if (typeof n == "bigint" && (n == 0n || m == 1n)) return -1n;
    let result = 0n;
    while (n % m == 0n) {
        n /= m;
        result++;
    }
    if (typeof n == "number") return Number(result)
    return result;
}

function expomodGaussian(n, m) { //Same as expomod, but for GaussianBigInts
    try {
        n = new GaussianBigInt(n);
        m = new GaussianBigInt(m);
    }
    catch {
        return -1n;
    }
    if (n.eq([0n, 0n]) || m.norm().eq(1n)) return -1n;
    let result = 0n;
    while (n.mod(m).eq([0n, 0n])) {
        n = n.div(m);
        result++;
    }
    return result;
}

function expomodRational(n, m) { // Same as expomod, but for BigRationals. Returns a BigRational instead of a BigInt, so I can use the non-finite numbers for special cases
    try {
        n = new BigRational(n);
        m = new BigRational(m);
    }
    catch {
        return new BigRational(NaN);
    }
    if (n.isNaN() || m.isNaN() || m.eq(0) || !m.isFinite()) return new BigRational(NaN);
    if (n.eq(0)) return new BigRational(-Infinity);
    if (!n.isFinite()) return new BigRational(Infinity);
    let num = n;
    let result = new BigRational(0n);
    while (n.numerator % m.numerator == 0n && n.denominator % m.denominator == 0n) {
        result = result.plus(1);
        num = num.div(m);
    }
    while (n.numerator % m.denominator == 0n && n.denominator % m.numerator == 0n) {
        result = result.minus(1);
        num = num.mul(m);
    }
    return result;
}

function factorial(n) {//Accepts both numbers and bigints, but whole numbers only.
    if (typeof n == "bigint") {
        if (n < 0n) return NaN;
        if (n == 0n) return 1n;
        else return n * factorial(n - 1n);
    }
    else {
        n = Number(n);
        if (Number.isNaN(n) || n < 0n) return NaN;
        n = Math.round(n);
        if (n > 175) return Infinity;
        if (n == 0) return 1;
        else return n * factorial(n - 1);
    }
}

function string_splice(input, start, length) { //Basically the splice method, but on strings instead of arrays. Returns a new string since strings are immutable
    let insert = "";
    if (arguments.length > 3) insert = arguments[3];
    let str = String(input);
    result = str.slice(0, start);
    result += insert;
    result += str.slice(start + length);
    return result;
}

function iroot(base, root) { // nth root for bigints
    if (typeof base !== 'bigint' || typeof root !== 'bigint') throw new Error("Arguments must be bigints.");
    if (base == 0n) return 0n;
    if (base == 1n) return 1n;
    if (root == 1n) return base;
    if (root < 1n) throw new RangeError("iroot called with degree < 1");
    if (base < 0n) {
        if (root % 2n == 1n) return iroot(-base, root) * -1n;
        else throw new Error("iroot called on even negative base");
    }

    // Find an upper bound
    let pow2 = ilog(base, 2n);
    pow2 /= root;
    let lower = 2n**pow2;
    let upper = lower * 2n;
    while (lower**root > base) {
        lower /= 2n;
        upper /= 2n;
    }
    while (upper**root < base) {
        lower *= 2n;
        upper *= 2n;
    }
    
    // Binary search
    let midpoint;
    while (upper - lower > 1n) {
        midpoint = (upper + lower) / 2n;
        if (midpoint**root >= base) upper = midpoint;
        else lower = midpoint;
    }
    if (lower**root > base || upper**root < base) console.log("iroot went wrong somewhere", lower, upper);
    if (upper**root <= base) return upper;
    else return lower;
}

function ilog(num, base) { //logarithm for bigints
    if (typeof num !== 'bigint' || typeof base !== 'bigint') throw new Error("Arguments must be bigints.");
    if (num < 0n) throw new RangeError("ilog called on a negative number");
    if (base < 2n) throw new RangeError("ilog called with base < 2");
    if (num == 0n) return -1n;
    if (num < base) return 0n;
    let upper = 1n;
    while (base**upper < num) upper *= 2n;
    let lower = upper / 2n;
    // Binary search
    let midpoint;
    while (upper - lower > 1n) {
        midpoint = (upper + lower) / 2n;
        if (base**midpoint >= num) upper = midpoint;
        else lower = midpoint;
    }
    if (base**lower > num || base**upper < num) console.log("ilog went wrong somewhere");
    if (base**upper <= num) return upper;
    else return lower;
}

function perfectPowerForm(num, maxPow = 2n**1024n) { // Returns an array expressing num as a perfect power. The array has three entries: the first is the base, the second is the exponent, the third is the sign.
    num = BigInt(num);
    if (maxPow == Infinity) maxPow = 2n**1024n; // I think I can safely assume no computer is ever going to be able to hold this many bits
    maxPow = BigInt(maxPow);
    if (num == 0n) return [0n, 0n, 0n]
    let sign = 1n;
    if (num < 0n) {
        sign = -1n;
        num *= -1n;
    }
    if (num == 1n) return [1n, 0n, sign]
    let power = min(ilog(num, 2n), maxPow);
    for (let p = power; p > 1n; p--) {
        let root = iroot(num, p);
        if (root**p == num) return [root, p, sign];
    }
    return [num, 1n, sign];
}

function perfectPowerFormRational(num, maxPow = 2n**1024n) {
    num = new BigRational(num);
    if (maxPow == Infinity) maxPow = 2n**1024n; // I think I can safely assume no computer is ever going to be able to hold this many bits
    maxPow = BigInt(maxPow);
    if (num.eq(0n) || !num.isFinite() || num.abs().eq(1)) return [new BigRational(num), 0n, num.sign()];
    let numP = perfectPowerForm(num.numerator);
    let numD = perfectPowerForm(num.denominator);
    let power = gcd(numP[1], numD[1]);
    if (power > maxPow) {
        power = listFactors(power).filter(value => (value <= maxPow)).at(-1);
    }
    return [new BigRational(numP[0]**(numP[1]/power), numD[0]**(numD[1]/power)), power, num.sign()];
}

function moduloCombine(...conditions) { 
    // Takes multiple modulo conditions and turns them into a single one. For example, if given 2 mod 3 and 1 mod 2, it returns 5 mod 6. Returns "false" if the combination has no solution.
    // Conditions are given as pairs, so "1 mod 3" is [1, 3]. Assumes all numbers involved are integers.
    conditions = compendiumStructuredClone(conditions);
    if (conditions.length == 0) return [];
    for (let c = 0; c < conditions.length; c++) {
        if (!Array.isArray(conditions[c]) || (typeof conditions[c][0] != "number" && typeof conditions[c][0] != "bigint") || (typeof conditions[c][0] != "number" && typeof conditions[c][0] != "bigint")) throw new Error("Wrong input type to moduloCombine");
        conditions[c][0] = mod(conditions[c][0], conditions[c][1]);
    }
    while (conditions.length > 1) {
        let conditionA = conditions[conditions.length - 1];
        let conditionB = conditions[conditions.length - 2];
        let bigModulus = lcm(conditionA[1], conditionB[1]);
        let testedNumber = conditionA[0];
        while (testedNumber < bigModulus && mod(testedNumber, conditionB[1]) != conditionB[0]) testedNumber += conditionA[1];
        if (mod(testedNumber, conditionB[1]) == conditionB[0]) {
            conditions.pop(); conditions.pop(); conditions.push([testedNumber, bigModulus]);
        }
        else return false;
    }
    return conditions[0];
}

function deepArrayReplace(entry, replacement, array) { // Replaces all occurances of the given entry in the given array with the replacement, including in nested subarrays.
    if (Array.isArray(array)) {
        for (let i = 0; i < array.length; i++) array[i] = deepArrayReplace(entry, replacement, array[i]);
    }
    else {
        if (array == entry) return replacement;
    }
    return array;
}

function nestedElement(array, indices) { // nestedElement(array, [1, 2, 0]) returns array[1][2][0]
    let result = array;
    for (let i = 0; i < indices.length; i++) {
        result = result[indices[i]];
        if (result == undefined) return undefined;
    }
    return result;
}

function arrayDepth(array) { // A flat array has a depth of 1, an array containing arrays has a depth of 2, an array containing arrays that themselves contain arrays has a depth of 3, and so on.
    if (!(Array.isArray(array))) return 0;
    let result = 1;
    for (let i = 0; i < array.length; i++) {
        if (Array.isArray(array[i])) result = Math.max(result, arrayDepth(array[i]) + 1);
    }
    return result;
}

function binarySearch(array, element, sortFunc = function(a, b){
    if (a < b) return -1;
    else if (b < a) return 1;
    else if (a == b) return 0;
    else return NaN;
}) {
    let start = 0; let end = array.length - 1;
    let midpoint;
    while (end - start > 1) {
        midpoint = Math.floor((end + start)/2);
        if (sortFunc(array[midpoint], element) == 0) return midpoint;
        else if (sortFunc(array[midpoint], element) < 0) start = midpoint;
        else if (sortFunc(array[midpoint], element) > 0) end = midpoint;
        else return -1; // Non-comparable elements, like NaN, mean the array isn't sorted
    }
    if (sortFunc(array[start], element) == 0) return start;
    else if (sortFunc(array[end], element) == 0) return end;
    else return -1;
}

function binaryInsert(array, element, sortFunc = function(a, b){
    if (a < b) return -1;
    else if (b < a) return 1;
    else if (a == b) return 0;
    else return NaN;
}) { // Yes, I know splice means this runs in O(n) anyway, but this is better than having to sort the array later
    let start = 0; let end = array.length - 1;
    if (array.length == 0) {
        array.push(element);
        return array;
    }
    let midpoint;
    while (end != start) {
        midpoint = Math.floor((end + start)/2);
        if (sortFunc(array[midpoint], element) == 0) {
            array.splice(midpoint, 0, element);
            return array;
        }
        else if (sortFunc(array[midpoint], element) < 0) start = midpoint + 1;
        else if (sortFunc(array[midpoint], element) > 0) end = midpoint;
        else {
            throw TypeError("Noncomparable element found during binaryInsert");
        }
    }
    if (sortFunc(array[start], element) >= 0) array.splice(start, 0, element);
    else array.splice(start + 1, 0, element);
    return array;
}

async function announce(message, ms) { // Makes a message appear on the screen for a certain number of milliseconds
    let popup = document.createElement("p");
    let popupText = document.createTextNode(boxArrayString(message));
    popup.appendChild(popupText);
    document.getElementById("announcements").appendChild(popup);
    await delay(ms);
    popup.remove();
}

function abbreviateNumber(num, system, decimals, commas, ...more) {
    if (num == 0) return "0";
    if (num == Infinity) return "Infinity";
    if (num == -Infinity) return "-Infinity";
    if (Number.isNaN(num)) return "NaN";
    if (system == "Number") {
        if (commas) {
        let sign = Math.sign(num);
        let whole = String(Math.abs(Math.trunc(num)));
        if (more.length > 0 && more[0]) {
            decimals = Math.max(decimals - Math.floor(Math.log10(Math.abs(num))), 0);
        }
        let decimal = String(Math.round(Math.abs(num - Math.trunc(num)) * 10**decimals) / 10**decimals);
        let result = "";
        let result_frag = "";
        while (whole.length > 3) {
            result_frag = whole.slice(whole.length - 3);
            whole = whole.slice(0, whole.length - 3);
            result = "," + result_frag + result;
        }
        result = whole + result + decimal.slice(1);
        if (sign == -1) result = "-" + result;
        return result;
        }
        else return String(Math.round(num * 10**decimals)/10**decimals);
    }
    else if (system == "Standard" || system == "SI") {
        let illions = [];
        let little_illions = [];
        if (system == "Standard") {
            illions = ["", "k", "M", "B", "T", "Qa", "Qi", "Sx", "Sp", "Oc", "No", "Dc", "UDc", "DDc", "TDc", "QaDc", "QiDc", "SxDc", "SpDc", "ODc", "NDc", "Vg", "UVg", "DVg", "TVg", "QaVg", "QiVg", "SxVg", "SpVg", "OVg", "NVg", "Tg", "UTg", "DTg", "TTg", "QaTg", "QiTg", "SxTg", "SpTg", "OTg", "NTg", "Qg", "UQg", "DQg", "TQg", "QaQg", "QiQg", "SxQg", "SpQg", "OQg", "NQg", "Qq", "UQq", "DQq", "TQq", "QaQq", "QiQq", "SxQq", "SpQq", "OQq", "NQq", "Sg", "USg", "DSg", "TSg", "QaSg", "QiSg", "SxSg", "SpSg", "OSg", "NSg", "St", "USt", "DSt", "TSt", "QaSt", "QiSt", "SxSt", "SpSt", "OSt", "NSt", "Og", "UOg", "DOg", "TOg", "QaOg", "QiOg", "SxOg", "SpOg", "OOg", "NOg", "Ng", "UNg", "DNg", "TNg", "QaNg", "QiNg", "SxNg", "SpNg", "ONg", "NNg", "Cn", "UCn"];
            little_illions = illions.map(function(i){return "/" + i;})
        }
        else if (system == "SI") {
            illions = ["", "k", "M", "G", "T", "P", "E", "Z", "Y", "R", "Q", "kQ", "MQ", "GQ", "TQ", "PQ", "EQ", "ZQ", "YQ", "RQ", "QQ", "kQQ", "MQQ", "GQQ", "TQQ", "PQQ", "EQQ", "ZQQ", "YQQ", "RQQ", "QQQ", "kQQQ", "MQQQ", "GQQQ", "TQQQ", "PQQQ", "EQQQ", "ZQQQ", "YQQQ", "RQQQ", "QQQQ", "kQQQQ", "MQQQQ", "GQQQQ", "TQQQQ", "PQQQQ", "EQQQQ", "ZQQQQ", "YQQQQ", "RQQQQ", "Q<sup>5</sup>", "kQ<sup>5</sup>", "MQ<sup>5</sup>", "GQ<sup>5</sup>", "TQ<sup>5</sup>", "PQ<sup>5</sup>", "EQ<sup>5</sup>", "ZQ<sup>5</sup>", "YQ<sup>5</sup>", "RQ<sup>5</sup>", "Q<sup>6</sup>", "kQ<sup>6</sup>", "MQ<sup>6</sup>", "GQ<sup>6</sup>", "TQ<sup>6</sup>", "PQ<sup>6</sup>", "EQ<sup>6</sup>", "ZQ<sup>6</sup>", "YQ<sup>6</sup>", "RQ<sup>6</sup>", "Q<sup>7</sup>", "kQ<sup>7</sup>", "MQ<sup>7</sup>", "GQ<sup>7</sup>", "TQ<sup>7</sup>", "PQ<sup>7</sup>", "EQ<sup>7</sup>", "ZQ<sup>7</sup>", "YQ<sup>7</sup>", "RQ<sup>7</sup>", "Q<sup>8</sup>", "kQ<sup>8</sup>", "MQ<sup>8</sup>", "GQ<sup>8</sup>", "TQ<sup>8</sup>", "PQ<sup>8</sup>", "EQ<sup>8</sup>", "ZQ<sup>8</sup>", "YQ<sup>8</sup>", "RQ<sup>8</sup>", "Q<sup>9</sup>", "kQ<sup>9</sup>", "MQ<sup>9</sup>", "GQ<sup>9</sup>", "TQ<sup>9</sup>", "PQ<sup>9</sup>", "EQ<sup>9</sup>", "ZQ<sup>9</sup>", "YQ<sup>9</sup>", "RQ<sup>9</sup>", "Q<sup>10</sup", "kQ<sup>10</sup", "MQ<sup>10</sup"];
            little_illions = ["", "m", "&#181;", "n", "p", "f", "a", "z", "y", "r", "q", "mq", "&#181;q", "nq", "pq", "fq", "aq", "zq", "yq", "rq", "qq", "mqq", "&#181;qq", "nqq", "pqq", "fqq", "aqq", "zqq", "yqq", "rqq", "qqq", "mqqq", "&#181;qqq", "nqqq", "pqqq", "fqqq", "aqqq", "zqqq", "yqqq", "rqqq", "qqqq", "mqqqq", "&#181;qqqq", "nqqqq", "pqqqq", "fqqqq", "aqqqq", "zqqqq", "yqqqq", "rqqqq", "qqqqq", "q<sup>5</sup>", "kq<sup>5</sup>", "&#181;q<sup>5</sup>", "nq<sup>5</sup>", "pq<sup>5</sup>", "fq<sup>5</sup>", "aq<sup>5</sup>", "zq<sup>5</sup>", "yq<sup>5</sup>", "rq<sup>5</sup>", "q<sup>6</sup>", "kq<sup>6</sup>", "&#181;q<sup>6</sup>", "nq<sup>6</sup>", "pq<sup>6</sup>", "fq<sup>6</sup>", "aq<sup>6</sup>", "zq<sup>6</sup>", "yq<sup>6</sup>", "rq<sup>6</sup>", "q<sup>7</sup>", "kq<sup7</sup>", "&#181;q<sup>7</sup>", "nq<sup>7</sup>", "pq<sup>7</sup>", "fq<sup>7</sup>", "aq<sup>7</sup>", "zq<sup>7</sup>", "yq<sup>7</sup>", "rq<sup>7</sup>", "q<sup>8</sup>", "kq<sup>8</sup>", "&#181;q<sup>8</sup>", "nq<sup>8</sup>", "pq<sup>8</sup>", "fq<sup>8</sup>", "aq<sup>8</sup>", "zq<sup>8</sup>", "yq<sup>8</sup>", "rq<sup>8</sup>", "q<sup>9</sup>", "kq<sup>9</sup>", "&#181;q<sup>9</sup>", "nq<sup>9</sup>", "pq<sup>9</sup>", "fq<sup>9</sup>", "aq<sup>9</sup>", "zq<sup>9</sup>", "yq<sup>9</sup>", "rq<sup>9</sup>", "q<sup>10</sup>", "kq<sup>10</sup>", "&#181;q<sup>10</sup>"]
        }
        let whole = Math.abs(num);
        let power = 0;
        let chosen = "";
        if (more.length < 2 || more[1] <= 0) power = Math.floor(Math.log10(whole) / 3) * 3;
        else power = Math.floor((Math.log10(whole) - more[1]) / 3) * 3;
        whole = whole / 10**power;
        if (more.length > 0 && more[0]) {
            decimals = Math.max(decimals - Math.floor(Math.log10(Math.abs(whole))), 0);
        }
        whole = Math.round(whole * 10**decimals) / 10**decimals;
        power /= 3;
        if (power > 0) chosen = " " + illions[power];
        else if (power < 0) chosen = little_illions[Math.abs(power)];
        let result = abbreviateNumber(whole, "Number", decimals, commas, ...more) + chosen;
        if (num < 0) result = "-" + result;
        return result;
    }
    else if (system == "Scientific") {
        let whole = Math.abs(num);
        let power = Math.floor(Math.log10(whole));
        if (more.length > 1) power -= more[1];
        whole = whole / 10**power;
        if (more.length > 0 && more[0]) {
            decimals = Math.max(decimals - Math.floor(Math.log10(Math.abs(whole))), 0);
        }
        let result = abbreviateNumber(whole, "Number", decimals, commas, ...more) + " &#215; 10<sup>" + power + "</sup>";
        if (num < 0) result = "-" + result;
        return result;
    }
    else if (system == "BigInt") {
        num = BigInt(num);
        let commasMin = 0n;
        if (more.length > 0) commasMin = more[0];
        if (!commas || abs(num) < commasMin) return String(num);
        let negative = false;
        if (num < 0n) {
            negative = true;
            num *= -1n;
        }
        num = String(num);
        let result = "";
        let piece = "";
        while (num.length > 3) {
            piece = num.slice(num.length - 3);
            num = num.slice(0, num.length - 3);
            result = "," + piece + result;
        }
        result = num + result;
        if (negative) result = "-" + result;
        return result;
    }
    else if (system == "GaussianBigInt") {
        if (num.imaginary == 0n)
            return abbreviateNumber(num.real, "BigInt", decimals, commas, ...more);
        else if (num.real == 0n)
            return abbreviateNumber(num.imaginary, "BigInt", decimals, commas, ...more) + "i";
        else if (num.imaginary < 0n)
            return abbreviateNumber(num.real, "BigInt", decimals, commas, ...more) + "-" + abbreviateNumber(num.imaginary * -1n, "BigInt", decimals, commas, ...more) + "i";
        else
            return abbreviateNumber(num.real, "BigInt", decimals, commas, ...more) + "+" + abbreviateNumber(num.imaginary, "BigInt", decimals, commas, ...more) + "i";
    }
    else if (system == "BigRational") {
        let result = "";
        if (num.eq(0)) return "0";
        if (num.lt(0)) {
            num = num.neg();
            result += "-";
        }
        let whole = BigInt(num.floor())
        if (whole != 0n) result += abbreviateNumber(whole, "BigInt", decimals, commas, ...more) + " ";
        let fraction = num.sub(whole);
        if (fraction.neq(BigRational.zero)) {
            result += abbreviateNumber(fraction.numerator, "BigInt", decimals, commas, ...more) + "/" + abbreviateNumber(fraction.denominator, "BigInt", decimals, commas, ...more)
        }
        return result;
    }
}


//Menu navigation
function switchScreen(screen, subscreen) {
    let oldscreen = currentScreen;
    currentScreen = screen;
    subScreen = subscreen;
    document.documentElement.style.setProperty("background-size", "none");
    document.getElementById("menu").style.setProperty("display", "none");
    document.getElementById("gamemode").style.setProperty("display", "none");
    document.getElementById("modifiers").style.setProperty("display", "none");
    document.getElementById("gameplay").style.setProperty("display", "none");
    document.getElementById("save_code").style.setProperty("display", "none");
    document.getElementById("custom_mode").style.setProperty("display", "none");
    document.getElementById("guide").style.setProperty("display", "none");
    document.getElementById("tile_viewer").style.setProperty("display", "none");
    document.getElementById("game_over_screen").style.setProperty("display", "none");
    document.getElementById("win_screen").style.setProperty("display", "none");
    document.getElementById("announcements").style.setProperty("display", "none");
    if (screen == "Menu") {
        document.getElementById("menu").style.setProperty("display", "block");
        if (oldscreen != "Menu") otherSecretStats[4] = 0;
        if (subScreen == 4) {
            document.documentElement.style.setProperty("background-image", "linear-gradient(90deg, #fff8, #0006, #000b, #0006, #fff8), linear-gradient(90deg, #ffff00, #0099ff)");
            document.getElementById("menu_grid_1").style.setProperty("display", "none");
            document.getElementById("menu_grid_2").style.setProperty("display", "none");
            document.getElementById("menu_grid_3").style.setProperty("display", "none");
            document.getElementById("menu_grid_4").style.setProperty("display", "inline-block");
        }
        else if (subScreen == 3) {
            document.documentElement.style.setProperty("background-image", "linear-gradient(90deg, #7e7e00, #003f69)");
            document.getElementById("menu_grid_1").style.setProperty("display", "none");
            document.getElementById("menu_grid_2").style.setProperty("display", "none");
            document.getElementById("menu_grid_3").style.setProperty("display", "inline-block");
            document.getElementById("menu_grid_4").style.setProperty("display", "none");
        }
        else if (subScreen == 2) {
            document.documentElement.style.setProperty("background-image", "linear-gradient(90deg, #b3b300, #005d9c)");
            document.getElementById("menu_grid_1").style.setProperty("display", "none");
            document.getElementById("menu_grid_2").style.setProperty("display", "inline-block");
            document.getElementById("menu_grid_3").style.setProperty("display", "none");
            document.getElementById("menu_grid_4").style.setProperty("display", "none");
        }
        else {
            document.documentElement.style.setProperty("background-image", "linear-gradient(90deg, #ffff00, #0099ff)");
            document.getElementById("menu_grid_1").style.setProperty("display", "inline-block");
            document.getElementById("menu_grid_2").style.setProperty("display", "none");
            document.getElementById("menu_grid_3").style.setProperty("display", "none");
            document.getElementById("menu_grid_4").style.setProperty("display", "none");
        }
        if ((window.screen.width / window.screen.height) <= 3/4) document.getElementById("menu_extra").innerHTML = "Switch Pages (" + subScreen + " / 4)" 
        else document.getElementById("menu_extra").innerHTML = "Switch Pages<br>(" + subScreen + " / 4)"; 
    }
    else if (screen == "Gamemode") {
        document.getElementById("gamemode").style.setProperty("display", "block");
        if (modifiers[5] == "Diamond" || modifiers[5] == "Hexagon" || modifiers[5] == "HexaTriangle") {
            document.getElementById("gm_size_line").style.setProperty("display", "none");
            document.getElementById("gm_diamond_line").style.setProperty("display", "flex");
            document.getElementById("gm_4D_line").style.setProperty("display", "none");
        }
        else if (modifiers[5] == "4D") {
            document.getElementById("gm_size_line").style.setProperty("display", "none");
            document.getElementById("gm_diamond_line").style.setProperty("display", "none");
            document.getElementById("gm_4D_line").style.setProperty("display", "flex");
        }
        else if (modifiers[5] == "Custom") {
            document.getElementById("gm_size_line").style.setProperty("display", "none");
            document.getElementById("gm_diamond_line").style.setProperty("display", "none");
            document.getElementById("gm_4D_line").style.setProperty("display", "none");
        }
        else {
            document.getElementById("gm_size_line").style.setProperty("display", "flex");
            document.getElementById("gm_diamond_line").style.setProperty("display", "none");
            document.getElementById("gm_4D_line").style.setProperty("display", "none");
        }
    }
    else if (screen == "Modifiers") {
        document.getElementById("modifiers").style.setProperty("display", "block");
        document.documentElement.style.setProperty("background-image", "linear-gradient(#ffcf88, #ffed88 30% 70%, #ffcf88)");
        if (subScreen == 3.2) {
            screenVars = [-1];
            inputAvailable = false;
            createCustomArrows();
        }
        if (subScreen == 6) {
            if (auto_directions.length == 0) screenVars = [-1];
            else screenVars = [0];
        }
        displayModifiers(subscreen);
    }
    else if (screen == "Gameplay") {
        document.getElementById("gameplay").style.setProperty("display", "block");
        document.getElementById("announcements").style.setProperty("display", "block");
        let dispbackground = evaluateColor(getComputedStyle(document.documentElement).getPropertyValue("--background-color"), 0, 0);
            if (dispbackground.includes("gradient")) {
                document.documentElement.style.setProperty("background-image", dispbackground);
            }
            else {
                document.documentElement.style.setProperty("background-image", "none");
            }
            let gridcolor = evaluateColor(getComputedStyle(document.documentElement).getPropertyValue("--grid-color"), 0, 0);
            if (gridcolor.includes("gradient")) {
                document.getElementById("grid").style.setProperty("background-image", gridcolor);
                document.getElementById("gp_export_button").style.setProperty("background-image", gridcolor);
                document.getElementById("go_again").style.setProperty("background-image", gridcolor);
                document.getElementById("lone_win_again").style.setProperty("background-image", gridcolor);
                document.getElementById("win_again").style.setProperty("background-image", gridcolor);
                document.getElementById("win_continue").style.setProperty("background-image", gridcolor);
            }
            else {
                document.getElementById("grid").style.setProperty("background-image", "none");
                document.getElementById("gp_export_button").style.setProperty("background-image", "none");
                document.getElementById("go_again").style.setProperty("background-image", "none");
                document.getElementById("lone_win_again").style.setProperty("background-image", "none");
                document.getElementById("win_again").style.setProperty("background-image", "none");
                document.getElementById("win_continue").style.setProperty("background-image", "none");
            }
    }
    else if (screen == "SaveCode") {
        document.getElementById("save_code").style.setProperty("display", "block");
        document.documentElement.style.setProperty("background-image", "linear-gradient(#5b0085, #ae00ff, #5b0085)");
        screenVars = [0];
        if (subscreen == "Export") {
            displaySaveCodeMode("Save Code", 0);
        }
        else if (subscreen == "Import") {
            displaySaveCodeMode("Save Code", -1);
        }
        else if (subscreen == "CustomExport") {
            displaySaveCodeMode("Custom Mode", 0);
        }
        else if (subscreen == "CustomImport") {
            displaySaveCodeMode("Custom Mode", -1);
        }
        else if (subScreen == "Modifiers") {
            displaySaveCodeMode("Modifiers", -1);
        }
    }
    else if (screen == "CustomMode") {
        document.getElementById("custom_mode").style.setProperty("display", "block");
        if (subscreen == "Merges") {
            if (customMerges.length == 0) screenVars = [-1];
            else screenVars = [0];
        }
        else if (subscreen == "ConsistencyCheck") {
            customGeneratedTiles = [];
            screenVars = [true, false, 1000, 1e12, 0, [], [], false, ""];
        }
        else if (subscreen == "Colors") {
            if (customColors.length == 0) screenVars = [-1, 0];
            else screenVars = [0, 0];
        }
        else if (subscreen == "Background") {
            screenVars = [0, 0];
        }
        displayCustomMode(subscreen, screenVars);
    }
    else if (screen == "Guide") {
        document.getElementById("guide").style.setProperty("display", "block");
        document.getElementById("regularGuide").style.setProperty("display", "none");
        document.getElementById("customGuide").style.setProperty("display", "none");
        document.getElementById("secretOffice").style.setProperty("display", "none");
        if (subscreen == "Regular") {
            document.documentElement.style.setProperty("background-image", "radial-gradient(#00552f, #00e980)");
            document.getElementById("regularGuide").style.setProperty("display", "block");
            document.getElementById("guide").style.setProperty("color", "#9affd1");
        }
        else if (subscreen == "CustomMode") {
            document.documentElement.style.setProperty("background-image", "radial-gradient(#370064, #8000e9)");
            document.getElementById("customGuide").style.setProperty("display", "block");
            document.getElementById("guide").style.setProperty("color", "#ce9aff");
        }
        else if (subscreen == "SecretOffice") {
            document.documentElement.style.setProperty("background-image", "repeating-linear-gradient(#714a13 0%, #9b8360 5%, #714a13 10%)");
            document.getElementById("secretOffice").style.setProperty("display", "block");
            document.getElementById("guide").style.setProperty("color", "#fac04b");
            if (otherSecretStats[0]) {
                document.getElementById("secretOffice_trackingOff").style.setProperty("display", "none");
                document.getElementById("secretOffice_trackingOn").style.setProperty("display", "block");
                localStorage.setItem("2048PowerCompendium_secretsFound", SCstringify(secretsFound));
                localStorage.setItem("2048PowerCompendium_secretsStored", SCstringify(true));
            }
            else {
                document.getElementById("secretOffice_trackingOff").style.setProperty("display", "block");
                document.getElementById("secretOffice_trackingOn").style.setProperty("display", "none");
                localStorage.removeItem("2048PowerCompendium_secretsFound");
                localStorage.removeItem("2048PowerCompendium_secretsStored");
            }
            for (let s = 1; s < secretsFound.length; s++) {
                let secretElement = document.getElementById("secretOffice_secret" + s)
                if (secretsFound[s]) {
                    secretElement.style.setProperty("color", "hsl(60, 100.00%, 65.10%)");
                    secretElement.children[1].style.setProperty("display", "block");
                }
                else {
                    secretElement.style.setProperty("color", "#722412");
                    secretElement.children[1].style.setProperty("display", "none");
                }
            }
            if (secretsFound.indexOf(false) == -1) document.getElementById("secretOffice_completeBox").style.setProperty("display", "block");
            else document.getElementById("secretOffice_completeBox").style.setProperty("display", "none");
        }
    }
    else if (screen == "Tile Viewer") {
        document.getElementById("tile_viewer").style.setProperty("display", "block");
        displayViewerTile();
        document.documentElement.style.setProperty("background-image", "linear-gradient(#ffeb9c, #ff9cfc, #ffeb9c)");
    }
}

function loadMode(mode) {
    gamemode = mode;
    switchScreen("Gamemode", mode);
    document.getElementById("gm_big_tile").style.setProperty("--gm_tfs", "6");
    document.getElementById("gamemode").style.setProperty("color", "black");
    if (mode == -1) document.getElementById("gm_big_tile").style.setProperty("display", "none");
    statBoxes = [["Score", "@Score"]];
    mode_vars = [];
    start_game_vars = [];
    scripts = [];
    loseConditions = [];
    loseRequirement = false;
    movementParameters = ["@VDir", "@HDir", "@SlideAmount"];
    postgameAllowed = true;
    forcedSpawns = [];
    tileDisplayKnownLevel = 3;
    mergeResultKnownLevel = 2;
    document.getElementById("mode_vars_line").style.setProperty("display", "none");
    for (let c of document.getElementById("mode_vars_line").children) c.style.setProperty("display", "none");

    if (mode == 1) { // 2048
        // width = 4; height = 4;
        TileNumAmount = 1;
        TileTypes = [[[0], 1, "#ffffff", "#776e65"], [[1], 2, "#f9eee3", "#776e65"], [[2], 4, "#ede0c8", "#776e65"], [[3], 8, "#f2b179", "#f9f6f2"],
        [[4], 16, "#f59563", "#f9f6f2"], [[5], 32, "#f67c5f", "#f9f6f2"], [[6], 64, "#f65e3b", "#f9f6f2"], [[7], 128, "#edcf72", "#f9f6f2"],
        [[8], 256, "#edcc61", "#f9f6f2"], [[9], 512, "#edc850", "#f9f6f2"], [[10], 1024, "#edc53f", "#f9f6f2"], [[11], 2048, "#edc22e", "#f9f6f2"],
        [[12], 4096, "#f29eff", "#f9f6f2"], [[13], 8192, "#eb75fd", "#f9f6f2"], [[14], 16384, "#e53bff", "#f9f6f2"], [[15], 32768, "#bd00db", "#f9f6f2"],
        [[16], 65536, "#770089", "#f9f6f2"], [[17], 131072, "#534de8", "#f9f6f2"], [[18], 262144, "#2922e1", "#f9f6f2"], [[19], 524288, "#0a05b6", "#f9f6f2"],
        [true, [2, "^", "@This 0"], ["@HSLA", [-15, "*", "@This 0", "+", 520], 100, [0.9, "^", ["@This 0", "-", 20], "*", 36], 1], "#f9f6f2"]];
        MergeRules = [[2, ["@Next 1 0", "=", "@This 0"], true, [[["@This 0", "+", 1]]], [2, "^", ["@This 0", "+", 1]], [false, true]]];
        startTileSpawns = [[[0], 85], [[1], 12], [[2], 3]];
        winConditions = [[11]];
        winRequirement = 1;
        mode_vars = [false, 0]; //If the first entry is true, TileSpawns is changed to the spawns of the original 2048
        knownMergeMaxLength = 2;
        knownMergeLookbackDistance = 0;
        document.documentElement.style.setProperty("background-image", "radial-gradient(#ffc400 0%, #fff 150%)");
        document.documentElement.style.setProperty("--background-color", "#fff5da");
        document.documentElement.style.setProperty("--grid-color", "#c7bea7");
        document.documentElement.style.setProperty("--tile-color", "#ece0c2");
        document.documentElement.style.setProperty("--text-color", "#524c46");
        displayRules("rules_text", ["h2", "Powers of 2"], ["h1", "2048"], ["p", "Merges occur between two tiles of the same number. Get to the 2048 tile to win!"],
        ["p", "Spawning tiles: 1 (85%), 2 (12%), 4 (3%)"]);
        displayRules("gm_rules_text", ["h2", "Powers of 2"], ["h1", "2048"], ["p", "Merges occur between two tiles of the same number. Get to the 2048 tile to win!"],
        ["p", "Spawning tiles: 1 (85%), 2 (12%), 4 (3%)"]);
        document.getElementById("mode_vars_line").style.setProperty("display", "block");
        document.getElementById("2048_vars").style.setProperty("display", "flex");
    }
    else if (mode == 2) { // 2187
        // width = 4; height = 4;
        TileNumAmount = 2;
        TileTypes = [[[0, 1], 1, "#ffffff", "#584153"], [[0, 2], 2, "#999999", "#f6ebf4"], [[1, 1], 3, "#ffffa2", "#584153"], [[1, 2], 6, "#e6e600", "#f6ebf4"],
        [[2, 1], 9, "#ff8181", "#584153"], [[2, 2], 18, "#ff0000", "#f6ebf4"], [[3, 1], 27, "#ffb96f", "#584153"], [[3, 2], 54, "#ff8400", "#f6ebf4"],
        [[4, 1], 81, "#6d62ff", "#584153"], [[4, 2], 162, "#0f00e4", "#f6ebf4"], [[5, 1], 243, "#96ff69", "#584153"], [[5, 2], 486, "#42dd00", "#f6ebf4"],
        [[6, 1], 729, "#e07bff", "#584153"], [[6, 2], 1458, "#bf00fa", "#f6ebf4"], [[7, 1], 2187, "#ff5ae6", "#584153"], [[7, 2], 4374, "#d600b6", "#f6ebf4"],
        [[8, 1], 6561, "#ffda69", "#584153"], [[8, 2], 13122, "#ffbf00", "#f6ebf4"], [[9, 1], 19683, "#e5ff7c", "#584153"], [[9, 2], 39366, "#ccff00", "#f6ebf4"],
        [[10, 1], 59049, "#78fdff", "#584153"], [[10, 2], 118098, "#00d7da", "#f6ebf4"], [[11, 1], 177147, "#ff896e", "#584153"], [[11, 2], 354294, "#e55000", "#f6ebf4"],
        [[12, 1], 531441, "#6baeff", "#584153"], [[12, 2], 1062882, "#0073ff", "#f6ebf4"],
        [["@This 1", "=", 1], [3, "^", "@This 0"], ["@HSLA", [97, "*", "@This 0", "-", 1111], [0.9, "^", ["@This 0", "-", 12], "*", 100], 70, 1], "#584153"],
        [["@This 1", "=", 2], [3, "^", "@This 0", "*", 2], ["@HSLA", [97, "*", "@This 0", "-", 1111], [0.9, "^", ["@This 0", "-", 12], "*", 100], 35, 1], "#f6ebf4"]];
        MergeRules = [
            [2, [["@Next 1 0", "=", "@This 0"], "&&", ["@Next 1 1", "=", 1], "&&", ["@This 1", "=", 1]], true, [["@This 0", 2]], [3, "^", "@This 0", "*", 2], [false, true]],
            [2, [["@Next 1 0", "=", "@This 0"], "&&", ["@Next 1 1", "=", 2], "&&", ["@This 1", "=", 1]], false, [[["@This 0", "+", 1], 1]], [3, "^", ["@This 0", "+", 1]], [false, true]]];
        startTileSpawns = [[[0, 1], 85], [[0, 2], 10], [[1, 1], 5]];
        winConditions = [[7, 1]];
        winRequirement = 1;
        knownMergeMaxLength = 2;
        knownMergeLookbackDistance = 0;
        document.documentElement.style.setProperty("background-image", "radial-gradient(#ff00d9 0%, #fff 150%)");
        document.documentElement.style.setProperty("--background-color", "#ffdaf9");
        document.documentElement.style.setProperty("--grid-color", "#c7a7c4");
        document.documentElement.style.setProperty("--tile-color", "#ecc2e6");
        document.documentElement.style.setProperty("--text-color", "#3c2237");
        displayRules("rules_text", ["h2", "Powers of 3"], ["h1", "2187"], ["p","Merges occur between two tiles that are both the same number and a power of 3, and between one tile that is a power of three and one tile that is double that power of three. Get to the 2187 tile to win!"],
        ["p", "Spawning tiles: 1 (85%), 2 (10%), 3 (5%)"]);
        displayRules("gm_rules_text", ["h2", "Powers of 3"], ["h1", "2187"], ["p","Merges occur between two tiles that are both the same number and a power of 3, and between one tile that is a power of three and one tile that is double that power of three. Get to the 2187 tile to win!"],
        ["p", "Spawning tiles: 1 (85%), 2 (10%), 3 (5%)"]);
    }
    else if (mode == 3) { // 1024
        // width = 5; height = 5;
        TileNumAmount = 2;
        TileTypes = [[[0, 1], 1, "#ffffff", "#564040"], [[0, 3], 3, "#777777", "#f4ecec"], [[1, 1], 4, "#00ff00", "#564040"], [[1, 3], 12, "#008a00", "#f4ecec"],
        [[2, 1], 16, "#bbff00", "#564040"], [[2, 3], 48, "#78a400", "#f4ecec"], [[3, 1], 64, "#ffc800", "#564040"], [[3, 3], 192, "#997800", "#f4ecec"],
        [[4, 1], 256, "#ff7300", "#564040"], [[4, 3], 768, "#924200", "#f4ecec"], [[5, 1], 1024, "#ff0000", "#564040"], [[5, 3], 3072, "#950000", "#f4ecec"],
        [[6, 1], 4096, "#ff009d", "#564040"], [[6, 3], 12288, "#870053", "#f4ecec"], [[7, 1], 16384, "#f900fe", "#564040"], [[7, 3], 49152, "#88008a", "#f4ecec"],
        [[8, 1], 65536, "#6f00ff", "#564040"], [[8, 3], 196608, "#3c008a", "#f4ecec"], [[9, 1], 262144, "#004cff", "#564040"], [[9, 3], 786432, "#002886", "#f4ecec"],
        [[10, 1], 1048576, "#01d0ff", "#564040"], [[10, 3], 3145728, "#00748e", "#f4ecec"], [[11, 1], 4194304, "#00ffae", "#564040"],
        [[11, 3], 12582912, "#009969", "#f4ecec"],
        [["@This 1", "=", 1], [4, "^", "@This 0"], ["@HSLA", [-31, "*", "@This 0", "+", 491], [0.95, "^", ["@This 0", "-", 12], "*", 75], 70, 1], "#564040"],
        [["@This 1", "=", 3], [4, "^", "@This 0", "*", 3], ["@HSLA", [-31, "*", "@This 0", "+", 491], [0.95, "^", ["@This 0", "-", 12], "*", 75], 35, 1], "#f4ecec"]];
        MergeRules = [
            [3, [["@Next 1 0", "=", "@This 0"], "&&", ["@Next 2 0", "=", "@This 0"], "&&", ["@Next 1 1", "=", 1], "&&", ["@Next 2 1", "=", 1], "&&", ["@This 1", "=", 1]], true, [["@This 0", 3]], [4, "^", "@This 0", "*", 3], [false, true, true]],
            [2, [["@Next 1 0", "=", "@This 0"], "&&", ["@Next 1 1", "=", 3], "&&", ["@This 1", "=", 1]], false, [[["@This 0", "+", 1], 1]], [4, "^", ["@This 0", "+", 1]], [false, true]]];
        startTileSpawns = [[[0, 1], 85], [[0, 3], 10], [[1, 1], 5]];
        winConditions = [[5, 1]];
        winRequirement = 1;
        knownMergeMaxLength = 3;
        knownMergeLookbackDistance = 0;
        document.documentElement.style.setProperty("background-image", "radial-gradient(#ff0000 0%, #fff 150%)");
        document.documentElement.style.setProperty("--background-color", "#ffdada");
        document.documentElement.style.setProperty("--grid-color", "#c7a7a7");
        document.documentElement.style.setProperty("--tile-color", "#ecc2c2");
        document.documentElement.style.setProperty("--text-color", "#564040");
        displayRules("rules_text", ["h2", "Powers of 4"], ["h1", "1024"], ["p","Merges occur between three tiles that are both the same number and a power of 4, and between one tile that is a power of four and one tile that is triple that power of four. Get to the 1024 tile to win!"],
        ["p", "Spawning tiles: 1 (85%), 3 (10%), 4 (5%)"]);
        displayRules("gm_rules_text", ["h2", "Powers of 4"], ["h1", "1024"], ["p","Merges occur between three tiles that are both the same number and a power of 4, and between one tile that is a power of four and one tile that is triple that power of four. Get to the 1024 tile to win!"],
        ["p", "Spawning tiles: 1 (85%), 3 (10%), 4 (5%)"]);
    }
    else if (mode == 4) { // 3125
        // width = 4; height = 4;
        TileNumAmount = 2;
        TileTypes = [[[0, 1], 1, "#ffffff", "#505246"], [[0, 2], 2, "#c6c6c6", "#505246"], [[0, 3], 3, "#898989", "#f4f7e9"], [[0, 4], 4, "#5f5f5f", "#f4f7e9"],
        [[1, 1], 5, "#ff9f9f", "#505246"], [[1, 2], 10, "#ff7272", "#505246"], [[1, 3], 15, "#ff3a3a", "#f4f7e9"], [[1, 4], 20, "#d50000", "#f4f7e9"],
        [[2, 1], 25, "#9fa2ff", "#505246"], [[2, 2], 50, "#5e64ff", "#505246"], [[2, 3], 75, "#0d15ff", "#f4f7e9"], [[2, 4], 100, "#0006be", "#f4f7e9"],
        [[3, 1], 125, "#fffa9f", "#505246"], [[3, 2], 250, "#fff53f", "#505246"], [[3, 3], 375, "#ebdf00", "#f4f7e9"], [[3, 4], 500, "#b3aa00", "#f4f7e9"],
        [[4, 1], 625, "#df9fff", "#505246"], [[4, 2], 1250, "#cf6fff", "#505246"], [[4, 3], 1875, "#bc35ff", "#f4f7e9"], [[4, 4], 2500, "#9900e5", "#f4f7e9"],
        [[5, 1], 3125, "#e9ff9f", "#505246"], [[5, 2], 6250, "#dafe65", "#505246"], [[5, 3], 9375, "#c9ff16", "#f4f7e9"], [[5, 4], 12500, "#abe000", "#f4f7e9"],
        [[6, 1], 15625, "#ff9fda", "#505246"], [[6, 2], 31250, "#ff69c5", "#505246"], [[6, 3], 46875, "#ff23ab", "#f4f7e9"], [[6, 4], 62500, "#eb0091", "#f4f7e9"],
        [[7, 1], 78125, "#9fffbf", "#505246"], [[7, 2], 152650, "#5aff91", "#505246"], [[7, 3], 234375, "#0aff5c", "#f4f7e9"], [[7, 4], 312500, "#00d547", "#f4f7e9"],
        [[8, 1], 390625, "#ffc19f", "#505246"], [[8, 2], 781250, "#ff9a63", "#505246"], [[8, 3], 1171875, "#ff772e", "#f4f7e9"], [[8, 4], 1562500, "#ff5900", "#f4f7e9"],
        [[9, 1], 1953125, "#9ff4ff", "#505246"], [[9, 2], 3906250, "#63edff", "#505246"], [[9, 3], 5859375, "#00e1ff", "#f4f7e9"], [[9, 4], 7812500, "#00c7e1", "#f4f7e9"],
        [[10, 1], 9765625, "#ffe79f", "#505246"], [[10, 2], 19531250, "#ffd65d", "#505246"], [[10, 3], 29296875, "#ffcd36", "#f4f7e9"], [[10, 4], 39062500, "#ebb000", "#f4f7e9"],
        [[11, 1], 48828125, "#9fc2ff", "#505246"], [[11, 2], 97656250, "#659eff", "#505246"], [[11, 3], 146484375, "#1e71ff", "#f4f7e9"], [[11, 4], 195312500, "#0058ef", "#f4f7e9"],
        [["@This 1", "=", 1], [5, "^", "@This 0"], ["@HSLA", [23.5, "*", "@This 0", "-", 212, "+", ["@This 0", "%", 2, "*", 156.5]], [0.95, "^", ["@This 0", "-", 12], "*", 75], 70, 1], "#505246"],
        [["@This 1", "=", 2], [5, "^", "@This 0", "*", 2], ["@HSLA", [23.5, "*", "@This 0", "-", 212, "+", ["@This 0", "%", 2, "*", 156.5]], [0.95, "^", ["@This 0", "-", 12], "*", 75], 60, 1], "#505246"],
        [["@This 1", "=", 3], [5, "^", "@This 0", "*", 3], ["@HSLA", [23.5, "*", "@This 0", "-", 212, "+", ["@This 0", "%", 2, "*", 156.5]], [0.95, "^", ["@This 0", "-", 12], "*", 75], 50, 1], "#f4f7e9"],
        [["@This 1", "=", 4], [5, "^", "@This 0", "*", 4], ["@HSLA", [23.5, "*", "@This 0", "-", 212, "+", ["@This 0", "%", 2, "*", 156.5]], [0.95, "^", ["@This 0", "-", 12], "*", 75], 40, 1], "#f4f7e9"]];
        MergeRules = [
            [2, [["@Next 1 0", "=", "@This 0"], "&&", ["@Next 1 1", "+", "@This 1", "<", 5]], true, [["@This 0", ["@Next 1 1", "+", "@This 1"]]], [5, "^", "@This 0", "*", ["@Next 1 1", "+", "@This 1"]], [false, true]],
            [2, [["@Next 1 0", "=", "@This 0"], "&&", ["@Next 1 1", "+", "@This 1", "=", 5]], true, [[["@This 0", "+", 1], 1]], [5, "^", ["@This 0", "+", 1]], [false, true]]
        ]
        startTileSpawns = [[[0, 1], 80], [[0, 2], 8], [[0, 3], 6], [[0, 4], 4], [[1, 1], 2]];
        winConditions = [[5, 1]];
        winRequirement = 1;
        mode_vars = [true] // Are merges between a power of five and triple that power of five allowed?
        knownMergeMaxLength = 2;
        knownMergeLookbackDistance = 0;
        document.documentElement.style.setProperty("background-image", "radial-gradient(#c3ff00 0%, #fff 150%)");
        document.documentElement.style.setProperty("--background-color", "#f6ffda");
        document.documentElement.style.setProperty("--grid-color", "#c1c7a7");
        document.documentElement.style.setProperty("--tile-color", "#e4ecc2");
        document.documentElement.style.setProperty("--text-color", "#505246");
        displayRules("rules_text", ["h2", "Powers of 5"], ["h1", "3125"], ["p","Merges occur between any two tiles that add to a power of five, double a power of five, triple a power of five, or quadruple a power of five. Get to the 3125 tile to win!"],
        ["p", "Spawning tiles: 1 (80%), 2 (8%), 3 (6%), 4 (4%), 5 (2%)"]);
        displayRules("gm_rules_text", ["h2", "Powers of 5"], ["h1", "3125"], ["p","Merges occur between any two tiles that add to a power of five, double a power of five, triple a power of five, or quadruple a power of five. Get to the 3125 tile to win!"],
        ["p", "Spawning tiles: 1 (80%), 2 (8%), 3 (6%), 4 (4%), 5 (2%)"]);
        document.getElementById("mode_vars_line").style.setProperty("display", "block");
        document.getElementById("3125_vars").style.setProperty("display", "flex");
    }
    else if (mode == 5) { // 1296
        // width = 5; height = 5;
        TileNumAmount = 2;
        TileTypes = [[[0, 1], 1, "#ffffff", "#464d52"], [[0, 2], 2, "#ffc4c4", "#464d52"], [[0, 3], 3, "#fffec4", "#464d52"],
        [[1, 1], 6, "#c300ff", "#464d52"], [[1, 2], 12, "#8000ff", "#464d52"], [[1, 3], 18, "#f200ff", "#464d52"],
        [[2, 1], 36, "#00ff00", "#464d52"], [[2, 2], 72, "#99ff00", "#464d52"], [[2, 3], 108, "#00ff88", "#464d52"],
        [[3, 1], 216, "#ff9d00", "#464d52"], [[3, 2], 432, "#ff5100", "#464d52"], [[3, 3], 648, "#ffc800", "#464d52"],
        [[4, 1], 1296, "#00a6ff", "#464d52"], [[4, 2], 2592, "#00eaff", "#464d52"], [[4, 3], 3888, "#0033ff", "#464d52"],
        [[5, 1], 7776, "#ff00bf", "#464d52"], [[5, 2], 15552, "#ff00fb", "#464d52"], [[5, 3], 23328, "#ff0062", "#464d52"],
        [[6, 1], 46656, "#ffff00", "#464d52"], [[6, 2], 93312, "#ffd900", "#464d52"], [[6, 3], 139968, "#c3ff00", "#464d52"],
        [["@This 1", "=", 1], [6, "^", "@This 0"], ["@HSLA", [97, "*", "@This 0", "-", 553], 100, [0.9, "^", ["@This 0", "-", 7], "*", 40], 1], "#e2ebf1"],
        [["@This 1", "=", 2], [6, "^", "@This 0", "*", 2], ["@HSLA", [97, "*", "@This 0", "-", 583], 100, [0.9, "^", ["@This 0", "-", 7], "*", 40], 1], "#e2ebf1"],
        [["@This 1", "=", 3], [6, "^", "@This 0", "*", 3], ["@HSLA", [97, "*", "@This 0", "-", 523], 100, [0.9, "^", ["@This 0", "-", 7], "*", 40], 1], "#e2ebf1"]];
        MergeRules = [
            [3, [["@Next 1 0", "=", "@This 0"], "&&", ["@Next 1 1", "=", "@This 1"], "&&", ["@Next 2 0", "=", "@This 0"], "&&", ["@Next 2 1", "=", "@This 1"], "&&", ["@This 1", "=", 1]], true, [["@This 0", 3]], [6, "^", "@This 0", "*", 3], [false, true, true]],
            [3, [["@Next 1 0", "=", "@This 0"], "&&", ["@Next 1 1", "=", "@This 1"], "&&", ["@Next 2 0", "=", "@This 0"], "&&", ["@Next 2 1", "=", "@This 1"], "&&", ["@This 1", "=", 2]], true, [[["@This 0", "+", 1], 1]], [6, "^", "@This 0", "*", 6], [false, true, true]],
            [2, [["@NextNE -1 0", "!=", "@This 0"], "||", ["@NextNE -1 1", "!=", "@This 1"], "&&", ["@Next 1 0", "=", "@This 0"], "&&", ["@Next 1 1", "=", "@This 1"], "&&", ["@This 1", "=", 1]], true, [["@This 0", 2]], [6, "^", "@This 0", "*", 2], [false, true]],
            [2, [["@Next 1 0", "=", "@This 0"], "&&", ["@Next 1 1", "=", "@This 1"], "&&", ["@This 1", "=", 3]], true, [[["@This 0", "+", 1], 1]], [6, "^", "@This 0", "*", 6], [false, true]]
        ]
        startTileSpawns = [[[0, 1], 80], [[0, 2], 12], [[0, 3], 6], [[1, 1], 2]];
        winConditions = [[4, 1]];
        winRequirement = 1;
        knownMergeMaxLength = 3;
        knownMergeLookbackDistance = 1;
        document.documentElement.style.setProperty("background-image", "radial-gradient(#00a6ff 0%, #fff 150%)");
        document.documentElement.style.setProperty("--background-color", "#daedff");
        document.documentElement.style.setProperty("--grid-color", "#a7b6c7");
        document.documentElement.style.setProperty("--tile-color", "#c2d9ec");
        document.documentElement.style.setProperty("--text-color", "#464d52");
        displayRules("rules_text", ["h2", "Powers of 6"], ["h1", "1296"], ["p","Merges occur between two or three of the same tile: two-tile merges occur between tiles that are a power of six or triple a power of six, and three-tile merges occur between tiles that are a power of six or double a power of six. Get to the 1296 tile to win!"],
        ["p", "Spawning tiles: 1 (80%), 2 (12%), 3 (6%), 6 (2%)"]);
        displayRules("gm_rules_text", ["h2", "Powers of 6"], ["h1", "1296"], ["p","Merges occur between two or three of the same tile: two-tile merges occur between tiles that are a power of six or triple a power of six, and three-tile merges occur between tiles that are a power of six or double a power of six. Get to the 1296 tile to win!"],
        ["p", "Spawning tiles: 1 (80%), 2 (12%), 3 (6%), 6 (2%)"]);
    }
    else if (mode == 6) { // 2401
        // width = 5; height = 5;
        TileNumAmount = 2;
        TileTypes = [[[0, 1], 1, "#d7d7d7", "#524b46"], [[0, 2], 2, "#afafaf", "#f1ebe7"], [[0, 3], 3, "#ffffff", "#6d6a67"], [[0, 4], 4, "#787878", "#f1ebe7"],
        [[1, 1], 7, "#00ff73", "#524b46"], [[1, 2], 14, "#00be55", "#f1ebe7"], [[1, 3], 21, "#78ffb5", "#6d6a67"], [[1, 4], 28, "#00893e", "#f1ebe7"],
        [[2, 1], 49, "#6fff00", "#524b46"], [[2, 2], 98, "#59ce00", "#f1ebe7"], [[2, 3], 149, "#a5ff60", "#6d6a67"], [[2, 4], 196, "#449c00", "#f1ebe7"],
        [[3, 1], 343, "#ffff00", "#524b46"], [[3, 2], 686, "#d2d200", "#f1ebe7"], [[3, 3], 1029, "#ffff7c", "#6d6a67"], [[3, 4], 1372, "#a0a000", "#f1ebe7"],
        [[4, 1], 2401, "#ff9d00", "#524b46"], [[4, 2], 4802, "#d58300", "#f1ebe7"], [[4, 3], 7203, "#ffc972", "#6d6a67"], [[4, 4], 9604, "#a26400", "#f1ebe7"],
        [[5, 1], 16807, "#ff2600", "#524b46"], [[5, 2], 33614, "#cb1e00", "#f1ebe7"], [[5, 3], 50421, "#ff6e54", "#6d6a67"], [[5, 4], 67228, "#901600", "#f1ebe7"],
        [[6, 1], 117649, "#fc01df", "#524b46"], [[6, 2], 235298, "#cb00b4", "#f1ebe7"], [[6, 3], 352947, "#ff6eee", "#6d6a67"], [[6, 4], 470596, "#9a0088", "#f1ebe7"],
        [[7, 1], 823543, "#6f00ff", "#524b46"], [[7, 2], 1647086, "#5100bb", "#f1ebe7"], [[7, 3], 2470629, "#ac6dff", "#6d6a67"], [[7, 4], 3294172, "#340078", "#f1ebe7"],
        [[8, 1], 5764801, "#0066ff", "#524b46"], [[8, 2], 11529602, "#0050c9", "#f1ebe7"], [[8, 3], 17294403, "#5e9eff", "#6d6a67"], [[8, 4], 23059204, "#003c95", "#f1ebe7"],
        [[9, 1], 40353607, "#00eaff", "#524b46"], [[9, 2], 80707214, "#00c6d7", "#f1ebe7"], [[9, 3], 121060821, "#6df3ff", "#6d6a67"], [[9, 4], 161414428, "#0097a5", "#f1ebe7"],
        [["@This 1", "=", 1], [7, "^", "@This 0"], ["@HSLA", [-37, "*", "@This 0", "-", 210], [0.95, "^", ["@This 0", "-", 10], "*", 75], 50, 1], "#524b46"],
        [["@This 1", "=", 2], [7, "^", "@This 0", "*", 2], ["@HSLA", [-37, "*", "@This 0", "-", 210], [0.95, "^", ["@This 0", "-", 10], "*", 75], 37.5, 1], "#f1ebe7"],
        [["@This 1", "=", 3], [7, "^", "@This 0", "*", 3], ["@HSLA", [-37, "*", "@This 0", "-", 210], [0.95, "^", ["@This 0", "-", 10], "*", 75], 70, 1], "#6d6a67"],
        [["@This 1", "=", 4], [7, "^", "@This 0", "*", 4], ["@HSLA", [-37, "*", "@This 0", "-", 210], [0.95, "^", ["@This 0", "-", 10], "*", 75], 25, 1], "#f1ebe7"]];
        MergeRules = [
            [3, [["@Next 1 0", "=", "@This 0"], "&&", ["@Next 1 1", "=", "@This 1"], "&&", ["@Next 2 0", "=", "@This 0"], "&&", ["@Next 2 1", "=", "@This 1"], "&&", ["@This 1", "=", 1]], true, [["@This 0", 3]], [7, "^", "@This 0", "*", 3], [false, true, true]],
            [2, [["@NextNE -1 0", "!=", "@This 0"], "||", ["@NextNE -1 1", "!=", "@This 1"], "&&", ["@Next 1 0", "=", "@This 0"], "&&", ["@Next 1 1", "=", "@This 1"], "&&", ["@This 1", "=", 1]], true, [["@This 0", 2]], [7, "^", "@This 0", "*", 2], [false, true]],
            [2, [["@Next 1 0", "=", "@This 0"], "&&", ["@Next 1 1", "=", "@This 1"], "&&", ["@This 1", "=", 2]], true, [["@This 0", 4]], [7, "^", "@This 0", "*", 4], [false, true]],
            [2, [["@Next 1 0", "=", "@This 0"], "&&", ["@Next 1 1", "=", 3], "&&", ["@This 1", "=", 4]], false, [[["@This 0", "+", 1], 1]], [7, "^", "@This 0", "*", 7], [false, true]]
        ]
        startTileSpawns = [[[0, 1], 80], [[0, 2], 10], [[0, 3], 5], [[0, 4], 5]];
        winConditions = [[4, 1]];
        winRequirement = 1;
        knownMergeMaxLength = 3;
        knownMergeLookbackDistance = 1;
        document.documentElement.style.setProperty("background-image", "radial-gradient(#ff9d00 0%, #fff 150%)");
        document.documentElement.style.setProperty("--background-color", "#ffedda");
        document.documentElement.style.setProperty("--grid-color", "#c7b6a7");
        document.documentElement.style.setProperty("--tile-color", "#ecd8c2");
        document.documentElement.style.setProperty("--text-color", "#524b46");
        displayRules("rules_text", ["h2", "Powers of 7"], ["h1", "2401"], ["p","Merges occur between two or three tiles that are the same power of seven, two tiles that are double the same power of seven, or one tile that is triple a power of seven and one tile that is quadruple that power of seven. Get to the 2401 tile to win!"],
        ["p", "Spawning tiles: 1 (80%), 2 (10%), 3 (5%), 4 (5%)"]);
        displayRules("gm_rules_text", ["h2", "Powers of 7"], ["h1", "2401"], ["p","Merges occur between two or three tiles that are the same power of seven, two tiles that are double the same power of seven, or one tile that is triple a power of seven and one tile that is quadruple that power of seven. Get to the 2401 tile to win!"],
        ["p", "Spawning tiles: 1 (80%), 2 (10%), 3 (5%), 4 (5%)"]);
    }
    else if (mode == 7) { // 4096
        // width = 4; height = 4;
        TileNumAmount = 2;
        TileTypes = [[[0, 1], 1, "#ffffff", "#484652"], [[0, 2], 2, "#c6c6c6", "#484652"], [[0, 3], 3, "#898989", "#e8e6f3"], [[0, 5], 5, "#5f5f5f", "#e8e6f3"],
        [[1, 1], 8, "#ff4646", "#484652"], [[1, 2], 16, "#ff0a0a", "#484652"], [[1, 3], 24, "#c50000", "#e8e6f3"], [[1, 5], 40, "#860000", "#e8e6f3"],
        [[2, 1], 64, "#ff66ed", "#484652"], [[2, 2], 128, "#ff00e1", "#484652"], [[2, 3], 192, "#c100aa", "#e8e6f3"], [[2, 5], 320, "#7b006d", "#e8e6f3"],
        [[3, 1], 512, "#d562ff", "#484652"], [[3, 2], 1024, "#bb00ff", "#484652"], [[3, 3], 1536, "#8800ba", "#e8e6f3"], [[3, 5], 2560, "#580078", "#e8e6f3"],
        [[4, 1], 4096, "#6b5aff", "#484652"], [[4, 2], 8192, "#1900ff", "#484652"], [[4, 3], 12288, "#1300be", "#e8e6f3"], [[4, 5], 20480, "#0c007a", "#e8e6f3"],
        [[5, 1], 32768, "#6dccff", "#484652"], [[5, 2], 65536, "#00a6ff", "#484652"], [[5, 3], 98304, "#0081c7", "#e8e6f3"], [[5, 5], 163840, "#006094", "#e8e6f3"],
        [[6, 1], 262144, "#75ffcf", "#484652"], [[6, 2], 524288, "#00ffa6", "#484652"], [[6, 3], 786432, "#00d289", "#e8e6f3"], [[6, 5], 1310720, "#00a26a", "#e8e6f3"],
        [["@This 1", "=", 1], [8, "^", "@This 0"], ["@HSLA", [-34.5, "*", "@This 0", "+", 331.5], [0.95, "^", ["@This 0", "-", 7], "*", 100], 65, 1], "#484652"],
        [["@This 1", "=", 2], [8, "^", "@This 0", "*", 2], ["@HSLA", [-34.5, "*", "@This 0", "+", 331.5], [0.9, "^", ["@This 0", "-", 7], "*", 100], 50, 1], "#484652"],
        [["@This 1", "=", 3], [8, "^", "@This 0", "*", 3], ["@HSLA", [-34.5, "*", "@This 0", "+", 331.5], [0.9, "^", ["@This 0", "-", 7], "*", 100], 37.5, 1], "#e8e6f3"],
        [["@This 1", "=", 5], [8, "^", "@This 0", "*", 5], ["@HSLA", [-34.5, "*", "@This 0", "+", 331.5], [0.9, "^", ["@This 0", "-", 7], "*", 100], 25, 1], "#e8e6f3"]]
        MergeRules = [
            [2, [["@Next 1 0", "=", "@This 0"], "&&", ["@Next 1 1", "=", 1], "&&", ["@This 1", "=", 1]], false, [["@This 0", 2]], [8, "^", "@This 0", "*", 2], [false, true]],
            [2, [["@Next 1 0", "=", "@This 0"], "&&", ["@Next 1 1", "=", 2], "&&", ["@This 1", "=", 1]], false, [["@This 0", 3]], [8, "^", "@This 0", "*", 3], [false, true]],
            [2, [["@Next 1 0", "=", "@This 0"], "&&", ["@Next 1 1", "=", 3], "&&", ["@This 1", "=", 2]], false, [["@This 0", 5]], [8, "^", "@This 0", "*", 5], [false, true]],
            [2, [["@Next 1 0", "=", "@This 0"], "&&", ["@Next 1 1", "=", 5], "&&", ["@This 1", "=", 3]], false, [[["@This 0", "+", 1], 1]], [8, "^", "@This 0", "*", 8], [false, true]],
        ]
        startTileSpawns = [[[0, 1], 85], [[0, 2], 8], [[0, 3], 5], [[0, 5], 2]];
        winConditions = [[4, 1]];
        winRequirement = 1;
        knownMergeMaxLength = 2;
        knownMergeLookbackDistance = 0;
        document.documentElement.style.setProperty("background-image", "radial-gradient(#1900ff 0%, #fff 150%)");
        document.documentElement.style.setProperty("--background-color", "#dedaff");
        document.documentElement.style.setProperty("--grid-color", "#a8a7c7");
        document.documentElement.style.setProperty("--tile-color", "#c5c2ec");
        document.documentElement.style.setProperty("--text-color", "#484652");
        displayRules("rules_text", ["h2", "Powers of 8"], ["h1", "4096"], ["p","Merges occur between two equal tiles that are a power of eight, between a tile that's a power of eight and a tile that's double that power of eight, between a tile that's double a power of eight and a tile that's triple that power of eight, and between a tile that's triple a power of eight and a tile that's quintuple that power of eight. Get to the 4096 tile to win!"],
        ["p", "Spawning tiles: 1 (85%), 2 (8%), 3 (5%), 5 (2%)"]);
        displayRules("gm_rules_text", ["h2", "Powers of 8"], ["h1", "4096"], ["p","Merges occur between two equal tiles that are a power of eight, between a tile that's a power of eight and a tile that's double that power of eight, between a tile that's double a power of eight and a tile that's triple that power of eight, and between a tile that's triple a power of eight and a tile that's quintuple that power of eight. Get to the 4096 tile to win!"],
        ["p", "Spawning tiles: 1 (85%), 2 (8%), 3 (5%), 5 (2%)"]);
    }
    else if (mode == 8) { // 6561
        // width = 6; height = 6;
        TileNumAmount = 2;
        TileTypes = [[[0, 1], 1, "#ffffff", "#465252"], [[0, 4], 4, "#828282", "#e2e9e9"], [[1, 1], 9, "#ff52b1", "#465252"], [[1, 4], 36, "#c2006b", "#e2e9e9"],
        [[2, 1], 81, "#df53ff", "#465252"], [[2, 4], 324, "#9000b0", "#e2e9e9"], [[3, 1], 729, "#6e4aff", "#465252"], [[3, 4], 2916, "#2500b7", "#e2e9e9"],
        [[4, 1], 6561, "#44f6ff", "#465252"], [[4, 4], 26244, "#00afb8", "#e2e9e9"], [[5, 1], 59049, "#6eff69", "#465252"], [[5, 4], 236196, "#06ba00", "#e2e9e9"],
        [[6, 1], 531441, "#ffff62", "#465252"], [[6, 4], 2125764, "#caca00", "#e2e9e9"], [[7, 1], 4782969, "#ffb151", "#465252"], [[7, 4], 19131876, "#d67600", "#e2e9e9"],
        [[8, 1], 43046721, "#ff6969", "#465252"], [[8, 4], 172186884, "#ac0000", "#e2e9e9"],
        [["@This 1", "=", 1], [9, "^", "@This 0"], ["@HSLA", [-48.5, "*", "@This 0", "+", 736.5], [0.9, "^", ["@This 0", "-", 9], "*", 85], 70, 1], "#465252"],
        [["@This 1", "=", 4], [9, "^", "@This 0", "*", 4], ["@HSLA", [-48.5, "*", "@This 0", "+", 736.5], [0.9, "^", ["@This 0", "-", 9], "*", 85], 30, 1], "#e2e9e9"],]
        MergeRules = [
            [4, [["@Next 1 0", "=", "@This 0"], "&&", ["@Next 1 1", "=", "@This 1"], "&&", ["@Next 2 0", "=", "@This 0"], "&&", ["@Next 2 1", "=", "@This 1"], "&&", ["@Next 3 0", "=", "@This 0"], "&&", ["@Next 3 1", "=", "@This 1"],"&&", ["@This 1", "=", 1]], true, [["@This 0", 4]], [9, "^", "@This 0", "*", 4], [false, true, true, true]],
            [3, [["@Next 1 0", "=", "@This 0"], "&&", ["@Next 2 0", "=", "@This 0"], "&&", ["@This 1", "=", 1], "&&", ["@Next 1 1", "=", 4], "&&", ["@Next 2 1", "=", 4]], false, [[["@This 0", "+", 1], 1]], [9, "^", "@This 0", "*", 9], [false, true, true]],
        ]
        startTileSpawns = [[[0, 1], 95], [[0, 4], 5]];
        winConditions = [[4, 1]];
        winRequirement = 1;
        knownMergeMaxLength = 4;
        knownMergeLookbackDistance = 0;
        document.documentElement.style.setProperty("background-image", "radial-gradient(#00f2ff 0%, #fff 150%)");
        document.documentElement.style.setProperty("--background-color", "#dafffe");
        document.documentElement.style.setProperty("--grid-color", "#a7c4c7");
        document.documentElement.style.setProperty("--tile-color", "#c2eaec");
        document.documentElement.style.setProperty("--text-color", "#465252");
        displayRules("rules_text", ["h2", "Powers of 9"], ["h1", "6561"], ["p","Merges occur between four equal tiles that are a power of nine, and between a tile that's a power of nine and two tiles that are quadruple that power of nine. Get to the 6561 tile to win!"],
        ["p", "Spawning tiles: 1 (95%), 4 (5%)"]);
        displayRules("gm_rules_text", ["h2", "Powers of 9"], ["h1", "6561"], ["p","Merges occur between four equal tiles that are a power of nine, and between a tile that's a power of nine and two tiles that are quadruple that power of nine. Get to the 6561 tile to win!"],
        ["p", "Spawning tiles: 1 (95%), 4 (5%)"]);
    }
    else if (mode == 9) { // 1000
        // width = 5; height = 5;
        TileNumAmount = 2;
        TileTypes = [[[0, 1], 1, "#ffffff", "#524946"], [[0, 2], 2, "#cacaca", "#524946"], [[0, 5], 5, "#7e7e7e", "#524946"],
        [[1, 1], 10, "#94cbff", "#524946"], [[1, 2], 20, "#54acff", "#524946"], [[1, 5], 50, "#0084ff", "#524946"],
        [[2, 1], 100, "#f1ffb8", "#524946"], [[2, 2], 200, "#e6ff82", "#524946"], [[2, 5], 500, "#ccff00", "#524946"],
        [[3, 1], 1000, "#ffa981", "#524946"], [[3, 2], 2000, "#ff834a", "#524946"], [[3, 5], 5000, "#ff5100", "#524946"],
        [[4, 1], 10000, "#faa4ff", "#524946"], [[4, 2], 20000, "#f765ff", "#524946"], [[4, 5], 50000, "#f200ff", "#524946"],
        [[5, 1], 100000, "#b184ff", "#524946"], [[5, 2], 200000, "#9355ff", "#524946"], [[5, 5], 500000, "#5d00ff", "#524946"],
        [[6, 1], 1000000, "#b0ffeb", "#524946"], [[6, 2], 2000000, "#65ffd9", "#524946"], [[6, 5], 5000000, "#00ffbf", "#524946"],
        [[7, 1], 10000000, "#fff49f", "#524946"], [[7, 2], 20000000, "#ffec5e", "#524946"], [[7, 5], 50000000, "#ffe100", "#524946"],
        [["@This 1", "=", 1], [10, "^", "@This 0"], ["@HSVA", [-83, "*", "@This 0", "+", 1000], 33, [0.9, "^", ["@This 0", "-", 8], "*", 100], 1], "#efe6e3"],
        [["@This 1", "=", 2], [10, "^", "@This 0", "*", 2], ["@HSVA", [-83, "*", "@This 0", "+", 1000], 66, [0.9, "^", ["@This 0", "-", 8], "*", 100], 1], "#efe6e3"],
        [["@This 1", "=", 3], [10, "^", "@This 0", "*", 5], ["@HSVA", [-83, "*", "@This 0", "+", 1000], 100, [0.9, "^", ["@This 0", "-", 8], "*", 100], 1], "#efe6e3"],
        ]
        MergeRules = [
            [2, [["@Next 1 0", "=", "@This 0"], "&&", ["@Next 1 1", "=", 1], "&&", ["@This 1", "=", 1]], false, [["@This 0", 2]], [10, "^", "@This 0", "*", 2], [false, true]],
            [3, [["@Next 1 0", "=", "@This 0"], "&&", ["@Next 2 0", "=", "@This 0"], "&&", ["@This 1", "=", 1], "&&", ["@Next 1 1", "=", 2], "&&", ["@Next 2 1", "=", 2]], false, [["@This 0", 5]], [10, "^", "@This 0", "*", 5], [false, true, true]],
            [2, [["@Next 1 0", "=", "@This 0"], "&&", ["@Next 1 1", "=", 5], "&&", ["@This 1", "=", 5]], false, [[["@This 0", "+", 1], 1]], [10, "^", "@This 0", "*", 10], [false, true]],
        ]
        startTileSpawns = [[[0, 1], 85], [[0, 2], 12], [[0, 5], 3]];
        winConditions = [[3, 1]];
        winRequirement = 1;
        knownMergeMaxLength = 3;
        knownMergeLookbackDistance = 0;
        document.documentElement.style.setProperty("background-image", "radial-gradient(#ff5100 0%, #fff 150%)");
        document.documentElement.style.setProperty("--background-color", "#ffe1da");
        document.documentElement.style.setProperty("--grid-color", "#c7b0a7");
        document.documentElement.style.setProperty("--tile-color", "#ecccc2");
        document.documentElement.style.setProperty("--text-color", "#524946");
        displayRules("rules_text", ["h2", "Powers of 10"], ["h1", "1000"], ["p","Merges occur between two equal tiles that are either a power of ten or quintuple a power of ten, or between one tile that is a power of ten and two tiles that are double that same power of 10. Get to the 1000 tile to win!"],
        ["p", "Spawning tiles: 1 (85%), 2 (12%), 5 (3%)"]);
        displayRules("gm_rules_text", ["h2", "Powers of 10"], ["h1", "1000"], ["p","Merges occur between two equal tiles that are either a power of ten or quintuple a power of ten, or between one tile that is a power of ten and two tiles that are double that same power of 10. Get to the 1000 tile to win!"],
        ["p", "Spawning tiles: 1 (85%), 2 (12%), 5 (3%)"]);
    }
    else if (mode == 10) { // 1331
        // width = 5; height = 5;
        TileNumAmount = 2;
        TileTypes = [[[0, 1], 1, "#ffffff", "#485246"], [[0, 2], 2, "#c6c6c6", "#485246"], [[0, 3], 3, "#898989", "#e1edde"], [[0, 6], 6, "#5f5f5f", "#e1edde"],
        [[1, 1], 11, "#ff5454", "#485246"], [[1, 2], 22, "#ff0000", "#485246"], [[1, 3], 33, "#cb0000", "#e1edde"], [[1, 6], 66, "#950000", "#e1edde"],
        [[2, 1], 121, "#fee975", "#485246"], [[2, 2], 242, "#ffd900", "#485246"], [[2, 3], 363, "#c6a800", "#e1edde"], [[2, 6], 726, "#826e00", "#e1edde"],
        [[3, 1], 1331, "#92ff92", "#485246"], [[3, 2], 2662, "#00ff00", "#485246"], [[3, 3], 3993, "#00b800", "#e1edde"], [[3, 6], 7986, "#006c00", "#e1edde"],
        [[4, 1], 14641, "#81dfff", "#485246"], [[4, 2], 29282, "#00bfff", "#485246"], [[4, 3], 43923, "#028bb8", "#e1edde"], [[4, 6], 87846, "#005673", "#e1edde"],
        [[5, 1], 161051, "#b367ff", "#485246"], [[5, 2], 322102, "#8000ff", "#485246"], [[5, 3], 483153, "#5900b1", "#e1edde"], [[5, 6], 966306, "#37006f", "#e1edde"],
        [[6, 1], 1771561, "#ff6fe5", "#485246"], [[6, 2], 3543122, "#ff00d0", "#485246"], [[6, 3], 5314683, "#c2009e", "#e1edde"], [[6, 6], 10629366, "#83016b", "#e1edde"],
        [["@This 1", "=", 1], [11, "^", "@This 0"], ["@HSLA", [67, "*", "@This 0", "-", 439], [0.9, "^", ["@This 0", "-", 7], "*", 100], 70, 1], "#485246"],
        [["@This 1", "=", 2], [11, "^", "@This 0", "*", 2], ["@HSLA", [67, "*", "@This 0", "-", 439], [0.9, "^", ["@This 0", "-", 7], "*", 100], 50, 1], "#485246"],
        [["@This 1", "=", 3], [11, "^", "@This 0", "*", 3], ["@HSLA", [67, "*", "@This 0", "-", 439], [0.9, "^", ["@This 0", "-", 7], "*", 100], 37.5, 1], "#e1edde"],
        [["@This 1", "=", 6], [11, "^", "@This 0", "*", 6], ["@HSLA", [67, "*", "@This 0", "-", 439], [0.9, "^", ["@This 0", "-", 7], "*", 100], 25, 1], "#e1edde"],
        ]
        MergeRules = [
            [3, [["@Next 1 0", "=", "@This 0"], "&&", ["@Next 2 0", "=", "@This 0"], "&&", ["@Next 2 1", "=", 3], "&&", ["@Next 1 1", "=", 2], "&&", ["@This 1", "=", 1]], false, [["@This 0", 6]], [11, "^", "@This 0", "*", 6], [false, true, true]],
            [3, [["@Next 1 0", "=", "@This 0"], "&&", ["@Next 2 0", "=", "@This 0"], "&&", ["@Next 2 1", "=", 6], "&&", ["@Next 1 1", "=", 3], "&&", ["@This 1", "=", 2]], false, [[["@This 0", "+", 1], 1]], [11, "^", "@This 0", "*", 11], [false, true, true]],
            [2, [["@Next 1 0", "=", "@This 0"], "&&", ["@Next 1 1", "=", 1], "&&", ["@This 1", "=", 1]], false, [["@This 0", 2]], [11, "^", "@This 0", "*", 2], [false, true]],
            [2, [["@Next 1 0", "=", "@This 0"], "&&", ["@Next 1 1", "=", 2], "&&", ["@This 1", "=", 1], "&&", [["@NextNE -1 0", "!=", "@This 0"], "||", ["@NextNE -1 1", "!=", 3]]], false, [["@This 0", 3]], [11, "^", "@This 0", "*", 3], [false, true]]
        ]
        startTileSpawns = [[[0, 1], 80], [[0, 2], 12], [[0, 3], 6], [[0, 6], 2]];
        winConditions = [[3, 1]];
        winRequirement = 1;
        knownMergeMaxLength = 3;
        knownMergeLookbackDistance = 1;
        document.documentElement.style.setProperty("background-image", "radial-gradient(#00ff00 0%, #fff 150%)");
        document.documentElement.style.setProperty("--background-color", "#e1ffda");
        document.documentElement.style.setProperty("--grid-color", "#a8c7a7");
        document.documentElement.style.setProperty("--tile-color", "#caecc2");
        document.documentElement.style.setProperty("--text-color", "#485246");
        displayRules("rules_text", ["h2", "Powers of 11"], ["h1", "1331"], ["p","  Merges can occur between two tiles that are both the same number and a power of eleven, between a power of eleven and a tile that's double it, between a tile that's a power of eleven, a tile that's double the same power of eleven, and a tile that's triple the same power of eleven, or between a tile that's double a power of eleven, a tile that's triple the same power of eleven, and a tile that's six times the same power of eleven. Get to the 1331 tile to win!"],
        ["p", "Spawning tiles: 1 (80%), 2 (12%), 3 (6%), 6 (2%)"]);
        displayRules("gm_rules_text", ["h2", "Powers of 11"], ["h1", "1331"], ["p","  Merges can occur between two tiles that are both the same number and a power of eleven, between a power of eleven and a tile that's double it, between a tile that's a power of eleven, a tile that's double the same power of eleven, and a tile that's triple the same power of eleven, or between a tile that's double a power of eleven, a tile that's triple the same power of eleven, and a tile that's six times the same power of eleven. Get to the 1331 tile to win!"],
        ["p", "Spawning tiles: 1 (80%), 2 (12%), 3 (6%), 6 (2%)"]);
    }
    else if (mode == 11) { // 1728
        // width = 5; height = 5;
        TileNumAmount = 2;
        TileTypes = [[[0, 1], 1, "#aaff00", "#584e59"], [[0, 2], 2, "#84c503", "#f4edf6"], [[0, 3], 3, "#dbff93", "#2d292e"],
        [[0, 4], 4, "#5c8a00", "#f4edf6"], [[0, 6], 6, "#a9e03c", "#584e59"],
        [[1, 1], 12, "#ff9500", "#584e59"], [[1, 2], 24, "#c97500", "#f4edf6"], [[1, 3], 36, "#ffbc5e", "#2d292e"],
        [[1, 4], 48, "#874f00", "#f4edf6"], [[1, 6], 72, "#d6902e", "#584e59"],
        [[2, 1], 144, "#ff007b", "#584e59"], [[2, 2], 288, "#be005c", "#f4edf6"], [[2, 3], 432, "#ff61ad", "#2d292e"],
        [[2, 4], 576, "#7a003b", "#f4edf6"], [[2, 6], 864, "#cd337e", "#584e59"],
        [[3, 1], 1728, "#d000ff", "#584e59"], [[3, 2], 3456, "#9a00bc", "#f4edf6"], [[3, 3], 5184, "#e261ff", "#2d292e"],
        [[3, 4], 6912, "#610077", "#f4edf6"], [[3, 6], 10368, "#ac27ca", "#584e59"],
        [[4, 1], 20736, "#006aff", "#584e59"], [[4, 2], 41472, "#004fbc", "#f4edf6"], [[4, 3], 62208, "#60a2ff", "#2d292e"],
        [[4, 4], 82944, "#003073", "#f4edf6"], [[4, 6], 124416, "#296ac6", "#584e59"],
        [[5, 1], 248832, "#00ff73", "#584e59"], [[5, 2], 497664, "#00bf56", "#f4edf6"], [[5, 3], 746496, "#70ffb0", "#2d292e"],
        [[5, 4], 995328, "#007f39", "#f4edf6"], [[5, 6], 1492992, "#26be6a", "#584e59"],
        [["@This 1", "=", 1], [12, "^", "@This 0"], ["@HSLA", [-74, "*", "@This 0", "+", 495], [0.95, "^", ["@This 0", "-", 6], "*", 100], 50, 1], "#584e59"],
        [["@This 1", "=", 2], [12, "^", "@This 0", "*", 2], ["@HSLA", [-74, "*", "@This 0", "+", 495], [0.95, "^", ["@This 0", "-", 6], "*", 100], 37.5, 1], "#f4edf6"],
        [["@This 1", "=", 3], [12, "^", "@This 0", "*", 3], ["@HSLA", [-74, "*", "@This 0", "+", 495], [0.95, "^", ["@This 0", "-", 6], "*", 100], 70, 1], "#2d292e"],
        [["@This 1", "=", 4], [12, "^", "@This 0", "*", 4], ["@HSLA", [-74, "*", "@This 0", "+", 495], [0.95, "^", ["@This 0", "-", 6], "*", 100], 25, 1], "#f4edf6"],
        [["@This 1", "=", 6], [12, "^", "@This 0", "*", 6], ["@HSLA", [-74, "*", "@This 0", "+", 495], [0.95, "^", ["@This 0", "-", 6], "*", 75], 50, 1], "#584e59"],
        ];
        MergeRules = [
            [4, [["@Next 1 0", "=", "@This 0"], "&&", ["@Next 1 1", "=", "@This 1"], "&&", ["@Next 2 0", "=", "@This 0"], "&&", ["@Next 2 1", "=", "@This 1"], "&&", ["@Next 3 0", "=", "@This 0"], "&&", ["@Next 3 1", "=", "@This 1"], "&&", ["@This 1", "=", 1]], true, [["@This 0", 4]], [12, "^", "@This 0", "*", 4], [false, true, true, true]],
            [4, [["@Next 1 0", "=", "@This 0"], "&&", ["@Next 1 1", "=", "@This 1"], "&&", ["@Next 2 0", "=", "@This 0"], "&&", ["@Next 2 1", "=", "@This 1"], "&&", ["@Next 3 0", "=", "@This 0"], "&&", ["@Next 3 1", "=", "@This 1"], "&&", ["@This 1", "=", 3]], true, [[["@This 0", "+", 1], 1]], [12, "^", "@This 0", "*", 12], [false, true, true, true]],
            [3, [["@NextNE -1 0", "!=", "@This 0"], "||", ["@NextNE -1 1", "!=", "@This 1"], "&&", ["@Next 1 0", "=", "@This 0"], "&&", ["@Next 1 1", "=", "@This 1"], "&&", ["@Next 2 0", "=", "@This 0"], "&&", ["@Next 2 1", "=", "@This 1"], "&&", ["@This 1", "=", 1]], true, [["@This 0", 3]], [12, "^", "@This 0", "*", 3], [false, true, true]],
            [3, [["@Next 1 0", "=", "@This 0"], "&&", ["@Next 1 1", "=", "@This 1"], "&&", ["@Next 2 0", "=", "@This 0"], "&&", ["@Next 2 1", "=", "@This 1"], "&&", ["@This 1", "=", 2]], true, [["@This 0", 6]], [12, "^", "@This 0", "*", 6], [false, true, true]],
            [3, [["@Next 1 0", "=", "@This 0"], "&&", ["@Next 1 1", "=", "@This 1"], "&&", ["@Next 2 0", "=", "@This 0"], "&&", ["@Next 2 1", "=", "@This 1"], "&&", ["@This 1", "=", 4]], true, [[["@This 0", "+", 1], 1]], [12, "^", "@This 0", "*", 12], [false, true, true]],
            [2, [["@NextNE -1 0", "!=", "@This 0"], "||", ["@NextNE -1 1", "!=", "@This 1"], "&&", ["@Next 1 0", "=", "@This 0"], "&&", ["@Next 1 1", "=", "@This 1"], "&&", ["@This 1", "=", 1]], true, [["@This 0", 2]], [12, "^", "@This 0", "*", 2], [false, true]],
            [2, [["@NextNE -1 0", "!=", "@This 0"], "||", ["@NextNE -1 1", "!=", "@This 1"], "&&", ["@Next 1 0", "=", "@This 0"], "&&", ["@Next 1 1", "=", "@This 1"], "&&", ["@This 1", "=", 2]], true, [["@This 0", 4]], [12, "^", "@This 0", "*", 4], [false, true]],
            [2, [[["@NextNE -2 0", "!=", "@This 0"], "||", ["@NextNE -2 1", "!=", "@This 1"]], "&&", [["@Next 2 0", "!=", "@This 0"], "||", ["@Next 2 1", "!=", "@This 1"]], "||", ["@NextNE -1 0", "!=", "@This 0"], "||", ["@NextNE -1 1", "!=", "@This 1"], "&&", ["@Next 1 0", "=", "@This 0"], "&&", ["@Next 1 1", "=", "@This 1"], "&&", ["@This 1", "=", 3]], true, [["@This 0", 6]], [12, "^", "@This 0", "*", 6], [false, true]],
            [2, [["@Next 1 0", "=", "@This 0"], "&&", ["@Next 1 1", "=", "@This 1"], "&&", ["@This 1", "=", 6]], true, [[["@This 0", "+", 1], 1]], [12, "^", "@This 0", "*", 12], [false, true]],
        ]
        startTileSpawns = [[[0, 1], 80], [[0, 2], 10], [[0, 3], 5], [[0, 4], 5]];
        winConditions = [[3, 1]];
        winRequirement = 1;
        knownMergeMaxLength = 4;
        knownMergeLookbackDistance = 2;
        document.documentElement.style.setProperty("background-image", "radial-gradient(#d000ff 0%, #fff 150%)");
        document.documentElement.style.setProperty("--background-color", "#fbdaff");
        document.documentElement.style.setProperty("--grid-color", "#c2a7c7");
        document.documentElement.style.setProperty("--tile-color", "#e6c2ec");
        document.documentElement.style.setProperty("--text-color", "#514652");
        displayRules("rules_text", ["h2", "Powers of 12"], ["h1", "1728"], ["p","Merges occur between two, three, or four of the same tile, as long as those tiles add up to a power of twelve or double, triple, quadruple, or sextuple a power of twelve, except a merge cannot occur between four tiles that are sextuple a power of twelve. Get to the 1728 tile to win!"],
        ["p", "Spawning tiles: 1 (80%), 2 (10%), 3 (5%), 4 (5%)"]);
        displayRules("gm_rules_text", ["h2", "Powers of 12"], ["h1", "1728"], ["p","Merges occur between two, three, or four of the same tile, as long as those tiles add up to a power of twelve or double, triple, quadruple, or sextuple a power of twelve, except a merge cannot occur between four tiles that are sextuple a power of twelve. Get to the 1728 tile to win!"],
        ["p", "Spawning tiles: 1 (80%), 2 (10%), 3 (5%), 4 (5%)"]);
    }
    else if (mode == 12) { // 2047
        // width = 5; height = 5;
        TileNumAmount = 1;
        TileTypes = [[[1], 1, "#ffffff", "#746577"], [[2], 3, "#d8ffb6", "#746577"], [[3], 7, "#a7ff5a", "#746577"],
        [[4], 15, "#77ff00", "#746577"], [[5], 31, "#00ff33", "#746577"], [[6], 63, "#00ff9d", "#746577"], [[7], 127, "#00ffd9", "#746577"],
        [[8], 255, "#dba6ff", "#f5eff7"], [[9], 511, "#c671ff", "#f5eff7"], [[10], 1023, "#b23eff", "#f5eff7"], [[11], 2047, "#9900ff", "#f5eff7"],
        [[12], 4095, "#ff9ed0", "#f5eff7"], [[13], 8191, "#ff62b3", "#f5eff7"], [[14], 16383, "#ff2b99", "#f5eff7"], [[15], 32767, "#e90079", "#f5eff7"],
        [[16], 65535, "#9d0051", "#f5eff7"], [[17], 131071, "#ff7b4f", "#f5eff7"], [[18], 262143, "#ff4000", "#f5eff7"], [[19], 524287, "#bf3000", "#f5eff7"],
        [true, [2, "^", "@This 0", "-", 1], ["@HSLA", [15, "*", "@This 0", "-", 265], 100, [0.9, "^", ["@This 0", "-", 20], "*", 36], 1], "#f5eff7"]];
        MergeRules = [[3, [["@Next 1 0", "=", "@This 0"], "&&", ["@Next 2 0", "=", 1], "&&", ["@This 0", "typeof", "=", "number"]], false, [[["@This 0", "+", 1]]], [2, "^", ["@This 0", "+", 1], "-", 1], [false, true, true]]];
        startTileSpawns = [[[1], 95], [[2], 5]];
        winConditions = [[11]];
        winRequirement = 1;
        knownMergeMaxLength = 3;
        knownMergeLookbackDistance = 0;
        document.documentElement.style.setProperty("background-image", "radial-gradient(#9900ff 0%, #fff 150%)");
        document.documentElement.style.setProperty("--background-color", "#f1daff");
        document.documentElement.style.setProperty("--grid-color", "#bca7c7");
        document.documentElement.style.setProperty("--tile-color", "#dac2ec");
        document.documentElement.style.setProperty("--text-color", "#4e4652");
        displayRules("rules_text", ["h2", "Powers of 2 Minus 1"], ["h1", "2047"], ["p", "Merges occur between three tiles. Two of them must be equal to each other, and the third must be a 1. Get to the 2047 tile to win!"],
        ["p", "Spawning tiles: 1 (95%), 3 (5%)"]);
        displayRules("gm_rules_text", ["h2", "Powers of 2 Minus 1"], ["h1", "2047"], ["p", "Merges occur between three tiles. Two of them must be equal to each other, and the third must be a 1. Get to the 2047 tile to win!"],
        ["p", "Spawning tiles: 1 (95%), 3 (5%)"]);
    }
    else if (mode == 13) { // 2186
        // width = 5; height = 5;
        TileNumAmount = 2;
        TileTypes = [[[0, 1], 1, "#ffffff", "#46524c"], [[1, 1], 2, "#a2a2ff", "#46524c"], [[1, 2], 5, "#0000e6", "#ebf6f1"],
        [[2, 1], 8, "#81ffff", "#46524c"], [[2, 2], 17, "#00ffff", "#ebf6f1"], [[3, 1], 26, "#6fb5ff", "#46524c"], [[3, 2], 53, "#007bff", "#ebf6f1"],
        [[4, 1], 80, "#f4ff62", "#46524c"], [[4, 2], 161, "#d5e400", "#ebf6f1"], [[5, 1], 242, "#d269ff", "#46524c"], [[5, 2], 485, "#9b00dd", "#ebf6f1"],
        [[6, 1], 728, "#9aff7b", "#46524c"], [[6, 2], 1457, "#3bfa00", "#ebf6f1"], [[7, 1], 2186, "#5affb5", "#46524c"], [[7, 2], 4373, "#00ff8c", "#ebf6f1"],
        [[8, 1], 6560, "#698eff", "#46524c"], [[8, 2], 13121, "#0040ff", "#ebf6f1"], [[9, 1], 19682, "#ff7cf4", "#46524c"], [[9, 2], 39365, "#ff00ea", "#ebf6f1"],
        [[10, 1], 59048, "#ff7a78", "#46524c"], [[10, 2], 118097, "#da0300", "#ebf6f1"], [[11, 1], 177146, "#6ee4ff", "#46524c"], [[11, 2], 354293, "#0095e5", "#ebf6f1"],
        [[12, 1], 531440, "#ffbc6b", "#46524c"], [[12, 2], 1062881, "#ff8c00", "#ebf6f1"],
        [["@This 1", "=", 1], [3, "^", "@This 0", "-", 1], ["@HSLA", [97, "*", "@This 0", "-", 931], [0.9, "^", ["@This 0", "-", 12], "*", 100], 70, 1], "#46524c"],
        [["@This 1", "=", 2], [3, "^", "@This 0", "*", 2, "-", 1], ["@HSLA", [97, "*", "@This 0", "-", 931], [0.9, "^", ["@This 0", "-", 12], "*", 100], 35, 1], "#ebf6f1"]];
        MergeRules = [
            [2, [["@This 0", "=", 0], "&&", ["@Next 1 0", "=", 0]], true, [[1, 1]], 2, [false, true]],
            [3, [["@Next 1 0", "=", "@This 0"], "&&", ["@Next 1 1", "=", 1], "&&", ["@This 1", "=", 1], "&&", ["@Next 2 0", "=", 0], "&&", ["@Next 2 1", "=", 1]], false, [["@This 0", 2]], [3, "^", "@This 0", "*", 2, "-", 1], [false, true, true]],
            [3, [["@Next 1 0", "=", "@This 0"], "&&", ["@Next 1 1", "=", 2], "&&", ["@This 1", "=", 1], "&&", ["@Next 2 0", "=", 0], "&&", ["@Next 2 1", "=", 1]], false, [[["@This 0", "+", 1], 1]], [3, "^", ["@This 0", "+", 1], "-", 1], [false, true, true]]];
        startTileSpawns = [[[0, 1], 92], [[1, 1], 7], [[1, 2], 1]];
        winConditions = [[7, 1]];
        winRequirement = 1;
        knownMergeMaxLength = 3;
        knownMergeLookbackDistance = 0;
        document.documentElement.style.setProperty("background-image", "radial-gradient(#00ff8c 0%, #fff 150%)");
        document.documentElement.style.setProperty("--background-color", "#dafff0");
        document.documentElement.style.setProperty("--grid-color", "#a7c7be");
        document.documentElement.style.setProperty("--tile-color", "#c2ecda");
        document.documentElement.style.setProperty("--text-color", "#46524c");
        displayRules("rules_text", ["h2", "Powers of 3 Minus 1"], ["h1", "2186"], ["p","Two 1s can merge into a 2, but all other merges occur between three tiles: one of the tiles is always a 1, and one of them is always one less than a power of three, while the third tile can be either one less than that same power of three or one less than double that power of three. Get to the 2186 tile to win!"],
        ["p", "Spawning tiles: 1 (92%), 2 (7%), 5 (1%)"]);
        displayRules("gm_rules_text", ["h2", "Powers of 3 Minus 1"], ["h1", "2186"], ["p","Two 1s can merge into a 2, but all other merges occur between three tiles: one of the tiles is always a 1, and one of them is always one less than a power of three, while the third tile can be either one less than that same power of three or one less than double that power of three. Get to the 2186 tile to win!"],
        ["p", "Spawning tiles: 1 (92%), 2 (7%), 5 (1%)"]);
    }
    else if (mode == 14) { // 2049
        // width = 5; height = 5;
        document.documentElement.style.setProperty("background-image", "radial-gradient(#ff0073 0%, #fff 150%)");
        document.documentElement.style.setProperty("--background-color", "#ffdae7");
        document.documentElement.style.setProperty("--grid-color", "#c7a7bb");
        document.documentElement.style.setProperty("--tile-color", "#ecc2dc");
        document.documentElement.style.setProperty("--text-color", "#52464e");
        //This mode has to completely reformat if the Negative Tiles modifier on, since it already has -1s in it even without Negative Tiles being on.
        if (modifiers[13] != "None") {
            TileNumAmount = 2;
            TileTypes = [
            [[-1, 1], 1, "#ffffff", "#52464e"],
            [[0, 1], 2, "#b6afff", "#52464e"], [[1, 1], 3, "#9086ff", "#52464e"], [[2, 1], 5, "#6a5cfc", "#52464e"], [[3, 1], 9, "#3624ff", "#52464e"],
            [[4, 1], 17, "#7c24ff", "#52464e"], [[5, 1], 33, "#bb00ff", "#52464e"], [[6, 1], 65, "#ee00ff", "#52464e"], [[7, 1], 129, "#ffb0d4", "#f9f2f5"],
            [[8, 1], 257, "#ff84bb", "#f9f2f5"], [[9, 1], 513, "#ff5ca5", "#f9f2f5"], [[10, 1], 1025, "#ff3590", "#f9f2f5"], [[11, 1], 2049, "#ff0073", "#f9f2f5"],
            [[12, 1], 4097, "#ffa078", "#f9f2f5"], [[13, 1], 8193, "#ff7a41", "#f9f2f5"], [[14, 1], 16385, "#ff4d00", "#f9f2f5"], [[15, 1], 32769, "#d33f00", "#f9f2f5"],
            [[16, 1], 65537, "#8d2a00", "#f9f2f5"], [[17, 1], 131073, "#ffbe5c", "#f9f2f5"], [[18, 1], 262145, "#ff9900", "#f9f2f5"], [[19, 1], 524289, "#c67700", "#f9f2f5"],
            [["@This 1", "=", 1], [2, "^", "@This 0", "+", 1], ["@HSLA", [15, "*", "@This 0", "-", 250], 100, [0.9, "^", ["@This 0", "-", 20], "*", 36], 1], "#f9f2f5"],
            [[-1, -1], -1, "#000000", "#adb9b1"],
            [[0, -1], -2, "#495000", "#adb9b1"], [[1, -1], -3, "#6f7900", "#adb9b1"], [[2, -1], -5, "#95a303", "#adb9b1"], [[3, -1], -9, "#c9db00", "#adb9b1"],
            [[4, -1], -17, "#83db00", "#adb9b1"], [[5, -1], -33, "#44ff00", "#adb9b1"], [[6, -1], -65, "#11ff00", "#adb9b1"], [[7, -1], -129, "#004f2b", "#060d0a"],
            [[8, -1], -257, "#007b44", "#060d0a"], [[9, -1], -513, "#00a35a", "#060d0a"], [[10, -1], -1025, "#00ca6f", "#060d0a"], [[11, -1], -2049, "#00ff8c", "#060d0a"],
            [[12, -1], -4097, "#005f87", "#060d0a"], [[13, -1], -8193, "#0085be", "#060d0a"], [[14, -1], -16385, "#00b2ff", "#060d0a"], [[15, -1], -32769, "#2cc0ff", "#060d0a"],
            [[16, -1], -65537, "#72d5ff", "#060d0a"], [[17, -1], -131073, "#0041a3", "#060d0a"], [[18, -1], -262145, "#0066ff", "#060d0a"], [[19, -1], -524289, "#3988ff", "#060d0a"],
            [["@This 1", "=", -1], [2, "^", "@This 0", "+", 1, "*", -1], ["@HSLA", [15, "*", "@This 0", "-", 70], 100, [100, "-", [0.9, "^", ["@This 0", "-", 20], "*", 36]], 1], "#060d0a"]
            ];
            MergeRules = [
                [2, [["@Next 1 0", "=", -1], "&&", ["@This 0", "=", -1], "&&", ["@Next 1 1", "=", "@This 1"]], false, [[0, ["@This 1"]]], 2, [false, true]],
                [3, [["@Next 1 0", "=", "@This 0"], "&&", ["@Next 2 0", "=", -1], "&&", ["@This 0", "typeof", "=", "number"], "&&", ["@Next 1 1", "=", "@This 1"], "&&", ["@Next 2 1", "!=", "@This 1"]], false, [[["@This 0", "+", 1], ["@This 1"]]], [2, "^", ["@This 0", "+", 1], "-", 1], [false, true, true]]
            ];
            if (modifiers[13] == "Interacting") MergeRules.unshift([2, [["@Next 1 0", "=", "@This 0"], "&&", ["@Next 1 1", "!=", "@This 1"]], false, [], 0, [true, true]]);
            startTileSpawns = [[[-1, 1], modifiers[22]], [[-1, -1], modifiers[23]]];
            winConditions = [[11, -1], [11, -1]];
            winRequirement = 2;
            knownMergeMaxLength = 3;
            knownMergeLookbackDistance = 0;
            displayRules("rules_text", ["h2", "Powers of 2 Plus 1"], ["h1", "2049"], ["p", "This mode, due to already having negatives, is slightly adjusted with Negative Tiles turned on. Two 1s or two -1s can merge, but all other merges occur between three tiles: two of them must be equal to each other and not 1s or -1s, and the third must be a 1 of the opposite sign to the first two. Get to the 2049 and -2049 tiles to win!"],
            ["p", "Spawning tiles: 1 (50%), -1 (50%)"]);
            displayRules("gm_rules_text", ["h2", "Powers of 2 Plus 1"], ["h1", "2049"], ["p", "This mode, due to already having negatives, is slightly adjusted with Negative Tiles turned on. Two 1s or two -1s can merge, but all other merges occur between three tiles: two of them must be equal to each other and not 1s or -1s, and the third must be a 1 of the opposite sign to the first two. Get to the 2049 and -2049 tiles to win!"],
            ["p", "Spawning tiles: 1 (50%), -1 (50%)"]);
        }
        else {
            TileNumAmount = 1;
            TileTypes = [[[-2], -1, "#444444", "#bbbbbb"], [[-1], 1, "#ffffff", "#52464e"],
            [[0], 2, "#b6afff", "#52464e"], [[1], 3, "#9086ff", "#52464e"], [[2], 5, "#6a5cfc", "#52464e"], [[3], 9, "#3624ff", "#52464e"],
            [[4], 17, "#7c24ff", "#52464e"], [[5], 33, "#bb00ff", "#52464e"], [[6], 65, "#ee00ff", "#52464e"], [[7], 129, "#ffb0d4", "#f9f2f5"],
            [[8], 257, "#ff84bb", "#f9f2f5"], [[9], 513, "#ff5ca5", "#f9f2f5"], [[10], 1025, "#ff3590", "#f9f2f5"], [[11], 2049, "#ff0073", "#f9f2f5"],
            [[12], 4097, "#ffa078", "#f9f2f5"], [[13], 8193, "#ff7a41", "#f9f2f5"], [[14], 16385, "#ff4d00", "#f9f2f5"], [[15], 32769, "#d33f00", "#f9f2f5"],
            [[16], 65537, "#8d2a00", "#f9f2f5"], [[17], 131073, "#ffbe5c", "#f9f2f5"], [[18], 262145, "#ff9900", "#f9f2f5"], [[19], 524289, "#c67700", "#f9f2f5"],
            [true, [2, "^", "@This 0", "+", 1], ["@HSLA", [15, "*", "@This 0", "-", 250], 100, [0.9, "^", ["@This 0", "-", 20], "*", 36], 1], "#f9f2f5"]];
            MergeRules = [
                [2, [["@Next 1 0", "=", -1], "&&", ["@This 0", "=", -1]], false, [[0]], 2, [false, true]],
                [2, [["@Next 1 0", "=", -1], "&&", ["@This 0", "=", -2]], false, [], 0, [true, true]],
                [3, [["@Next 1 0", "=", "@This 0"], "&&", ["@Next 2 0", "=", -2], "&&", ["@This 0", "typeof", "=", "number"], "&&", ["@This 0", ">", -1]], false, [[["@This 0", "+", 1]]], [2, "^", ["@This 0", "+", 1], "-", 1], [false, true, true]]
            ];
            startTileSpawns = [[[-1], 65], [[-2], 35]];
            winConditions = [[11]];
            winRequirement = 1;
            knownMergeMaxLength = 3;
            knownMergeLookbackDistance = 0;
            displayRules("rules_text", ["h2", "Powers of 2 Plus 1"], ["h1", "2049"], ["p", "Two 1s can merge, but all other merges occur between three tiles: two of them must be equal to each other and not 1s or -1s, and the third must be a -1. But be careful, because if a 1 and a -1 collide, they're both destroyed. Get to the 2049 tile to win!"],
            ["p", "Spawning tiles: 1 (65%), -1 (35%)"]);
            displayRules("gm_rules_text", ["h2", "Powers of 2 Plus 1"], ["h1", "2049"], ["p", "Two 1s can merge, but all other merges occur between three tiles: two of them must be equal to each other and not 1s or -1s, and the third must be a -1. But be careful, because if a 1 and a -1 collide, they're both destroyed. Get to the 2049 tile to win!"],
            ["p", "Spawning tiles: 1 (65%), -1 (35%)"]);
        }
    }
    else if (mode == 15) { // 5040
        // width = 5; height = 5;
        TileNumAmount = 2;
        TileTypes = [[[1, 1], 1, "#ffd900", "#776e65"],
        [[2, 1], 2, "#ff5ae6", "#584153"], [[2, 2], 4, "#d600b6", "#f6ebf4"],
        [[3, 1], 6, "#ff0000", "#564040"], [[3, 3], 18, "#950000", "#f4ecec"],
        [[4, 1], 24, "#e9ff9f", "#505246"], [[4, 2], 48, "#dafe65", "#505246"], [[4, 3], 72, "#c9ff16", "#f4f7e9"], [[4, 4], 96, "#abe000", "#f4f7e9"],
        [[5, 1], 120, "#00a6ff", "#464d52"], [[5, 2], 240, "#007bbe", "#464d52"], [[5, 3], 360, "#69caff", "#464d52"],
        [[6, 1], 720, "#ff9d00", "#524b46"], [[6, 2], 1440, "#d58300", "#f1ebe7"], [[6, 3], 2160, "#ffc972", "#6d6a67"], [[6, 4], 2880, "#a26400", "#f1ebe7"],
        [[7, 1], 5040, "#6b5aff", "#484652"], [[7, 2], 10080, "#1900ff", "#484652"], [[7, 3], 15120, "#1300be", "#e8e6f3"], [[7, 5], 25200, "#0c007a", "#e8e6f3"],
        [[8, 1], 40320, "#44f6ff", "#465252"], [[8, 4], 161280, "#00afb8", "#e2e9e9"],
        [[9, 1], 362800, "#ffa981", "#524946"], [[9, 2], 725760, "#ff834a", "#524946"], [[9, 5], 1814400, "#ff5100", "#524946"],
        [[10, 1], 3628800, "#92ff92", "#485246"], [[10, 2], 7257600, "#00ff00", "#485246"], [[10, 3], 10886400, "#00b800", "#e1edde"], [[10, 6], 21772800, "#006c00", "#e1edde"],
        [[11, 1], 39916800, "#d000ff", "#584e59"], [[11, 2], 79833600, "#9a00bc", "#f4edf6"], [[11, 3], 119750400, "#e261ff", "#2d292e"], [[11, 4], 159667200, "#610077", "#f4edf6"], [[11, 6], 239500800, "#ac27ca", "#584e59"],
        [[12, 1], 479001600, "#000000", "#ffff00"]
        ];
        MergeRules = [ //No generalizing here; different tiers have different merge rule, so every case gets its own rule
            [2, [["@This 0", "=", 1], "&&", ["@Next 1 0", "=", 1]], true, [[2, 1]], 2, [false, true]],

            [2, [["@This 0", "=", 2], "&&", ["@Next 1 0", "=", 2], "&&", ["@Next 1 1", "=", 1], "&&", ["@This 1", "=", 1]], true, [[2, 2]], 4, [false, true]],
            [2, [["@This 0", "=", 2], "&&", ["@Next 1 0", "=", 2], "&&", ["@Next 1 1", "=", 2], "&&", ["@This 1", "=", 1]], false, [[3, 1]], 6, [false, true]],

            [3, [["@This 0", "=", 3], "&&", ["@Next 1 0", "=", 3], "&&", ["@Next 2 0", "=", 3], "&&", ["@Next 1 1", "=", 1], "&&", ["@Next 2 1", "=", 1], "&&", ["@This 1", "=", 1]], true, [[3, 3]], 18, [false, true, true]],
            [2, [["@This 0", "=", 3], "&&", ["@Next 1 0", "=", 3], "&&", ["@Next 1 1", "=", 3], "&&", ["@This 1", "=", 1]], false, [[4, 1]], 24, [false, true]],

            [2, [["@This 0", "=", 4], "&&", ["@Next 1 0", "=", 4], "&&", ["@Next 1 1", "+", "@This 1", "<", 5]], true, [[4, ["@Next 1 1", "+", "@This 1"]]], [24, "*", ["@Next 1 1", "+", "@This 1"]], [false, true]],
            [2, [["@This 0", "=", 4], "&&", ["@Next 1 0", "=", 4], "&&", ["@Next 1 1", "+", "@This 1", "=", 5]], true, [[5, 1]], 120, [false, true]],

            [3, [["@This 0", "=", 5], "&&", ["@Next 1 0", "=", "@This 0"], "&&", ["@Next 1 1", "=", "@This 1"], "&&", ["@Next 2 0", "=", "@This 0"], "&&", ["@Next 2 1", "=", "@This 1"], "&&", ["@This 1", "=", 1]], true, [[5, 3]], 360, [false, true, true]],
            [3, [["@This 0", "=", 5], "&&", ["@Next 1 0", "=", "@This 0"], "&&", ["@Next 1 1", "=", "@This 1"], "&&", ["@Next 2 0", "=", "@This 0"], "&&", ["@Next 2 1", "=", "@This 1"], "&&", ["@This 1", "=", 2]], true, [[6, 1]], 720, [false, true, true]],
            [2, [["@NextNE -1 0", "!=", "@This 0"], "||", ["@NextNE -1 1", "!=", "@This 1"], "&&", ["@This 0", "=", 5], "&&", ["@Next 1 0", "=", "@This 0"], "&&", ["@Next 1 1", "=", "@This 1"], "&&", ["@This 1", "=", 1]], true, [[5, 2]], 240, [false, true]],
            [2, [["@This 0", "=", 5], "&&", ["@Next 1 0", "=", "@This 0"], "&&", ["@Next 1 1", "=", "@This 1"], "&&", ["@This 1", "=", 3]], true, [[6, 1]], 720, [false, true]],

            [3, [["@This 0", "=", 6], "&&", ["@Next 1 0", "=", "@This 0"], "&&", ["@Next 1 1", "=", "@This 1"], "&&", ["@Next 2 0", "=", "@This 0"], "&&", ["@Next 2 1", "=", "@This 1"], "&&", ["@This 1", "=", 1]], true, [[6, 3]], 2160, [false, true, true]],
            [2, [["@NextNE -1 0", "!=", "@This 0"], "||", ["@NextNE -1 1", "!=", "@This 1"], "&&", ["@This 0", "=", 6], "&&", ["@Next 1 0", "=", "@This 0"], "&&", ["@Next 1 1", "=", "@This 1"], "&&", ["@This 1", "=", 1]], true, [[6, 2]], 1440, [false, true]],
            [2, [["@This 0", "=", 6], "&&", ["@Next 1 0", "=", "@This 0"], "&&", ["@Next 1 1", "=", "@This 1"], "&&", ["@This 1", "=", 2]], true, [[6, 4]], 2880, [false, true]],
            [2, [["@This 0", "=", 6], "&&", ["@Next 1 0", "=", "@This 0"], "&&", ["@Next 1 1", "=", 3], "&&", ["@This 1", "=", 4]], false, [[7, 1]], 5040, [false, true]],

            [2, [["@This 0", "=", 7], "&&", ["@Next 1 0", "=", "@This 0"], "&&", ["@Next 1 1", "=", 1], "&&", ["@This 1", "=", 1]], false, [[7, 2]], 10080, [false, true]],
            [2, [["@This 0", "=", 7], "&&", ["@Next 1 0", "=", "@This 0"], "&&", ["@Next 1 1", "=", 2], "&&", ["@This 1", "=", 1]], false, [[7, 3]], 15120, [false, true]],
            [2, [["@This 0", "=", 7], "&&", ["@Next 1 0", "=", "@This 0"], "&&", ["@Next 1 1", "=", 3], "&&", ["@This 1", "=", 2]], false, [[7, 5]], 25200, [false, true]],
            [2, [["@This 0", "=", 7], "&&", ["@Next 1 0", "=", "@This 0"], "&&", ["@Next 1 1", "=", 5], "&&", ["@This 1", "=", 3]], false, [[8, 1]], 40320, [false, true]],

            [4, [["@This 0", "=", 8], "&&", ["@Next 1 0", "=", "@This 0"], "&&", ["@Next 1 1", "=", "@This 1"], "&&", ["@Next 2 0", "=", "@This 0"], "&&", ["@Next 2 1", "=", "@This 1"], "&&", ["@Next 3 0", "=", "@This 0"], "&&", ["@Next 3 1", "=", "@This 1"],"&&", ["@This 1", "=", 1]], true, [[8, 4]], 161280, [false, true, true, true]],
            [3, [["@This 0", "=", 8], "&&", ["@Next 1 0", "=", "@This 0"], "&&", ["@Next 2 0", "=", "@This 0"], "&&", ["@This 1", "=", 1], "&&", ["@Next 1 1", "=", 4], "&&", ["@Next 2 1", "=", 4]], false, [[9, 1]], 362880, [false, true, true]],

            [2, [["@This 0", "=", 9], "&&", ["@Next 1 0", "=", "@This 0"], "&&", ["@Next 1 1", "=", 1], "&&", ["@This 1", "=", 1]], false, [[9, 2]], 725760, [false, true]],
            [3, [["@This 0", "=", 9], "&&", ["@Next 1 0", "=", "@This 0"], "&&", ["@Next 2 0", "=", "@This 0"], "&&", ["@This 1", "=", 1], "&&", ["@Next 1 1", "=", 2], "&&", ["@Next 2 1", "=", 2]], false, [[9, 5]], 1814400, [false, true, true]],
            [2, [["@This 0", "=", 9], "&&", ["@Next 1 0", "=", "@This 0"], "&&", ["@Next 1 1", "=", 5], "&&", ["@This 1", "=", 5]], false, [[10, 1]], 3628800, [false, true]],

            [3, [["@This 0", "=", 10], "&&", ["@Next 1 0", "=", "@This 0"], "&&", ["@Next 2 0", "=", "@This 0"], "&&", ["@Next 2 1", "=", 3], "&&", ["@Next 1 1", "=", 2], "&&", ["@This 1", "=", 1]], false, [[10, 6]], 21772800, [false, true, true]],
            [3, [["@This 0", "=", 10], "&&", ["@Next 1 0", "=", "@This 0"], "&&", ["@Next 2 0", "=", "@This 0"], "&&", ["@Next 2 1", "=", 6], "&&", ["@Next 1 1", "=", 3], "&&", ["@This 1", "=", 2]], false, [[11, 1]], 39916800, [false, true, true]],
            [2, [["@This 0", "=", 10], "&&", ["@Next 1 0", "=", "@This 0"], "&&", ["@Next 1 1", "=", 1], "&&", ["@This 1", "=", 1]], false, [[10, 2]], 7257600, [false, true]],
            [2, [["@This 0", "=", 10], "&&", ["@Next 1 0", "=", "@This 0"], "&&", ["@Next 1 1", "=", 2], "&&", ["@This 1", "=", 1], "&&", [["@NextNE -1 0", "!=", "@This 0"], "||", ["@NextNE -1 1", "!=", 3]]], false, [[10, 3]], 10886400, [false, true]],

            [4, [["@This 0", "=", 11], "&&", ["@Next 1 0", "=", "@This 0"], "&&", ["@Next 1 1", "=", "@This 1"], "&&", ["@Next 2 0", "=", "@This 0"], "&&", ["@Next 2 1", "=", "@This 1"], "&&", ["@Next 3 0", "=", "@This 0"], "&&", ["@Next 3 1", "=", "@This 1"], "&&", ["@This 1", "=", 1]], true, [[11, 4]], 159667200, [false, true, true, true]],
            [4, [["@This 0", "=", 11], "&&", ["@Next 1 0", "=", "@This 0"], "&&", ["@Next 1 1", "=", "@This 1"], "&&", ["@Next 2 0", "=", "@This 0"], "&&", ["@Next 2 1", "=", "@This 1"], "&&", ["@Next 3 0", "=", "@This 0"], "&&", ["@Next 3 1", "=", "@This 1"], "&&", ["@This 1", "=", 3]], true, [[12, 1]], 479001600, [false, true, true, true]],
            [3, [["@NextNE -1 0", "!=", "@This 0"], "||", ["@NextNE -1 1", "!=", "@This 1"], "&&", ["@This 0", "=", 11], "&&",  ["@Next 1 0", "=", "@This 0"], "&&", ["@Next 1 1", "=", "@This 1"], "&&", ["@Next 2 0", "=", "@This 0"], "&&", ["@Next 2 1", "=", "@This 1"], "&&", ["@This 1", "=", 1]], true, [[11, 3]], 119750400, [false, true, true]],
            [3, [["@This 0", "=", 11], "&&", ["@Next 1 0", "=", "@This 0"], "&&", ["@Next 1 1", "=", "@This 1"], "&&", ["@Next 2 0", "=", "@This 0"], "&&", ["@Next 2 1", "=", "@This 1"], "&&", ["@This 1", "=", 2]], true, [[11, 6]], 239500800, [false, true, true]],
            [3, [["@This 0", "=", 11], "&&", ["@Next 1 0", "=", "@This 0"], "&&", ["@Next 1 1", "=", "@This 1"], "&&", ["@Next 2 0", "=", "@This 0"], "&&", ["@Next 2 1", "=", "@This 1"], "&&", ["@This 1", "=", 4]], true, [[12, 1]], 479001600, [false, true, true]],
            [2, [["@NextNE -1 0", "!=", "@This 0"], "||", ["@NextNE -1 1", "!=", "@This 1"], "&&", ["@This 0", "=", 11], "&&",  ["@Next 1 0", "=", "@This 0"], "&&", ["@Next 1 1", "=", "@This 1"], "&&", ["@This 1", "=", 1]], true, [[11, 2]], 79833600, [false, true]],
            [2, [["@NextNE -1 0", "!=", "@This 0"], "||", ["@NextNE -1 1", "!=", "@This 1"], "&&", ["@This 0", "=", 11], "&&",  ["@Next 1 0", "=", "@This 0"], "&&", ["@Next 1 1", "=", "@This 1"], "&&", ["@This 1", "=", 2]], true, [[11, 4]], 159667200, [false, true]],
            [2, [[["@NextNE -2 0", "!=", "@This 0"], "||", ["@NextNE -2 1", "!=", "@This 1"]], "&&", [["@Next 2 0", "!=", "@This 0"], "||", ["@Next 2 1", "!=", "@This 1"]], "||", ["@NextNE -1 0", "!=", "@This 0"], "||", ["@NextNE -1 1", "!=", "@This 1"], "&&", ["@This 0", "=", 11], "&&", ["@Next 1 0", "=", "@This 0"], "&&", ["@Next 1 1", "=", "@This 1"], "&&", ["@This 1", "=", 3]], true, [[11, 6]], 239500800, [false, true]],
            [2, [["@This 0", "=", 11], "&&", ["@Next 1 0", "=", "@This 0"], "&&", ["@Next 1 1", "=", "@This 1"], "&&", ["@This 1", "=", 6]], true, [[12, 1]], 479001600, [false, true]]
        ];
        startTileSpawns = [[[1, 1], 100]];
        winConditions = [[7, 1]];
        winRequirement = 1;
        knownMergeMaxLength = 4;
        knownMergeLookbackDistance = 2;
        document.documentElement.style.setProperty("background-image", "radial-gradient(#ffff00 0%, #fff 150%)");
        document.documentElement.style.setProperty("--background-color", "#fffeda");
        document.documentElement.style.setProperty("--grid-color", "#c7c6a7");
        document.documentElement.style.setProperty("--tile-color", "#eceac2");
        document.documentElement.style.setProperty("--text-color", "#525146");
        displayRules("rules_text", ["h2", "Factorials"], ["h1", "5040"], ["p","For any whole number x between 1 and 11, tiles that are at least x! and less than (x+1)! follow the merging rules of the gamemode based around powers of (x+1), with x! taking the place of the powers of (x+1) within that particular ruleset. Get to the 5040 tile to win!"],
        ["p", "Spawning tiles: 1 (100%)"]);
        displayRules("gm_rules_text", ["h2", "Factorials"], ["h1", "5040"], ["p","For any whole number x between 1 and 11, tiles that are at least x! and less than (x+1)! follow the merging rules of the gamemode based around powers of (x+1), with x! taking the place of the powers of (x+1) within that particular ruleset. Get to the 5040 tile to win!"],
        ["p", "Spawning tiles: 1 (100%)"]);
    }
    else if (mode == 16) { // 2197
        // width = 4; height = 4;
        TileNumAmount = 2;
        TileTypes = [
        [[0, 1], 1, "#305300", "#f7eaf4"], [[0, 2], 2, "#528d00", "#f7eaf4"], [[0, 3], 3, "#72c400", "#f7eaf4"],
        [[0, 4], 4, "#95ff00", "#272326"], [[0, 6], 6, "#beff63", "#272326"], [[0, 9], 9, "#dbffa8", "#272326"],
        [[1, 1], 13, "#4d0067", "#f7eaf4"], [[1, 2], 26, "#7a00a3", "#f7eaf4"], [[1, 3], 39, "#a203d6", "#f7eaf4"],
        [[1, 4], 52, "#bf00ff", "#272326"], [[1, 6], 78, "#d452ff", "#272326"], [[1, 9], 117, "#e38fff", "#272326"],
        [[2, 1], 169, "#642600", "#f7eaf4"], [[2, 2], 338, "#9c3c00", "#f7eaf4"], [[2, 3], 507, "#cc4e00", "#f7eaf4"],
        [[2, 4], 676, "#ff6200", "#272326"], [[2, 6], 1014, "#ff8a41", "#272326"], [[2, 9], 1521, "#ffb07e", "#272326"],
        [[3, 1], 2197, "#57004a", "#f7eaf4"], [[3, 2], 4394, "#970080", "#f7eaf4"], [[3, 3], 6591, "#c400a6", "#f7eaf4"],
        [[3, 4], 8788, "#ff00d9", "#272326"], [[3, 6], 13182, "#ff52e5", "#272326"], [[3, 9], 19773, "#ff84ed", "#272326"],
        [[4, 1], 28561, "#6e6700", "#f7eaf4"], [[4, 2], 57122, "#9f9400", "#f7eaf4"], [[4, 3], 85683, "#c9bc00", "#f7eaf4"],
        [[4, 4], 114244, "#ffee00", "#272326"], [[4, 6], 171366, "#fff67d", "#272326"], [[4, 9], 257049, "#fffab5", "#272326"],
        [[5, 1], 371293, "#00636e", "#f7eaf4"], [[5, 2], 742586, "#008e9d", "#f7eaf4"], [[5, 3], 1113879, "#00b4c8", "#f7eaf4"],
        [[5, 4], 1485172, "#00e5ff", "#272326"], [[5, 6], 2227758, "#71f1ff", "#272326"], [[5, 9], 3341637, "#b1f7ff", "#272326"],
        [["@This 1", "=", 1], [13, "^", "@This 0"], ["@HSLA", [103, "*", "@This 0", "-", 321], [0.9, "^", ["@This 0", "-", 6], "*", 100], 20, 1], "#f7eaf4"],
        [["@This 1", "=", 2], [13, "^", "@This 0", "*", 2], ["@HSLA", [103, "*", "@This 0", "-", 321], [0.9, "^", ["@This 0", "-", 6], "*", 100], 30, 1], "#f7eaf4"],
        [["@This 1", "=", 3], [13, "^", "@This 0", "*", 3], ["@HSLA", [103, "*", "@This 0", "-", 321], [0.9, "^", ["@This 0", "-", 6], "*", 100], 40, 1], "#f7eaf4"],
        [["@This 1", "=", 4], [13, "^", "@This 0", "*", 4], ["@HSLA", [103, "*", "@This 0", "-", 321], [0.9, "^", ["@This 0", "-", 6], "*", 100], 50, 1], "#272326"],
        [["@This 1", "=", 6], [13, "^", "@This 0", "*", 6], ["@HSLA", [103, "*", "@This 0", "-", 321], [0.9, "^", ["@This 0", "-", 6], "*", 100], 65, 1], "#272326"],
        [["@This 1", "=", 9], [13, "^", "@This 0", "*", 9], ["@HSLA", [103, "*", "@This 0", "-", 321], [0.9, "^", ["@This 0", "-", 6], "*", 100], 80, 1], "#272326"],
        ]
        MergeRules = [
            [2, [["@Next 1 0", "=", "@This 0"], "&&", ["@Next 1 1", "=", 1], "&&", ["@This 1", "=", 1]], false, [["@This 0", 2]], [13, "^", "@This 0", "*", 2], [false, true]],
            [2, [["@Next 1 0", "=", "@This 0"], "&&", ["@Next 1 1", "=", 2], "&&", ["@This 1", "=", 1]], false, [["@This 0", 3]], [13, "^", "@This 0", "*", 3], [false, true]],
            [2, [["@Next 1 0", "=", "@This 0"], "&&", ["@Next 1 1", "=", 3], "&&", ["@This 1", "=", 1]], false, [["@This 0", 4]], [13, "^", "@This 0", "*", 4], [false, true]],
            [2, [["@Next 1 0", "=", "@This 0"], "&&", ["@Next 1 1", "=", 4], "&&", ["@This 1", "=", 2]], false, [["@This 0", 6]], [13, "^", "@This 0", "*", 6], [false, true]],
            [2, [["@Next 1 0", "=", "@This 0"], "&&", ["@Next 1 1", "=", 6], "&&", ["@This 1", "=", 3]], false, [["@This 0", 9]], [13, "^", "@This 0", "*", 9], [false, true]],
            [2, [["@Next 1 0", "=", "@This 0"], "&&", ["@Next 1 1", "=", 9], "&&", ["@This 1", "=", 4]], false, [[["@This 0", "+", 1], 1]], [13, "^", "@This 0", "*", 13], [false, true]],
        ]
        startTileSpawns = [[[0, 1], 85], [[0, 2], 8], [[0, 3], 5], [[0, 4], 2]];
        winConditions = [[3, 1]];
        winRequirement = 1;
        knownMergeMaxLength = 2;
        knownMergeLookbackDistance = 0;
        document.documentElement.style.setProperty("background-image", "radial-gradient(#6f0062 0%, #fff 150%)");
        document.documentElement.style.setProperty("--background-color", "#c9abc1");
        document.documentElement.style.setProperty("--grid-color", "#9d8597");
        document.documentElement.style.setProperty("--tile-color", "#ba9db3");
        document.documentElement.style.setProperty("--text-color", "#272326");
        displayRules("rules_text", ["h2", "Powers of 13"], ["h1", "2197"], ["p","Merges occur between two equal tiles that are a power of 13, between a tile that's a power of 13 and a tile that's double or triple that power of 13, between a tile that's double a power of 13 and a tile that's quadruple that power of 13, between a tile that's triple a power of 13 and a tile that's sextuple that power of 13, or between a tile that's quadruple a power of 13 and a tile that's 9 times that power of 13. Get to the 2197 tile to win!"],
        ["p", "Spawning tiles: 1 (85%), 2 (8%), 3 (5%), 4 (2%)"]);
        displayRules("gm_rules_text", ["h2", "Powers of 13"], ["h1", "2197"], ["p","Merges occur between two equal tiles that are a power of 13, between a tile that's a power of 13 and a tile that's double or triple that power of 13, between a tile that's double a power of 13 and a tile that's quadruple that power of 13, between a tile that's triple a power of 13 and a tile that's sextuple that power of 13, or between a tile that's quadruple a power of 13 and a tile that's 9 times that power of 13. Get to the 2197 tile to win!"],
        ["p", "Spawning tiles: 1 (85%), 2 (8%), 3 (5%), 4 (2%)"]);
    }
    else if (mode == 17) { // 3375
        // width = 4; height = 4;
        TileNumAmount = 2;
        TileTypes = [
        [[0, 1], 1, "#ffffff", "#665b57"], [[0, 2], 2, "#f3ceff", "#665b57"], [[0, 4], 4, "#e69bff", "#665b57"],
        [[0, 8], 8, "#d863ff", "#665b57"], [[0, 9], 9, "#bf00ff", "#665b57"], [[0, 11], 11, "#9500ff", "#665b57"],
        [[1, 1], 15, "#c5f9ff", "#665b57"], [[1, 2], 30, "#a4f6ff", "#665b57"], [[1, 4], 60, "#70f1ff", "#665b57"],
        [[1, 8], 120, "#32eaff", "#665b57"], [[1, 9], 135, "#00c3ff", "#665b57"], [[1, 11], 165, "#0088ff", "#665b57"],
        [[2, 1], 225, "#f1ffb8", "#665b57"], [[2, 2], 450, "#e8ff8d", "#665b57"], [[2, 4], 900, "#dffe62", "#665b57"],
        [[2, 8], 1800, "#ccff00", "#665b57"], [[2, 9], 2025, "#91ff00", "#665b57"], [[2, 11], 2475, "#00ff00", "#665b57"],
        [[3, 1], 3375, "#ffb096", "#665b57"], [[3, 2], 6750, "#ff936e", "#665b57"], [[3, 4], 13500, "#ff6e3e", "#665b57"],
        [[3, 8], 27000, "#ff4000", "#665b57"], [[3, 9], 30375, "#ff1500", "#665b57"], [[3, 11], 37125, "#ff0055", "#665b57"],
        [[4, 1], 50625, "#9d9dff", "#665b57"], [[4, 2], 101250, "#7a7aff", "#665b57"], [[4, 4], 202500, "#5f5fff", "#665b57"],
        [[4, 8], 405000, "#3f3fff", "#665b57"], [[4, 9], 455625, "#0000ff", "#665b57"], [[4, 11], 556875, "#6a00ff", "#665b57"],
        [[5, 1], 759375, "#fff5b5", "#665b57"], [[5, 2], 1518750, "#ffef86", "#665b57"], [[5, 4], 3037500, "#ffe853", "#665b57"],
        [[5, 8], 6075000, "#ffdd00", "#665b57"], [[5, 9], 6834375, "#ffbb00", "#665b57"], [[5, 11], 8353125, "#ff9900", "#665b57"],
        [[6, 1], 11390625, "#ffb7ff", "#665b57"], [[6, 2], 22781250, "#ff8bff", "#665b57"], [[6, 4], 45562500, "#ff62ff", "#665b57"],
        [[6, 8], 91125000, "#ff00ff", "#665b57"], [[6, 9], 102515625, "#ff00e1", "#665b57"], [[6, 11], 125296875, "#ff00ae", "#665b57"],
        [["@This 1", "=", 1], [15, "^", "@This 0"], ["@HSVA", [-97, "*", "@This 0", "+", 889], 30, [0.9, "^", ["@This 0", "-", 6], "*", 100], 1], "#f0dfd8"],
        [["@This 1", "=", 2], [15, "^", "@This 0", "*", 2], ["@HSVA", [-97, "*", "@This 0", "+", 889], 45, [0.9, "^", ["@This 0", "-", 6], "*", 100], 1], "#f0dfd8"],
        [["@This 1", "=", 4], [15, "^", "@This 0", "*", 4], ["@HSVA", [-97, "*", "@This 0", "+", 889], 65, [0.9, "^", ["@This 0", "-", 6], "*", 100], 1], "#f0dfd8"],
        [["@This 1", "=", 8], [15, "^", "@This 0", "*", 8], ["@HSVA", [-97, "*", "@This 0", "+", 889], 100, [0.9, "^", ["@This 0", "-", 6], "*", 100], 1], "#f0dfd8"],
        [["@This 1", "=", 9], [15, "^", "@This 0", "*", 9], ["@HSVA", [-97, "*", "@This 0", "+", 904], 100, [0.9, "^", ["@This 0", "-", 6], "*", 100], 1], "#f0dfd8"],
        [["@This 1", "=", 11], [15, "^", "@This 0", "*", 11], ["@HSVA", [-97, "*", "@This 0", "+", 919], 100, [0.9, "^", ["@This 0", "-", 6], "*", 100], 1], "#f0dfd8"],
        ]
        MergeRules = [
            [2, [["@Next 1 0", "=", "@This 0"], "&&", ["@Next 1 1", "=", 1], "&&", ["@This 1", "=", 1]], false, [["@This 0", 2]], [15, "^", "@This 0", "*", 2], [false, true]],
            [2, [["@Next 1 0", "=", "@This 0"], "&&", ["@Next 1 1", "=", 2], "&&", ["@This 1", "=", 2]], false, [["@This 0", 4]], [15, "^", "@This 0", "*", 4], [false, true]],
            [2, [["@Next 1 0", "=", "@This 0"], "&&", ["@Next 1 1", "=", 4], "&&", ["@This 1", "=", 4]], false, [["@This 0", 8]], [15, "^", "@This 0", "*", 8], [false, true]],
            [2, [["@Next 1 0", "=", "@This 0"], "&&", ["@Next 1 1", "=", 8], "&&", ["@This 1", "=", 1]], false, [["@This 0", 9]], [15, "^", "@This 0", "*", 9], [false, true]],
            [2, [["@Next 1 0", "=", "@This 0"], "&&", ["@Next 1 1", "=", 9], "&&", ["@This 1", "=", 2]], false, [["@This 0", 11]], [15, "^", "@This 0", "*", 11], [false, true]],
            [2, [["@Next 1 0", "=", "@This 0"], "&&", ["@Next 1 1", "=", 11], "&&", ["@This 1", "=", 4]], false, [[["@This 0", "+", 1], 1]], [15, "^", "@This 0", "*", 15], [false, true]],
        ]
        startTileSpawns = [[[0, 1], 85], [[0, 2], 12], [[0, 4], 3]];
        winConditions = [[3, 1]];
        winRequirement = 1;
        knownMergeMaxLength = 2;
        knownMergeLookbackDistance = 0;
        document.documentElement.style.setProperty("background-image", "radial-gradient(#ff8258 0%, #fff 150%)");
        document.documentElement.style.setProperty("--background-color", "#ffece8");
        document.documentElement.style.setProperty("--grid-color", "#e7c4b6");
        document.documentElement.style.setProperty("--tile-color", "#ffddd0");
        document.documentElement.style.setProperty("--text-color", "#665b57");
        displayRules("rules_text", ["h2", "Powers of 15"], ["h1", "3375"], ["p","Merges occur between a tile that's a power of 15 and a tile that's equal to or eight times that power of 15, between a tile that's double a power of 15 and a tile that's double or nine times that power of 15, or between a tile that's quadruple a power of 15 and a tile that's quadruple or 11 times that power of 15. Get to the 3375 tile to win!"],
        ["p", "Spawning tiles: 1 (85%), 2 (12%), 4 (3%)"]);
        displayRules("gm_rules_text", ["h2", "Powers of 15"], ["h1", "3375"], ["p","Merges occur between a tile that's a power of 15 and a tile that's equal to or eight times that power of 15, between a tile that's double a power of 15 and a tile that's double or nine times that power of 15, or between a tile that's quadruple a power of 15 and a tile that's quadruple or 11 times that power of 15. Get to the 3375 tile to win!"],
        ["p", "Spawning tiles: 1 (85%), 2 (12%), 4 (3%)"]);
    }
    else if (mode == 18) { // 4913
        // width = 5; height = 5;
        TileNumAmount = 2;
        TileTypes = [
            [[0, 1], 1, "#ffffff", "#3d443c"], [[0, 3], 3, "#c1c1ff", "#3d443c"], [[0, 5], 5, "#9090ff", "#f1faef"], [[0, 11], 11, "#6363ff", "#f1faef"],
            [[1, 1], 17, "#ff93ff", "#3d443c"], [[1, 3], 51, "#ff5cff", "#3d443c"], [[1, 5], 85, "#ff00ff", "#f1faef"], [[1, 11], 187, "#be00be", "#f1faef"],
            [[2, 1], 289, "#ffc17f", "#3d443c"], [[2, 3], 867, "#ffab51", "#3d443c"], [[2, 5], 1445, "#ff8400", "#f1faef"], [[2, 11], 3179, "#c56600", "#f1faef"],
            [[3, 1], 4913, "#90ff90", "#3d443c"], [[3, 3], 14739, "#00ff00", "#3d443c"], [[3, 5], 24565, "#00d000", "#f1faef"], [[3, 11], 54043, "#008f00", "#f1faef"],
            [[4, 1], 83521, "#8ee5ff", "#3d443c"], [[4, 3], 250563, "#57d8ff", "#3d443c"], [[4, 5], 417605, "#00c3ff", "#f1faef"], [[4, 11], 918731, "#009bca", "#f1faef"],
            [[5, 1], 1419857, "#d68aff", "#3d443c"], [[5, 3], 4259571, "#c559ff", "#3d443c"], [[5, 5], 7099285, "#a600ff", "#f1faef"], [[5, 11], 15618427, "#7e00c2", "#f1faef"],
            [[6, 1], 24137569, "#ff9191", "#3d443c"], [[6, 3], 72412707, "#ff5d5d", "#3d443c"], [[6, 5], 120687845, "#ff0000", "#f1faef"], [[6, 11], 265513259, "#c50000", "#f1faef"],
            [[7, 1], 410338673, "#ffff7d", "#3d443c"], [[7, 3], 1231016019, "#ffff00", "#3d443c"], [[7, 5], 2051693365, "#d0d000", "#f1faef"], [[7, 11], 4513725403, "#989800", "#f1faef"],
            [["@This 1", "=", 1], [17, "^", "@This 0"], ["@HSLA", [53, "*", "@This 0", "-", 264], [0.9, "^", ["@This 0", "-", 7], "*", 100], 80, 1], "#3d443c"],
            [["@This 1", "=", 3], [17, "^", "@This 0", "*", 3], ["@HSLA", [53, "*", "@This 0", "-", 264], [0.9, "^", ["@This 0", "-", 7], "*", 100], 65, 1], "#3d443c"],
            [["@This 1", "=", 5], [17, "^", "@This 0", "*", 5], ["@HSLA", [53, "*", "@This 0", "-", 264], [0.9, "^", ["@This 0", "-", 7], "*", 100], 50, 1], "#f1faef"],
            [["@This 1", "=", 11], [17, "^", "@This 0", "*", 11], ["@HSLA", [53, "*", "@This 0", "-", 264], [0.9, "^", ["@This 0", "-", 7], "*", 100], 35, 1], "#f1faef"],
        ]
        MergeRules = [
            [3, [["@Next 1 0", "=", "@This 0"], "&&", ["@Next 2 0", "=", "@This 0"], "&&", ["@Next 2 1", "=", 1], "&&", ["@Next 1 1", "=", 1], "&&", ["@This 1", "=", 1]], true, [["@This 0", 3]], [17, "^", "@This 0", "*", 3], [false, true, true]],
            [3, [["@Next 1 0", "=", "@This 0"], "&&", ["@Next 2 0", "=", "@This 0"], "&&", ["@Next 2 1", "=", 3], "&&", ["@Next 1 1", "=", 1], "&&", ["@This 1", "=", 1]], false, [["@This 0", 5]], [17, "^", "@This 0", "*", 5], [false, true, true]],
            [3, [["@Next 1 0", "=", "@This 0"], "&&", ["@Next 2 0", "=", "@This 0"], "&&", ["@Next 2 1", "=", 5], "&&", ["@Next 1 1", "=", 5], "&&", ["@This 1", "=", 1]], false, [["@This 0", 11]], [17, "^", "@This 0", "*", 11], [false, true, true]],
            [3, [["@Next 1 0", "=", "@This 0"], "&&", ["@Next 2 0", "=", "@This 0"], "&&", ["@Next 2 1", "=", 11], "&&", ["@Next 1 1", "=", 5], "&&", ["@This 1", "=", 1]], false, [[["@This 0", "+", 1], 1]], [17, "^", "@This 0", "*", 17], [false, true, true]],
        ]
        startTileSpawns = [[[0, 1], 90], [[0, 3], 7], [[0, 5], 3]];
        winConditions = [[3, 1]];
        winRequirement = 1;
        knownMergeMaxLength = 3;
        knownMergeLookbackDistance = 0;
        document.documentElement.style.setProperty("background-image", "radial-gradient(#88ff88 0%, #fff 150%)");
        document.documentElement.style.setProperty("--background-color", "#eaffe5");
        document.documentElement.style.setProperty("--grid-color", "#b3e0b2");
        document.documentElement.style.setProperty("--tile-color", "#c3f6b8");
        document.documentElement.style.setProperty("--text-color", "#6f796d");
        displayRules("rules_text", ["h2", "Powers of 17"], ["h1", "4913"], ["p","  Merges can occur between three tiles that are both the same number and a power of 17, between two tiles that are the same power of 17 and one tile that's triple that power of 17, between one tile that's a power of 17 and two tiles that are quintuple that power of 17, or between one tile that's a power of 17, one tile that's quintuple that power of 17, and one tile that's 11 times that power of 17. Get to the 4913 tile to win!"],
        ["p", "Spawning tiles: 1 (90%), 3 (7%), 5 (3%)"]);
        displayRules("gm_rules_text", ["h2", "Powers of 17"], ["h1", "4913"], ["p","  Merges can occur between three tiles that are both the same number and a power of 17, between two tiles that are the same power of 17 and one tile that's triple that power of 17, between one tile that's a power of 17 and two tiles that are quintuple that power of 17, or between one tile that's a power of 17, one tile that's quintuple that power of 17, and one tile that's 11 times that power of 17. Get to the 4913 tile to win!"],
        ["p", "Spawning tiles: 1 (90%), 3 (7%), 5 (3%)"]);
    }
    else if (mode == 19) { // 8000
        // width = 5; height = 5;
        TileNumAmount = 2;
        TileTypes = [
            [[0, 1], 1, "#460046", "#dcd9ec"], [[0, 2], 2, "#7e007e", "#dcd9ec"], [[0, 6], 6, "#bd00bd", "#dcd9ec"], [[0, 12], 12, "#ff00ff", "#dcd9ec"],
            [[1, 1], 20, "#462000", "#dcd9ec"], [[1, 2], 40, "#7d3800", "#dcd9ec"], [[1, 6], 120, "#b55100", "#dcd9ec"], [[1, 12], 240, "#ff7300", "#dcd9ec"],
            [[2, 1], 400, "#005800", "#dcd9ec"], [[2, 2], 800, "#008000", "#dcd9ec"], [[2, 6], 2400, "#00b300", "#dcd9ec"], [[2, 12], 4800, "#00df00", "#dcd9ec"],
            [[3, 1], 8000, "#000049", "#dcd9ec"], [[3, 2], 16000, "#00007d", "#dcd9ec"], [[3, 6], 48000, "#0000ba", "#dcd9ec"], [[3, 12], 96000, "#0000ff", "#dcd9ec"],
            [[4, 1], 160000, "#460000", "#dcd9ec"], [[4, 2], 320000, "#720000", "#dcd9ec"], [[4, 6], 960000, "#b60000", "#dcd9ec"], [[4, 12], 1920000, "#ff0000", "#dcd9ec"],
            [[5, 1], 3200000, "#5c5000", "#dcd9ec"], [[5, 2], 6400000, "#917e00", "#dcd9ec"], [[5, 6], 19200000, "#c8ad00", "#dcd9ec"], [[5, 12], 38400000, "#ffdd00", "#dcd9ec"],
            [["@This 1", "=", 1], [20, "^", "@This 0"], ["@HSVA", [82, "*", "@This 0", "-", 307], [0.9, "^", ["@This 0", "-", 6], "*", 100], 25, 1], "#dcd9ec"],
            [["@This 1", "=", 2], [20, "^", "@This 0", "*", 2], ["@HSVA", [82, "*", "@This 0", "-", 307], [0.9, "^", ["@This 0", "-", 6], "*", 100], 50, 1], "#dcd9ec"],
            [["@This 1", "=", 6], [20, "^", "@This 0", "*", 6], ["@HSVA", [82, "*", "@This 0", "-", 307], [0.9, "^", ["@This 0", "-", 6], "*", 100], 75, 1], "#2d2b39"],
            [["@This 1", "=", 12], [20, "^", "@This 0", "*", 12], ["@HSVA", [82, "*", "@This 0", "-", 307], [0.9, "^", ["@This 0", "-", 6], "*", 100], 100, 1], "#2d2b39"],
        ]
        MergeRules = [
            [2, [["@Next 1 0", "=", "@This 0"], "&&", ["@Next 1 1", "=", "@This 1"], "&&", [["@This 1", "=", 1], "||", ["@This 1", "=", 6]]], true, [["@This 0", ["@This 1", "*", 2]]], [20, "^", "@This 0", "*", "@This 1", "*", 2], [false, true]],
            [3, [["@Next 1 0", "=", "@This 0"], "&&", ["@Next 2 0", "=", "@This 0"], "&&", ["@Next 2 1", "=", 2], "&&",  ["@Next 1 1", "=", 2], "&&", ["@This 1", "=", 2]], true, [["@This 0", 6]], [20, "^", "@This 0", "*", 6], [false, true, true]],
            [3, [["@Next 1 0", "=", "@This 0"], "&&", ["@Next 2 0", "=", "@This 0"], "&&", ["@Next 2 1", "=", 12], "&&",  ["@Next 1 1", "=", 6], "&&", ["@This 1", "=", 2]], false, [[["@This 0", "+", 1], 1]], [20, "^", "@This 0", "*", 20], [false, true, true]]
        ]
        startTileSpawns = [[[0, 1], 90], [[0, 2], 9], [[0, 6], 1]];
        winConditions = [[3, 1]];
        winRequirement = 1;
        knownMergeMaxLength = 3;
        knownMergeLookbackDistance = 0;
        document.documentElement.style.setProperty("background-image", "radial-gradient(#0000a8 0%, #fff 150%)");
        document.documentElement.style.setProperty("--background-color", "#b4afe0");
        document.documentElement.style.setProperty("--grid-color", "#767593");
        document.documentElement.style.setProperty("--tile-color", "#5c5a8f");
        document.documentElement.style.setProperty("--text-color", "#2d2b39");
        displayRules("rules_text", ["h2", "Powers of 20"], ["h1", "8000"], ["p","Merges occur between two equal tiles that are a power of 20 or sextuple a power of 20, between three equal tiles that are double a power of 20, or between a tile that's double a power of 20, a tile that's sextuple that power of 20, and a tile that's 12 times that power of 20. Get to the 8000 tile to win!"],
        ["p", "Spawning tiles: 1 (90%), 2 (9%), 6 (1%)"]);
        displayRules("gm_rules_text", ["h2", "Powers of 20"], ["h1", "8000"], ["p","Merges occur between two equal tiles that are a power of 20 or sextuple a power of 20, between three equal tiles that are double a power of 20, or between a tile that's double a power of 20, a tile that's sextuple that power of 20, and a tile that's 12 times that power of 20. Get to the 8000 tile to win!"],
        ["p", "Spawning tiles: 1 (90%), 2 (9%), 6 (1%)"]);
    }
    else if (mode == 20) { // 9261
        // width = 5; height = 5;
        TileNumAmount = 2;
        TileTypes = [
            [[0, 1], 1, "#aaffaa", "#554051"], [[0, 3], 3, "#72ff72", "#554051"], [[0, 6], 6, "#00ff00", "#554051"],
            [[0, 10], 10, "#88ff00", "#7e277e"], [[0, 15], 15, "#00ff95", "#277e7e"],
            [[1, 1], 21, "#ffffc4", "#554051"], [[1, 3], 63, "#ffff80", "#554051"], [[1, 6], 126, "#ffff00", "#554051"],
            [[1, 10], 210, "#ffe000", "#7e277e"], [[1, 15], 315, "#d4ff00", "#277e7e"],
            [[2, 1], 441, "#a3eaff", "#554051"], [[2, 3], 1323, "#6bddff", "#554051"], [[2, 6], 2646, "#00c3ff", "#554051"],
            [[2, 10], 4410, "#00eeff", "#7e277e"], [[2, 15], 6615, "#00aaff", "#277e7e"],
            [[3, 1], 9261, "#ffa4ff", "#554051"], [[3, 3], 27783, "#ff72ff", "#554051"], [[3, 6], 55566, "#ff00ff", "#554051"],
            [[3, 10], 92610, "#d900ff", "#7e277e"], [[3, 15], 138915, "#ff00c8", "#277e7e"],
            [[4, 1], 194481, "#ff9696", "#554051"], [[4, 3], 583443, "#ff6363", "#554051"], [[4, 6], 1166886, "#ff0000", "#554051"],
            [[4, 10], 1944810, "#ff006f", "#7e277e"], [[4, 15], 2917215, "#ff4800", "#277e7e"],
            [[5, 1], 4084101, "#a1a1ff", "#554051"], [[5, 3], 12252303, "#6767ff", "#554051"], [[5, 6], 24504606, "#0000ff", "#554051"],
            [[5, 10], 40841010, "#0066ff", "#7e277e"], [[5, 15], 61261515, "#7b00ff", "#277e7e"],
            [["@This 1", "=", 1], [21, "^", "@This 0"], ["@HSVA", [113, "*", "@This 0", "-", 648], 33, [0.9, "^", ["@This 0", "-", 5], "*", 100], 1], "#f3e7f1"],
            [["@This 1", "=", 3], [21, "^", "@This 0", "*", 3], ["@HSVA", [113, "*", "@This 0", "-", 648], 66, [0.9, "^", ["@This 0", "-", 5], "*", 100], 1], "#f3e7f1"],
            [["@This 1", "=", 6], [21, "^", "@This 0", "*", 6], ["@HSVA", [113, "*", "@This 0", "-", 648], 100, [0.9, "^", ["@This 0", "-", 5], "*", 100], 1], "#f3e7f1"],
            [["@This 1", "=", 10], [21, "^", "@This 0", "*", 10], ["@HSVA", [113, "*", "@This 0", "-", 668], 100, [0.9, "^", ["@This 0", "-", 5], "*", 100], 1], "#ffbbff"],
            [["@This 1", "=", 15], [21, "^", "@This 0", "*", 15], ["@HSVA", [113, "*", "@This 0", "-", 628], 100, [0.9, "^", ["@This 0", "-", 5], "*", 100], 1], "#bbffff"],
        ];
        MergeRules = [
            [3, [["@Next 1 0", "=", "@This 0"], "&&", ["@Next 2 0", "=", "@This 0"], "&&", [["@This 1", "+", "@Next 1 1", "+", "@Next 2 1"], "@end_vars", ["@var_retain", "@Var 0", "=", 3], "||", ["@var_retain", "@Var 0", "=", 6], "||", ["@var_retain", "@Var 0", "=", 10], "||", ["@var_retain", "@Var 0", "=", 15]]], true, [["@This 0", ["@This 1", "+", "@Next 1 1", "+", "@Next 2 1"]]], [21, "^", "@This 0", "*", ["@This 1", "+", "@Next 1 1", "+", "@Next 2 1"]], [false, true, true]],
            [3, [["@Next 1 0", "=", "@This 0"], "&&", ["@Next 2 0", "=", "@This 0"], "&&", [["@This 1", "+", "@Next 1 1", "+", "@Next 2 1"], "@end_vars", ["@var_retain", "@Var 0", "=", 21]]], true, [[["@This 0", "+", 1], 1]], [21, "^", "@This 0", "*", 21], [false, true, true]],
            [2, [["@Next 1 0", "=", "@This 0"], "&&", [["@This 1", "+", "@Next 1 1"], "@end_vars", ["@var_retain", "@Var 0", "=", 3], "||", ["@var_retain", "@Var 0", "=", 6], "||", ["@var_retain", "@Var 0", "=", 10], "||", ["@var_retain", "@Var 0", "=", 15]], "&&", [[["@Next 1 0", "=", "@This 0"], "&&", ["@NextNE -1 0", "=", "@This 0"], "&&", [["@This 1", "+", "@Next 1 1", "+", "@NextNE -1 1"], "@end_vars", ["@var_retain", "@Var 0", "=", 3], "||", ["@var_retain", "@Var 0", "=", 6], "||", ["@var_retain", "@Var 0", "=", 10], "||", ["@var_retain", "@Var 0", "=", 15], "||", ["@var_retain", "@Var 0", "=", 21]]], "!"]], true, [["@This 0", ["@This 1", "+", "@Next 1 1"]]], [21, "^", "@This 0", "*", ["@This 1", "+", "@Next 1 1"]], [false, true]],
            [2, [["@Next 1 0", "=", "@This 0"], "&&", [["@This 1", "+", "@Next 1 1"], "@end_vars", ["@var_retain", "@Var 0", "=", 21]], "&&", [[["@Next 1 0", "=", "@This 0"], "&&", ["@NextNE -1 0", "=", "@This 0"], "&&", [["@This 1", "+", "@Next 1 1", "+", "@NextNE -1 1"], "@end_vars", ["@var_retain", "@Var 0", "=", 3], "||", ["@var_retain", "@Var 0", "=", 6], "||", ["@var_retain", "@Var 0", "=", 10], "||", ["@var_retain", "@Var 0", "=", 15], "||", ["@var_retain", "@Var 0", "=", 21]]], "!"]], true, [[["@This 0", "+", 1], 1]], [21, "^", "@This 0", "*", 21], [false, true]]
        ]
        startTileSpawns = [[[0, 1], 95], [[0, 3], 4], [[0, 6], 1]];
        winConditions = [[3, 1]];
        winRequirement = 1;
        knownMergeMaxLength = 3;
        knownMergeLookbackDistance = 1;
        document.documentElement.style.setProperty("background-image", "radial-gradient(#ff8cf5 0%, #fff 150%)");
        document.documentElement.style.setProperty("--background-color", "#fff0fd");
        document.documentElement.style.setProperty("--grid-color", "#ecc7e9");
        document.documentElement.style.setProperty("--tile-color", "#eaa4e4");
        document.documentElement.style.setProperty("--text-color", "#554051");
        displayRules("rules_text", ["h2", "Powers of 21"], ["h1", "9261"], ["p","Merges occur between any two or three tiles that add to a power of 21, triple a power of 21, sextuple a power of 21, 10 times a power of 21, or 15 times a power of 21. Get to the 9261 tile to win!"],
        ["p", "Spawning tiles: 1 (95%), 3 (4%), 6 (1%)"]);
        displayRules("gm_rules_text", ["h2", "Powers of 21"], ["h1", "9261"], ["p","Merges occur between any two or three tiles that add to a power of 21, triple a power of 21, sextuple a power of 21, 10 times a power of 21, or 15 times a power of 21. Get to the 9261 tile to win!"],
        ["p", "Spawning tiles: 1 (95%), 3 (4%), 6 (1%)"]);
    }
    else if (mode == 21) { // 625
        // width = 5; height = 5;
        TileNumAmount = 2;
        TileTypes = [
            [[0, 0], 1, "#ff8c00", "#515a5a"], [[0, 1], 2, "#c76d00", "#eef9f9"], [[0, 2], 4, "#904f00", "#eef9f9"], [[0, 3], 8, "#633700", "#eef9f9"],
                [[0, 4], 16, "#402300", "#eef9f9"], [[0, -1], 3, "#ffaf4e", "#323939"], [[0, -2], 9, "#ffce93", "#323939"],
            [[1, 0], 25, "#d000ff", "#515a5a"], [[1, 1], 50, "#9f00c3", "#eef9f9"], [[1, 2], 100, "#780093", "#eef9f9"], [[1, 3], 200, "#480058", "#eef9f9"],
                [[1, 4], 400, "#30003a", "#eef9f9"], [[1, -1], 75, "#e260ff", "#323939"], [[1, -2], 225, "#eea1ff", "#323939"],
            [[2, 0], 625, "#00ccff", "#515a5a"], [[2, 1], 1250, "#00a9d3", "#eef9f9"], [[2, 2], 2500, "#007b9a", "#eef9f9"], [[2, 3], 5000, "#005469", "#eef9f9"],
                [[2, 4], 10000, "#003441", "#eef9f9"], [[2, -1], 1875, "#6ee2ff", "#323939"], [[2, -2], 5625, "#aeefff", "#323939"],
            [[3, 0], 15625, "#80ff00", "#515a5a"], [[3, 1], 31250, "#61c300", "#eef9f9"], [[3, 2], 62500, "#4a9400", "#eef9f9"], [[3, 3], 125000, "#316200", "#eef9f9"],
                [[3, 4], 250000, "#1d3900", "#eef9f9"], [[3, -1], 46875, "#aeff5d", "#323939"], [[3, -2], 140625, "#c8ff92", "#323939"],
            [[4, 0], 390625, "#ff006f", "#515a5a"], [[4, 1], 781250, "#c50055", "#eef9f9"], [[4, 2], 1562500, "#940040", "#eef9f9"], [[4, 3], 3125000, "#66002c", "#eef9f9"],
                [[4, 4], 6250000, "#3e001b", "#eef9f9"], [[4, -1], 1171875, "#ff519d", "#323939"], [[4, -2], 3515625, "#ff93c2", "#323939"],
            [["@This 1", "=", 0], [25, "^", "@This 0"], ["@HSLA", [-107, "*", "@This 0", "+", 775], [0.8, "^", ["@This 0", "-", 5], "*", 100], 50, 1], "#515a5a"],
            [["@This 1", "=", 1], [25, "^", "@This 0", "*", 2], ["@HSLA", [-107, "*", "@This 0", "+", 775], [0.8, "^", ["@This 0", "-", 5], "*", 100], 40, 1], "#eef9f9"],
            [["@This 1", "=", 2], [25, "^", "@This 0", "*", 4], ["@HSLA", [-107, "*", "@This 0", "+", 775], [0.8, "^", ["@This 0", "-", 5], "*", 100], 30, 1], "#eef9f9"],
            [["@This 1", "=", 3], [25, "^", "@This 0", "*", 8], ["@HSLA", [-107, "*", "@This 0", "+", 775], [0.8, "^", ["@This 0", "-", 5], "*", 100], 20, 1], "#eef9f9"],
            [["@This 1", "=", 4], [25, "^", "@This 0", "*", 16], ["@HSLA", [-107, "*", "@This 0", "+", 775], [0.8, "^", ["@This 0", "-", 5], "*", 100], 10, 1], "#eef9f9"],
            [["@This 1", "=", -1], [25, "^", "@This 0", "*", 3], ["@HSLA", [-107, "*", "@This 0", "+", 775], [0.8, "^", ["@This 0", "-", 5], "*", 100], 66, 1], "#323939"],
            [["@This 1", "=", -2], [25, "^", "@This 0", "*", 9], ["@HSLA", [-107, "*", "@This 0", "+", 775], [0.8, "^", ["@This 0", "-", 5], "*", 100], 83, 1], "#323939"],
        ]
        MergeRules = [
            [3, [["@Next 1 0", "=", "@This 0"], "&&", ["@Next 1 1", "=", "@This 1"], "&&", ["@Next 2 0", "=", "@This 0"], "&&", ["@Next 2 1", "=", "@This 1"], "&&", ["@This 1", "<=", 0], "&&", ["@This 1", ">", -2]], true, [["@This 0", ["@This 1", "-", 1]]], [25, "^", "@This 0", "*", [3, "^", ["@This 1", "*", -1], "*", 3]], [false, true, true]],
            [2, [["@NextNE -1 0", "!=", "@This 0"], "||", ["@NextNE -1 1", "!=", "@This 1"], "&&", ["@Next 1 0", "=", "@This 0"], "&&", ["@Next 1 1", "=", "@This 1"], "&&", ["@This 1", ">=", 0], "&&", ["@This 1", "<", 4]], true, [["@This 0", ["@This 1", "+", 1]]], [25, "^", "@This 0", "*", [2, "^", "@This 1", "*", 2]], [false, true]],
            [2, [["@Next 1 0", "=", "@This 0"], "&&", ["@This 1", "=", -2], "&&", ["@Next 1 1", "=", 4]], false, [[["@This 0", "+", 1], 0]], [25, "^", "@This 0", "*", 25], [false, true]],
        ]
        startTileSpawns = [[[0, 0], 90], [[0, 1], 5], [[0, -1], 5]];
        winConditions = [[2, 1]];
        winRequirement = 1;
        knownMergeMaxLength = 3;
        knownMergeLookbackDistance = 1;
        document.documentElement.style.setProperty("background-image", "radial-gradient(#007b7b 0%, #fff 150%)");
        document.documentElement.style.setProperty("--background-color", "#bbe1e0");
        document.documentElement.style.setProperty("--grid-color", "#789a9d");
        document.documentElement.style.setProperty("--tile-color", "#88c8ce");
        document.documentElement.style.setProperty("--text-color", "#323939");
        displayRules("rules_text", ["h2", "Powers of 25"], ["h1", "625"], ["p","Merges occur between two equal tiles that are a power of 25, double a power of 25, quadruple a power of 25, or 8 times a power of 25, between three equal tiles that are a power of 25 or triple a power of 25, or between a tile that's 9 times a power of 25 and a tile that's 16 times a power of 25. Get to the 625 tile to win!"],
        ["p", "Spawning tiles: 1 (90%), 2 (5%), 3 (5%)"]);
        displayRules("gm_rules_text", ["h2", "Powers of 25"], ["h1", "625"], ["p","Merges occur between two equal tiles that are a power of 25, double a power of 25, quadruple a power of 25, or 8 times a power of 25, between three equal tiles that are a power of 25 or triple a power of 25, or between a tile that's 9 times a power of 25 and a tile that's 16 times a power of 25. Get to the 625 tile to win!"],
        ["p", "Spawning tiles: 1 (90%), 2 (5%), 3 (5%)"]);
    }
    else if (mode == 22) { // 900
        // width = 7; height = 7;
        TileNumAmount = 2;
        TileTypes = [
            [[0, 1], 1, "#000000", "#ffffff"], [[0, 2], 2, "radial-gradient(#000000 0% 33%, #f00)", "#ffffff"], [[0, 3], 3, "radial-gradient(#000000 0% 33%, #0f0)", "#ffffff"],
            [[0, 5], 5, "radial-gradient(#000000 0% 33%, #00f)", "#ffffff"], [[0, 6], 6, "radial-gradient(#000000 0% 33%, #ff0)", "#ffffff"],
            [[0, 10], 10, "radial-gradient(#000000 0% 33%, #f0f)", "#ffffff"], [[0, 15], 15, "radial-gradient(#000000 0% 33%, #0ff)", "#ffffff"],
            [[1, 1], 30, "#ffffff", "#000000"], [[1, 2], 60, "radial-gradient(#ffffff 0% 33%, #f00)", "#000000"], [[1, 3], 90, "radial-gradient(#ffffff 0% 33%, #0f0)", "#000000"],
            [[1, 5], 150, "radial-gradient(#ffffff 0% 33%, #00f)", "#000000"], [[1, 6], 180, "radial-gradient(#ffffff 0% 33%, #ff0)", "#000000"],
            [[1, 10], 300, "radial-gradient(#ffffff 0% 33%, #f0f)", "#000000"], [[1, 15], 450, "radial-gradient(#ffffff 0% 33%, #0ff)", "#000000"],
            [[2, 1], 900, "#97006c", "#ffffff"], [[2, 2], 1800, "radial-gradient(#97006c 0% 33%, #f00)", "#ffffff"], [[2, 3], 2700, "radial-gradient(#97006c 0% 33%, #0f0)", "#ffffff"],
            [[2, 5], 4500, "radial-gradient(#97006c 0% 33%, #00f)", "#ffffff"], [[2, 6], 5400, "radial-gradient(#97006c 0% 33%, #ff0)", "#ffffff"],
            [[2, 10], 9000, "radial-gradient(#97006c 0% 33%, #f0f)", "#ffffff"], [[2, 15], 13500, "radial-gradient(#97006c 0% 33%, #0ff)", "#ffffff"],
            [[3, 1], 27000, "#ffe788", "#000000"], [[3, 2], 54000, "radial-gradient(#ffe788 0% 33%, #f00)", "#000000"], [[3, 3], 81000, "radial-gradient(#ffe788 0% 33%, #0f0)", "#000000"],
            [[3, 5], 135000, "radial-gradient(#ffe788 0% 33%, #00f)", "#000000"], [[3, 6], 162000, "radial-gradient(#ffe788 0% 33%, #ff0)", "#000000"],
            [[3, 10], 270000, "radial-gradient(#ffe788 0% 33%, #f0f)", "#000000"], [[3, 15], 405000, "radial-gradient(#ffe788 0% 33%, #0ff)", "#000000"],
            [[4, 1], 810000, "#00306e", "#ffffff"], [[4, 2], 1620000, "radial-gradient(#00306e 0% 33%, #f00)", "#ffffff"], [[4, 3], 2430000, "radial-gradient(#00306e 0% 33%, #0f0)", "#ffffff"],
            [[4, 5], 4050000, "radial-gradient(#00306e 0% 33%, #00f)", "#ffffff"], [[4, 6], 4860000, "radial-gradient(#00306e 0% 33%, #ff0)", "#ffffff"],
            [[4, 10], 8100000, "radial-gradient(#00306e 0% 33%, #f0f)", "#ffffff"], [[4, 15], 12150000, "radial-gradient(#00306e 0% 33%, #0ff)", "#ffffff"],
            [[5, 1], 24300000, "#7affb6", "#000000"], [[5, 2], 48600000, "radial-gradient(#7affb6 0% 33%, #f00)", "#000000"], [[5, 3], 72900000, "radial-gradient(#7affb6 0% 33%, #0f0)", "#000000"],
            [[5, 5], 121500000, "radial-gradient(#7affb6 0% 33%, #00f)", "#000000"], [[5, 6], 145800000, "radial-gradient(#7affb6 0% 33%, #ff0)", "#000000"],
            [[5, 10], 243000000, "radial-gradient(#7affb6 0% 33%, #f0f)", "#000000"], [[5, 15], 364500000, "radial-gradient(#7affb6 0% 33%, #0ff)", "#000000"],
            [["@This 1", "=", 1], [30, "^", "@This 0"], ["@HSLA", [139, "*", "@This 0", "-", 804], [0.85, "^", ["@This 0", "-", 6], "*", 100], ["@This 0", "%", 2, "*", 50, "+", 25], 1], ["@HSLA", 0, 0, ["@This 0", "%", 2, "*", -100, "+", 100], 1]],
            [["@This 1", "=", 2], [30, "^", "@This 0", "*", 2], ["@radial-gradient", ["@HSLA", [139, "*", "@This 0", "-", 804], [0.85, "^", ["@This 0", "-", 6], "*", 100], ["@This 0", "%", 2, "*", 50, "+", 25], 1], 0, 25, "#f00"], ["@HSLA", 0, 0, ["@This 0", "%", 2, "*", -100, "+", 100], 1]],
            [["@This 1", "=", 3], [30, "^", "@This 0", "*", 3], ["@radial-gradient", ["@HSLA", [139, "*", "@This 0", "-", 804], [0.85, "^", ["@This 0", "-", 6], "*", 100], ["@This 0", "%", 2, "*", 50, "+", 25], 1], 0, 25, "#0f0"], ["@HSLA", 0, 0, ["@This 0", "%", 2, "*", -100, "+", 100], 1]],
            [["@This 1", "=", 5], [30, "^", "@This 0", "*", 5], ["@radial-gradient", ["@HSLA", [139, "*", "@This 0", "-", 804], [0.85, "^", ["@This 0", "-", 6], "*", 100], ["@This 0", "%", 2, "*", 50, "+", 25], 1], 0, 25, "#00f"], ["@HSLA", 0, 0, ["@This 0", "%", 2, "*", -100, "+", 100], 1]],
            [["@This 1", "=", 6], [30, "^", "@This 0", "*", 6], ["@radial-gradient", ["@HSLA", [139, "*", "@This 0", "-", 804], [0.85, "^", ["@This 0", "-", 6], "*", 100], ["@This 0", "%", 2, "*", 50, "+", 25], 1], 0, 25, "#ff0"], ["@HSLA", 0, 0, ["@This 0", "%", 2, "*", -100, "+", 100], 1]],
            [["@This 1", "=", 10], [30, "^", "@This 0", "*", 10], ["@radial-gradient", ["@HSLA", [139, "*", "@This 0", "-", 804], [0.85, "^", ["@This 0", "-", 6], "*", 100], ["@This 0", "%", 2, "*", 50, "+", 25], 1], 0, 25, "#f0f"], ["@HSLA", 0, 0, ["@This 0", "%", 2, "*", -100, "+", 100], 1]],
            [["@This 1", "=", 15], [30, "^", "@This 0", "*", 15], ["@radial-gradient", ["@HSLA", [139, "*", "@This 0", "-", 804], [0.85, "^", ["@This 0", "-", 6], "*", 100], ["@This 0", "%", 2, "*", 50, "+", 25], 1], 0, 25, "#0ff"], ["@HSLA", 0, 0, ["@This 0", "%", 2, "*", -100, "+", 100], 1]],
        ];
        MergeRules = [
            [5, [["@This 1", "=", 1], "||", ["@This 1", "=", 2], "||", ["@This 1", "=", 3], "&&", [["@NextNE -1 0", "!=", "@This 0"], "||", ["@NextNE -1 1", "!=", "@This 1"]], "&&", [["@Next 5 0", "!=", "@This 0"], "||", ["@Next 5 1", "!=", "@This 1"]], "&&", ["@Next 1 0", "=", "@This 0"], "&&", ["@Next 1 1", "=", "@This 1"], "&&", ["@Next 2 0", "=", "@This 0"], "&&", ["@Next 2 1", "=", "@This 1"], "&&", ["@Next 3 0", "=", "@This 0"], "&&", ["@Next 3 1", "=", "@This 1"], "&&", ["@Next 4 0", "=", "@This 0"], "&&", ["@Next 4 1", "=", "@This 1"]], true, [["@This 0", ["@This 1", "*", 5]]], [30, "^", "@This 0", "*", "@This 1", "*", 5], [false, true, true, true, true]],
            [3, [["@This 1", "=", 1], "||", ["@This 1", "=", 2], "||", ["@This 1", "=", 5], "&&", [["@NextNE -1 0", "!=", "@This 0"], "||", ["@NextNE -1 1", "!=", "@This 1"]], "&&", [["@Next 3 0", "!=", "@This 0"], "||", ["@Next 3 1", "!=", "@This 1"]], "&&", ["@Next 1 0", "=", "@This 0"], "&&", ["@Next 1 1", "=", "@This 1"], "&&", ["@Next 2 0", "=", "@This 0"], "&&", ["@Next 2 1", "=", "@This 1"]], true, [["@This 0", ["@This 1", "*", 3]]], [30, "^", "@This 0", "*", "@This 1", "*", 3], [false, true, true]],
            [2, [["@This 1", "=", 1], "||", ["@This 1", "=", 3], "||", ["@This 1", "=", 5], "&&", [["@NextNE -1 0", "!=", "@This 0"], "||", ["@NextNE -1 1", "!=", "@This 1"]], "&&", [["@Next 2 0", "!=", "@This 0"], "||", ["@Next 2 1", "!=", "@This 1"]], "&&", ["@Next 1 0", "=", "@This 0"], "&&", ["@Next 1 1", "=", "@This 1"]], true, [["@This 0", ["@This 1", "*", 2]]], [30, "^", "@This 0", "*", "@This 1", "*", 2], [false, true]],
            [5, [["@This 1", "=", 6], "&&", [["@NextNE -1 0", "!=", "@This 0"], "||", ["@NextNE -1 1", "!=", "@This 1"]], "&&", [["@Next 5 0", "!=", "@This 0"], "||", ["@Next 5 1", "!=", "@This 1"]], "&&", ["@Next 1 0", "=", "@This 0"], "&&", ["@Next 1 1", "=", "@This 1"], "&&", ["@Next 2 0", "=", "@This 0"], "&&", ["@Next 2 1", "=", "@This 1"], "&&", ["@Next 3 0", "=", "@This 0"], "&&", ["@Next 3 1", "=", "@This 1"], "&&", ["@Next 4 0", "=", "@This 0"], "&&", ["@Next 4 1", "=", "@This 1"]], true, [[["@This 0", "+", 1], 1]], [30, "^", "@This 0", "*", "@This 1", "*", 30], [false, true, true, true, true]],
            [3, [["@This 1", "=", 10], "&&", [["@NextNE -1 0", "!=", "@This 0"], "||", ["@NextNE -1 1", "!=", "@This 1"]], "&&", [["@Next 3 0", "!=", "@This 0"], "||", ["@Next 3 1", "!=", "@This 1"]], "&&", ["@Next 1 0", "=", "@This 0"], "&&", ["@Next 1 1", "=", "@This 1"], "&&", ["@Next 2 0", "=", "@This 0"], "&&", ["@Next 2 1", "=", "@This 1"]], true, [[["@This 0", "+", 1], 1]], [30, "^", "@This 0", "*", "@This 1", "*", 30], [false, true, true]],
            [2, [["@This 1", "=", 15], "&&", [["@NextNE -1 0", "!=", "@This 0"], "||", ["@NextNE -1 1", "!=", "@This 1"]], "&&", [["@Next 2 0", "!=", "@This 0"], "||", ["@Next 2 1", "!=", "@This 1"]], "&&", ["@Next 1 0", "=", "@This 0"], "&&", ["@Next 1 1", "=", "@This 1"]], true, [[["@This 0", "+", 1], 1]], [30, "^", "@This 0", "*", "@This 1", "*", 30], [false, true]]
        ];
        startTileSpawns = [[[0, 1], 100]];
        winConditions = [[2, 1]];
        winRequirement = 1;
        knownMergeMaxLength = 6; // Because we need to ensure that six doesn't merge even though five does
        knownMergeLookbackDistance = 1;
        document.documentElement.style.setProperty("background-image", "radial-gradient(#acacac 0%, #fff 100%)");
        document.documentElement.style.setProperty("--background-color", "#ffffff");
        document.documentElement.style.setProperty("--grid-color", "#a8a8a8");
        document.documentElement.style.setProperty("--tile-color", "#cbcbcb");
        document.documentElement.style.setProperty("--text-color", "#484848");
        displayRules("rules_text", ["h2", "Powers of 30"], ["h1", "900"], ["p", "Merges occur between two equal tiles that are equal to, triple, quintuple, or 15 times a power of 30, between three equal tiles that are equal to, double, quintuple, or 10 times a power of 30, or between five equal tiles that are equal to, double, triple, or sextuple a power of 30. A line of four, six, seven, etc. of the same tile will not merge. Get to the 900 tile to win!"],
        ["p", "Spawning tiles: 1 (100%)"]);
        displayRules("gm_rules_text", ["h2", "Powers of 30"], ["h1", "900"], ["p", "Merges occur between two equal tiles that are equal to, triple, quintuple, or 15 times a power of 30, between three equal tiles that are equal to, double, quintuple, or 10 times a power of 30, or between five equal tiles that are equal to, double, triple, or sextuple a power of 30. A line of four, six, seven, etc. of the same tile will not merge. Get to the 900 tile to win!"],
        ["p", "Spawning tiles: 1 (100%)"]);
    }
    else if (mode == 23) { // 2059
        // width = 5; height = 5;
        TileNumAmount = 2;
        TileTypes = [
            [[1, 1], 1, "#ffffff", "#33312c"], [[1, 2], 2, "#808080", "#f9f5ee"], [[1, 3], 3, "#c4c4c4", "#33312c"],
            [[2, 1], 5, "#0066ff", "#33312c"], [[2, 2], 4, "#003c97", "#f9f5ee"], [[2, 3], 15, "#72aaff", "#33312c"],
            [[3, 1], 19, "#f200ff", "#33312c"], [[3, 2], 8, "#8a0091", "#f9f5ee"], [[3, 3], 57, "#f988ff", "#33312c"],
            [[4, 1], 65, "#a2ff00", "#33312c"], [[4, 2], 16, "#588a00", "#f9f5ee"], [[4, 3], 195, "#ceff79", "#33312c"],
            [[5, 1], 211, "#ff5100", "#33312c"], [[5, 2], 32, "#932e00", "#f9f5ee"], [[5, 3], 633, "#ff8f5b", "#33312c"],
            [[6, 1], 665, "#8c00ff", "#33312c"], [[6, 2], 64, "#4e008f", "#f9f5ee"], [[6, 3], 1995, "#bd6cff", "#33312c"],
            [[7, 1], 2059, "#ffcc00", "#33312c"], [[7, 2], 128, "#886d00", "#f9f5ee"], [[7, 3], 6177, "#ffe991", "#33312c"],
            [[8, 1], 6305, "#00ff04", "#33312c"], [[8, 2], 256, "#007a02", "#f9f5ee"], [[8, 3], 18915, "#96ff98", "#33312c"],
            [[9, 1], 19171, "#ff0099", "#33312c"], [[9, 2], 512, "#98005b", "#f9f5ee"], [[9, 3], 57513, "#ff88cf", "#33312c"],
            [[10, 1], 58025, "#00ffff", "#33312c"], [[10, 2], 1024, "#009191", "#f9f5ee"], [[10, 3], 174075, "#b2ffff", "#33312c"],
            [[11, 1], 175099, "#ffff00", "#33312c"], [[11, 2], 2048, "#797900", "#f9f5ee"], [[11, 3], 525297, "#ffff9f", "#33312c"],
            [[12, 1], 527345, "#00aaff", "#33312c"], [[12, 2], 4096, "#005681", "#f9f5ee"], [[12, 3], 1582035, "#87d7ff", "#33312c"],
            [["@This 1", "=", 1], [[3, "^", "@This 0"], "-", [2, "^", "@This 0"]], ["@HSLA", [157, "*", "@This 0", "-", 2041], [0.9, "^", ["@This 0", "-", 12], "*", 100], 50, 1], "#33312c"],
            [["@This 1", "=", 2], [2, "^", "@This 0"], ["@HSLA", [157, "*", "@This 0", "-", 2041], [0.9, "^", ["@This 0", "-", 12], "*", 100], 25, 1], "#f9f5ee"],
            [["@This 1", "=", 3], [[3, "^", "@This 0"], "-", [2, "^", "@This 0"], "*", 3], ["@HSLA", [157, "*", "@This 0", "-", 2041], [0.9, "^", ["@This 0", "-", 12], "*", 100], 75, 1], "#33312c"],
        ];
        MergeRules = [
            [2, [["@Next 1 0", "=", "@This 0"], "&&", ["@Next 1 1", "=", 2], "&&", ["@This 1", "=", 2]], true, [[["@This 0", "+", 1], 2]], [2, "^", "@This 0", "*", 2], [false, true]],
            [3, [["@Next 1 0", "=", "@This 0"], "&&", ["@Next 2 0", "=", "@This 0"], "&&", ["@Next 1 1", "=", 1], "&&", ["@This 1", "=", 1], "&&", ["@Next 2 1", "=", 1]], false, [["@This 0", 3]], [[3, "^", "@This 0"], "-", [2, "^", "@This 0"], "*", 3], [false, true, true]],
            [2, [["@Next 1 0", "=", "@This 0"], "&&", ["@Next 1 1", "=", 3], "&&", ["@This 1", "=", 2]], false, [[["@This 0", "+", 1], 1]], [[3, "^", ["@This 0", "+", 1]], "-", [2, "^", ["@This 0", "+", 1]]], [false, true]],
            [2, [["@NextNE -1 0", "!=", 1], "||", ["@NextNE -1 1", "!=", 1], "&&", ["@Next 1 0", "=", 1], "&&", ["@Next 1 1", "=", 1], "&&", ["@This 0", "=", 1], "&&", ["@This 1", "=", 1]], true, [[1, 2]], 2, [false, true]],
        ]
        startTileSpawns = [[[1, 1], 90], [[1, 2], 6], [[1, 3], 4]];
        winConditions = [[7, 1]];
        winRequirement = 1;
        knownMergeMaxLength = 3;
        knownMergeLookbackDistance = 1;
        document.documentElement.style.setProperty("background-image", "radial-gradient(#ffdf76 0%, #fff 150%)");
        document.documentElement.style.setProperty("--background-color", "#fffbde");
        document.documentElement.style.setProperty("--grid-color", "#efe1be");
        document.documentElement.style.setProperty("--tile-color", "#ddc994");
        document.documentElement.style.setProperty("--text-color", "#33312c");
        displayRules("rules_text", ["h2", "Powers of 3 Minus Powers of 2"], ["h1", "2059"], ["p","For any nonnegative integer n, merges can occur between two 2<sup>n</sup> tiles, between three (3<sup>n</sup> - 2<sup>n</sup>) tiles, or between one (3 * (3<sup>n</sup> - 2<sup>n</sup>)) tile and one 2<sup>n</sup> tile. Get to the 2059 (3<sup>7</sup> - 2<sup>7</sup>) tile to win! (Tip: 1 is both 2<sup>0</sup> and (3<sup>1</sup> - 2<sup>1</sup>), so two 1s and three 1s both have merges)"],
        ["p", "Spawning tiles: 1 (90%), 2 (6%), 3 (4%)"]);
        displayRules("gm_rules_text", ["h2", "Powers of 3 Minus Powers of 2"], ["h1", "2059"], ["p","For any nonnegative integer n, merges can occur between two 2<sup>n</sup> tiles, between three (3<sup>n</sup> - 2<sup>n</sup>) tiles, or between one (3 * (3<sup>n</sup> - 2<sup>n</sup>)) tile and one 2<sup>n</sup> tile. Get to the 2059 (3<sup>7</sup> - 2<sup>7</sup>) tile to win! (Tip: 1 is both 2<sup>0</sup> and (3<sup>1</sup> - 2<sup>1</sup>), so two 1s and three 1s both have merges)"],
        ["p", "Spawning tiles: 1 (90%), 2 (6%), 3 (4%)"]);
    }
    else if (mode == 24) { // 2315
        // width = 5; height = 5;
        TileNumAmount = 2;
        TileTypes = [
            [[0, 1], 1, "#808080", "#d9e3f4"], [[0, 2], 2, "#dddddd", "#333943"],
            [[1, 1], 3, "#b28900", "#d9e3f4"], [[1, 2], 5, "#ffd54a", "#333943"],
            [[2, 1], 9, "#9500b2", "#d9e3f4"], [[2, 2], 13, "#e566ff", "#333943"],
            [[3, 1], 27, "#00bd65", "#d9e3f4"], [[3, 2], 35, "#64ffb7", "#333943"],
            [[4, 1], 81, "#b43000", "#d9e3f4"], [[4, 2], 97, "#ff6e39", "#333943"],
            [[5, 1], 243, "#00becc", "#d9e3f4"], [[5, 2], 275, "#50f3ff", "#333943"],
            [[6, 1], 729, "#c80099", "#d9e3f4"], [[6, 2], 793, "#ff42d3", "#333943"],
            [[7, 1], 2187, "#0080cb", "#d9e3f4"], [[7, 2], 2315, "#4cbdff", "#333943"],
            [[8, 1], 6561, "#6f00be", "#d9e3f4"], [[8, 2], 6817, "#b144ff", "#333943"],
            [[9, 1], 19683, "#bd5e00", "#d9e3f4"], [[9, 2], 20195, "#ff9e3d", "#333943"],
            [[10, 1], 59049, "#0045c4", "#d9e3f4"], [[10, 2], 60073, "#2c76ff", "#333943"],
            [[11, 1], 177147, "#67d500", "#d9e3f4"], [[11, 2], 179195, "#9fff46", "#333943"],
            [["@This 1", "=", 1], [3, "^", "@This 0"], ["@HSLA", [-149, "*", "@This 0", "+", 1788], [0.9, "^", ["@This 0", "-", 12], "*", 100], 35, 1], "#d9e3f4"],
            [["@This 1", "=", 2], [[3, "^", "@This 0"], "+", [2, "^", "@This 0"]], ["@HSLA", [-149, "*", "@This 0", "+", 1788], [0.9, "^", ["@This 0", "-", 12], "*", 100], 65, 1], "#333943"],
        ];
        MergeRules = [
            [3, [["@Next 1 0", "=", "@This 0"], "&&", ["@Next 2 0", "=", "@This 0"], "&&", ["@Next 1 1", "=", 1], "&&", ["@This 1", "=", 1], "&&", ["@Next 2 1", "=", 1]], false, [[["@This 0", "+", 1], 1]], [3, "^", "@This 0"], [false, true, true]],
            [3, [["@Next 1 0", "=", "@This 0"], "&&", ["@Next 2 0", "=", "@This 0"], "&&", ["@Next 1 1", "=", 2], "&&", ["@This 1", "=", 2], "&&", ["@Next 2 1", "=", 1]], false, [[["@This 0", "+", 1], 2]], [[3, "^", ["@This 0", "+", 1]], "*", [2, "^", ["@This 0", "+", 1]]], [false, true, true]],
            [2, [["@NextNE -1 0", "!=", 0], "||", ["@NextNE -1 1", "!=", 1], "&&", ["@Next 1 0", "=", 0], "&&", ["@Next 1 1", "=", 1], "&&", ["@This 0", "=", 0], "&&", ["@This 1", "=", 1]], true, [[0, 2]], 2, [false, true]]
        ]
        startTileSpawns = [[[0, 1], 90], [[0, 2], 6], [[1, 1], 4]];
        winConditions = [[7, 2]];
        winRequirement = 1;
        knownMergeMaxLength = 3;
        knownMergeLookbackDistance = 1;
        document.documentElement.style.setProperty("background-image", "radial-gradient(#829bff 0%, #fff 150%)");
        document.documentElement.style.setProperty("--background-color", "#dae5ff");
        document.documentElement.style.setProperty("--grid-color", "#b1c4e0");
        document.documentElement.style.setProperty("--tile-color", "#bad3fa");
        document.documentElement.style.setProperty("--text-color", "#333943");
        displayRules("rules_text", ["h2", "Powers of 3 Plus Powers of 2"], ["h1", "2315"], ["p", "Two or three 1s can merge, and for any nonnegative integer n, merges can occur between three 3<sup>n</sup> tiles, or between two (3<sup>n</sup> + 2<sup>n</sup>) tiles and one 3<sup>n</sup> tile. Get to the 2315 (3<sup>7</sup> + 2<sup>7</sup>) tile to win!"],
        ["p", "Spawning tiles: 1 (90%), 2 (6%), 3 (4%)"]);
        displayRules("gm_rules_text", ["h2", "Powers of 3 Plus Powers of 2"], ["h1", "2315"], ["p", "Two or three 1s can merge, and for any nonnegative integer n, merges can occur between three 3<sup>n</sup> tiles, or between two (3<sup>n</sup> + 2<sup>n</sup>) tiles and one 3<sup>n</sup> tile. Get to the 2315 (3<sup>7</sup> + 2<sup>7</sup>) tile to win!"],
        ["p", "Spawning tiles: 1 (90%), 2 (6%), 3 (4%)"]);
    }
    else if (mode == 25) { // XXXX
        // width = 6; height = 6;
        TileNumAmount = 2;
        start_game_vars = [0, 0]; // Controls the display of Discovered Tiles and Discovered Winning Tiles
        TileTypes = [[[1, 0], 1, "#ffffff", "#000000"],
        [[["@This 0", ">", 1], "&&", ["@This 1", "<", 5]], ["@This 0", "^", "@This 1"], ["@HSLA", [222.49223595, "*", "@This 0", "-", 444.9844719], 100, [100, "-", ["@This 1", "*", 12.5]], 1], "#000000"],
        [true, ["@This 0", "^", "@This 1"], ["@HSLA", [222.49223595, "*", "@This 0", "-", 444.9844719], 100, [0.85, "^", ["@This 1", "-", 5], "*", 50], 1], "#ffffff"],];
        MergeRules = [
            [2, [["@NextNE -1 0", "!=", "@This 0"], "&&", ["@Next 1 0", "=", 1], "&&", ["@This 0", "=", 1]], true, [["@MLength", 1]], ["@MLength"], [], 2, [0, 1], 1, Math.max(width, height)],
            [Math.max(width, height), [["@Next 1 0", "=", 1], "&&", ["@This 0", "=", 1]], true, [["@MLength", 1]], ["@MLength"], [], 2, [0, 1], 1, Math.max(width, height)],
            ["@This 0", [["@Next 1 0", "=", "@This 0"], "&&", ["@Next 1 1", "=", "@This 1"], "&&", ["@This 0", ">", 1]], true, [["@This 0", ["@This 1", "+", 1]]], ["@This 0", "^", ["@This 1", "+", 1]], [], 2, [0, 1], 1],
        ];
        startTileSpawns = [[[1, 0], 100]];
        winConditions = [[["@This 0", "^", "@This 1", ">=", 1000]]]; // Any tile that's at least 1000 is winning
        winRequirement = 4;
        mode_vars = [2, Infinity]; //Minimum and maximum merge lengths; there's some special behavior if these are equal
        knownMergeMaxLength = Infinity;
        knownMergeLookbackDistance = 1;
        document.documentElement.style.setProperty("background-image", "radial-gradient(#636363 0%, #fff 150%)");
        document.documentElement.style.setProperty("--background-color", "#e8e8e8");
        document.documentElement.style.setProperty("--grid-color", "#e1c3c3");
        document.documentElement.style.setProperty("--tile-color", "#c6c3e1");
        document.documentElement.style.setProperty("--text-color", "#41433f");
        displayRules("rules_text", ["h2", "Powers of n"], ["h1", "XXXX"], ["p", "Any number of 1s can merge, but upon doing so, they merge into a tile that must merge with the same number of itself on each higher tier: for example, merging two 1s makes a 2, then it takes two 2s to merge, then two of those 4s, and so on, but merging three 1s makes a 3, then it takes three 3s to merge, then three of those 9s, and so on. To win, you must make at least four different tiles that have at least four digits. Sure, you could just win with 1024, 2048, 4096, and 8192, but where's the fun in that? How many different tiles can you discover?"],
        ["p", "Spawning tiles: 1 (100%)"]);
        displayRules("gm_rules_text", ["h2", "Powers of n"], ["h1", "XXXX"], ["p", "Any number of 1s can merge, but upon doing so, they merge into a tile that must merge with the same number of itself on each higher tier: for example, merging two 1s makes a 2, then it takes two 2s to merge, then two of those 4s, and so on, but merging three 1s makes a 3, then it takes three 3s to merge, then three of those 9s, and so on. To win, you must make at least four different tiles that have at least four digits. Sure, you could just win with 1024, 2048, 4096, and 8192, but where's the fun in that? How many different tiles can you discover?"],
        ["p", "Spawning tiles: 1 (100%)"]);
        statBoxes = [["Discovered Tiles", ["@DiscTiles", "arr_length"], false, ...[,,,], ["@GVar 0", "=", 0], [0, "@edit_gvar", 0, 1], true], ["Discovered Tiles", ["@DiscTiles"], true, false, "TileArray", "Self", ["@GVar 0", "=", 1], [0, "@edit_gvar", 0, 0], true], ["Score", "@Score"], ["Discovered Winning Tiles", ["@DiscWinning", "arr_length"], false, ...[,,,], ["@GVar 1", "=", 0], [0, "@edit_gvar", 1, 1], true], ["Discovered Winning Tiles", ["@DiscWinning"], true, false, "TileArray", "Self", ["@GVar 1", "=", 1], [0, "@edit_gvar", 1, 0], true]];
        document.getElementById("mode_vars_line").style.setProperty("display", "block");
        document.getElementById("XXXX_vars").style.setProperty("display", "flex");
    }
    else if (mode == 26) { // 2584
        // width = 4; height = 4;
        mode_vars = [0] // Controls how negatives and positives interact
        TileNumAmount = 1;
        TileTypes = [[[0], 1, "#ffffff", "#2d2b31"], [[1], 2, "#b3ffe8", "#2d2b31"], [[2], 3, "#52ffcb", "#2d2b31"], [[3], 5, "#00ff99", "#2d2b31"],
        [[4], 8, "#00c777", "#2d2b31"], [[5], 13, "#008b53", "#2d2b31"], [[6], 21, "#008b00", "#2d2b31"], [[7], 34, "#00e200", "#2d2b31"],
        [[8], 55, "#4aff4a", "#2d2b31"], [[9], 89, "#94ff94", "#2d2b31"], [[10], 144, "#8ac4ff", "#dddbe1"], [[11], 233, "#50a8ff", "#dddbe1"],
        [[12], 377, "#0180ff", "#dddbe1"], [[13], 610, "#0055a9", "#dddbe1"], [[14], 987, "#0030a9", "#dddbe1"], [[15], 1597, "#2d0087", "#dddbe1"],
        [[16], 2584, "#1a004f", "#dddbe1"], [[17], 4181, "#3d004f", "#dddbe1"], [[18], 6765, "#750099", "#dddbe1"], [[19], 10946, "#c300ff", "#dddbe1"],
        [[20], 17711, "#d85aff", "#dddbe1"], [[21], 28657, "#e591ff", "#dddbe1"],
        [true, [[((1 + Math.sqrt(5))/2), "^", ["@This 0", "+", 2]], "-", [((1 + Math.sqrt(5))/-2), "^", ["@This 0", "*", -1, "-", 2]], "/", Math.sqrt(5), "round", 1], ["@HSLA", [6.5, "*", "@This 0", "+", 157], [0.99, "^", ["@This 0", "-", 22], "*", 100], ["@This 0", "-", 21, "%", 9, "*", -1, "+", 4, "abs", "*", 10, "+", 30], 1], "#dddbe1"]];
        MergeRules = [
            [2, [["@Next 1 0", "=", 0], "&&", ["@This 0", "=", 0]], true, [[1]], 2, [false, true]],
            [2, ["@This 0", "-", 1, "=", "@Next 1 0"], false, [[["@This 0", "+", 1]]], [[((1 + Math.sqrt(5))/2), "^", ["@This 0", "+", 3]], "-", [((1 + Math.sqrt(5))/-2), "^", ["@This 0", "*", -1, "-", 3]], "/", Math.sqrt(5), "round", 1], [false, true]]
        ];
        startTileSpawns = [[[0], 85], [[1], 10], [[2], 5]];
        winConditions = [[16]];
        winRequirement = 1;
        knownMergeMaxLength = 2;
        knownMergeLookbackDistance = 0;
        document.documentElement.style.setProperty("background-image", "radial-gradient(#6637a8 0%, #fff 150%)");
        document.documentElement.style.setProperty("--background-color", "#d4caec");
        document.documentElement.style.setProperty("--grid-color", "#645f71");
        document.documentElement.style.setProperty("--tile-color", "#9f94b4");
        document.documentElement.style.setProperty("--text-color", "#2d2b31");
        displayRules("rules_text", ["h2", "Fibonacci Sequence"], ["h1", "2584"], ["p", "Merges occur between two 1s or between any tile above 1 and the tile before it. Get to the 2584 tile to win!"],
        ["p", "Spawning tiles: 1 (85%), 2 (10%), 3 (5%)"]);
        displayRules("gm_rules_text", ["h2", "Fibonacci Sequence"], ["h1", "2584"], ["p", "Merges occur between two 1s or between any tile above 1 and the tile before it. Get to the 2584 tile to win!"],
        ["p", "Spawning tiles: 1 (85%), 2 (10%), 3 (5%)"]);
        if (modifiers[13] != "None") {
            document.getElementById("mode_vars_line").style.setProperty("display", "block");
            document.getElementById("2584_vars").style.setProperty("display", "flex");
        }
    }
    else if (mode == 27) { // 2745
        // width = 4; height = 4;
        TileNumAmount = 1;
        TileTypes = [
            [[-1], 1, "#003655", "#ebd9cd"], [[0], 2, "#005b90", "#ebd9cd"], [[1], 3, "#0088d6", "#ebd9cd"], [[2], 4, "#00a2ff", "#796c64"],
            [[3], 6, "#61c5ff", "#796c64"], [[4], 9, "#a8dfff", "#796c64"], [[5], 13, "#d2eeff", "#796c64"],
            [[6], 19, "#004a00", "#ebd9cd"], [[7], 28, "#008000", "#ebd9cd"], [[8], 41, "#00c200", "#ebd9cd"], [[9], 60, "#00ff00", "#796c64"],
            [[10], 88, "#8aff8a", "#796c64"], [[11], 129, "#aeffae", "#796c64"], [[12], 189, "#d3ffd3", "#796c64"],
            [[13], 277, "#4f2900", "#ebd9cd"], [[14], 406, "#8d4900", "#ebd9cd"], [[15], 595, "#c26400", "#ebd9cd"], [[16], 872, "#ff8400", "#796c64"],
            [[17], 1278, "#ffb05c", "#796c64"], [[18], 1873, "#ffcb93", "#796c64"], [[19], 2745, "#ffdebc", "#796c64"],
            [[20], 4023, "#3f000d", "#ebd9cd"], [[21], 5896, "#6f0016", "#ebd9cd"], [[22], 8641, "#ab0022", "#ebd9cd"], [[23], 12664, "#ff0033", "#796c64"],
            [[24], 18560, "#ff4f72", "#796c64"], [[25], 27201, "#ff859e", "#796c64"], [[26], 39865, "#ffbac8", "#796c64"],
            [[27], 58425, "#2c003d", "#ebd9cd"], [[28], 85626, "#560079", "#ebd9cd"], [[29], 125491, "#8200b6", "#ebd9cd"], [[30], 183916, "#b700ff", "#796c64"],
            [[31], 269542, "#d365ff", "#796c64"], [[32], 395033, "#e39dff", "#796c64"], [[33], 578949, "#f1cfff", "#796c64"],
            [["@This 0", "+", 1, "%", 7, "=", 0], [2, "@repeat", "@This 0", "*", 1.46557123187676802666, "round", 1, "@end-repeat"], ["@HSLA", ["@This 0", "+", 1, "floor", 7, "/", 7, "*", -79, "+", 635], [0.98, "^", ["@This 0", "-", 34], "*", 100], 12.5, 1], "#ebd9cd"],
            [["@This 0", "+", 1, "%", 7, "=", 1], [2, "@repeat", "@This 0", "*", 1.46557123187676802666, "round", 1, "@end-repeat"], ["@HSLA", ["@This 0", "+", 1, "floor", 7, "/", 7, "*", -79, "+", 635], [0.98, "^", ["@This 0", "-", 34], "*", 100], 25, 1], "#ebd9cd"],
            [["@This 0", "+", 1, "%", 7, "=", 2], [2, "@repeat", "@This 0", "*", 1.46557123187676802666, "round", 1, "@end-repeat"], ["@HSLA", ["@This 0", "+", 1, "floor", 7, "/", 7, "*", -79, "+", 635], [0.98, "^", ["@This 0", "-", 34], "*", 100], 37.5, 1], "#ebd9cd"],
            [["@This 0", "+", 1, "%", 7, "=", 3], [2, "@repeat", "@This 0", "*", 1.46557123187676802666, "round", 1, "@end-repeat"], ["@HSLA", ["@This 0", "+", 1, "floor", 7, "/", 7, "*", -79, "+", 635], [0.98, "^", ["@This 0", "-", 34], "*", 100], 50, 1], "#796c64"],
            [["@This 0", "+", 1, "%", 7, "=", 4], [2, "@repeat", "@This 0", "*", 1.46557123187676802666, "round", 1, "@end-repeat"], ["@HSLA", ["@This 0", "+", 1, "floor", 7, "/", 7, "*", -79, "+", 635], [0.98, "^", ["@This 0", "-", 34], "*", 100], 65, 1], "#796c64"],
            [["@This 0", "+", 1, "%", 7, "=", 5], [2, "@repeat", "@This 0", "*", 1.46557123187676802666, "round", 1, "@end-repeat"], ["@HSLA", ["@This 0", "+", 1, "floor", 7, "/", 7, "*", -79, "+", 635], [0.98, "^", ["@This 0", "-", 34], "*", 100], 80, 1], "#796c64"],
            [["@This 0", "+", 1, "%", 7, "=", 6], [2, "@repeat", "@This 0", "*", 1.46557123187676802666, "round", 1, "@end-repeat"], ["@HSLA", ["@This 0", "+", 1, "floor", 7, "/", 7, "*", -79, "+", 635], [0.98, "^", ["@This 0", "-", 34], "*", 100], 90, 1], "#796c64"],
        ];
        MergeRules = [
            [2, [["@Next 1 0", "=", -1], "&&", ["@This 0", "=", -1]], true, [[0]], 2, [false, true]],
            [2, [["@Next 1 0", "=", -1], "&&", ["@This 0", "=", 0]], false, [[1]], 3, [false, true]],
            [2, ["@This 0", "-", 2, "=", "@Next 1 0"], false, [[["@This 0", "+", 1]]], [2, "@repeat", "@This 0", "*", 1.46557123187676802666, "round", 1, "@end-repeat"], [false, true]]
        ];
        startTileSpawns = [[[-1], 85], [[0], 10], [[1], 5]];
        winConditions = [[19]];
        winRequirement = 1;
        knownMergeMaxLength = 2;
        knownMergeLookbackDistance = 0;
        document.documentElement.style.setProperty("background-image", "radial-gradient(#ffba7d 0%, #fff 150%)");
        document.documentElement.style.setProperty("--background-color", "#fff3e6");
        document.documentElement.style.setProperty("--grid-color", "#dbc2ad");
        document.documentElement.style.setProperty("--tile-color", "#f9e1ce");
        document.documentElement.style.setProperty("--text-color", "#796c64");
        displayRules("rules_text", ["h2", "Narayana's Cows Sequence"], ["h1", "2745"], ["p", "Merges occur between two 1s, between a 1 and a 2, or between any tile above 2 and the tile two tiles before it. Get to the 2745 tile to win!"],
        ["p", "Spawning tiles: 1 (85%), 2 (10%), 3 (5%)"]);
        displayRules("gm_rules_text", ["h2", "Narayana's Cows Sequence"], ["h1", "2745"], ["p", "Merges occur between two 1s, between a 1 and a 2, or between any tile above 2 and the tile two tiles before it. Get to the 2745 tile to win!"],
        ["p", "Spawning tiles: 1 (85%), 2 (10%), 3 (5%)"]);
    }
    else if (mode == 28) { // 1705
        // width = 5; height = 5;
        TileNumAmount = 1;
        TileTypes = [[[0], 1, "#ffffff", "#2b352a"], [[1], 2, "#fff7c9", "#2b352a"], [[2], 4, "#fff098", "#2b352a"], [[3], 7, "#ffe75f", "#2b352a"],
        [[4], 13, "#ffdd1c", "#2b352a"], [[5], 24, "#cfb000", "#e5eee4"], [[6], 44, "#8e7900", "#e5eee4"], [[7], 81, "#aeffae", "#2b352a"],
        [[8], 149, "#65ff65", "#2b352a"], [[9], 274, "#00ff00", "#2b352a"], [[10], 504, "#00bc00", "#e5eee4"], [[11], 927, "#007d00", "#e5eee4"],
        [[12], 1705, "#005a00", "#e5eee4"], [[13], 3136, "#a6f5ff", "#2b352a"], [[14], 5768, "#60ecff", "#2b352a"], [[15], 10609, "#00d6f3", "#2b352a"],
        [[16], 19513, "#00b0c7", "#e5eee4"], [[17], 35890, "#008192", "#e5eee4"], [[18], 66012, "#004d57", "#e5eee4"],
        [["@This 0", "-", 1, "%", 6, "<", 3], [1, "@repeat", "@This 0", "*", 1.83928675521416113255, "round", 1, "@end-repeat"], ["@HSLA", ["@This 0", "-", 1, "floor", 6, "/", 6, "*", 79, "+", 33], [0.98, "^", ["@This 0", "-", 18], "*", 100], ["@This 0", "-", 1, "%", 6, "*", -15, "+", 80], 1], "#2b352a"],
        [["@This 0", "-", 1, "%", 6, ">=", 3], [1, "@repeat", "@This 0", "*", 1.83928675521416113255, "round", 1, "@end-repeat"], ["@HSLA", ["@This 0", "-", 1, "floor", 6, "/", 6, "*", 79, "+", 33], [0.98, "^", ["@This 0", "-", 18], "*", 100], ["@This 0", "-", 1, "%", 6, "*", -10, "+", 70], 1], "#e5eee4"]];
        MergeRules = [
            [3, [["@This 0", "-", 1, "=", "@Next 1 0"], "&&", ["@This 0", "-", 2, "=", "@Next 2 0"]], false, [[["@This 0", "+", 1]]], [1, "@repeat", ["@This 0", "+", 1], "*", 1.83928675521416113255, "round", 1, "@end-repeat"], [false, true, true]],
            [3, [["@Next 1 0", "=", 0], "&&", ["@This 0", "=", 0], "&&", ["@Next 2 0", "=", 1]], false, [[2]], 4, [false, true, true]],
            [2, [["@Next 1 0", "=", 0], "&&", ["@This 0", "=", 0], "&&", ["@NextNE -1 0", "!=", 1]], true, [[1]], 2, [false, true]],
        ];
        startTileSpawns = [[[0], 85], [[1], 12], [[2], 3]];
        winConditions = [[12]];
        winRequirement = 1;
        knownMergeMaxLength = 3;
        knownMergeLookbackDistance = 1;
        document.documentElement.style.setProperty("background-image", "radial-gradient(#009900 0%, #fff 150%)");
        document.documentElement.style.setProperty("--background-color", "#b5d4ae");
        document.documentElement.style.setProperty("--grid-color", "#7c8f79");
        document.documentElement.style.setProperty("--tile-color", "#a6c09f");
        document.documentElement.style.setProperty("--text-color", "#2b352a");
        displayRules("rules_text", ["h2", "Tribonacci Sequence"], ["h1", "1705"], ["p", "Merges occur between two 1s, between two 1s and a 2, or between any tile above 2, the tile before it, and the tile two before it. Get to the 1705 tile to win!"],
        ["p", "Spawning tiles: 1 (85%), 2 (12%), 4 (3%)"]);
        displayRules("gm_rules_text", ["h2", "Tribonacci Sequence"], ["h1", "1705"], ["p", "Merges occur between two 1s, between two 1s and a 2, or between any tile above 2, the tile before it, and the tile two before it. Get to the 1705 tile to win!"],
        ["p", "Spawning tiles: 1 (85%), 2 (12%), 4 (3%)"]);
    }
    else if (mode == 29) { // 1535, 1536, 1537
        // width = 4; height = 4;
        TileNumAmount = 2;
        TileTypes = [
            [[0, -1], 2, "#ffffff", "#742020"], [[0, 0], 3, "#cecece", "#18571a"], [[0, 1], 4, "#919191", "#171a51"],
            [[1, -1], 5, "#c561ff", "#742020"], [[1, 0], 6, "#a200ff", "#18571a"], [[1, 1], 7, "#7500b9", "#171a51"],
            [[2, -1], 11, "#6c6cff", "#742020"], [[2, 0], 12, "#0000ff", "#18571a"], [[2, 1], 13, "#0000b4", "#171a51"],
            [[3, -1], 23, "#7bdaff", "#742020"], [[3, 0], 24, "#00b7ff", "#18571a"], [[3, 1], 25, "#0084b8", "#171a51"],
            [[4, -1], 47, "#9bffff", "#742020"], [[4, 0], 48, "#00ffff", "#18571a"], [[4, 1], 49, "#00cece", "#171a51"],
            [[5, -1], 95, "#6fffb2", "#742020"], [[5, 0], 96, "#00ff77", "#18571a"], [[5, 1], 97, "#00c35b", "#171a51"],
            [[6, -1], 191, "#c0ff74", "#742020"], [[6, 0], 192, "#8cff00", "#18571a"], [[6, 1], 193, "#69bf00", "#171a51"],
            [[7, -1], 383, "#ffff8b", "#742020"], [[7, 0], 384, "#ffff00", "#18571a"], [[7, 1], 385, "#d4d400", "#171a51"],
            [[8, -1], 767, "#ffe572", "#742020"], [[8, 0], 768, "#ffd000", "#18571a"], [[8, 1], 769, "#c09d00", "#171a51"],
            [[9, -1], 1535, "#ffb765", "#742020"], [[9, 0], 1536, "#ff8800", "#18571a"], [[9, 1], 1537, "#bd6500", "#171a51"],
            [[10, -1], 3071, "#ff7e65", "#742020"], [[10, 0], 3072, "#ff2a00", "#18571a"], [[10, 1], 3073, "#9a1a00", "#171a51"],
            [[11, -1], 6143, "#ff6dca", "#742020"], [[11, 0], 6144, "#ff00a2", "#18571a"], [[11, 1], 6145, "#a20067", "#171a51"],
            [[12, -1], 12287, "#f67dff", "#742020"], [[12, 0], 12288, "#ee00ff", "#18571a"], [[12, 1], 12289, "#82008b", "#171a51"],
            [["@This 1", "=", -1], [2, "^", "@This 0", "*", 3, "-", 1], ["@HSLA", [-29, "*", "@This 0", "+", 636], [0.95, "^", ["@This 0", "-", 13], "*", 65], 70, 1], "#742020"],
            [["@This 1", "=", 0], [2, "^", "@This 0", "*", 3], ["@HSLA", [-29, "*", "@This 0", "+", 636], [0.95, "^", ["@This 0", "-", 13], "*", 65], 50, 1], "#18571a"],
            [["@This 1", "=", 1], [2, "^", "@This 0", "*", 3, "+", 1], ["@HSLA", [-29, "*", "@This 0", "+", 636], [0.95, "^", ["@This 0", "-", 13], "*", 65], 30, 1], "#171a51"]
        ];
        MergeRules = [
            [2, [["@Next 1 0", "=", "@This 0"], "&&", ["@Next 1 1", "!=", "@This 1"]], true, [[["@This 0", "+", 1], ["@This 1", "+", "@Next 1 1"]]], [2, "^", ["@This 0", "+", 1], "*", 3, "+", ["@This 1", "+", "@Next 1 1"]], [false, true]]
        ];
        startTileSpawns = [["Box", 1, [0, -1], [0, 0], [0, 1]]];
        winConditions = [[9, -1], [9, 0], [9, 1]];
        winRequirement = 1;
        knownMergeMaxLength = 2;
        knownMergeLookbackDistance = 0;
        document.documentElement.style.setProperty("background-image", "radial-gradient(#cf7a24 0%, #fff 150%)");
        document.documentElement.style.setProperty("--background-color", "#ecdccb");
        document.documentElement.style.setProperty("--grid-color", "#a68c73");
        document.documentElement.style.setProperty("--tile-color", "#c3a589");
        document.documentElement.style.setProperty("--text-color", "#46413c");
        displayRules("rules_text", ["h1", "1535, 1536, 1537"], ["p", 'The starting tiles are 2, 3, and 4, and any two different starting tiles can merge. The "second tier" of tiles is thus 5, 6, and 7, and any two different second-tier tiles can merge, meaning the third tier of tiles is 11, 12, and 13, and in general merges occur between two different tiles of the same tier. To win, make a 1535, a 1536, or a 1537; you only need to make one of them to win.'],
        ["p", "Spawning tiles: Pulls from a \"box\" that starts with one 2, one 3, and one 4, and only refills once it's empty."]);
        displayRules("gm_rules_text", ["h1", "1535, 1536, 1537"], ["p", 'The starting tiles are 2, 3, and 4, and any two different starting tiles can merge. The "second tier" of tiles is thus 5, 6, and 7, and any two different second-tier tiles can merge, meaning the third tier of tiles is 11, 12, and 13, and in general merges occur between two different tiles of the same tier. To win, make a 1535, a 1536, and a 1537; you only need to make one of them to win.'],
        ["p", "Spawning tiles: Pulls from a \"box\" that starts with one 2, one 3, and one 4, and only refills once it's empty."]);
    }
    else if (mode == 30) { // 3072
        // width = 4; height = 4;
        TileNumAmount = 1;
        TileTypes = [
            [[-1], 1, "#30cbff", "#ffffff"], [[-2], 2, "#ff5462", "#ffffff"],
            [["@This 0", "<", 24], [2, "^", "@This 0", "*", 3], ["@linear-gradient", ["@HSLA", ["@This 0", "*", -15, "+", 46], 100, 65, 1], 0, 15, "#ffffff", 15, 85, ["@HSLA", ["@This 0", "*", -15, "+", 46], 100, 65, 1], 85, 100], "#000000"],
            [true, [2, "^", "@This 0", "*", 3], ["@linear-gradient", ["@HSLA", ["@This 0", "*", -15, "+", 46], 100, [0.75, "^", ["@This 0", "floor", 24, "/", 24], "*", 65], 1], 0, 15, ["@HSLA", 0, 0, [0.75, "^", ["@This 0", "floor", 24, "/", 24], "*", 100], 1], 15, 85, ["@HSLA", ["@This 0", "*", -15, "+", 46], 100, [0.75, "^", ["@This 0", "floor", 24, "/", 24], "*", 65], 1], 85, 100], "#ffffff"],
        ];
        MergeRules = [
            [2, [["@Next 1 0", "=", -1], "&&", ["@This 0", "=", -2]], false, [[0]], 3, [false, true]],
            [2, [["@Next 1 0", "=", "@This 0"], "&&", ["@This 0", ">=", 0]], true, [[["@This 0", "+", 1]]], [2, "^", ["@This 0", "+", 1], "*", 3], [false, true]]
        ];
        startTileSpawns = [["Box", 20, [-1], 4, [-2], 4, [0], 4], [["@CalcArray", "@DiscTiles", "arr_reduce", -2, ["@if", ["@var_retain", "@Var -1", "arr_elem", 0, ">", "@Parent -2"], "2nd", "@Var -1", "@end-if"], "-", 3, "rand_int", 1, "Array"], [0, "@if", ["@DiscTiles", "arr_reduce", -2, ["@if", ["@var_retain", "@Var -1", "arr_elem", 0, ">", "@Parent -2"], "2nd", "@Var -1", "@end-if"], ">=", 4], "2nd", 1, "@end-if"]]];
        winConditions = [[10]];
        winRequirement = 1;
        knownMergeMaxLength = 2;
        knownMergeLookbackDistance = 0;
        document.documentElement.style.setProperty("background-image", "radial-gradient(#b2dbe9 0%, #fff 100%)");
        document.documentElement.style.setProperty("--background-color", "#ffffff");
        document.documentElement.style.setProperty("--grid-color", "#6cb9d3");
        document.documentElement.style.setProperty("--tile-color", "#5792a5");
        document.documentElement.style.setProperty("--text-color", "#ff5462");
        displayRules("rules_text", ["h2", "Powers of 2 Times 3"], ["h1", "3072"], ["p", "1s and 2s merge with each other, and all higher tiles merge with themselves. Get to the 3072 tile to win!"],
        ["p", "Spawning tiles: Pulls from a \"box\" containing four 1s, four 2s, and four 3s, which only refills once it's empty. However, if your highest tile is at least 48, there's a 1/21 chance for a \"bonus\" tile to spawn instead, which could be any tile from 6 to the tile that's an eighth of your highest tile."]);
        displayRules("gm_rules_text", ["h2", "Powers of 2 Times 3"], ["h1", "3072"], ["p", "1s and 2s merge with each other, and all higher tiles merge with themselves. Get to the 3072 tile to win!"],
        ["p", "Spawning tiles: Pulls from a \"box\" containing four 1s, four 2s, and four 3s, which only refills once it's empty. However, if your highest tile is at least 48, there's a 1/21 chance for a \"bonus\" tile to spawn instead, which could be any tile from 6 to the tile that's an eighth of your highest tile."],
        ["p", 'Note: This is not a full recreation of Threes!, as moves still work like they do in 2048. To get a better recreation, go to Modifiers, change "Maximum Spaces per Move" to 1, change "Visible Next Spawned Tiles" to 1, change "Tiles Spawned at the Start" to 9, and change the location of tile spawns to be only on the edge you moved away from.']);
    }
    else if (mode == 31) { // Isotopic 256
        // width = 3; height = 3;
        mode_vars = [0.75]; //Lifespan multiplier
        document.documentElement.style.setProperty("background-image", "radial-gradient(#edcc61 0% 40%, #d6ff63 90%, #fff 150%)");
        document.documentElement.style.setProperty("--background-color", "radial-gradient(#fff5da 0% 50%, #edffbb)");
        document.documentElement.style.setProperty("--grid-color", "#dcca9e");
        document.documentElement.style.setProperty("--tile-color", "#cedc9e");
        document.documentElement.style.setProperty("--text-color", "#525246");
        displayRules("rules_text", ["h1", "Isotopic 256"], ["p", "Regular 2048, but odd powers of 2 other than 2 itself (8, 32, 128, etc.) are radioactive, disappearing if they go without merging for more than 0.75x its number of turns. For aesthetic purposes, the tiles are associated with isotopes of elements with the corresponding atomic mass (though they stop making chemical sense for 256 and above; 256 should be radioactive but isn't, and higher tiles don't have real elements that are that heavy). Get to the <sup>256</sup>No tile to win!"],
        ["p", "Spawning tiles: <sup>2</sup>H (90%), <sup>4</sup>He (10%)"]);
        displayRules("gm_rules_text", ["h1", "Isotopic 256"], ["p", "Regular 2048, but odd powers of 2 other than 2 itself (8, 32, 128, etc.) are radioactive, disappearing if they go without merging for more than 0.75x its number of turns. For aesthetic purposes, the tiles are associated with isotopes of elements with the corresponding atomic mass (though they stop making chemical sense for 256 and above; 256 should be radioactive but isn't, and higher tiles don't have real elements that are that heavy). Get to the <sup>256</sup>No tile to win!"],
        ["p", "Spawning tiles: <sup>2</sup>H (90%), <sup>4</sup>He (10%)"]);
        document.getElementById("mode_vars_line").style.setProperty("display", "block");
        document.getElementById("Isotopic256_vars").style.setProperty("display", "flex");
        if (modifiers[13] == "None") {
            TileNumAmount = 2;
            TileTypes = [
                [["@This 0", "=", 1], "<sup>2</sup>H", "#f9eee3", "#776e65", "none", 3, 0],
                [["@This 0", "=", 2], "<sup>4</sup>He", "#ede0c8", "#776e65", "none", 3, 0],
                [["@This 0", "=", 3], "<sup>8</sup>Be", "#f2b179", "#f9f6f2", "none", 3, 0, ["Innerscript", "@This 1", "bottom-center", 4, 0]],
                [["@This 0", "=", 4], "<sup>16</sup>O", "#f59563", "#f9f6f2", "none", 3, 0],
                [["@This 0", "=", 5], "<sup>32</sup>P", "#f67c5f", "#f9f6f2", "none", 3, 0, ["Innerscript", "@This 1", "bottom-center", 4, 0]],
                [["@This 0", "=", 6], "<sup>64</sup>Ni", "#f65e3b", "#f9f6f2", "none", 3, 0],
                [["@This 0", "=", 7], "<sup>128</sup>Sn", "#edcf72", "#f9f6f2", "none", 3, 0, ["Innerscript", "@This 1", "bottom-center", 4, 0]],
                [["@This 0", "=", 8], "<sup>256</sup>No", "#edcc61", "#f9f6f2", "none", 3, 0],
                [["@This 0", "=", 9], "<sup>512</sup>Uss", "#edc850", "#f9f6f2", "none", 3, 0, ["Innerscript", "@This 1", "bottom-center", 4, 0]],
                [["@This 0", "=", 10], "<sup>1024</sup>Bep", "#edc53f", "#f9f6f2", "none", 3, 0],
                [["@This 0", "=", 11], "<sup>2048</sup>Qsu", "#edc22e", "#f9f6f2", "none", 3, 0, ["Innerscript", "@This 1", "bottom-center", 4, 0]],
                [["@This 0", "=", 12], "<sup>4096</sup>Sbs", "#f29eff", "#f9f6f2", "none", 3, 0],
                [["@This 0", "=", 13], "<sup>8192</sup>Uneh", "#eb75fd", "#f9f6f2", "none", 3, 0, ["Innerscript", "@This 1", "bottom-center", 4, 0]],
                [["@This 0", "=", 14], "<sup>16384</sup>Uhbu", "#e53bff", "#f9f6f2", "none", 3, 0],
                [["@This 0", "=", 15], "<sup>32768</sup>Btho", "#bd00db", "#f9f6f2", "none", 3, 0, ["Innerscript", "@This 1", "bottom-center", 4, 0]],
                [["@This 0", "=", 16], "<sup>65536</sup>Tqbh", "#770089", "#f9f6f2", "none", 3, 0],
                [["@This 0", "=", 17], "<sup>131072</sup>Qebq", "#534de8", "#f9f6f2", "none", 3, 0, ["Innerscript", "@This 1", "bottom-center", 4, 0]],
                [["@This 0", "=", 18], "<sup>262144</sup>Snqq", "#2922e1", "#f9f6f2", "none", 3, 0],
                [["@This 0", "=", 19], "<sup>524288</sup>Unnqb", "#0a05b6", "#f9f6f2", 3, 0, ["Innerscript", "@This 1", "bottom-center", 4, 0]],
                [["@This 0", "%", 2, "=", 0], ["<sup>", "str_concat", [2, "^", "@This 0"], "str_concat", "</sup>", "str_concat", [[[2, "^", "@This 0"], "+", 200, "^", 0.5, "*", 14.1421356237, "-", 200, "round", 1, "String"], ["@Literal", "n", "u", "d", "t", "q", "p", "h", "s", "o", "e"], "@end_vars", -1, "@repeat", ["@var_retain", "@Var 0", "str_length"], "+", 1, "@edit_var", 0, ["@var_retain", "@Var 0", "str_splice", "@Parent -2", 1, ["@var_retain", "@Var 1", "arr_elem", ["@var_retain", "@Var 0", "str_char", "@Parent -4", "Number"]]], "@end-repeat", "@edit_var", 0, ["@var_retain", "@Var 0", "str_splice", 0, 1, ["@var_retain", "@Var 0", "str_char", 0, "str_toUpperCase"]], "2nd", "@Var 0"]], ["@HSLA", [-15, "*", "@This 0", "+", 520], 100, [0.9, "^", ["@This 0", "-", 20], "*", 36], 1], "#f9f6f2", "none", 3, 0],
                [["@This 0", "%", 2, "=", 1], ["<sup>", "str_concat", [2, "^", "@This 0"], "str_concat", "</sup>", "str_concat", [[[2, "^", "@This 0"], "+", 200, "^", 0.5, "*", 14.1421356237, "-", 200, "round", 1, "String"], ["@Literal", "n", "u", "d", "t", "q", "p", "h", "s", "o", "e"], "@end_vars", -1, "@repeat", ["@var_retain", "@Var 0", "str_length"], "+", 1, "@edit_var", 0, ["@var_retain", "@Var 0", "str_splice", "@Parent -2", 1, ["@var_retain", "@Var 1", "arr_elem", ["@var_retain", "@Var 0", "str_char", "@Parent -4", "Number"]]], "@end-repeat", "@edit_var", 0, ["@var_retain", "@Var 0", "str_splice", 0, 1, ["@var_retain", "@Var 0", "str_char", 0, "str_toUpperCase"]], "2nd", "@Var 0"]], ["@HSLA", [-15, "*", "@This 0", "+", 520], 100, [0.9, "^", ["@This 0", "-", 20], "*", 36], 1], "#f9f6f2", "none", 3, 0, ["Innerscript", "@This 1", "bottom-center", 4, 0]]
            ];
            MergeRules = [
                [2, [["@Next 1 0", "=", "@This 0"], "&&", ["@This 0", "%", 2, "=", 1]], true, [[["@This 0", "+", 1], 1e300]], [2, "^", ["@This 0", "+", 1]], [false, true]],
                [2, [["@Next 1 0", "=", "@This 0"], "&&", ["@This 0", "%", 2, "=", 0]], true, [[["@This 0", "+", 1], [2, "^", ["@This 0", "+", 1], "*", 0.75, "round", 1]]], [2, "^", ["@This 0", "+", 1]], [false, true]],
                [0, [["@This 1", ">", 0]], true, [["@This 0", ["@This 1", "-", 1]]], 0],
                [0, [["@This 1", "<=", 0]], true, [], 0],
            ];
            startTileSpawns = [[[1, 1e300], 90], [[2, 1e300], 10]]; //JSON.stringify, which used to be used for the save codes for things like tiles, converts Infinity to null, so a number that might as well be infinity was chosen for the lifespans of stable tiles
            winConditions = [[["@This 0", "=", 8]]];
            winRequirement = 1;
            knownMergeMaxLength = 2;
            knownMergeLookbackDistance = 0;
        }
        else { // The overline above the element symbols for the negative tiles means they're antimatter
            TileNumAmount = 3;
            TileTypes = [
                [[["@This 0", "=", 1], "&&", ["@This 2", "=", 1]], "<sup>2</sup>H", "#f9eee3", "#776e65", "none", 3, 0],
                [[["@This 0", "=", 2], "&&", ["@This 2", "=", 1]], "<sup>4</sup>He", "#ede0c8", "#776e65", "none", 3, 0],
                [[["@This 0", "=", 3], "&&", ["@This 2", "=", 1]], "<sup>8</sup>Be", "#f2b179", "#f9f6f2", "none", 3, 0, ["Innerscript", "@This 1", "bottom-center", 4, 0]],
                [[["@This 0", "=", 4], "&&", ["@This 2", "=", 1]], "<sup>16</sup>O", "#f59563", "#f9f6f2", "none", 3, 0],
                [[["@This 0", "=", 5], "&&", ["@This 2", "=", 1]], "<sup>32</sup>P", "#f67c5f", "#f9f6f2", "none", 3, 0, ["Innerscript", "@This 1", "bottom-center", 4, 0]],
                [[["@This 0", "=", 6], "&&", ["@This 2", "=", 1]], "<sup>64</sup>Ni", "#f65e3b", "#f9f6f2", "none", 3, 0],
                [[["@This 0", "=", 7], "&&", ["@This 2", "=", 1]], "<sup>128</sup>Sn", "#edcf72", "#f9f6f2", "none", 3, 0, ["Innerscript", "@This 1", "bottom-center", 4, 0]],
                [[["@This 0", "=", 8], "&&", ["@This 2", "=", 1]], "<sup>256</sup>No", "#edcc61", "#f9f6f2", "none", 3, 0],
                [[["@This 0", "=", 9], "&&", ["@This 2", "=", 1]], "<sup>512</sup>Uss", "#edc850", "#f9f6f2", "none", 3, 0, ["Innerscript", "@This 1", "bottom-center", 4, 0]],
                [[["@This 0", "=", 10], "&&", ["@This 2", "=", 1]], "<sup>1024</sup>Bep", "#edc53f", "#f9f6f2", "none", 3, 0],
                [[["@This 0", "=", 11], "&&", ["@This 2", "=", 1]], "<sup>2048</sup>Qsu", "#edc22e", "#f9f6f2", "none", 3, 0, ["Innerscript", "@This 1", "bottom-center", 4, 0]],
                [[["@This 0", "=", 12], "&&", ["@This 2", "=", 1]], "<sup>4096</sup>Sbs", "#f29eff", "#f9f6f2", "none", 3, 0],
                [[["@This 0", "=", 13], "&&", ["@This 2", "=", 1]], "<sup>8192</sup>Uneh", "#eb75fd", "#f9f6f2", "none", 3, 0, ["Innerscript", "@This 1", "bottom-center", 4, 0]],
                [[["@This 0", "=", 14], "&&", ["@This 2", "=", 1]], "<sup>16384</sup>Uhbu", "#e53bff", "#f9f6f2", "none", 3, 0],
                [[["@This 0", "=", 15], "&&", ["@This 2", "=", 1]], "<sup>32768</sup>Btho", "#bd00db", "#f9f6f2", "none", 3, 0, ["Innerscript", "@This 1", "bottom-center", 4, 0]],
                [[["@This 0", "=", 16], "&&", ["@This 2", "=", 1]], "<sup>65536</sup>Tqbh", "#770089", "#f9f6f2", "none", 3, 0],
                [[["@This 0", "=", 17], "&&", ["@This 2", "=", 1]], "<sup>131072</sup>Qebq", "#534de8", "#f9f6f2", "none", 3, 0, ["Innerscript", "@This 1", "bottom-center", 4, 0]],
                [[["@This 0", "=", 18], "&&", ["@This 2", "=", 1]], "<sup>262144</sup>Snqq", "#2922e1", "#f9f6f2", "none", 3, 0],
                [[["@This 0", "=", 19], "&&", ["@This 2", "=", 1]], "<sup>524288</sup>Unnqb", "#0a05b6", "#f9f6f2", "none", 3, 0, ["Innerscript", "@This 1", "bottom-center", 4, 0]],
                [[["@This 0", "%", 2, "=", 0], "&&", ["@This 2", "=", 1]], ["<sup>", "str_concat", [2, "^", "@This 0"], "str_concat", "</sup>", "str_concat", [[[2, "^", "@This 0"], "+", 200, "^", 0.5, "*", 14.1421356237, "-", 200, "round", 1, "String"], ["@Literal", "n", "u", "d", "t", "q", "p", "h", "s", "o", "e"], "@end_vars", -1, "@repeat", ["@var_retain", "@Var 0", "str_length"], "+", 1, "@edit_var", 0, ["@var_retain", "@Var 0", "str_splice", "@Parent -2", 1, ["@var_retain", "@Var 1", "arr_elem", ["@var_retain", "@Var 0", "str_char", "@Parent -4", "Number"]]], "@end-repeat", "@edit_var", 0, ["@var_retain", "@Var 0", "str_splice", 0, 1, ["@var_retain", "@Var 0", "str_char", 0, "str_toUpperCase"]], "2nd", "@Var 0"]], ["@HSLA", [-15, "*", "@This 0", "+", 520], 100, [0.9, "^", ["@This 0", "-", 20], "*", 36], 1], "#f9f6f2", "none", 3, 0],
                [[["@This 0", "%", 2, "=", 1], "&&", ["@This 2", "=", 1]], ["<sup>", "str_concat", [2, "^", "@This 0"], "str_concat", "</sup>", "str_concat", [[[2, "^", "@This 0"], "+", 200, "^", 0.5, "*", 14.1421356237, "-", 200, "round", 1, "String"], ["@Literal", "n", "u", "d", "t", "q", "p", "h", "s", "o", "e"], "@end_vars", -1, "@repeat", ["@var_retain", "@Var 0", "str_length"], "+", 1, "@edit_var", 0, ["@var_retain", "@Var 0", "str_splice", "@Parent -2", 1, ["@var_retain", "@Var 1", "arr_elem", ["@var_retain", "@Var 0", "str_char", "@Parent -4", "Number"]]], "@end-repeat", "@edit_var", 0, ["@var_retain", "@Var 0", "str_splice", 0, 1, ["@var_retain", "@Var 0", "str_char", 0, "str_toUpperCase"]], "2nd", "@Var 0"]], ["@HSLA", [-15, "*", "@This 0", "+", 520], 100, [0.9, "^", ["@This 0", "-", 20], "*", 36], 1], "#f9f6f2", "none", 3, 0, ["Innerscript", "@This 1", "bottom-center", 4, 0]],
                [[["@This 0", "=", 1], "&&", ["@This 2", "=", -1]], "<sup>2</sup><span style='text-decoration:overline'>H</span>", "#06111c", "#88919a", "none", 3, 0],
                [[["@This 0", "=", 2], "&&", ["@This 2", "=", -1]], "<sup>4</sup><span style='text-decoration:overline'>He</span>", "#121f37", "#88919a", "none", 3, 0],
                [[["@This 0", "=", 3], "&&", ["@This 2", "=", -1]], "<sup>8</sup><span style='text-decoration:overline'>Be</span>", "#0d4e86", "#06090d", "none", 3, 0, ["Innerscript", "@This 1", "bottom-center", 4, 0]],
                [[["@This 0", "=", 4], "&&", ["@This 2", "=", -1]], "<sup>16</sup><span style='text-decoration:overline'>O</span>", "#0a6a9c", "#06090d", "none", 3, 0],
                [[["@This 0", "=", 5], "&&", ["@This 2", "=", -1]], "<sup>32</sup><span style='text-decoration:overline'>P</span>", "#0983a0", "#06090d", "none", 3, 0, ["Innerscript", "@This 1", "bottom-center", 4, 0]],
                [[["@This 0", "=", 6], "&&", ["@This 2", "=", -1]], "<sup>64</sup><span style='text-decoration:overline'>Ni</span>", "#09a1c4", "#06090d", "none", 3, 0],
                [[["@This 0", "=", 7], "&&", ["@This 2", "=", -1]], "<sup>128</sup><span style='text-decoration:overline'>Sn</span>", "#12308d", "#06090d", "none", 3, 0, ["Innerscript", "@This 1", "bottom-center", 4, 0]],
                [[["@This 0", "=", 8], "&&", ["@This 2", "=", -1]], "<sup>256</sup><span style='text-decoration:overline'>No</span>", "#12339e", "#06090d", "none", 3, 0],
                [[["@This 0", "=", 9], "&&", ["@This 2", "=", -1]], "<sup>512</sup><span style='text-decoration:overline'>Uss</span>", "#1237af", "#06090d", "none", 3, 0, ["Innerscript", "@This 1", "bottom-center", 4, 0]],
                [[["@This 0", "=", 10], "&&", ["@This 2", "=", -1]], "<sup>1024</sup><span style='text-decoration:overline'>Bep</span>", "#123ac0", "#06090d", "none", 3, 0],
                [[["@This 0", "=", 11], "&&", ["@This 2", "=", -1]], "<sup>2048</sup><span style='text-decoration:overline'>Qsu</span>", "#123dd1", "#06090d", "none", 3, 0, ["Innerscript", "@This 1", "bottom-center", 4, 0]],
                [[["@This 0", "=", 12], "&&", ["@This 2", "=", -1]], "<sup>4096</sup><span style='text-decoration:overline'>Sbs</span>", "#0d6100", "#06090d", "none", 3, 0],
                [[["@This 0", "=", 13], "&&", ["@This 2", "=", -1]], "<sup>8192</sup><span style='text-decoration:overline'>Uneh</span>", "#148a02", "#06090d", "none", 3, 0, ["Innerscript", "@This 1", "bottom-center", 4, 0]],
                [[["@This 0", "=", 14], "&&", ["@This 2", "=", -1]], "<sup>16384</sup><span style='text-decoration:overline'>Uhbu</span>", "#1ac400", "#06090d", "none", 3, 0],
                [[["@This 0", "=", 15], "&&", ["@This 2", "=", -1]], "<sup>32768</sup><span style='text-decoration:overline'>Btho</span>", "#42ff24", "#06090d", "none", 3, 0, ["Innerscript", "@This 1", "bottom-center", 4, 0]],
                [[["@This 0", "=", 16], "&&", ["@This 2", "=", -1]], "<sup>65536</sup><span style='text-decoration:overline'>Tqbh</span>", "#88ff76", "##06090d", "none", 3, 0],
                [[["@This 0", "=", 17], "&&", ["@This 2", "=", -1]], "<sup>131072</sup><span style='text-decoration:overline'>Qebq</span>", "#acb217", "#06090d", "none", 3, 0, ["Innerscript", "@This 1", "bottom-center", 4, 0]],
                [[["@This 0", "=", 18], "&&", ["@This 2", "=", -1]], "<sup>262144</sup><span style='text-decoration:overline'>Snqq</span>", "#d6dd1e", "#06090d", "none", 3, 0],
                [[["@This 0", "=", 19], "&&", ["@This 2", "=", -1]], "<sup>524288</sup><span style='text-decoration:overline'>Unnqb</span>", "#f5fa49", "#06090d", "none", 3, 0, ["@This 1", "bottom-center", 4, 0]],
                [[["@This 0", "%", 2, "=", 0], "&&", ["@This 2", "=", -1]], ["<sup>", "str_concat", [2, "^", "@This 0"], "str_concat", "</sup><span style='text-decoration:overline'>", "str_concat", [[[2, "^", "@This 0"], "+", 200, "^", 0.5, "*", 14.1421356237, "-", 200, "round", 1, "String"], ["@Literal", "n", "u", "d", "t", "q", "p", "h", "s", "o", "e"], "@end_vars", -1, "@repeat", ["@var_retain", "@Var 0", "str_length"], "+", 1, "@edit_var", 0, ["@var_retain", "@Var 0", "str_splice", "@Parent -2", 1, ["@var_retain", "@Var 1", "arr_elem", ["@var_retain", "@Var 0", "str_char", "@Parent -4", "Number"]]], "@end-repeat", "@edit_var", 0, ["@var_retain", "@Var 0", "str_splice", 0, 1, ["@var_retain", "@Var 0", "str_char", 0, "str_toUpperCase"]], "2nd", "@Var 0"], "str_concat", "</span>"], ["@HSLA", [-15, "*", "@This 0", "+", 340], 100, [100, "-", [0.9, "^", ["@This 0", "-", 20], "*", 36]], 1], "#06090d", "none", 3, 0],
                [[["@This 0", "%", 2, "=", 1], "&&", ["@This 2", "=", -1]], ["<sup>", "str_concat", [2, "^", "@This 0"], "str_concat", "</sup><span style='text-decoration:overline'>", "str_concat", [[[2, "^", "@This 0"], "+", 200, "^", 0.5, "*", 14.1421356237, "-", 200, "round", 1, "String"], ["@Literal", "n", "u", "d", "t", "q", "p", "h", "s", "o", "e"], "@end_vars", -1, "@repeat", ["@var_retain", "@Var 0", "str_length"], "+", 1, "@edit_var", 0, ["@var_retain", "@Var 0", "str_splice", "@Parent -2", 1, ["@var_retain", "@Var 1", "arr_elem", ["@var_retain", "@Var 0", "str_char", "@Parent -4", "Number"]]], "@end-repeat", "@edit_var", 0, ["@var_retain", "@Var 0", "str_splice", 0, 1, ["@var_retain", "@Var 0", "str_char", 0, "str_toUpperCase"]], "2nd", "@Var 0"], "str_concat", "</span>"], ["@HSLA", [-15, "*", "@This 0", "+", 340], 100, [100, "-", [0.9, "^", ["@This 0", "-", 20], "*", 36]], 1], "#06090d", "none", 3, 0, ["Innerscript", "@This 1", "bottom-center", 4, 0]]
            ];
            MergeRules = [
                [2, [["@Next 1 0", "=", "@This 0"], "&&", ["@This 0", "%", 2, "=", 1], "&&", ["@This 2", "=", "@Next 1 2"]], true, [[["@This 0", "+", 1], 1e300, "@This 2"]], [2, "^", ["@This 0", "+", 1]], [false, true]], //Infinity gets replaced by null in save codes, so a number that might as well be infinity will have to do for the lifespans of stable tiles
                [2, [["@Next 1 0", "=", "@This 0"], "&&", ["@This 0", "%", 2, "=", 0], "&&", ["@This 2", "=", "@Next 1 2"]], true, [[["@This 0", "+", 1], [2, "^", ["@This 0", "+", 1], "*", 0.75, "round", 1], "@This 2"]], [2, "^", ["@This 0", "+", 1]], [false, true]],
                [0, [["@This 1", ">", 0]], true, [["@This 0", ["@This 1", "-", 1], "@This 2"]], 0],
                [0, [["@This 1", "<=", 0]], true, [], 0],
            ];
            if (modifiers[13] == "Interacting") MergeRules.unshift([2, [["@Next 1 0", "=", "@This 0"], "&&", ["@This 2", "!=", "@Next 1 2"]], true, [], 0, [true, true]])
            startTileSpawns = [[[1, 1e300, 1], 90 * modifiers[22]], [[1, 1e300, -1], 90 * modifiers[23]], [[2, 1e300, 1], 10 * modifiers[22]], [[2, 1e300, -1], 10 * modifiers[23]]];
            winConditions = [[["@This 0", "=", 8]]];
            winRequirement = 2;
            knownMergeMaxLength = 2;
            knownMergeLookbackDistance = 0;
        }
    }
    else if (mode == 32) { // Bicolor 2187
        // width = 4; height = 4;
        TileNumAmount = 2;
        TileTypes = [[[0, 1], 1, "#ffffff", "#584153"], [[0, 2], 2, "#999999", "#f6ebf4"],
        [[1, 1], 3, ["@linear-gradient", "#ff3030", 0, "#ffffa2", 25, 75, "#ff3030", 100], "#584153"],
        [[1, -1], 3, ["@linear-gradient", "#3030ff", 0, "#ffffa2", 25, 75, "#3030ff", 100], "#584153"],
        [[1, 2], 6, "#e6e600", "#f6ebf4"],
        [[2, 1], 9, ["@linear-gradient", "#ff3030", 0, "#ff8181", 25, 75, "#ff3030", 100], "#584153"],
        [[2, -1], 9, ["@linear-gradient", "#3030ff", 0, "#ff8181", 25, 75, "#3030ff", 100], "#584153"],
        [[2, 2], 18, "#ff0000", "#f6ebf4"],
        [[3, 1], 27, ["@linear-gradient", "#ff3030", 0, "#ffb96f", 25, 75, "#ff3030", 100], "#584153"],
        [[3, -1], 27, ["@linear-gradient", "#3030ff", 0, "#ffb96f", 25, 75, "#3030ff", 100], "#584153"],
        [[3, 2], 54, "#ff8400", "#f6ebf4"],
        [[4, 1], 81, ["@linear-gradient", "#ff3030", 0, "#6d62ff", 25, 75, "#ff3030", 100], "#584153"],
        [[4, -1], 81, ["@linear-gradient", "#3030ff", 0, "#6d62ff", 25, 75, "#3030ff", 100], "#584153"],
        [[4, 2], 162, "#0f00e4", "#f6ebf4"],
        [[5, 1], 243, ["@linear-gradient", "#ff3030", 0, "#96ff69", 25, 75, "#ff3030", 100], "#584153"],
        [[5, -1], 243, ["@linear-gradient", "#3030ff", 0, "#96ff69", 25, 75, "#3030ff", 100], "#584153"],
        [[5, 2], 486, "#42dd00", "#f6ebf4"],
        [[6, 1], 729, ["@linear-gradient", "#ff3030", 0, "#e07bff", 25, 75, "#ff3030", 100], "#584153"],
        [[6, -1], 729, ["@linear-gradient", "#3030ff", 0, "#e07bff", 25, 75, "#3030ff", 100], "#584153"],
        [[6, 2], 1458, "#bf00fa", "#f6ebf4"],
        [[7, 1], 2187, ["@linear-gradient", "#ff3030", 0, "#ff5ae6", 25, 75, "#ff3030", 100], "#584153"],
        [[7, -1], 2187, ["@linear-gradient", "#3030ff", 0, "#ff5ae6", 25, 75, "#3030ff", 100], "#584153"],
        [[7, 2], 4374, "#d600b6", "#f6ebf4"],
        [[8, 1], 6561, ["@linear-gradient", "#ff3030", 0, "#ffda69", 25, 75, "#ff3030", 100], "#584153"],
        [[8, -1], 6561, ["@linear-gradient", "#3030ff", 0, "#ffda69", 25, 75, "#3030ff", 100], "#584153"],
        [[8, 2], 13122, "#ffbf00", "#f6ebf4"],
        [[9, 1], 19683, ["@linear-gradient", "#ff3030", 0, "#e5ff7c", 25, 75, "#ff3030", 100], "#584153"],
        [[9, -1], 19683, ["@linear-gradient", "#3030ff", 0, "#e5ff7c", 25, 75, "#3030ff", 100], "#584153"],
        [[9, 2], 39366, "#ccff00", "#f6ebf4"],
        [[10, 1], 59049, ["@linear-gradient", "#ff3030", 0, "#78fdff", 25, 75, "#ff3030", 100], "#584153"],
        [[10, -1], 59049, ["@linear-gradient", "#3030ff", 0, "#78fdff", 25, 75, "#3030ff", 100], "#584153"],
        [[10, 2], 118098, "#00d7da", "#f6ebf4"],
        [[11, 1], 177147, ["@linear-gradient", "#ff3030", 0, "#ff896e", 25, 75, "#ff3030", 100], "#584153"],
        [[11, -1], 177147, ["@linear-gradient", "#3030ff", 0, "#ff896e", 25, 75, "#3030ff", 100], "#584153"],
        [[11, 2], 354294, "#e55000", "#f6ebf4"],
        [[12, 1], 531441, ["@linear-gradient", "#ff3030", 0, "#6baeff", 25, 75, "#ff3030", 100], "#584153"],
        [[12, -1], 531441, ["@linear-gradient", "#3030ff", 0, "#6baeff", 25, 75, "#3030ff", 100], "#584153"],
        [[12, 2], 1062882, "#0073ff", "#f6ebf4"],
        [["@This 1", "=", 1], [3, "^", "@This 0"], ["@linear-gradient", "#ff3030", 0, ["@HSLA", [97, "*", "@This 0", "-", 1111], [0.9, "^", ["@This 0", "-", 12], "*", 100], 70, 1], 25, 75, "#ff3030", 100], "#584153"],
        [["@This 1", "=", -1], [3, "^", "@This 0"], ["@linear-gradient", "#3030ff", 0, ["@HSLA", [97, "*", "@This 0", "-", 1111], [0.9, "^", ["@This 0", "-", 12], "*", 100], 70, 1], 25, 75, "#3030ff", 100], "#584153"],
        [["@This 1", "=", 2], [3, "^", "@This 0", "*", 2], ["@HSLA", [97, "*", "@This 0", "-", 1111], [0.9, "^", ["@This 0", "-", 12], "*", 100], 35, 1], "#f6ebf4"]];
        MergeRules = [
            [2, [["@Next 1 0", "=", "@This 0"], "&&", ["@Next 1 1", "=", -1], "&&", ["@This 1", "=", 1]], false, [["@This 0", 2]], [3, "^", "@This 0", "*", 2], [false, true]],
            [2, [["@Next 1 0", "=", "@This 0"], "&&", ["@Next 1 1", "=", 2], "&&", ["@This 1", "abs", "=", 1]], true, [[["@This 0", "+", 1], -1]], [3, "^", ["@This 0", "+", 1]], [false, true]],
            [2, [["@Next 1 0", "=", "@This 0"], "&&", ["@Next 1 1", "abs", "=", 1], "&&", ["@This 1", "=", 2]], true, [[["@This 0", "+", 1], 1]], [3, "^", ["@This 0", "+", 1]], [false, true]],
            [2, [["@Next 1 0", "=", 0], "&&", ["@This 0", "=", 0], "&&", ["@Next 1 1", "=", 1], "&&", ["@This 1", "=", 1]], true, [[0, 2]], 2, [false, true]]
        ];
        startTileSpawns = [[[0, 1], 85], [[0, 2], 10], [[1, 1], 2.5], [[1, -1], 2.5]];
        winConditions = [[7, 1], [7, -1]];
        winRequirement = 1;
        knownMergeMaxLength = 2;
        knownMergeLookbackDistance = 0;
        document.documentElement.style.setProperty("background-image", "linear-gradient(#ff8080 0%, #ff00d9 25% 75%, #8080ff 100%)");
        document.documentElement.style.setProperty("--background-color", "linear-gradient(#ffbbbb 0%, #ff00ff 25% 75%, #bbbbff 100%)");
        document.documentElement.style.setProperty("--grid-color", "#c7a7c4");
        document.documentElement.style.setProperty("--tile-color", "#ecc2e6");
        document.documentElement.style.setProperty("--text-color", "#3c2237");
        displayRules("rules_text", ["h1", "Bicolor 2187"], ["p","2187 mode, except tiles that are powers of 3 (other than 1) come in two colors. Two tiles that are a power of three can only merge if they're opposite colors, and which color a power of three tile is depends on which of the two tiles that merged to make it was the one that collided into the other one: the resulting tile is blue if the previous power of three collided into its double, the resulting tile is red if the previous power of three's double collided into its half. Get to either 2187 tile to win!"],
        ["p", "Spawning tiles: 1 (85%), 2 (10%), Red 3 (2.5%), Blue 3 (2.5%)"]);
        displayRules("gm_rules_text", ["h1", "Bicolor 2187"], ["p","2187 mode, except tiles that are powers of 3 (other than 1) come in two colors. Two tiles that are a power of three can only merge if they're opposite colors, and which color a power of three tile is depends on which of the two tiles that merged to make it was the one that collided into the other one: the resulting tile is blue if the previous power of three collided into its double, the resulting tile is red if the previous power of three's double collided into its half. Get to either 2187 tile to win!"],
        ["p", "Spawning tiles: 1 (85%), 2 (10%), Red 3 (2.5%), Blue 3 (2.5%)"]);
    }
    else if (mode == 33) { // Harder 3125
        // width = 5; height = 5;
        TileNumAmount = 2;
        TileTypes = [[[0, 1], 1, "#ffffff", "#505246"], [[0, 3], 3, "#898989", "#f4f7e9"],
        [[1, 1], 5, "#ff9f9f", "#505246"], [[1, 3], 15, "#ff3a3a", "#f4f7e9"],
        [[2, 1], 25, "#9fa2ff", "#505246"], [[2, 3], 75, "#0d15ff", "#f4f7e9"],
        [[3, 1], 125, "#fffa9f", "#505246"], [[3, 3], 375, "#ebdf00", "#f4f7e9"],
        [[4, 1], 625, "#df9fff", "#505246"], [[4, 3], 1875, "#bc35ff", "#f4f7e9"],
        [[5, 1], 3125, "#e9ff9f", "#505246"], [[5, 3], 9375, "#c9ff16", "#f4f7e9"],
        [[6, 1], 15625, "#ff9fda", "#505246"], [[6, 3], 46875, "#ff23ab", "#f4f7e9"],
        [[7, 1], 78125, "#9fffbf", "#505246"], [[7, 3], 234375, "#0aff5c", "#f4f7e9"],
        [[8, 1], 390625, "#ffc19f", "#505246"], [[8, 3], 1171875, "#ff772e", "#f4f7e9"],
        [[9, 1], 1953125, "#9ff4ff", "#505246"], [[9, 3], 5859375, "#00e1ff", "#f4f7e9"],
        [[10, 1], 9765625, "#ffe79f", "#505246"], [[10, 3], 29296875, "#ffcd36", "#f4f7e9"],
        [[11, 1], 48828125, "#9fc2ff", "#505246"], [[11, 3], 146484375, "#1e71ff", "#f4f7e9"],
        [["@This 1", "=", 1], [5, "^", "@This 0"], ["@HSLA", [23.5, "*", "@This 0", "-", 212, "+", ["@This 0", "%", 2, "*", 156.5]], [0.95, "^", ["@This 0", "-", 12], "*", 75], 70, 1], "#505246"],
        [["@This 1", "=", 3], [5, "^", "@This 0", "*", 3], ["@HSLA", [23.5, "*", "@This 0", "-", 212, "+", ["@This 0", "%", 2, "*", 156.5]], [0.95, "^", ["@This 0", "-", 12], "*", 75], 50, 1], "#f4f7e9"],];
        MergeRules = [
            [3, [["@Next 1 0", "=", "@This 0"], "&&", ["@Next 2 0", "=", "@This 0"], "&&", ["@This 1", "=", 1], "&&", ["@Next 1 1", "=", 1], "&&", ["@Next 2 1", "=", 1]], true, [["@This 0", 3]], [5, "^", "@This 0", "*", 3], [false, true, true]],
            [3, [["@Next 1 0", "=", "@This 0"], "&&", ["@Next 2 0", "=", "@This 0"], "&&", ["@This 1", "=", 1], "&&", ["@Next 1 1", "=", 1], "&&", ["@Next 2 1", "=", 3]], false, [[["@This 0", "+", 1], 1]], [5, "^", ["@This 0", "+", 1]], [false, true, true]]
        ]
        startTileSpawns = [[[0, 1], 90], [[0, 3], 10]];
        winConditions = [[5, 1]];
        winRequirement = 1;
        knownMergeMaxLength = 3;
        knownMergeLookbackDistance = 0;
        document.documentElement.style.setProperty("background-image", "radial-gradient(#8fba00 0%, #fff 150%)");
        document.documentElement.style.setProperty("--background-color", "#dde6c4");
        document.documentElement.style.setProperty("--grid-color", "#bec59d");
        document.documentElement.style.setProperty("--tile-color", "#e0eab7");
        document.documentElement.style.setProperty("--text-color", "#3e3f36");
        displayRules("rules_text", ["h1", "Harder 3125"], ["p","Merges occur between three equal tiles that are a power of five, or between two equal tiles that are a power of five and one tile that's triple that power of 5. Get to the 3125 tile to win!"],
        ["p", "Spawning tiles: 1 (90%), 3 (10%)"]);
        displayRules("gm_rules_text", ["h1", "Harder 3125"], ["p","3125 is a little too easy, so here's a mode that makes it more challenging. Merges occur between three equal tiles that are a power of five, or between two equal tiles that are a power of five and one tile that's triple that power of 5. Get to the 3125 tile to win!"],
        ["p", "Spawning tiles: 1 (90%), 3 (10%)"]);
    }
    else if (mode == 34) { // Partial Absorb 243 (yes, I'm aware that the first few partial absorb modes aren't good, sorry)
        // width = 5; height = 5;
        TileNumAmount = 2;
        TileTypes = [[[0, 1], 1, "#ffffff", "#584153"], [[0, 2], 2, "#999999", "#f6ebf4"],
        [[1, 1], 3, "#ffffa2", "#584153"], [[1, 2], 4, "#e6e600", "#584153"], [[1, 3], 6, "#a1a100", "#f6ebf4"],
        [[2, 1], 9, "#ff8181", "#584153"], [[2, 2], 12, "#ff0000", "#584153"], [[2, 3], 18, "#9a0000", "#f6ebf4"],
        [[3, 1], 27, "#ffb96f", "#584153"], [[3, 2], 36, "#ff8400", "#584153"], [[3, 3], 54, "#994f00", "#f6ebf4"],
        [[4, 1], 81, "#6d62ff", "#584153"], [[4, 2], 108, "#1100ff", "#584153"], [[4, 3], 162, "#08007d", "#f6ebf4"],
        [[5, 1], 243, "#b8ff99", "#584153"], [[5, 2], 324, "#4dff00", "#584153"], [[5, 3], 486, "#247800", "#f6ebf4"],
        [[6, 1], 729, "#e07bff", "#584153"], [[6, 2], 972, "#c300ff", "#584153"], [[6, 3], 1458, "#690088", "#f6ebf4"],
        [[7, 1], 2187, "#ff7aeb", "#584153"], [[7, 2], 2916, "#ff00d9", "#584153"], [[7, 3], 4374, "#6c005c", "#f6ebf4"],
        [[8, 1], 6561, "#ffda69", "#584153"], [[8, 2], 8748, "#ffbf00", "#584153"], [[8, 3], 13122, "#8e6a00", "#f6ebf4"],
        [[9, 1], 19683, "#e5ff7c", "#584153"], [[9, 2], 26244, "#ccff00", "#584153"], [[9, 3], 39366, "#7e9e00", "#f6ebf4"],
        [[10, 1], 59049, "#a2fdff", "#584153"], [[10, 2], 78732, "#00fbff", "#584153"], [[10, 3], 118098, "#00aeb1", "#f6ebf4"],
        [[11, 1], 177147, "#ff896e", "#584153"], [[11, 2], 236196, "#ff5900", "#584153"], [[11, 3], 354294, "#832e00", "#f6ebf4"],
        [[12, 1], 531441, "#6baeff", "#584153"], [[12, 2], 708588, "#0073ff", "#584153"], [[12, 3], 1062882, "#003e8a", "#f6ebf4"],
        [["@This 1", "=", 1], [3, "^", "@This 0"], ["@HSLA", [97, "*", "@This 0", "-", 1111], [0.9, "^", ["@This 0", "-", 12], "*", 100], 70, 1], "#584153"],
        [["@This 1", "=", 2], [3, "^", "@This 0", "*", 4, "/", 3], ["@HSLA", [97, "*", "@This 0", "-", 1111], [0.9, "^", ["@This 0", "-", 12], "*", 100], 50, 1], "#584153"],
        [["@This 1", "=", 3], [3, "^", "@This 0", "*", 2], ["@HSLA", [97, "*", "@This 0", "-", 1111], [0.9, "^", ["@This 0", "-", 12], "*", 100], 30, 1], "#f6ebf4"]];
        MergeRules = [
            [2, [["@Next 1 0", "=", 0], "&&", ["@This 0", "=", 0], "&&", ["@Next 1 1", "=", 1], "&&", ["@This 1", "=", 1]], true, [[0, 2]], 2, [false, true]],
            [2, [["@Next 1 0", "=", 0], "&&", ["@This 0", "=", 0], "&&", ["@Next 1 1", "=", 2], "&&", ["@This 1", "=", 2]], true, [[1, 1], [0, 1]], 3, [false, false]],
            [2, [["@Next 1 0", "=", 1], "&&", ["@This 0", "=", 1], "&&", ["@Next 1 1", "=", 1], "&&", ["@This 1", "=", 1]], true, [[1, 2], [0, 2]], 4, [false, false]],
            [2, [["@Next 1 0", "=", 1], "&&", ["@This 0", "=", 1], "&&", ["@Next 1 1", "=", 2], "&&", ["@This 1", "=", 2]], true, [[1, 3], [0, 2]], 6, [false, false]],
            [2, [["@Next 1 0", "=", "@This 0"], "&&", ["@This 0", ">", 1], "&&", ["@Next 1 1", "=", 1], "&&", ["@This 1", "=", 1]], true, [["@This 0", 2], [["@This 0", "-", 1], 3]], [3, "^", "@This 0", "*", 4, "/", 3], [false, false]],
            [2, [["@Next 1 0", "=", "@This 0"], "&&", ["@This 0", ">", 1], "&&", ["@Next 1 1", "=", 2], "&&", ["@This 1", "=", 2]], true, [["@This 0", 3], [["@This 0", "-", 1], 3]], [3, "^", "@This 0", "*", 2], [false, false]],
            [2, [["@Next 1 0", "=", "@This 0"], "&&", ["@This 0", ">", 0], "&&", ["@Next 1 1", "=", 3], "&&", ["@This 1", "=", 3]], true, [[["@This 0", "+", 1], 1], ["@This 0", 1]], [3, "^", "@This 0", "*", 3], [false, false]],
        ];
        startTileSpawns = [[[0, 1], 85], [[0, 2], 10], [[1, 1], 5]];
        winConditions = [[5, 1]];
        winRequirement = 1;
        knownMergeMaxLength = 2;
        knownMergeLookbackDistance = 0;
        document.documentElement.style.setProperty("background-image", "radial-gradient(#ff00d9 0%, #000 150%)");
        document.documentElement.style.setProperty("--background-color", "linear-gradient( #ffdaf9, #b689af)");
        document.documentElement.style.setProperty("--grid-color", "#c7a7c4");
        document.documentElement.style.setProperty("--tile-color", "#ecc2e6");
        document.documentElement.style.setProperty("--text-color", "#3c2237");
        displayRules("rules_text", ["h1", "Partial Absorb 243"], ["p","Merges occur between two tiles that are the same number. If those are two 1s, they will merge into a 2 as normal, but higher tiles don't merge completely. When two even numbers merge, only half of the colliding tile is absorbed into the result: for example, two 2s merge into a 3 and a 1. If the merging tiles aren't even, they must be a power of three, in which case only a third of the colliding tile is merged into the result: for example, two 3s merge into a 4 and a 2. Get to the 243 tile to win!"],
        ["p", "Spawning tiles: 1 (85%), 2 (10%), 3 (5%)"]);
        displayRules("gm_rules_text", ["h1", "Partial Absorb 243"], ["p","Merges occur between two tiles that are the same number. If those are two 1s, they will merge into a 2 as normal, but higher tiles don't merge completely. When two even numbers merge, only half of the colliding tile is absorbed into the result: for example, two 2s merge into a 3 and a 1. If the merging tiles aren't even, they must be a power of three, in which case only a third of the colliding tile is merged into the result: for example, two 3s merge into a 4 and a 2. Get to the 243 tile to win!"],
        ["p", "Spawning tiles: 1 (85%), 2 (10%), 3 (5%)"]);
    }
    else if (mode == 35) { // Partial Absorb 255
        // width = 6; height = 6;
        TileNumAmount = 1;
        TileTypes = [[[1], 1, "#ffffff", "#746577"], [[2], 3, "#d8ffb6", "#746577"], [[3], 7, "#a7ff5a", "#746577"],
        [[4], 15, "#77ff00", "#746577"], [[5], 31, "#00ff33", "#746577"], [[6], 63, "#00ff9d", "#746577"], [[7], 127, "#00ffd9", "#746577"],
        [[8], 255, "#dba6ff", "#f5eff7"], [[9], 511, "#c671ff", "#f5eff7"], [[10], 1023, "#b23eff", "#f5eff7"], [[11], 2047, "#9900ff", "#f5eff7"],
        [[12], 4095, "#ff9ed0", "#f5eff7"], [[13], 8191, "#ff62b3", "#f5eff7"], [[14], 16383, "#ff2b99", "#f5eff7"], [[15], 32767, "#e90079", "#f5eff7"],
        [[16], 65535, "#9d0051", "#f5eff7"], [[17], 131071, "#ff7b4f", "#f5eff7"], [[18], 262143, "#ff4000", "#f5eff7"], [[19], 524287, "#bf3000", "#f5eff7"],
        [true, [2, "^", "@This 0", "-", 1], ["@HSLA", [15, "*", "@This 0", "-", 265], 100, [0.9, "^", ["@This 0", "-", 20], "*", 36], 1], "#f5eff7"]];
        MergeRules = [
            [3, [["@Next 1 0", "=", 1], "&&", ["@Next 2 0", "=", 1], "&&", ["@This 0", "=", 1]], true, [[2]], 3, [false, true, true]],
            [3, [["@Next 1 0", "=", "@This 0"], "&&", ["@Next 2 0", "=", "@This 0"], "&&", ["@This 0", ">", 1]], true, [[["@This 0", "+", 1]], [["@This 0", "-", 1]], [["@This 0", "-", 1]]], [2, "^", ["@This 0", "+", 1], "-", 1], [false, false, false]]
        ];
        startTileSpawns = [[[1], 95], [[2], 5]];
        winConditions = [[8]];
        winRequirement = 1;
        knownMergeMaxLength = 3;
        knownMergeLookbackDistance = 0;
        document.documentElement.style.setProperty("background-image", "radial-gradient(#9900ff 0%, #000 150%)");
        document.documentElement.style.setProperty("--background-color", "linear-gradient(#f1daff, #b59cc4)");
        document.documentElement.style.setProperty("--grid-color", "#bca7c7");
        document.documentElement.style.setProperty("--tile-color", "#dac2ec");
        document.documentElement.style.setProperty("--text-color", "#4e4652");
        displayRules("rules_text", ["h1", "Partial Absorb 255"], ["p", "Merges occur between three equal tiles. Three 1s will merge into a single 3, but for higher tiles, the result tile will only absorb 0.5 more than half of each of the other two tiles, meaning the result tile becomes the next tile while the other two tiles become the previous tile. Get to the 255 tile to win!"],
        ["p", "Spawning tiles: 1 (95%), 3 (5%)"]);
        displayRules("gm_rules_text", ["h1", "Partial Absorb 255"], ["p", "Merges occur between three equal tiles. Three 1s will merge into a single 3, but for higher tiles, the result tile will only absorb 0.5 more than half of each of the other two tiles, meaning the result tile becomes the next tile while the other two tiles become the previous tile. Get to the 255 tile to win!"],
        ["p", "Spawning tiles: 1 (95%), 3 (5%)"]);
    }
    else if (mode == 36) { // 1280
        // width = 8; height = 8;
        TileNumAmount = 2;
        TileTypes = [
            [[0, 2], 2, "#79ff94", "#3b3338"], [[0, 3], 3, "#00ff33", "#3b3338"], [[0, 5], 5, "#00a120", "#f1e1eb"],
            [[1, 2], 4, "#c7ff6e", "#3b3338"], [[1, 3], 6, "#9dff00", "#3b3338"], [[1, 5], 10, "#619e00", "#f1e1eb"],
            [[2, 2], 8, "#f8ff7b", "#3b3338"], [[2, 3], 12, "#f2ff00", "#3b3338"], [[2, 5], 20, "#9da500", "#f1e1eb"],
            [[3, 2], 16, "#ffef77", "#3b3338"], [[3, 3], 24, "#ffe100", "#3b3338"], [[3, 5], 40, "#ad9900", "#f1e1eb"],
            [[4, 2], 32, "#ffd16e", "#3b3338"], [[4, 3], 48, "#ffae00", "#3b3338"], [[4, 5], 80, "#9e6c00", "#f1e1eb"],
            [[5, 2], 64, "#ffae67", "#3b3338"], [[5, 3], 96, "#ff7700", "#3b3338"], [[5, 5], 160, "#a34c00", "#f1e1eb"],
            [[6, 2], 128, "#ff7d55", "#3b3338"], [[6, 3], 192, "#ff3c00", "#3b3338"], [[6, 5], 320, "#9f2500", "#f1e1eb"],
            [[7, 2], 256, "#ff5e7b", "#3b3338"], [[7, 3], 384, "#ff002f", "#3b3338"], [[7, 5], 640, "#9e001d", "#f1e1eb"],
            [[8, 2], 512, "#ff5fc2", "#3b3338"], [[8, 3], 768, "#ff009d", "#3b3338"], [[8, 5], 1280, "#a30065", "#f1e1eb"],
            [[9, 2], 1024, "#ff85ff", "#3b3338"], [[9, 3], 1536, "#ff00ff", "#3b3338"], [[9, 5], 2560, "#a200a2", "#f1e1eb"],
            [[10, 2], 2048, "#e476ff", "#3b3338"], [[10, 3], 3072, "#cc00ff", "#3b3338"], [[10, 5], 5120, "#8200a2", "#f1e1eb"],
            [[11, 2], 4096, "#a35cff", "#3b3338"], [[11, 3], 6144, "#6f00ff", "#3b3338"], [[11, 5], 10240, "#45009f", "#f1e1eb"],
            [[12, 2], 8192, "#6e6eff", "#3b3338"], [[12, 3], 12288, "#0000ff", "#3b3338"], [[12, 5], 20480, "#00008f", "#f1e1eb"],
            [[13, 2], 16384, "#5a9fff", "#3b3338"], [[13, 3], 24576, "#006aff", "#3b3338"], [[13, 5], 40960, "#0046a9", "#f1e1eb"],
            [[14, 2], 32768, "#79d5ff", "#3b3338"], [[14, 3], 49152, "#00aeff", "#3b3338"], [[14, 5], 81920, "#006d9f", "#f1e1eb"],
            [[15, 2], 65536, "#8af5ff", "#3b3338"], [[15, 3], 98304, "#00eaff", "#3b3338"], [[15, 5], 163840, "#009ba9", "#f1e1eb"],
            [[16, 2], 131072, "#90fff0", "#3b3338"], [[16, 3], 196608, "#00ffdd", "#3b3338"], [[16, 5], 327680, "#00a993", "#f1e1eb"],
            [["@This 1", "=", 2], [2, "^", "@This 0", "*", 2], ["@HSLA", [-21.5, "*", "@This 0", "+", 505.5], [0.985, "^", ["@This 0", "-", 17], "*", 70], 70, 1], "#3b3338"],
            [["@This 1", "=", 3], [2, "^", "@This 0", "*", 3], ["@HSLA", [-21.5, "*", "@This 0", "+", 505.5], [0.985, "^", ["@This 0", "-", 17], "*", 70], 50, 1], "#3b3338"],
            [["@This 1", "=", 5], [2, "^", "@This 0", "*", 5], ["@HSLA", [-21.5, "*", "@This 0", "+", 505.5], [0.985, "^", ["@This 0", "-", 17], "*", 70], 30, 1], "#f1e1eb"]
        ];
        MergeRules = [
            [3, [["@Next 1 0", "=", "@This 0"], "&&", ["@Next 2 0", "=", "@This 0"], "&&", ["@Next 1 1", "=", 2], "&&", ["@Next 2 1", "=", 2], "&&", ["@This 1", "=", 2]], true, [["@This 0", 3], ["@This 0", 3]], [2, "^", "@This 0", "*", 6], [false, false, true]],
            [3, [["@Next 1 0", "=", "@This 0"], "&&", ["@Next 2 0", "=", "@This 0"], "&&", ["@Next 1 1", "=", 3], "&&", ["@Next 2 1", "=", 3], "&&", ["@This 1", "=", 3]], true, [["@This 0", 5], [["@This 0", "+", 1], 2]], [2, "^", "@This 0", "*", 9], [false, false, true]],
            [3, [["@Next 1 0", "=", "@This 0"], "&&", ["@Next 2 0", "=", "@This 0"], "&&", ["@Next 1 1", "=", 5], "&&", ["@Next 2 1", "=", 5], "&&", ["@This 1", "=", 5]], true, [[["@This 0", "+", 2], 3], ["@This 0", 3]], [2, "^", "@This 0", "*", 15], [false, false, true]],
        ]
        startTileSpawns = [[[0, 2], 85], [[0, 3], 15]];
        winConditions = [[8, 5]];
        winRequirement = 1;
        knownMergeMaxLength = 3;
        knownMergeLookbackDistance = 0;
        document.documentElement.style.setProperty("background-image", "radial-gradient(#9a005f 0%, #fff 150%)");
        document.documentElement.style.setProperty("--background-color", "#c0a3b4");
        document.documentElement.style.setProperty("--grid-color", "#877280");
        document.documentElement.style.setProperty("--tile-color", "#b799ab");
        document.documentElement.style.setProperty("--text-color", "#3b3338");
        displayRules("rules_text", ["h1", "1280"], ["p","Merges occur between three tiles that are the same number. If these three tiles are a power of two, then they merge into two tiles that are each 1.5 times that power of two. If these three tiles are triple a power of two, then they merge into a tile that's 5 times that power of two and a tile that's 4 times that power of two. If these three tiles are quintuple a power of two, then they merge into a tile that's 12 times that power of two and a tile that's 3 times that power of two. Get to the 1280 tile to win!"],
        ["p", "Spawning tiles: 2 (85%), 3 (15%)"]);
        displayRules("gm_rules_text", ["h1", "1280"], ["p","Merges occur between three tiles that are the same number. If these three tiles are a power of two, then they merge into two tiles that are each 1.5 times that power of two. If these three tiles are triple a power of two, then they merge into a tile that's 5 times that power of two and a tile that's 4 times that power of two. If these three tiles are quintuple a power of two, then they merge into a tile that's 12 times that power of two and a tile that's 3 times that power of two. Get to the 1280 tile to win!"],
        ["p", "Spawning tiles: 2 (85%), 3 (15%)"]);
    }
    else if (mode == 37) { // 2216.8378200531005859375
        // width = 5; height = 5;
        TileNumAmount = 2;
        TileTypes = [
            [["Div2", "@Signless"], "&#247;2", ["@linear-gradient", "#cccccc", "#444444"], "#765c8f"],
            [[0, 1], 1, "#ffffff", "#3f3d32"], [[0, 2], 0.5, "#999999", "#625b2f"],
            [[1, 1], 1.5, "#b5faff", "#3f3d32"], [[1, 2], 0.75, "#cfe1e2", "#625b2f"],
            [[2, 1], 2.25, "#76f6ff", "#3f3d32"], [[2, 2], 1.125, "#98d8dd", "#625b2f"],
            [[3, 1], 1.5**3, "#00eeff", "#3f3d32"], [[3, 2], 1.5**3/2, "#40b7bf", "#625b2f"],
            [[4, 1], 1.5**4, "#00c3ff", "#3f3d32"], [[4, 2], 1.5**4/2, "#40a2bf", "#625b2f"],
            [[5, 1], 1.5**5, "#0099ff", "#3f3d32"], [[5, 2], 1.5**5/2, "#408cbf", "#625b2f"],
            [[6, 1], 1.5**6, "#0055ff", "#3f3d32"], [[6, 2], 1.5**6/2, "#406abf", "#625b2f"],
            [[7, 1], 1.5**7, "#0000ff", "#3f3d32"], [[7, 2], 1.5**7/2, "#4040bf", "#625b2f"],
            [[8, 1], 1.5**8, "#ffa2ba", "#3f3d32"], [[8, 2], 1.5**8/2, "#e8bac6", "#625b2f"],
            [[9, 1], 1.5**9, "#ff799a", "#3f3d32"], [[9, 2], 1.5**9/2, "#de9cac", "#625b2f"],
            [[10, 1], 1.5**10, "#ff547e", "#3f3d32"], [[10, 2], 1.5**10/2, "#d47d93", "#625b2f"],
            [[11, 1], 1.5**11, "#ff2d62", "#3f3d32"], [[11, 2], 1.5**11/2, "#cb627c", "#625b2f"],
            [[12, 1], 1.5**12, "#ff0040", "#eeebda"], [[12, 2], 1.5**12/2, "#bf4060", "#e3dbaf"],
            [[13, 1], 1.5**13, "#c20031", "#eeebda"], [[13, 2], 1.5**13/2, "#913049", "#e3dbaf"],
            [[14, 1], 1.5**14, "#ff9f63", "#eeebda"], [[14, 2], 1.5**14/2, "#d7a788", "#e3dbaf"],
            [[15, 1], 1.5**15, "#ff8132", "#eeebda"], [[15, 2], 1.5**15/2, "#cc8d66", "#e3dbaf"],
            [[16, 1], 1.5**16, "#ff6200", "#eeebda"], [[16, 2], 1.5**16/2, "#bf7140", "#e3dbaf"],
            [[17, 1], 1.5**17, "#ff9900", "#eeebda"], [[17, 2], 1.5**17/2, "#bf8c40", "#e3dbaf"],
            [[18, 1], 1.5**18, "#ffc400", "#eeebda"], [[18, 2], 1.5**18/2, "#bfa240", "#e3dbaf"],
            [[19, 1], 1.5**19, "#c49600", "#eeebda"], [[19, 2], 1.5**19/2, "#917b30", "#e3dbaf"],
            [[20, 1], 1.5**20, "#947100", "#eeebda"], [[20, 2], 1.5**20/2, "#6f5e25", "#e3dbaf"],
            [[21, 1], 1.5**21, "#634c00", "#eeebda"], [[21, 2], 1.5**21/2, "#493d18", "#e3dbaf"],
            [["@This 1", "=", 1], [1.5, "^", "@This 0"], ["@HSLA", [13, "*", "@This 0", "-", 151], 100, [0.95, "^", ["@This 0", "-", 21], "*", 50], 1], "#eeebda"],
            [["@This 1", "=", 2], [1.5, "^", "@This 0", "/", 2], ["@HSLA", [13, "*", "@This 0", "-", 151], 50, [0.95, "^", ["@This 0", "-", 21], "*", 50], 1], "#e3dbaf"],
        ];
        MergeRules = [
            [2, [["@Next 1 0", "=", "@This 0"], "&&", ["@This 1", "=", 1], "&&", ["@Next 1 1", "=", 1]], true, [[["@This 0", "+", 1], 1], ["@This 0", 2]], [1.5, "^", "@This 0", "*", 1.5], [false, false]],
            [2, [["@Next 1 0", "=", "@This 0"], "&&", ["@This 1", "=", 2], "&&", ["@Next 1 1", "=", 2]], true, [["@This 0", 1]], [1.5, "^", "@This 0"], [false, true]]
        ];
        startTileSpawns = [[[0, 1], 80], [[0, 2], 10], [[1, 1], 10]];
        winConditions = [[19, 1]];
        winRequirement = 1;
        mode_vars = [1, 0]; // Which of the three versions of this mode are we in? Second entry controls allowed merges in the 1+1=1.5+0.5 version.
        knownMergeMaxLength = 2;
        knownMergeLookbackDistance = 0;
        document.documentElement.style.setProperty("background-image", "radial-gradient(#af8c00 0%, #fff 150%)");
        document.documentElement.style.setProperty("--background-color", "#dfd1ac");
        document.documentElement.style.setProperty("--grid-color", "#a59772");
        document.documentElement.style.setProperty("--tile-color", "#bba66a");
        document.documentElement.style.setProperty("--text-color", "#3f3d32");
        displayRules("rules_text", ["h2", "Powers of 1.5"], ["h1", "2216.8378200531005859375"], ["p","Merges occur between two tiles that are the same number. Tiles that are a power of 1.5 will only merge partially, with only half of the colliding tile absorbed into the result, so two 1s merge into a 1.5 and a 0.5, while two 1.5s merge into a 2.25 and a 0.75. If the tiles are not powers of 1.5, they merge entirely, so two 0.5s merge into a 1. Get to the 2216.838 (1.5<sup>19</sup>) tile to win!"],
        ["p", "Spawning tiles: 1 (80%), 0.5 (10%), 1.5 (10%)"]);
        displayRules("gm_rules_text", ["h2", "Powers of 1.5"], ["h1", "2216.8378200531005859375"], ["p","Merges occur between two tiles that are the same number. Tiles that are a power of 1.5 will only merge partially, with only half of the colliding tile absorbed into the result, so two 1s merge into a 1.5 and a 0.5, while two 1.5s merge into a 2.25 and a 0.75. If the tiles are not powers of 1.5, they merge entirely, so two 0.5s merge into a 1. Get to the 2216.838 (1.5<sup>19</sup>) tile to win!"],
        ["p", "Spawning tiles: 1 (80%), 0.5 (10%), 1.5 (10%)"]);
        document.getElementById("mode_vars_line").style.setProperty("display", "block");
        document.getElementById("ThreeHalves_vars").style.setProperty("display", "flex");
    }
    else if (mode == 38) { // 180
        // width = 7; height = 7;
        mode_vars = [0, 0, 6]; // For the first entry, 0 means merges are between 2, 3 or 5 of the same tile, 1 allows any prime merge length, and 2 allows any merge length. The second entry controls the random goals, and the third entry is the minimum of the first random goal.
        start_game_vars = [2n, 0, false, 0, 0, 6, 0] // The first entry is the current random goal, the second entry is the amount of random goals met so far, the third entry is whether a random goal has been met this turn, the fourth and fifth entries are used to randomize the random goals, and the sixth entry is the minimum of the first random goal. Seventh entry controls the display of Discovered Tiles.
        TileNumAmount = 3;
        TileTypes = [
            [[0, 0, 0], 1, "#000000", "#ffffff"],
            [[["@This 0", "=", "@This 1"], "&&", ["@This 1", "=", "@This 2"]], [[2, "^", "@This 0"], "*", [3, "^", "@This 1"], "*", [5, "^", "@This 2"]], ["@HSVA", 0, 0, [0.85, "^", ["@This 0", "-", 1], "*", 100], 1], ["@HSVA", 0, 0, ["@This 0", "*", 100, "-", 500], 1]],
            [[["@This 0", ">=", "@This 2"], "&&", ["@This 1", ">=", "@This 2"]], [[2, "^", "@This 0"], "*", [3, "^", "@This 1"], "*", [5, "^", "@This 2"]], ["@HSVA", [["@This 1", "-", "@This 2"], "/", ["@This 2", "*", -2, "+", "@This 0", "+", "@This 1"], "*", 120], [0.7, "^", "@This 2", "*", 100], [0.85, "^", [["@This 0", "-", "@This 2"], "gcd", ["@This 1", "-", "@This 2"], "-", 1], "*", 100], 1], ["@HSVA", 0, 0, [[["@This 0", "-", "@This 2"], "gcd", ["@This 1", "-", "@This 2"]], "*", 100, "-", 500], 1]],
            [[["@This 1", ">=", "@This 0"], "&&", ["@This 2", ">=", "@This 0"]], [[2, "^", "@This 0"], "*", [3, "^", "@This 1"], "*", [5, "^", "@This 2"]], ["@HSVA", [["@This 2", "-", "@This 0"], "/", ["@This 0", "*", -2, "+", "@This 1", "+", "@This 2"], "*", 120, "+", 120], [0.7, "^", "@This 0", "*", 100], [0.85, "^", [["@This 1", "-", "@This 0"], "gcd", ["@This 2", "-", "@This 0"], "-", 1], "*", 100], 1], ["@HSVA", 0, 0, [[["@This 1", "-", "@This 0"], "gcd", ["@This 2", "-", "@This 0"]], "*", 100, "-", 500], 1]],
            [[["@This 0", ">=", "@This 1"], "&&", ["@This 2", ">=", "@This 1"]], [[2, "^", "@This 0"], "*", [3, "^", "@This 1"], "*", [5, "^", "@This 2"]], ["@HSVA", [["@This 0", "-", "@This 1"], "/", ["@This 1", "*", -2, "+", "@This 0", "+", "@This 2"], "*", 120, "+", 240], [0.7, "^", "@This 1", "*", 100], [0.85, "^", [["@This 0", "-", "@This 1"], "gcd", ["@This 2", "-", "@This 1"], "-", 1], "*", 100], 1], ["@HSVA", 0, 0, [[["@This 0", "-", "@This 1"], "gcd", ["@This 2", "-", "@This 1"]], "*", 100, "-", 500], 1]],
        ];
        MergeRules = [
            [5, [[["@NextNE -1 0", "!=", "@This 0"], "||", ["@NextNE -1 1", "!=", "@This 1"], "||", ["@NextNE -1 2", "!=", "@This 2"]], "&&", [["@Next 5 0", "!=", "@This 0"], "||", ["@Next 5 1", "!=", "@This 1"], "||", ["@Next 5 2", "!=", "@This 2"]], "&&", ["@Next 1 0", "=", "@This 0"], "&&", ["@Next 1 1", "=", "@This 1"], "&&", ["@Next 1 2", "=", "@This 2"], "&&", ["@Next 2 0", "=", "@This 0"], "&&", ["@Next 2 1", "=", "@This 1"], "&&", ["@Next 2 2", "=", "@This 2"], "&&", ["@Next 3 0", "=", "@This 0"], "&&", ["@Next 3 1", "=", "@This 1"], "&&", ["@Next 3 2", "=", "@This 2"], "&&", ["@Next 4 0", "=", "@This 0"], "&&", ["@Next 4 1", "=", "@This 1"], "&&", ["@Next 4 2", "=", "@This 2"]], true, [["@This 0", "@This 1", ["@This 2", "+", 1]]], [[2, "^", "@This 0"], "*", [3, "^", "@This 1"], "*", [5, "^", "@This 2"], "*", 5], [false, true, true, true, true]],
            [3, [[["@NextNE -1 0", "!=", "@This 0"], "||", ["@NextNE -1 1", "!=", "@This 1"], "||", ["@NextNE -1 2", "!=", "@This 2"]], "&&", [["@Next 3 0", "!=", "@This 0"], "||", ["@Next 3 1", "!=", "@This 1"], "||", ["@Next 3 2", "!=", "@This 2"]], "&&", ["@Next 1 0", "=", "@This 0"], "&&", ["@Next 1 1", "=", "@This 1"], "&&", ["@Next 1 2", "=", "@This 2"], "&&", ["@Next 2 0", "=", "@This 0"], "&&", ["@Next 2 1", "=", "@This 1"], "&&", ["@Next 2 2", "=", "@This 2"]], true, [["@This 0", ["@This 1", "+", 1], "@This 2"]], [[2, "^", "@This 0"], "*", [3, "^", "@This 1"], "*", [5, "^", "@This 2"], "*", 3], [false, true, true]],
            [2, [[["@NextNE -1 0", "!=", "@This 0"], "||", ["@NextNE -1 1", "!=", "@This 1"], "||", ["@NextNE -1 2", "!=", "@This 2"]], "&&", [["@Next 2 0", "!=", "@This 0"], "||", ["@Next 2 1", "!=", "@This 1"], "||", ["@Next 2 2", "!=", "@This 2"]], "&&", ["@Next 1 0", "=", "@This 0"], "&&", ["@Next 1 1", "=", "@This 1"], "&&", ["@Next 1 2", "=", "@This 2"]], true, [[["@This 0", "+", 1], "@This 1", "@This 2"]], [[2, "^", "@This 0"], "*", [3, "^", "@This 1"], "*", [5, "^", "@This 2"], "*", 2], [false, true]],
        ];
        startTileSpawns = [[[0, 0, 0], 100]];
        winConditions = [[2, 2, 1]];
        winRequirement = 1;
        knownMergeMaxLength = 6;
        knownMergeLookbackDistance = 1;
        document.documentElement.style.setProperty("background-image", "radial-gradient(#e5e55b 0%, #fff 100%)");
        document.documentElement.style.setProperty("--background-color", "#fffdf1");
        document.documentElement.style.setProperty("--grid-color", "#a8a8a8");
        document.documentElement.style.setProperty("--tile-color", "#ece0c2");
        document.documentElement.style.setProperty("--text-color", "#484848");
        displayRules("rules_text", ["h2", "5-Smooth Supermerging"], ["h1", "180"], ["p", "Merges occur between exactly two, three, or five tiles of the same number - note that a line of four, six, etc. of the same tile will not merge! Get to the 180 tile to win, or see how many different tiles you can discover!"],
        ["p", "Spawning tiles: 1 (100%)"]);
        displayRules("gm_rules_text", ["h2", "5-Smooth Supermerging"], ["h1", "180"], ["p", "Merges occur between exactly two, three, or five tiles of the same number - note that a line of four, six, etc. of the same tile will not merge! Get to the 180 tile to win, or see how many different tiles you can discover!"],
        ["p", "Spawning tiles: 1 (100%)"]);
        statBoxes = [["Discovered Tiles", ["@DiscTiles", "arr_length"], false, ...[,,,], ["@GVar 6", "=", 0], [0, "@edit_gvar", 6, 1], true], ["Discovered Tiles", ["@DiscTiles"], true, false, "TileArray", "Self", ["@GVar 6", "=", 1], [0, "@edit_gvar", 6, 0], true], ["Score", "@Score"]];
        document.getElementById("mode_vars_line").style.setProperty("display", "block");
        document.getElementById("180_vars").style.setProperty("display", "flex");
    }
    else if (mode == 39) { // 2592
        // width = 6; height = 6;
        TileNumAmount = 2;
        mode_vars = [0, 0, 4]; // The first entry controls when the merge rules switch, the second entry controls the random goals, and the third entry is the minimum of the first random goal.
        start_game_vars = [[0, 0], 0, false, 0, 4, 0] // The first entry is the current random goal, the second entry is the amount of random goals met so far, the third entry is whether a random goal has been met this turn, the fourth entry is a random number used to randomize the random goals, and the fifth entry is the minimum of the first random goal. Sixth entry controls the display of Discovered Tiles.
        TileTypes = [[true, [[2, "^", "@This 0"], "*", [3, "^", "@This 1"]], ["@HSVA", [["@This 0", "%", 8, "-", 3.5, "abs", "*", -15], "+", ["@This 1", "*", 149], "+", 300], [0.75, "^", ["@This 1", "floor", 5, "/", 5], "*", 100], [0.8, "^", ["@This 0", "floor", 4, "/", 4], "*", 100], 1], "#ffffff"]];
        MergeRules = [
            [3, [["@Next 1 0", "=", "@This 0"], "&&", ["@Next 1 1", "=", "@This 1"], "&&", ["@Next 2 0", "=", "@This 0"], "&&", ["@Next 2 1", "=", "@This 1"], "&&", ["@Moves", "%", 2, "=", 1]], true, [["@This 0", ["@This 1", "+", 1]]], [[2, "^", "@This 0"], "*", [3, "^", "@This 1"], "*", 3], [false, true, true]],
            [2, [["@Next 1 0", "=", "@This 0"], "&&", ["@Next 1 1", "=", "@This 1"], "&&", ["@Moves", "%", 2, "=", 0]], true, [[["@This 0", "+", 1], "@This 1"]], [[2, "^", "@This 0"], "*", [3, "^", "@This 1"], "*", 2], [false, true]]
        ]
        startTileSpawns = [[[0, 0], 90], [[1, 0], 5], [[0, 1], 5]];
        winConditions = [[5, 4]];
        winRequirement = 1;
        mergeResultKnownLevel = 0;
        document.documentElement.style.setProperty("background-image", "radial-gradient(#00a068 0%, #fff 150%)");
        document.documentElement.style.setProperty("--background-color", "#c3e3d6");
        document.documentElement.style.setProperty("--grid-color", "#7eaa9d");
        document.documentElement.style.setProperty("--tile-color", "#7bd0b7");
        document.documentElement.style.setProperty("--text-color", "#282f2b");
        displayRules("rules_text", ["h2", "3-Smooth Numbers"], ["h1", "2592"], ["p","The merge rules switch on each move. On even-numbered moves, merges occur between two equal tiles. On odd-numbered moves, merges occur between three equal tiles. Get to the 2592 tile to win!"],
        ["p", "Spawning tiles: 1 (90%), 2 (5%), 3 (5%)"]);
        displayRules("gm_rules_text", ["h2", "3-Smooth Numbers"], ["h1", "2592"], ["p","The merge rules switch on each move. On even-numbered moves, merges occur between two equal tiles. On odd-numbered moves, merges occur between three equal tiles. Get to the 2592 tile to win!"],
        ["p", "Spawning tiles: 1 (90%), 2 (5%), 3 (5%)"]);
        statBoxes = [["Discovered Tiles", ["@DiscTiles", "arr_length"], false, ...[,,,], ["@GVar 5", "=", 0], [0, "@edit_gvar", 5, 1], true], ["Discovered Tiles", ["@DiscTiles"], true, false, "TileArray", "Self", ["@GVar 5", "=", 1], [0, "@edit_gvar", 5, 0], true], ["Score", "@Score"]];
        document.getElementById("mode_vars_line").style.setProperty("display", "block");
        document.getElementById("2592_vars").style.setProperty("display", "flex");
    }
    else if (mode == 40) { // Wildcard 2048
        // width = 4; height = 4;
        mode_vars = [0, false]; //If mode_vars[0] is 1, all possibilities of wildcards merge rather than just the shared ones. If mode_vars[0] is 2, the wildcards are "multitiles" instead. If mode_vars[1] is true, all tile spawns are crazy combinations.
        document.documentElement.style.setProperty("background-image", "linear-gradient(#f2b179, #ede0c8, #f9eee3, #ffffff, #f9eee3, #ede0c8, #f2b179)");
        document.documentElement.style.setProperty("--background-color", "radial-gradient(#f2b179, #ede0c8, #f9eee3, #ffffff, #f9eee3, #ede0c8, #f2b179)");
        document.documentElement.style.setProperty("--grid-color", "#c7bea7");
        document.documentElement.style.setProperty("--tile-color", "#ece0c2");
        document.documentElement.style.setProperty("--text-color", "#524c46");
        displayRules("rules_text", ["h1", "Wildcard 2048"], ["p", "2048, but some tiles can act as multiple tiles, such as a \"2 4\" tile, which could merge with a 2 to make a 4, or it could merge with a 4 to make an 8. Two of these \"wildcard\" tiles can merge as long as they share at least one possibility, and the result of their merge is a tile that contains all of the possibilities they both had, but doubled since they just merged. For example, a 1 2 4 tile and a 2 4 8 tile share the 2 and 4 possibilities, so they merge into a 4 8 tile. To win, you must make a regular 2048 tile - a tile with 2048 as one of its multiple possibilities doesn't count!"],
        ["p", "Spawning tiles: 1 (35%), 2 (15%), 4 (10%), 1 2 (12%), 1 4 (8%), 2 4 (8%), 1 2 4 (8%). The remaining 4% chance spawns a tile that could be any combination of tiles up to (but not including) the highest power of 2 you've reached, but is biased towards smaller values."]);
        displayRules("gm_rules_text", ["h1", "Wildcard 2048"], ["p", "2048, but some tiles can act as multiple tiles, such as a \"2 4\" tile, which could merge with a 2 to make a 4, or it could merge with a 4 to make an 8. Two of these \"wildcard\" tiles can merge as long as they share at least one possibility, and the result of their merge is a tile that contains all of the possibilities they both had, but doubled since they just merged. For example, a 1 2 4 tile and a 2 4 8 tile share the 2 and 4 possibilities, so they merge into a 4 8 tile. To win, you must make a regular 2048 tile - a tile with 2048 as one of its multiple possibilities doesn't count!"],
        ["p", "Spawning tiles: 1 (35%), 2 (15%), 4 (10%), 1 2 (12%), 1 4 (8%), 2 4 (8%), 1 2 4 (8%). The remaining 4% chance spawns a tile that could be any combination of tiles up to (but not including) the highest power of 2 you've reached, but is biased towards smaller values."]);
        document.getElementById("mode_vars_line").style.setProperty("display", "block");
        document.getElementById("Wildcard2048_vars").style.setProperty("display", "flex");
        if (modifiers[13] == "None") {
            TileNumAmount = 1;
            TileTypes = [ //The powers of 2 could be rendered using the rule for wildcards, but they're given specified types to reduce lag
            [[1], "1", "#89817b", "#f9f6f2"], [[2], "2", "#aa937f", "#f9f6f2"], [[4], "4", "#c69d79", "#f9f6f2"], [[8], "8", "#f2b179", "#f9f6f2"],
            [[16], "16", "#f59563", "#f9f6f2"], [[32], "32", "#f67c5f", "#f9f6f2"], [[64], "64", "#f65e3b", "#f9f6f2"], [[128], "128", "#edcf72", "#f9f6f2"],
            [[256], "256", "#edcc61", "#f9f6f2"], [[512], "512", "#edc850", "#f9f6f2"], [[1024], "1024", "#edc53f", "#f9f6f2"], [[2048], "2048", "#edc22e", "#f9f6f2"],
            [[4096], "4096", "#f29eff", "#f9f6f2"], [[8192], "8192", "#eb75fd", "#f9f6f2"], [[16384], "16384", "#e53bff", "#f9f6f2"],
            [[32768], "32768", "#bd00db", "#f9f6f2"], [[65536], "65536", "#770089", "#f9f6f2"], [[131072], "131072", "#534de8", "#f9f6f2"],
            [[262144], "262144", "#2922e1", "#f9f6f2"], [[524288], "524288", "#0a05b6", "#f9f6f2"],
            [true, 0, "@ColorScheme", "Wildcard 2048", ["@This 0", true]]
            ];
            MergeRules = [[["@This 0", "bit&", "@Next 1 0"], "@end_vars", 2, ["@var_retain", "@Var 0", ">", 0], true, [[["@var_retain", "@Var 0", "*", 2]]], ["@var_retain", "@Var 0", "*", 2], [false, true]]];
            startTileSpawns = [[[1], 35], [[2], 15], [[4], 10], [[3], 12], [[5], 8], [[6], 8], [[7], 8], [[[2, "^", ["@DiscTiles", "arr_reduce", 0, ["@if", ["@var_retain", "@Var -1", "arr_elem", 0, ">", "@Parent -2"], "2nd", ["@var_retain", "@Var -1", "arr_elem", 0], "@end-if"], "+", 0.5, "log", 2, "floor", 1, "rand_float", 1], "round", 1, "-", 1, "max", 1]], 4]];
            winConditions = [[2048]];
            winRequirement = 1;
            knownMergeMaxLength = 2;
            knownMergeLookbackDistance = 0;
        }
        else { //A tile cannot contain both positive and negative possibilities, so "2 -1" is not possible. This restriction was mostly placed to make the code easier to write
            TileNumAmount = 2;
            TileTypes = [
                [[1, 1], "1", "#89817b", "#f9f6f2"], [[2, 1], "2", "#aa937f", "#f9f6f2"], [[4, 1], "4", "#c69d79", "#f9f6f2"],
                [[8, 1], "8", "#f2b179", "#f9f6f2"], [[16, 1], "16", "#f59563", "#f9f6f2"], [[32, 1], "32", "#f67c5f", "#f9f6f2"],
                [[64, 1], "64", "#f65e3b", "#f9f6f2"], [[128, 1], "128", "#edcf72", "#f9f6f2"],  [[256, 1], "256", "#edcc61", "#f9f6f2"],
                [[512, 1], "512", "#edc850", "#f9f6f2"], [[1024, 1], "1024", "#edc53f", "#f9f6f2"], [[2048, 1], "2048", "#edc22e", "#f9f6f2"],
                [[4096, 1], "4096", "#f29eff", "#f9f6f2"], [[8192, 1], "8192", "#eb75fd", "#f9f6f2"], [[16384, 1], "16384", "#e53bff", "#f9f6f2"],
                [[32768, 1], "32768", "#bd00db", "#f9f6f2"], [[65536, 1], "65536", "#770089", "#f9f6f2"], [[131072, 1], "131072", "#534de8", "#f9f6f2"],
                [[262144, 1], "262144", "#2922e1", "#f9f6f2"], [[524288, 1], "524288", "#0a05b6", "#f9f6f2"],
                [[1, -1], "-1", "#767e84", "#06090d"], [[2, -1], "-2", "#556c80", "#06090d"], [[4, -1], "-4", "#396286", "#06090d"],
                [[8, -1], "-8", "#0d4e86", "#06090d"], [[16, -1], "-16", "#0a6a9c", "#06090d"], [[32, -1], "-32", "#0983a0", "#06090d"],
                [[64, -1], "-64", "#09a1c4", "#06090d"], [[128, -1], "-128", "#12308d", "#06090d"], [[256, -1], "-256", "#12339e", "#06090d"],
                [[512, -1], "-512", "#1237af", "#06090d"], [[1024, -1], "-1024", "#123ac0", "#06090d"], [[2048, -1], "-2048", "#123dd1", "#06090d"],
                [[4096, -1], "-4096", "#0d6100", "#06090d"], [[8192, -1], "-8192", "#148a02", "#06090d"], [[16384, -1], "-16384", "#1ac400", "#06090d"],
                [[32768, -1], "-32768", "#42ff24", "#06090d"], [[65536, -1], "-65536", "#88ff76", "#06090d"], [[131072, -1], "-131072", "#acb217", "#06090d"],
                [[262144, -1], "-262144", "#d6dd1e", "#06090d"], [[524288, -1], "-524288", "#f5fa49", "#06090d"],
                [true, 0, "@ColorScheme", "Wildcard 2048", [["@This 0", "*", "@This 1"], true]]
            ];
            MergeRules = [[["@This 0", "bit&", "@Next 1 0"], "@end_vars", 2, ["@var_retain", "@Var 0", ">", 0, "&&", ["@This 1", "=", "@Next 1 1"]], true, [[["@var_retain", "@Var 0", "*", 2], "@This 1"]], ["@var_retain", "@Var 0", "*", 2], [false, true]]];
            if (modifiers[13] == "Interacting") MergeRules.push([[1, "@end_vars", 0, "@repeat", ["@var_retain", "@This 0", "min", "@Next 1 0", ">=", "@Var 0"], "@if", ["@var_retain", ["@var_retain", "@This 0", "floor", "@Var 0", "/", "@Var 0", "%", 2, "=", 1], "&&", ["@var_retain", "@Next 1 0", "floor", "@Var 0", "/", "@Var 0", "%", 2, "=", 1]], "+", "@Var 0", "@end-if", "@edit_var", 0, ["@var_retain", "@Var 0", "*", 2], "@end-repeat"], "@end_vars", 2, ["@var_retain", "@Var 0", ">", 0, "&&", ["@This 1", "!=", "@Next 1 1"]], true, [], 0, [true, true]]);
            startTileSpawns = [[[1, 1], 35 * modifiers[22]], [[2, 1], 15 * modifiers[22]], [[4, 1], 10 * modifiers[22]], [[3, 1], 12 * modifiers[22]], [[5, 1], 8 * modifiers[22]], [[6, 1], 8 * modifiers[22]], [[7, 1], 8 * modifiers[22]], [[[2, "^", ["@DiscTiles", "arr_reduce", 0, ["@if", ["@var_retain", "@Var -1", "arr_elem", 0, ">", "@Parent -2"], "2nd", ["@var_retain", "@Var -1", "arr_elem", 0], "@end-if"], "+", 0.5, "log", 2, "floor", 1, "rand_float", 1], "round", 1, "-", 1, "max", 1], 1], 4 * modifiers[22]], [[1, -1], 35 * modifiers[23]], [[2, -1], 15 * modifiers[23]], [[4, -1], 10 * modifiers[23]], [[3, -1], 12 * modifiers[23]], [[5, -1], 8 * modifiers[23]], [[6, -1], 8 * modifiers[23]], [[7, -1], 8 * modifiers[23]], [[[2, "^", ["@DiscTiles", "arr_reduce", 0, ["@if", ["@var_retain", "@Var -1", "arr_elem", 0, ">", "@Parent -2"], "2nd", ["@var_retain", "@Var -1", "arr_elem", 0], "@end-if"], "+", 0.5, "log", 2, "floor", 1, "rand_float", 1], "round", 1, "-", 1, "max", 1], -1], 4 * modifiers[23]]];
            winConditions = [[2048, 1], [2048, -1]];
            winRequirement = 2;
            knownMergeMaxLength = 2;
            knownMergeLookbackDistance = 0;
        }
    }
    else if (mode == 41) { // X^Y
        // width = 5; height = 5;
        mode_vars = [2n**1024n, 4]; //mode_vars[0] is the maximum prime power, mode_vars[1] is the maximum merge length
        start_game_vars = [0, 0] // Controls the display of Discovered Tiles and Discovered Winning Tiles
        document.documentElement.style.setProperty("background-image", "linear-gradient(#660000, #664e00, #1d6600, #00664e, #005866, #003366, #050066, #3f0066)");
        document.documentElement.style.setProperty("--background-color", "radial-gradient(#000000, #4c0000, #775800, #3ca400, #00d4c9, #0020f2 110%)");
        document.documentElement.style.setProperty("--grid-color", "#272727");
        document.documentElement.style.setProperty("--tile-color", "#494949");
        document.documentElement.style.setProperty("--text-color", "#d5d5d5");
        displayRules("rules_text", ["h2", "All Perfect Powers"], ["h1", "X<sup>Y</sup>"], ["p", "Any two, three, or four tiles can merge as long as those tiles add up to a perfect power, i.e. any number that can be represented as x<sup>y</sup> with x being a positive integer and y being a positive integer above 1. To win, make at least twelve different tiles that are cubes, fourth powers, or higher. The real quest, though, is to discover as many tiles as you can."],
        ["p", "Spawning tiles: 1 (100%)"]);
        displayRules("gm_rules_text", ["h2", "All Perfect Powers"], ["h1", "X<sup>Y</sup>"], ["p", "Any two, three, or four tiles can merge as long as those tiles add up to a perfect power, i.e. any number that can be represented as x<sup>y</sup> with x being a positive integer and y being a positive integer above 1. To win, make at least twelve different tiles that are perfect cubes, fourth powers, or higher. The real quest, though, is to discover as many tiles as you can."],
        ["p", "Spawning tiles: 1 (100%)"]);
        statBoxes = [["Discovered Tiles", ["@DiscTiles", "arr_length"], false, ...[,,,], ["@GVar 0", "=", 0], [0, "@edit_gvar", 0, 1], true], ["Discovered Tiles", ["@DiscTiles"], true, false, "TileArray", "Self", ["@GVar 0", "=", 1], [0, "@edit_gvar", 0, 0], true], ["Score", "@Score"], ["Discovered Winning Tiles", ["@DiscWinning", "arr_length"], false, ...[,,,], ["@GVar 1", "=", 0], [0, "@edit_gvar", 1, 1], true], ["Discovered Winning Tiles", ["@DiscWinning"], true, false, "TileArray", "Self", ["@GVar 1", "=", 1], [0, "@edit_gvar", 1, 0], true],];
        document.getElementById("mode_vars_line").style.setProperty("display", "block");
        document.getElementById("XpowY_vars").style.setProperty("display", "flex");
        if (modifiers[13] == "None") {
            TileNumAmount = 2;
            TileTypes = [
                [[1n, 0n], 1n, "#000000", "#ffffff"],
                [["@This 1", "<", 7n], ["@This 0", "^B", "@This 1"], ["@HSVA", ["@This 0", "+", 4, "log", 2, "-", [6, "log", 2], "*", 240], [0.7, "^", ["@This 0", "+", 4, "log", 2, "-", [6, "log", 2]], "*", 100], [0.75, "^", "@This 1", "*", -100, "+", 100], 1], ["@HSVA", ["@This 1", "-", 2, "*", 49], 25, 100, 1]],
                [["@This 1", ">=", 7n], ["@This 0", "^B", "@This 1"], ["@HSVA", ["@This 0", "+", 4, "log", 2, "-", [6, "log", 2], "*", 240], [0.7, "^", ["@This 0", "+", 4, "log", 2, "-", [6, "log", 2]], "*", 100], [0.75, "^", "@This 1", "*", -100, "+", 100], 1], ["@HSVA", ["@This 1", "-", 2, "*", 49], 100, [0.95, "^", ["@This 1", "-", 9], "*", 40], 1]],
            ];
            MergeRules = [
                [["@This 0", "^B", "@This 1", "+B", ["@Next", "arr_reduce", 0, ["+B", ["@var_retain", ["@var_retain", "@Var -1", "arr_elem", 0], "^B", ["@var_retain", "@Var -1", "arr_elem", 1]]]], "perfectPowerFormB", 2n**1024n], "@end_vars", 2, ["@var_retain", "@Var 0", "arr_elem", 1, "!=", 1n, "&&", ["@This 0", "typeof", "=", "bigint"], "&&", ["@Next", "arr_reduce", true, ["@if", ["@var_retain", "@Var -1", "arr_elem", 0, "typeof", "!=", "bigint"], "2nd", false, "@end-if"]]], true, [[["@var_retain", "@Var 0", "arr_elem", 0], ["@var_retain", "@Var 0", "arr_elem", 1]]], ["@var_retain", ["@var_retain", "@Var 0", "arr_elem", 0], "^", ["@var_retain", "@Var 0", "arr_elem", 1]], [], 2, [0, 0], 1, 4]
            ]
            startTileSpawns = [[[1n, 0n], 100]];
            winConditions = [[["@This 1", ">=", 3n]]];
            winRequirement = 12;
            knownMergeMaxLength = 4;
            knownMergeLookbackDistance = 0;
        }
        else { // If Negative Tiles is Non-Interacting, then positives and negatives can't interact with each other, as usual. If Negative Tiles is Interacting, then positive and negative tiles in this mode can freely add under the rules of the mode; for example, a 25 tile and a -9 tile can merge into a 16 tile.
            TileNumAmount = 3;
            TileTypes = [
                [[1n, 0n, 1n], 1, "#000000", "#ffffff"],
                [[["@This 1", "<", 7n], "&&", ["@This 2", "=", 1n]], ["@This 0", "^B", "@This 1"], ["@HSVA", ["@This 0", "+", 4, "log", 2, "-", [6, "log", 2], "*", 240], [0.7, "^", ["@This 0", "+", 4, "log", 2, "-", [6, "log", 2]], "*", 100], [0.75, "^", "@This 1", "*", -100, "+", 100], 1], ["@HSVA", ["@This 1", "-", 2, "*", 49], 25, 100, 1]],
                [[["@This 1", ">=", 7n], "&&", ["@This 2", "=", 1n]], ["@This 0", "^B", "@This 1"], ["@HSVA", ["@This 0", "+", 4, "log", 2, "-", [6, "log", 2], "*", 240], [0.7, "^", ["@This 0", "+", 4, "log", 2, "-", [6, "log", 2]], "*", 100], [0.75, "^", "@This 1", "*", -100, "+", 100], 1], ["@HSVA", ["@This 1", "-", 2, "*", 49], 100, [0.95, "^", ["@This 1", "-", 9], "*", 40], 1]],
                [[1n, 0n, -1n], -1, "#ffffff", "#000000"],
                [[["@This 1", "<", 7n], "&&", ["@This 2", "=", -1n]], ["@This 0", "^B", "@This 1", "*B", -1n], ["@rotate", 180, true, ["@HSVA", ["@This 0", "+", 4, "log", 2, "-", [6, "log", 2], "*", 240], [0.7, "^", ["@This 0", "+", 4, "log", 2, "-", [6, "log", 2]], "*", 100], [0.75, "^", "@This 1", "*", -100, "+", 100], 1]], ["@rotate", 180, true, ["@HSVA", ["@This 1", "-", 2, "*", 49], 25, 100, 1]]],
                [[["@This 1", ">=", 7n], "&&", ["@This 2", "=", -1n]], ["@This 0", "^B", "@This 1", "*B", -1n], ["@rotate", 180, true, ["@HSVA", ["@This 0", "+", 4, "log", 2, "-", [6, "log", 2], "*", 240], [0.7, "^", ["@This 0", "+", 4, "log", 2, "-", [6, "log", 2]], "*", 100], [0.75, "^", "@This 1", "*", -100, "+", 100], 1]], ["@rotate", 180, true, ["@HSVA", ["@This 1", "-", 2, "*", 49], 100, [0.95, "^", ["@This 1", "-", 9], "*", 40], 1]]],
            ];
            startTileSpawns = [[[1n, 0n, 1n], 100 * modifiers[22]], [[1n, 0n, -1n], 100 * modifiers[23]]];
            winConditions = [[["@This 1", ">=", 3n]]];
            winRequirement = 24;
            knownMergeMaxLength = 4;
            knownMergeLookbackDistance = 0;
            if (modifiers[13] == "Interacting") {
                MergeRules = [
                    [["@This 0", "^B", "@This 1", "*B", "@This 2", "+B", ["@Next", "arr_reduce", 0, ["+B", ["@var_retain", ["@var_retain", "@Var -1", "arr_elem", 0], "^B", ["@var_retain", "@Var -1", "arr_elem", 1], "*", ["@var_retain", "@Var -1", "arr_elem", 2]]]], "perfectPowerFormB", 2n**1024n], "@end_vars", 2, ["@var_retain", "@Var 0", "arr_elem", 0, "=", 0n, "&&", ["@var_retain", "@Var 0", "arr_elem", 1, "!=", 1n], "&&", ["@This 0", "typeof", "=", "bigint"], "&&", ["@Next", "arr_reduce", true, ["@if", ["@var_retain", "@Var -1", "arr_elem", 0, "typeof", "!=", "bigint"], "2nd", false, "@end-if"]]], true, [], 0, [], 2, [0, 0], 1, 4],
                    [["@This 0", "^B", "@This 1", "*B", "@This 2", "+B", ["@Next", "arr_reduce", 0, ["+B", ["@var_retain", ["@var_retain", "@Var -1", "arr_elem", 0], "^B", ["@var_retain", "@Var -1", "arr_elem", 1], "*", ["@var_retain", "@Var -1", "arr_elem", 2]]]], "perfectPowerFormB", 2n**1024n], "@end_vars", 2, ["@var_retain", "@Var 0", "arr_elem", 0, "!=", 0n, "&&", ["@var_retain", "@Var 0", "arr_elem", 1, "!=", 1n], "&&", ["@This 0", "typeof", "=", "bigint"], "&&", ["@Next", "arr_reduce", true, ["@if", ["@var_retain", "@Var -1", "arr_elem", 0, "typeof", "!=", "bigint"], "2nd", false, "@end-if"]]], true, [[["@var_retain", "@Var 0", "arr_elem", 0], ["@var_retain", "@Var 0", "arr_elem", 1], ["@var_retain", "@Var 0", "arr_elem", 2]]], ["@var_retain", ["@var_retain", "@Var 0", "arr_elem", 0], "^", ["@var_retain", "@Var 0", "arr_elem", 1]], [], 2, [0, 0], 1, 4]
                ]
            }
            else {
                MergeRules = [
                    [["@This 0", "^B", "@This 1", "*B", "@This 2", "+B", ["@Next", "arr_reduce", 0, ["+B", ["@var_retain", ["@var_retain", "@Var -1", "arr_elem", 0], "^B", ["@var_retain", "@Var -1", "arr_elem", 1], "*", ["@var_retain", "@Var -1", "arr_elem", 2]]]], "perfectPowerFormB", 2n**1024n], "@end_vars", 2, ["@var_retain", "@Var 0", "arr_elem", 1, "!=", 1n, "&&", ["@This 0", "typeof", "=", "bigint"], "&&", ["@Next", "arr_reduce", true, ["@if", ["@var_retain", "@Var -1", "arr_elem", 0, "typeof", "!=", "bigint"], "2nd", false, "@end-if"]], "&&", ["@Next", "arr_reduce", true, ["@if", ["@var_retain", "@Var -1", "arr_elem", 2, "!=", "@This 2"], "2nd", false, "@end-if"]]], true, [[["@var_retain", "@Var 0", "arr_elem", 0], ["@var_retain", "@Var 0", "arr_elem", 1], "@This 2"]], ["@var_retain", ["@var_retain", "@Var 0", "arr_elem", 0], "^", ["@var_retain", "@Var 0", "arr_elem", 1]], [], 2, [0, 0], 1, 4]
                ]
            }
        }
    }
    else if (mode == 42) { // Bicolor 2584
        // width = 4; height = 4;
        TileNumAmount = 2;
        TileTypes = [
        [[0, 0], 1, "#ffffff", "#2d2b31"], [[1, 0], 2, "#b3ffe8", "#2d2b31"],
        [[2, -1], 3, ["@linear-gradient", "#30ffff", 0, "#52ffcb", 25, 75, "#30ffff", 100], "#2d2b31"],
        [[2, 1], 3, ["@linear-gradient", "#ffff30", 0, "#52ffcb", 25, 75, "#ffff30", 100], "#2d2b31"],
        [[3, -1], 5, ["@linear-gradient", "#30ffff", 0, "#00ff99", 25, 75, "#30ffff", 100], "#2d2b31"],
        [[3, 1], 5, ["@linear-gradient", "#ffff30", 0, "#00ff99", 25, 75, "#ffff30", 100], "#2d2b31"],
        [[4, -1], 8, ["@linear-gradient", "#30ffff", 0, "#00c777", 25, 75, "#30ffff", 100], "#2d2b31"],
        [[4, 1], 8, ["@linear-gradient", "#ffff30", 0, "#00c777", 25, 75, "#ffff30", 100], "#2d2b31"],
        [[5, -1], 13, ["@linear-gradient", "#30ffff", 0, "#008b53", 25, 75, "#30ffff", 100], "#2d2b31"],
        [[5, 1], 13, ["@linear-gradient", "#ffff30", 0, "#008b53", 25, 75, "#ffff30", 100], "#2d2b31"],
        [[6, -1], 21, ["@linear-gradient", "#30ffff", 0, "#008b00", 25, 75, "#30ffff", 100], "#2d2b31"],
        [[6, 1], 21, ["@linear-gradient", "#ffff30", 0, "#008b00", 25, 75, "#ffff30", 100], "#2d2b31"],
        [[7, -1], 34, ["@linear-gradient", "#30ffff", 0, "#00e200", 25, 75, "#30ffff", 100], "#2d2b31"],
        [[7, 1], 34, ["@linear-gradient", "#ffff30", 0, "#00e200", 25, 75, "#ffff30", 100], "#2d2b31"],
        [[8, -1], 55, ["@linear-gradient", "#30ffff", 0, "#4aff4a", 25, 75, "#30ffff", 100], "#2d2b31"],
        [[8, 1], 55, ["@linear-gradient", "#ffff30", 0, "#4aff4a", 25, 75, "#ffff30", 100], "#2d2b31"],
        [[9, -1], 89, ["@linear-gradient", "#30ffff", 0, "#94ff94", 25, 75, "#30ffff", 100], "#2d2b31"],
        [[9, 1], 89, ["@linear-gradient", "#ffff30", 0, "#94ff94", 25, 75, "#ffff30", 100], "#2d2b31"],
        [[10, -1], 144, ["@linear-gradient", "#30ffff", 0, "#8ac4ff", 25, 75, "#30ffff", 100], "#dddbe1"],
        [[10, 1], 144, ["@linear-gradient", "#ffff30", 0, "#8ac4ff", 25, 75, "#ffff30", 100], "#dddbe1"],
        [[11, -1], 233, ["@linear-gradient", "#30ffff", 0, "#50a8ff", 25, 75, "#30ffff", 100], "#dddbe1"],
        [[11, 1], 233, ["@linear-gradient", "#ffff30", 0, "#50a8ff", 25, 75, "#ffff30", 100], "#dddbe1"],
        [[12, -1], 377, ["@linear-gradient", "#30ffff", 0, "#0180ff", 25, 75, "#30ffff", 100], "#dddbe1"],
        [[12, 1], 377, ["@linear-gradient", "#ffff30", 0, "#0180ff", 25, 75, "#ffff30", 100], "#dddbe1"],
        [[13, -1], 610, ["@linear-gradient", "#30ffff", 0, "#0055a9", 25, 75, "#30ffff", 100], "#dddbe1"],
        [[13, 1], 610, ["@linear-gradient", "#ffff30", 0, "#0055a9", 25, 75, "#ffff30", 100], "#dddbe1"],
        [[14, -1], 987, ["@linear-gradient", "#30ffff", 0, "#0030a9", 25, 75, "#30ffff", 100], "#dddbe1"],
        [[14, 1], 987, ["@linear-gradient", "#ffff30", 0, "#0030a9", 25, 75, "#ffff30", 100], "#dddbe1"],
        [[15, -1], 1597, ["@linear-gradient", "#30ffff", 0, "#2d0087", 25, 75, "#30ffff", 100], "#dddbe1"],
        [[15, 1], 1597, ["@linear-gradient", "#ffff30", 0, "#2d0087", 25, 75, "#ffff30", 100], "#dddbe1"],
        [[16, -1], 2584, ["@linear-gradient", "#30ffff", 0, "#1a004f", 25, 75, "#30ffff", 100], "#dddbe1"],
        [[16, 1], 2584, ["@linear-gradient", "#ffff30", 0, "#1a004f", 25, 75, "#ffff30", 100], "#dddbe1"],
        [[17, -1], 4181, ["@linear-gradient", "#30ffff", 0, "#3d004f", 25, 75, "#30ffff", 100], "#dddbe1"],
        [[17, 1], 4181, ["@linear-gradient", "#ffff30", 0, "#3d004f", 25, 75, "#ffff30", 100], "#dddbe1"],
        [[18, -1], 6765, ["@linear-gradient", "#30ffff", 0, "#750099", 25, 75, "#30ffff", 100], "#dddbe1"],
        [[18, 1], 6765, ["@linear-gradient", "#ffff30", 0, "#750099", 25, 75, "#ffff30", 100], "#dddbe1"],
        [[19, -1], 10946, ["@linear-gradient", "#30ffff", 0, "#c300ff", 25, 75, "#30ffff", 100], "#dddbe1"],
        [[19, 1], 10946, ["@linear-gradient", "#ffff30", 0, "#c300ff", 25, 75, "#ffff30", 100], "#dddbe1"],
        [[20, -1], 17711, ["@linear-gradient", "#30ffff", 0, "#d85aff", 25, 75, "#30ffff", 100], "#dddbe1"],
        [[20, 1], 17711, ["@linear-gradient", "#ffff30", 0, "#d85aff", 25, 75, "#ffff30", 100], "#dddbe1"],
        [[21, -1], 28657, ["@linear-gradient", "#30ffff", 0, "#e591ff", 25, 75, "#30ffff", 100], "#dddbe1"],
        [[21, 1], 28657, ["@linear-gradient", "#ffff30", 0, "#e591ff", 25, 75, "#ffff30", 100], "#dddbe1"],
        [["@This 1", "=", -1], [[((1 + Math.sqrt(5))/2), "^", ["@This 0", "+", 2]], "-", [((1 + Math.sqrt(5))/-2), "^", ["@This 0", "*", -1, "-", 2]], "/", Math.sqrt(5), "round", 1], ["@linear-gradient", "#30ffff", 0, ["@HSLA", [6.5, "*", "@This 0", "+", 157], [0.99, "^", ["@This 0", "-", 22], "*", 100], ["@This 0", "-", 21, "%", 9, "*", -1, "+", 4, "abs", "*", 10, "+", 30], 1], 25, 75, "#30ffff", 100], "#2d2b31"],
        [["@This 1", "=", 1], [[((1 + Math.sqrt(5))/2), "^", ["@This 0", "+", 2]], "-", [((1 + Math.sqrt(5))/-2), "^", ["@This 0", "*", -1, "-", 2]], "/", Math.sqrt(5), "round", 1], ["@linear-gradient", "#ffff30", 0, ["@HSLA", [6.5, "*", "@This 0", "+", 157], [0.99, "^", ["@This 0", "-", 22], "*", 100], ["@This 0", "-", 21, "%", 9, "*", -1, "+", 4, "abs", "*", 10, "+", 30], 1], 25, 75, "#ffff30", 100], "#2d2b31"],
        ];
        MergeRules = [
            [2, [["@Next 1 0", "=", 0], "&&", ["@This 0", "=", 0]], true, [[1, 0]], 2, [false, true]],
            [2, [["@Next 1 0", "=", 1], "&&", ["@This 0", "=", 0]], true, [[2, 1]], 3, [false, true]],
            [2, [["@Next 1 0", "=", 0], "&&", ["@This 0", "=", 1]], true, [[2, -1]], 3, [false, true]],
            [2, [["@Next 1 0", "=", 1], "&&", ["@This 0", "=", 2]], false, [[3, "@This 1"]], 5, [false, true]],
            [2, [["@This 0", "-", 1, "=", "@Next 1 0"], "&&", ["@This 1", "!=", "@Next 1 1"]], false, [[["@This 0", "+", 1], "@This 1"]], [[((1 + Math.sqrt(5))/2), "^", ["@This 0", "+", 3]], "-", [((1 + Math.sqrt(5))/-2), "^", ["@This 0", "*", -1, "-", 3]], "/", Math.sqrt(5), "round", 1], [false, true]]
        ];
        startTileSpawns = [[[0, 0], 85], [[1, 0], 10], [[2, -1], 2.5], [[2, 1], 2.5]];
        winConditions = [["@This 0", "=", 16]];
        winRequirement = 1;
        knownMergeMaxLength = 2;
        knownMergeLookbackDistance = 0;
        document.documentElement.style.setProperty("background-image", "linear-gradient(#80ffff 0%, #6637a8 25% 75%, #ffff80 100%)");
        document.documentElement.style.setProperty("--background-color", "linear-gradient(#bbffff 0%, #b184ee 25% 75%, #ffffbb 100%)");
        document.documentElement.style.setProperty("--grid-color", "#645f71");
        document.documentElement.style.setProperty("--tile-color", "#9f94b4");
        document.documentElement.style.setProperty("--text-color", "#2d2b31");
        displayRules("rules_text", ["h1", "Bicolor 2584"], ["p", "2584 mode, except every tile above 2 comes in two colors. When a 2 and a 1 merge, they become a cyan 3 if the 2 collided into the 1, but they become a yellow 3 if the 1 collided into the 2. 5s retain the color of the 3 used to make them. Merges between two tiles that both have a color can only occur if they're opposite colors, and the color of the larger tile in the merge is retained by the resulting tile. Get to either 2584 tile to win!"],
        ["p", "Spawning tiles: 1 (85%), 2 (10%), Cyan 3 (2.5%), Yellow 3 (2.5%)"]);
        displayRules("gm_rules_text", ["h1", "Bicolor 2584"], ["p", "2584 mode, except every tile above 2 comes in two colors. When a 2 and a 1 merge, they become a cyan 3 if the 2 collided into the 1, but they become a yellow 3 if the 1 collided into the 2. 5s retain the color of the 3 used to make them. Merges between two tiles that both have a color can only occur if they're opposite colors, and the color of the larger tile in the merge is retained by the resulting tile. Get to either 2584 tile to win!"],
        ["p", "Spawning tiles: 1 (85%), 2 (10%), Cyan 3 (2.5%), Yellow 3 (2.5%)"]);
    }
    else if (mode == 43) { // 1321
        // width = 5; height = 5;
        TileNumAmount = 2;
        mode_vars = [false, 0, 3]; // If mode_vars[0] is true, +1s can only merge with even numbers. mode_vars[1] controls the random goals, mode_vars[2] controls the size of the first random goal
        start_game_vars = [2n, 0, false, 3, 0, 0] // The first entry is the current random goal, the second entry is the amount of random goals met so far, the third entry is whether a random goal has been met this turn, and the fourth entry controls the size of the first random goal. Fifth entry controls the display of Discovered Tiles, sixth entry controls the display of Discovered Multiples of 32.
        TileTypes = [
            [["@This 1", "=", 0], ["@This 0"], "@ColorScheme", "1321", ["@This 0"]],
            [["@This 1", "=", 1], ["+", "str_concat", ["@This 0", "defaultAbbrev"]], "@ColorScheme", "1321", ["@This 0"], 0, 0, ["PrimeImage", ["@conic-gradient", "#ff0000", "#ffff00", "#00ff00", "#00ffff", "#0000ff", "#ff00ff", "#ff0000"], ["@radial-gradient", "#0000", "#0008"]]]
        ];
        if (modifiers[13] == "None") {
            MergeRules = [
                [2, [["@This 0", "=", "@Next 1 0"], "&&", ["@This 1", "=", 0], "&&", ["@Next 1 1", "=", 0]], true, [[["@This 0", "+", "@Next 1 0"], 0]], ["@This 0", "+", "@Next 1 0"], [false, true]],
                [2, [["@This 1", "=", 0], "&&", ["@Next 1 1", "=", 1]], false, [[["@This 0", "+", "@Next 1 0"], 0]], ["@This 0", "+", "@Next 1 0"], [false, true]],
                [2, [["@This 1", "=", 1], "&&", ["@Next 1 1", "=", 1]], true, [[["@This 0", "+", "@Next 1 0"], 1]], ["@This 0", "+", "@Next 1 0"], [false, true]]
            ];
            startTileSpawns = [[[1, 0], 70], [[1, 1], 30]];
            winConditions = [["@This 0", "=", 1321]];
            winRequirement = 1;
        }
        else {
            MergeRules = [
                [2, [["@This 0", "=", "@Next 1 0"], "&&", ["@This 1", "=", 0], "&&", ["@Next 1 1", "=", 0]], true, [[["@This 0", "+", "@Next 1 0"], 0]], ["@This 0", "+", "@Next 1 0"], [false, true]],
                [2, [["@This 1", "=", 0], "&&", ["@Next 1 1", "=", 1], "&&", [["@This 0", "sign"], "=", ["@Next 1 0", "sign"]]], false, [[["@This 0", "+", "@Next 1 0"], 0]], ["@This 0", "+", "@Next 1 0", "abs"], [false, true]],
                [2, [["@This 1", "=", 1], "&&", ["@Next 1 1", "=", 1], "&&", [["@This 0", "sign"], "=", ["@Next 1 0", "sign"]]], true, [[["@This 0", "+", "@Next 1 0"], 1]], ["@This 0", "+", "@Next 1 0", "abs"], [false, true]]
            ];
            if (modifiers[13] == "Interacting") {
                MergeRules = [
                    [2, ["@This 0", "+", "@Next 1 0", "=", 0], true, [], 0],
                    [2, [["@This 0", "=", "@Next 1 0"], "&&", ["@This 1", "=", 0], "&&", ["@Next 1 1", "=", 0]], true, [[["@This 0", "+", "@Next 1 0"], 0]], ["@This 0", "+", "@Next 1 0", "abs"], [false, true]],
                    [2, [["@This 1", "=", 0], "&&", ["@Next 1 1", "=", 1]], false, [[["@This 0", "+", "@Next 1 0"], 0]], ["@This 0", "+", "@Next 1 0", "abs"], [false, true]],
                    [2, [["@This 1", "=", 1], "&&", ["@Next 1 1", "=", 1]], true, [[["@This 0", "+", "@Next 1 0"], 1]], ["@This 0", "+", "@Next 1 0", "abs"], [false, true]]
                ];
            }
            startTileSpawns = [[[1, 0], 70 * modifiers[22]], [[-1, 0], 70 * modifiers[23]], [[1, 1], 30 * modifiers[22]], [[-1, 1], 30 * modifiers[23]]];
            winConditions = [["@This 0", "abs", "=", 1321]];
            winRequirement = 2;
        }
        knownMergeMaxLength = 2;
        knownMergeLookbackDistance = 0;
        document.documentElement.style.setProperty("background-image", "radial-gradient(#deeedd 0% 50%, #deeeddaa 100%), conic-gradient(#f00, #ff0, #0f0, #0ff, #00f, #f0f, #f00)");
        document.documentElement.style.setProperty("--background-color", "#deeedd");
        document.documentElement.style.setProperty("--grid-color", "#94ac93");
        document.documentElement.style.setProperty("--tile-color", "#c1d4c1");
        document.documentElement.style.setProperty("--text-color", "#2f332f");
        displayRules("rules_text", ["h1", "1321"], ["p", "Merges occur between two equal tiles, but there are also +1 tiles that can merge with anything. Get to the 1321 tile to win (your first task is figuring out how to get there...). If you're looking for a different kind of challenge, see how many different multiples of 32 you can make!"],
        ["p", "Spawning tiles: 1 (70%), +1 (30%)"]);
        displayRules("gm_rules_text", ["h1", "1321"], ["p", "Merges occur between two equal tiles, but there are also +1 tiles that can merge with anything. Get to the 1321 tile to win (your first task is figuring out how to get there...). If you're looking for a different kind of challenge, see how many different multiples of 32 you can make!"],
        ["p", "Spawning tiles: 1 (70%), +1 (30%)"]);
        statBoxes = [["Discovered Tiles", ["@DiscTiles", "arr_length"], false, ...[,,,], ["@GVar 4", "=", 0], [0, "@edit_gvar", 4, 1], true], ["Discovered Tiles", ["@DiscTiles"], true, false, "TileArray", "Self", ["@GVar 4", "=", 1], [0, "@edit_gvar", 4, 0], true], ["Score", "@Score"], ["Discovered Multiples of 32", ["@DiscTiles", "arr_reduce", 0, ["@if", ["@var_retain", "@Var -1", "arr_elem", "0", "expomod", 2, ">=", 5], "+", 1, "@end-if"]], false, ...[,,,], ["@GVar 5", "=", 0], [0, "@edit_gvar", 5, 1], true], ["Discovered Multiples of 32", ["@DiscTiles", "arr_filter", ["@Var -1", "arr_elem", "0", "expomod", 2, ">=", 5]], true, false, "TileArray", "Self", ["@GVar 5", "=", 1], [0, "@edit_gvar", 5, 0], true]];
        document.getElementById("mode_vars_line").style.setProperty("display", "block");
        document.getElementById("1321_vars").style.setProperty("display", "flex");
    }
    else if (mode == 44) { // mod 27
        // width = 5; height = 5;
        start_game_vars = [3]; // The modulus
        if (modifiers[13] == "None") {
            TileNumAmount = 1;
            TileTypes = [
                [true, "@This 0", "@ColorScheme", "mod 27", ["@This 0"]]
            ];
            MergeRules = [
                [2, [["@NextNE -1 0", "!=", "@This 0"], "&&", ["@This 0", "=", "@Next 1 0"], "&&", ["@This 0", "!=", 1]], true, [[["@This 0", "*", "@MLength", "%", "@GVar 0"]]], [0, "@if", [["@This 0", "*", "@MLength", "%", "@GVar 0"], "=", 1], "2nd", 1, "@end-if"], [], 2, [0, 1], 1, Math.max(width, height)],
                [0, ["@This 0", "=", 1], true, [], 0]
            ];
            startTileSpawns = [[[2], 1]];
        }
        else {
            TileNumAmount = 1;
            TileTypes = [
                [true, ["@This 0"], "@ColorScheme", "mod 27", ["@This 0"]]
            ];
            MergeRules = [
                [2, [["@NextNE -1 0", "!=", "@This 0"], "&&", ["@This 0", "=", "@Next 1 0"], "&&", ["@This 0", "abs", "!=", 1]], true, [[["@This 0", "*", "@MLength", "%", "@GVar 0"]]], [0, "@if", [["@This 0", "*", "@MLength", "%", "@GVar 0", "abs"], "=", 1], "2nd", 1, "@end-if"], [], 2, [0, 1], 1, Math.max(width, height)],
                [0, ["@This 0", "abs", "=", 1], true, [], 0]
            ];
            startTileSpawns = [[[2], 1 * modifiers[22]], [[-2], 1 * modifiers[23]]];
            if (modifiers[13] == "Interacting") MergeRules.push([2, [["@This 0", "*", -1, "=", "@Next 1 0"]], true, [[0]], 0, [false, true]]);
        }
        winConditions = [];
        winRequirement = ["@GVar 0", "=", 27];
        mergeResultKnownLevel = 0; // Probably could get away with setting this to 1 but I'm not going to bother
        scripts = [[[0, "@if", ["@Grid", "arr_flat", 1, "arr_reduce", false, ["@if", ["@var_retain", "@Var -1", "arr_elem", 0, "abs", "=", 1], "2nd", true, "@end-if"]], "@edit_gvar", 0, ["@GVar 0", "+", 2], "@end-if"], "EndMovement"]]
        document.documentElement.style.setProperty("background-image", "linear-gradient(90deg, #bfff98, #df96d9, #bfff98)");
        document.documentElement.style.setProperty("--background-color", "linear-gradient(#df96d9, #bfff98, #df96d9)");
        document.documentElement.style.setProperty("--grid-color", "#ff81f5");
        document.documentElement.style.setProperty("--tile-color", "#c3ed8f");
        document.documentElement.style.setProperty("--text-color", "#3c293b");
        displayRules("rules_text", ["h2", "Modular Supermerging"], ["h1", "mod 27"], ["p", "Merges occur between any amount of equal tiles, but they obey modular arithmetic. The modulus starts at 3, but any 1 tiles disappear at the end of a turn and the modulus goes up by 2 after a turn where any 1 tiles are made. Get to a modulus of 27 to win!"],
        ["p", "Spawning tiles: 2 (100%)"]);
        displayRules("gm_rules_text", ["h2", "Modular Supermerging"], ["h1", "mod 27"], ["p", "Merges occur between any amount of equal tiles, but they obey modular arithmetic. The modulus starts at 3, but any 1 tiles disappear at the end of a turn and the modulus goes up by 2 after a turn where any 1 tiles are made. Get to a modulus of 27 to win!"],
        ["p", "Spawning tiles: 2 (100%)"]);
        statBoxes = [["Modulus", "@GVar 0"], ["1s Created", "@Score"]];
    }
    else if (mode == 45) { // Directional Merges
        // width = 6; height = 6;
        TileNumAmount = 6;
        mode_vars = [2]; // The difficulty; different difficulties have different merge rules, meaning they're essentially different gamemodes
        start_game_vars = [0]; // Controls the display of Discovered Tiles
        TileTypes = [
            [[0, 0, 0, 0, 0, 0], 1, "#666666", "#cccccc"],
            [[["@This 2", "=", 0], "&&", ["@This 3", "=", 0], "&&", ["@This 4", "=", 0], "&&", ["@This 5", "=", 0]], [[2, "^", "@This 0"], "*", [3, "^", "@This 1"], "*", [5, "^", "@This 2"], "*", [7, "^", "@This 3"], "*", [11, "^", "@This 4"], "*", [13, "^", "@This 5"]], ["@HSLA", ["@This 1", "/", ["@This 0", "+", "@This 1"], "*", -240], 100, [0.75, "^", ["@This 0", "gcd", "@This 1"], "*", -50, "+", 100], 1], "#000000"],
            [[["@This 0", "=", 0], "&&", ["@This 1", "=", 0], "&&", ["@This 4", "=", 0], "&&", ["@This 5", "=", 0]], [[2, "^", "@This 0"], "*", [3, "^", "@This 1"], "*", [5, "^", "@This 2"], "*", [7, "^", "@This 3"], "*", [11, "^", "@This 4"], "*", [13, "^", "@This 5"]], ["@HSLA", ["@This 3", "/", ["@This 2", "+", "@This 3"], "*", 240, "+", 180], 100, [0.75, "^", ["@This 2", "gcd", "@This 3"], "*", 50], 1], "#ffffff"],
            [[["@This 0", "=", 0], "&&", ["@This 1", "=", 0], "&&", ["@This 2", "=", 0], "&&", ["@This 3", "=", 0]], [[2, "^", "@This 0"], "*", [3, "^", "@This 1"], "*", [5, "^", "@This 2"], "*", [7, "^", "@This 3"], "*", [11, "^", "@This 4"], "*", [13, "^", "@This 5"]], ["@HSLA", ["@This 5", "/", ["@This 4", "+", "@This 5"], "*", -240, "+", 150], 75, [0.75, "^", ["@This 4", "gcd", "@This 5"], "*", -50, "+", 100], 1], "#000000"],
            [[["@This 4", "=", 0], "&&", ["@This 5", "=", 0]], [[2, "^", "@This 0"], "*", [3, "^", "@This 1"], "*", [5, "^", "@This 2"], "*", [7, "^", "@This 3"], "*", [11, "^", "@This 4"], "*", [13, "^", "@This 5"]], ["@linear-gradient", ["@HSLA", ["@This 1", "/", ["@This 0", "+", "@This 1"], "*", -240], 100, [0.75, "^", ["@This 0", "gcd", "@This 1"], "*", -50, "+", 100], 1], ["@HSLA", ["@This 3", "/", ["@This 2", "+", "@This 3"], "*", 240, "+", 180], 100, [0.75, "^", ["@This 2", "gcd", "@This 3"], "*", 50], 1]], "#ffffff"],
            [[["@This 2", "=", 0], "&&", ["@This 3", "=", 0]], [[2, "^", "@This 0"], "*", [3, "^", "@This 1"], "*", [5, "^", "@This 2"], "*", [7, "^", "@This 3"], "*", [11, "^", "@This 4"], "*", [13, "^", "@This 5"]], ["@linear-gradient", ["@HSLA", ["@This 1", "/", ["@This 0", "+", "@This 1"], "*", -240], 100, [0.75, "^", ["@This 0", "gcd", "@This 1"], "*", -50, "+", 100], 1], ["@HSLA", ["@This 5", "/", ["@This 4", "+", "@This 5"], "*", -240, "+", 150], 75, [0.75, "^", ["@This 4", "gcd", "@This 5"], "*", -50, "+", 100], 1]], "#000000"],
            [[["@This 0", "=", 0], "&&", ["@This 1", "=", 0]], [[2, "^", "@This 0"], "*", [3, "^", "@This 1"], "*", [5, "^", "@This 2"], "*", [7, "^", "@This 3"], "*", [11, "^", "@This 4"], "*", [13, "^", "@This 5"]], ["@linear-gradient", ["@HSLA", ["@This 3", "/", ["@This 2", "+", "@This 3"], "*", 240, "+", 180], 100, [0.75, "^", ["@This 2", "gcd", "@This 3"], "*", 50], 1], ["@HSLA", ["@This 5", "/", ["@This 4", "+", "@This 5"], "*", -240, "+", 150], 75, [0.75, "^", ["@This 4", "gcd", "@This 5"], "*", -50, "+", 100], 1]], "#ffffff"],
            [true, [[2, "^", "@This 0"], "*", [3, "^", "@This 1"], "*", [5, "^", "@This 2"], "*", [7, "^", "@This 3"], "*", [11, "^", "@This 4"], "*", [13, "^", "@This 5"]], ["@linear-gradient", ["@HSLA", ["@This 1", "/", ["@This 0", "+", "@This 1"], "*", -240], 100, [0.75, "^", ["@This 0", "gcd", "@This 1"], "*", -50, "+", 100], 1], ["@HSLA", ["@This 3", "/", ["@This 2", "+", "@This 3"], "*", 240, "+", 180], 100, [0.75, "^", ["@This 2", "gcd", "@This 3"], "*", 50], 1], ["@HSLA", ["@This 5", "/", ["@This 4", "+", "@This 5"], "*", -240, "+", 150], 75, [0.75, "^", ["@This 4", "gcd", "@This 5"], "*", -50, "+", 100], 1]], "#ffffff"],
        ];
        startTileSpawns = [[[0, 0, 0, 0, 0, 0], 1]];
        winRequirement = 1;
        mergeResultKnownLevel = 0; // Directional merges can't do known merge results
        // A lot of the setup for this mode is handled by gmDisplayVars
        statBoxes = [["Discovered Tiles", ["@DiscTiles", "arr_length"], false, ...[,,,], ["@GVar 0", "=", 0], [0, "@edit_gvar", 0, 1], true], ["Discovered Tiles", ["@DiscTiles"], true, false, "TileArray", "Self", ["@GVar 0", "=", 1], [0, "@edit_gvar", 0, 0], true], ["Score", "@Score"]];
        document.getElementById("mode_vars_line").style.setProperty("display", "block");
        document.getElementById("2100_vars").style.setProperty("display", "flex");
    }
    else if (mode == 46) { // 2378
        // width = 5; height = 5;
        TileNumAmount = 1;
        TileTypes = [
            [[1], 1, "#ffffff", "#403f3a"], [[2], 2, "#d5ddea", "#403f3a"], [[3], 5, "#aabcd8", "#403f3a"], [[4], 12, "#7892bc", "#403f3a"],
            [[5], 29, "#5171a5", "#403f3a"], [[6], 70, "#335286", "#403f3a"], [[7], 169, "#6a6449", "#eae8db"], [[8], 408, "#a2955a", "#eae8db"],
            [[9], 985, "#c6b25c", "#eae8db"], [[10], 2378, "#e9cd53", "#eae8db"], [[11], 5741, "#5c8865", "#eae8db"], [[12], 13860, "#54a564", "#eae8db"],
            [[13], 33461, "#44cb5f", "#eae8db"], [[14], 80782, "#1dee47", "#eae8db"],
            [true, [[(1 + Math.sqrt(2)), "^", "@This 0"], "-", [(1 - Math.sqrt(2)), "^", "@This 0"], "/", Math.sqrt(2), "/", 2, "round", 1], ["@HSLA", [141, "*", ["@This 0", "-", 3, "floor", 4, "/", 4], "-", 130], [23, "*", ["@This 0", "-", 3, "%", 4], "+", 23], [0.95, "^", ["@This 0", "-", 15, "floor", 4, "/", 4], "*", 50], 1], "#eae8db"]
        ];
        MergeRules = [
            [2, [["@Next 1 0", "=", 1], "&&", ["@This 0", "=", 1]], true, [[2]], 2, [false, true]],
            [3, [["@This 0", "=", "@Next 1 0"], "&&", ["@This 0", "-", 1, "=", "@Next 2 0"]], false, [[["@This 0", "+", 1]]], [[(1 + Math.sqrt(2)), "^", ["@This 0", "+", 1]], "-", [(1 - Math.sqrt(2)), "^", ["@This 0", "+", 1]], "/", Math.sqrt(2), "/", 2, "round", 1], [false, true]]
        ];
        startTileSpawns = [[[1], 85], [[2], 12], [[3], 3]];
        winConditions = [[10]];
        winRequirement = 1;
        knownMergeMaxLength = 3;
        knownMergeLookbackDistance = 0;
        document.documentElement.style.setProperty("background-image", "radial-gradient(#eace51 0%, #fff 150%)");
        document.documentElement.style.setProperty("--background-color", "#f1d98f");
        document.documentElement.style.setProperty("--grid-color", "#a58d46");
        document.documentElement.style.setProperty("--tile-color", "#c8b270");
        document.documentElement.style.setProperty("--text-color", "#403f3a");
        displayRules("rules_text", ["h2", "Pell Numbers"], ["h1", "2378"], ["p", "Merges occur between two 1s or between two of the same tile and one of the tile before that. Get to the 2378 tile to win!"],
        ["p", "Spawning tiles: 1 (85%), 2 (12%), 5 (3%)"]);
        displayRules("gm_rules_text", ["h2", "Pell Numbers"], ["h1", "2378"], ["p", "Merges occur between two 1s or between two of the same tile and one of the tile before that. Get to the 2378 tile to win!"],
        ["p", "Spawning tiles: 1 (85%), 2 (12%), 5 (3%)"]);
    }
    else if (mode == 47) { // 1093 1094
        // width = 4; height = 4;
        TileNumAmount = 2;
        TileTypes = [
            [[1, -1], 1, "#ffffff", "#656a5c"], [[1, 1], 2, "#919191", "#dde3d0"], [[1, 0], 3, "#cecece", "#333b24"],
            [[2, -1], 4, "#96ffd2", "#656a5c"], [[2, 1], 5, "#00b365", "#dde3d0"], [[2, 0], 9, "#00ff91", "#333b24"],
            [[3, -1], 13, "#cc74ff", "#656a5c"], [[3, 1], 14, "#7300b5", "#dde3d0"], [[3, 0], 27, "#a200ff", "#333b24"],
            [[4, -1], 40, "#ffc16f", "#656a5c"], [[4, 1], 41, "#aa6100", "#dde3d0"], [[4, 0], 81, "#ff9100", "#333b24"],
            [[5, -1], 121, "#fff98d", "#656a5c"], [[5, 1], 122, "#aea600", "#dde3d0"], [[5, 0], 243, "#fff200", "#333b24"],
            [[6, -1], 364, "#76cfff", "#656a5c"], [[6, 1], 365, "#0075b4", "#dde3d0"], [[6, 0], 729, "#00a6ff", "#333b24"],
            [[7, -1], 1093, "#d3ff75", "#656a5c"], [[7, 1], 1094, "#7eb800", "#dde3d0"], [[7, 0], 2187, "#aeff00", "#333b24"],
            [[8, -1], 3280, "#ff7364", "#656a5c"], [[8, 1], 3281, "#a61100", "#dde3d0"], [[8, 0], 6561, "#ff1900", "#333b24"],
            [[9, -1], 9841, "#ff7dfb", "#656a5c"], [[9, 1], 9842, "#a800a2", "#dde3d0"], [[9, 0], 19683, "#ff00f7", "#333b24"],
            [[10, -1], 29524, "#5e86ff", "#656a5c"], [[10, 1], 29525, "#00289e", "#dde3d0"], [[10, 0], 59049, "#0040ff", "#333b24"],
            [["@This 1", "=", -1], [3, "^", "@This 0", "-", 1, "/", 2], ["@HSLA", [-97, "*", "@This 0", "+", 1090], [0.95, "^", ["@This 0", "-", 11], "*", 100], 70, 1], "#656a5c"],
            [["@This 1", "=", 1], [3, "^", "@This 0", "+", 1, "/", 2], ["@HSLA", [-97, "*", "@This 0", "+", 1090], [0.95, "^", ["@This 0", "-", 11], "*", 100], 30, 1], "#dde3d0"],
            [["@This 1", "=", 0], [3, "^", "@This 0"], ["@HSLA", [-97, "*", "@This 0", "+", 1090], [0.95, "^", ["@This 0", "-", 11], "*", 100], 50, 1], "#333b24"]
        ];
        MergeRules = [
            [2, [["@Next 1 0", "=", "@This 0"], "&&", ["@This 1", "=", 1], "&&", ["@Next 1 1", "=", -1]], false, [["@This 0", 0]], [3, "^", "@This 0"], [false, true]],
            [2, [["@Next 1 0", "=", "@This 0"], "&&", ["@This 1", "!=", 0], "&&", ["@Next 1 1", "=", 0]], false, [[["@This 0", "+", 1], "@This 1"]], [3, "^", "@This 0", "*", 3, "+", "@This 1", "/", 2], [false, true]]
        ];
        startTileSpawns = [["Box", 1, [1, -1], 3, [1, 1], 3, [1, 0], 1]];
        winConditions = [[7, 0]];
        winRequirement = 1;
        knownMergeMaxLength = 2;
        knownMergeLookbackDistance = 0;
        document.documentElement.style.setProperty("background-image", "radial-gradient(#77b700 0%, #fff 150%)");
        document.documentElement.style.setProperty("--background-color", "#d7eeac");
        document.documentElement.style.setProperty("--grid-color", "#91bb43");
        document.documentElement.style.setProperty("--tile-color", "#d2ee9d");
        document.documentElement.style.setProperty("--text-color", "#333b24");
        displayRules("rules_text", ["h1", "1093, 1094"], ["p", 'Merges occur between two tiles of consecutive number, or between a power of three and a tile that\'s less than 1 away from half that power of three. Get to the 2187 tile to win!'],
        ["p", "Spawning tiles: Pulls from a \"box\" that starts with three 1s, three 2s, and one 3, and only refills once it's empty."]);
        displayRules("gm_rules_text", ["h1", "1093, 1094"], ["p", 'Merges occur between two tiles of consecutive number, or between a power of three and a tile that\'s less than 1 away from half that power of three. Get to the 2187 tile to win!'],
        ["p", "Spawning tiles: Pulls from a \"box\" that starts with three 1s, three 2s, and one 3, and only refills once it's empty."]);
    }
    else if (mode == 48) { // 2310
        // width = 4; height = 4;
        TileNumAmount = 2;
        TileTypes = [
            [[0, 0], 1, "#ffffff", "#1a2727"],
            [["@This 1", "=", 0], [0, "@end_vars", 1, "@repeat", "@This 0", "@edit_var", 0, ["@var_retain", "@Var 0", "+", 1], "*", ["@var_retain", "@Var 0", "prime"], "@end-repeat", "*", ["@This 1", "prime"]], ["@HSLA", [[-1, "@end_vars", "@This 0", "-", 1, "@repeat", ["@Parent -2", ">=", 3], "/", 2, "@edit_var", 0, ["@var_retain", "@Var 0", "+", 1], "@end-repeat", "2nd", "@Var 0"], "@end_vars", "@This 0", "-", 1, "*", 120, "@if", ["@var_retain", "@Var 0", ">", -1], "2nd", ["@var_retain", 0, "+", 120, "/", ["@var_retain", 2, "^", "@Var 0"], "*", ["@This 0", "-", 0.5]], "@end-if"], 100, 35, 1], "#e4ffff"],
            [true, [0, "@end_vars", 1, "@repeat", "@This 0", "@edit_var", 0, ["@var_retain", "@Var 0", "+", 1], "*", ["@var_retain", "@Var 0", "prime"], "@end-repeat", "*", ["@This 1", "prime"]], ["@radial-gradient", ["@HSLA", [[-1, "@end_vars", "@This 1", "-", 1, "@repeat", ["@Parent -2", ">=", 3], "/", 2, "@edit_var", 0, ["@var_retain", "@Var 0", "+", 1], "@end-repeat", "2nd", "@Var 0"], "@end_vars", "@This 1", "-", 1, "*", 120, "@if", ["@var_retain", "@Var 0", ">", -1], "2nd", ["@var_retain", 0, "+", 120, "/", ["@var_retain", 2, "^", "@Var 0"], "*", ["@This 1", "-", 0.5]], "@end-if"], 100, 65, 1], 0, 20, ["@HSLA", [[-1, "@end_vars", "@This 0", "-", 1, "@repeat", ["@Parent -2", ">=", 3], "/", 2, "@edit_var", 0, ["@var_retain", "@Var 0", "+", 1], "@end-repeat", "2nd", "@Var 0"], "@end_vars", "@This 0", "-", 1, "*", 120, "@if", ["@var_retain", "@Var 0", ">", -1], "2nd", ["@var_retain", 0, "+", 120, "/", ["@var_retain", 2, "^", "@Var 0"], "*", ["@This 0", "-", 0.5]], "@end-if"], 100, 35, 1], 100], "#1a2727"],
        ];
        MergeRules = [
            [2, [["@Next 1 0", "=", "@This 0"], "&&", ["@This 1", "<", 2], "&&", ["@Next 1 1", "=", 0]], false, [[["@This 0", "@if", ["@This 0", "=", "@This 1"], "+", 1, "@end-if"], ["@This 1", "+", 1, "%", ["@This 0", "+", 1]]]], [0, "@end_vars", 1, "@repeat", "@This 0", "@edit_var", 0, ["@var_retain", "@Var 0", "+", 1], "*", ["@var_retain", "@Var 0", "prime"], "@end-repeat", "*", ["@This 1", "+", 1, "prime"]], [false, true]],
            [2, [["@Next 1 0", "=", "@This 0"], "&&", ["@This 1", ">", "@Next 1 1"], "&&", [["@This 1", "prime"], "+", 2, "=", ["@This 1", "+", 1, "prime"]], "&&", ["@Next 1 1", "=", 1]], false, [[["@This 0", "@if", ["@This 0", "=", "@This 1"], "+", 1, "@end-if"], ["@This 1", "+", 1, "%", ["@This 0", "+", 1]]]], [0, "@end_vars", 1, "@repeat", "@This 0", "@edit_var", 0, ["@var_retain", "@Var 0", "+", 1], "*", ["@var_retain", "@Var 0", "prime"], "@end-repeat", "*", ["@This 1", "+", 1, "prime"]], [false, true]],
            [3, [["@Next 1 0", "=", "@This 0"], "&&", ["@Next 2 0", "=", "@This 0"], "&&", ["@This 1", ">", "@Next 1 1"], "&&", ["@This 1", ">", "@Next 2 1"], "&&", [["@This 1", "prime"], "+", ["@Next 1 1", "prime"], "+", ["@Next 2 1", "prime"], "=", ["@This 1", "+", 1, "prime"]], "&&", ["@Next 1 1", "!=", 0], "&&", ["@Next 2 1", "!=", 0]], false, [[["@This 0", "@if", ["@This 0", "=", "@This 1"], "+", 1, "@end-if"], ["@This 1", "+", 1, "%", ["@This 0", "+", 1]]]], [0, "@end_vars", 1, "@repeat", "@This 0", "@edit_var", 0, ["@var_retain", "@Var 0", "+", 1], "*", ["@var_retain", "@Var 0", "prime"], "@end-repeat", "*", ["@This 1", "+", 1, "prime"]], [false, true]]
        ];
        startTileSpawns = [[[0, 0], 85], [[1, 0], 12], [[1, 1], 3]];
        winConditions = [[5, 0]];
        winRequirement = 1;
        knownMergeMaxLength = 3;
        knownMergeLookbackDistance = 0;
        document.documentElement.style.setProperty("background-image", "radial-gradient(#007575 0%, #a6ffff 100%)");
        document.documentElement.style.setProperty("--background-color", "radial-gradient(#80ffff 0%, #00dada 150%)");
        document.documentElement.style.setProperty("--grid-color", "#82dbdb");
        document.documentElement.style.setProperty("--tile-color", "#539a9a");
        document.documentElement.style.setProperty("--text-color", "#1a2727");
        displayRules("rules_text", ["h2", "Primorials"], ["h1", "2310"], ["p", "Tiles that are not a multiple of any square number merge with themselves. A tile that's a multiple of 4 merges with a tile that's half of it. A tile that's a multiple of 9 merges with a tile that's two-thirds of it. A tile that's a multiple of 25 merges with a tile that's two-fifths of it. A tile that's a multiple of 49 merges with two tiles that are each two-sevenths of it. This continues for each squared prime: a tile that's a multiple of a squared prime merges with two or three tiles that get it to either be the next primorial or a multiple of the next squared prime. Three-tile merges cannot include tiles that are primorials. Get to the 2310 tile to win!"],
        ["p", "Spawning tiles: 1 (85%), 2 (12%), 4 (3%)"]);
        displayRules("gm_rules_text", ["h2", "Primorials"], ["h1", "2310"], ["p", "Tiles that are not a multiple of any square number merge with themselves. A tile that's a multiple of 4 merges with a tile that's half of it. A tile that's a multiple of 9 merges with a tile that's two-thirds of it. A tile that's a multiple of 25 merges with a tile that's two-fifths of it. A tile that's a multiple of 49 merges with two tiles that are each two-sevenths of it. This continues for each squared prime: a tile that's a multiple of a squared prime merges with two or three tiles that get it to either be the next primorial or a multiple of the next squared prime. Three-tile merges cannot include tiles that are primorials. Get to the 2310 tile to win!"],
        ["p", "Spawning tiles: 1 (85%), 2 (12%), 4 (3%)"]);
    }
    else if (mode == 49) { // 378
        // width = 5; height = 5; 
        start_game_vars = [3, false]; // The 0th entry is the goal tile, the 1st entry is whether a goal tile was made this turn. If not playing with a goal tile, the 0th entry controls the display of Discovered Tiles instead.
        mode_vars = [true, 3]; // The 0th entry is whether a goal tile exists, the 1st entry is the maximum merge length
        if (modifiers[13] == "None") {
            TileNumAmount = 1;
            TileTypes = [
                [[1], 1, "#ffffff", "#2c2700"],
                [true, ["@This 0", "+", 1, "*", "@This 0", "/", 2], ["@radial-gradient", ["@HSLA", [34, "*", "@This 0", "-", 8], ["@This 0", "%", 320, "-", 160, "abs", "/", 2, "+", 20], ["@This 0", "%", 81, "-", 40, "abs", "*", 2, "+", 10], 1], ["@HSLA", [34, "*", "@This 0", "*", 0.995, "-", 8], ["@This 0", "*", 0.995, "%", 320, "-", 160, "abs", "/", 2, "+", 20], ["@This 0", "*", 0.995, "%", 81, "-", 40, "abs", "*", 2, "+", 10], 1]], "#ffffff"]
            ];
            MergeRules = [
                [["@This 0", "+", 1, "*", "@This 0", "/", 2, "+", ["@Next", "arr_reduce", 0, ["+", ["@var_retain", ["@var_retain", "@Var -1", "arr_elem", 0], "+", 1, "*", ["@var_retain", "@Var -1", "arr_elem", 0], "/", 2]]]], ["@This 0", "+", 1, "*", "@This 0", "/", 2, "+", ["@Next", "arr_reduce", 0, ["+", ["@var_retain", ["@var_retain", "@Var -1", "arr_elem", 0], "+", 1, "*", ["@var_retain", "@Var -1", "arr_elem", 0], "/", 2]]], "*", 8, "+", 1, "^", 0.5, "-", 1, "/", 2, "round", 1], "@end_vars", 2, ["@var_retain", ["@This 0", "typeof", "=", "number"], "&&", ["@Next", "arr_reduce", true, ["@if", ["@var_retain", "@Var -1", "arr_elem", 0, "typeof", "!=", "number"], "2nd", false, "@end-if"]], "&&", ["@var_retain", "@Var 1", "+", 1, "*", "@Var 1", "/", 2, "=", "@Var 0"]], true, [[["@var_retain", "@Var 1"]]], "@Var 0", [], 2, [0, 0], 1, 3],
                [0, ["@This 0", "=", "@GVar 0"], false, [], 0, []]
            ];
            startTileSpawns = [[[1], 90], [[2], 10]];
            winConditions = [[27]];
            winRequirement = 1;
        }
        else {
            TileNumAmount = 2;
            TileTypes = [
                [[1, 1], 1, "#ffffff", "#2c2700"], [[1, -1], -1, "#000000", "#d3d8ff"],
                [["@This 1", "=", 1], ["@This 0", "+", 1, "*", "@This 0", "/", 2], ["@radial-gradient", ["@HSLA", [34, "*", "@This 0", "-", 8], ["@This 0", "%", 320, "-", 160, "abs", "/", 2, "+", 20], ["@This 0", "%", 81, "-", 40, "abs", "*", 2, "+", 10], 1], ["@HSLA", [34, "*", "@This 0", "*", 0.995, "-", 8], ["@This 0", "*", 0.995, "%", 320, "-", 160, "abs", "/", 2, "+", 20], ["@This 0", "*", 0.995, "%", 81, "-", 40, "abs", "*", 2, "+", 10], 1]], "#ffffff"],
                [["@This 1", "=", -1], ["@This 0", "+", 1, "*", "@This 0", "/", -2], ["@rotate", 180, true, ["@radial-gradient", ["@HSLA", [34, "*", "@This 0", "-", 8], ["@This 0", "%", 320, "-", 160, "abs", "/", 2, "+", 20], ["@This 0", "%", 81, "-", 40, "abs", "*", 2, "+", 10], 1], ["@HSLA", [34, "*", "@This 0", "*", 0.995, "-", 8], ["@This 0", "*", 0.995, "%", 320, "-", 160, "abs", "/", 2, "+", 20], ["@This 0", "*", 0.995, "%", 81, "-", 40, "abs", "*", 2, "+", 10], 1]]], "#000000"]
            ];
            startTileSpawns = [[[1, 1], 90 * modifiers[22]], [[1, -1], 90 * modifiers[23]], [[2, 1], 10 * modifiers[22]], [[2, -1], 10 * modifiers[23]]];
            winConditions = [["@This 0", "=", 27]];
            winRequirement = 1;
            if (modifiers[13] == "Non-Interacting") {
                MergeRules = [
                    [["@This 0", "+", 1, "*", "@This 0", "/", 2, "*", "@This 1", "+", ["@Next", "arr_reduce", 0, ["+", ["@var_retain", ["@var_retain", "@Var -1", "arr_elem", 0], "+", 1, "*", ["@var_retain", "@Var -1", "arr_elem", 0], "/", 2, "*", ["@var_retain", "@Var -1", "arr_elem", 1]]]]], ["@This 0", "+", 1, "*", "@This 0", "/", 2, "*", "@This 1", "+", ["@Next", "arr_reduce", 0, ["+", ["@var_retain", ["@var_retain", "@Var -1", "arr_elem", 0], "+", 1, "*", ["@var_retain", "@Var -1", "arr_elem", 0], "/", 2, "*", ["@var_retain", "@Var -1", "arr_elem", 1]]]], "abs", "*", 8, "+", 1, "^", 0.5, "-", 1, "/", 2, "round", 1], "@end_vars", 2, ["@var_retain", ["@This 0", "typeof", "=", "number"], "&&", ["@Next", "arr_reduce", true, ["@if", ["@var_retain", "@Var -1", "arr_elem", 0, "typeof", "!=", "number"], "2nd", false, "@end-if"]], "&&", ["@Next", "arr_reduce", true, ["@if", ["@var_retain", "@Var -1", "arr_elem", 1, "!=", "@This 1"], "2nd", false, "@end-if"]], "&&", ["@var_retain", "@Var 1", "+", 1, "*", "@Var 1", "/", 2, "=", ["@var_retain", "@Var 0", "abs"]]], true, [[["@var_retain", "@Var 1"], ["@var_retain", "@Var 0", "sign"]]], ["@var_retain", "@Var 0", "abs"], [], 2, [0, 0], 1, 3],
                    [0, ["@This 0", "=", "@GVar 0"], false, [], 0, []]
                ];
            }
            else {
                MergeRules = [
                    [["@This 0", "+", 1, "*", "@This 0", "/", 2, "*", "@This 1", "+", ["@Next", "arr_reduce", 0, ["+", ["@var_retain", ["@var_retain", "@Var -1", "arr_elem", 0], "+", 1, "*", ["@var_retain", "@Var -1", "arr_elem", 0], "/", 2, "*", ["@var_retain", "@Var -1", "arr_elem", 1]]]]], ["@This 0", "+", 1, "*", "@This 0", "/", 2, "*", "@This 1", "+", ["@Next", "arr_reduce", 0, ["+", ["@var_retain", ["@var_retain", "@Var -1", "arr_elem", 0], "+", 1, "*", ["@var_retain", "@Var -1", "arr_elem", 0], "/", 2, "*", ["@var_retain", "@Var -1", "arr_elem", 1]]]], "abs", "*", 8, "+", 1, "^", 0.5, "-", 1, "/", 2, "round", 1], "@end_vars", 2, ["@var_retain", ["@This 0", "typeof", "=", "number"], "&&", ["@Next", "arr_reduce", true, ["@if", ["@var_retain", "@Var -1", "arr_elem", 0, "typeof", "!=", "number"], "2nd", false, "@end-if"]], "&&", ["@var_retain", "@Var 1", "=", 0]], true, [], 0, [], 2, [0, 0], 1, 3],
                    [["@This 0", "+", 1, "*", "@This 0", "/", 2, "*", "@This 1", "+", ["@Next", "arr_reduce", 0, ["+", ["@var_retain", ["@var_retain", "@Var -1", "arr_elem", 0], "+", 1, "*", ["@var_retain", "@Var -1", "arr_elem", 0], "/", 2, "*", ["@var_retain", "@Var -1", "arr_elem", 1]]]]], ["@This 0", "+", 1, "*", "@This 0", "/", 2, "*", "@This 1", "+", ["@Next", "arr_reduce", 0, ["+", ["@var_retain", ["@var_retain", "@Var -1", "arr_elem", 0], "+", 1, "*", ["@var_retain", "@Var -1", "arr_elem", 0], "/", 2, "*", ["@var_retain", "@Var -1", "arr_elem", 1]]]], "abs", "*", 8, "+", 1, "^", 0.5, "-", 1, "/", 2, "round", 1], "@end_vars", 2, ["@var_retain", ["@This 0", "typeof", "=", "number"], "&&", ["@Next", "arr_reduce", true, ["@if", ["@var_retain", "@Var -1", "arr_elem", 0, "typeof", "!=", "number"], "2nd", false, "@end-if"]], "&&", ["@var_retain", "@Var 1", "+", 1, "*", "@Var 1", "/", 2, "=", ["@var_retain", "@Var 0", "abs"]]], true, [[["@var_retain", "@Var 1"], ["@var_retain", "@Var 0", "sign"]]], ["@var_retain", "@Var 0", "abs"], [], 2, [0, 0], 1, 3],
                    [0, ["@This 0", "=", "@GVar 0"], false, [], 0, []]
                ];
            }
        }
        loseConditions = [["@This 0", ">", "@GVar 0"]];
        loseRequirement = 1;
        winPriority = false;
        knownMergeMaxLength = 3;
        knownMergeLookbackDistance = 0;
        scripts = [
            [[0, "@if", ["@Grid", "arr_flat", 1, "arr_reduce", false, ["@if", ["@var_retain", "@Var -1", "arr_elem", 0, "=", "@GVar 0"], "2nd", true, "@end-if"]], "@edit_gvar", 1, true, "@end-if"], "EndMovement"],
            [[0, "@if", "@GVar 1", "@edit_gvar", 1, false, "@edit_gvar", 0, ["@GVar 0", "+", 1], "@end-if"], "TrueEndTurn"]
        ];
        document.documentElement.style.setProperty("background-image", "linear-gradient(90deg, #ffffac, #d8ffae, #a6ffcd, #aaf8ff, #b7c2ff, #e2bcff, #ffaaff)");
        document.documentElement.style.setProperty("--background-color", "radial-gradient(#ffaaff, #aaf8ff, #ffffac)");
        document.documentElement.style.setProperty("--grid-color", "#eea0e9");
        document.documentElement.style.setProperty("--tile-color", "#fff6c3");
        document.documentElement.style.setProperty("--text-color", "#2c2700");
        displayRules("rules_text", ["h2", "Triangular Numbers"], ["h1", "378"], ["p", "Any two or three tiles can merge as long as they add to a triangular number. There is a \"goal tile\" that starts at 6. Whenever you make the goal tile, that tile disappears and the goal tile increases to the next triangular number. If you ever make a tile greater than the current goal tile, you immediately lose. Get to and make the 378 tile to win!"],
        ["p", "Spawning tiles: 1 (90%), 3 (10%)"]);
        displayRules("gm_rules_text", ["h2", "Triangular Numbers"], ["h1", "378"], ["p", "Any two or three tiles can merge as long as they add to a triangular number. There is a \"goal tile\" that starts at 6. Whenever you make the goal tile, that tile disappears and the goal tile increases to the next triangular number. If you ever make a tile greater than the current goal tile, you immediately lose. Get to and make the 378 tile to win!"],
        ["p", "Spawning tiles: 1 (90%), 3 (10%)"]);
        document.getElementById("mode_vars_line").style.setProperty("display", "block");
        document.getElementById("378_vars").style.setProperty("display", "flex");
        statBoxes = [["Goal Tile", ["@GVar 0", "+", 1, "*", "@GVar 0", "/", 2]], ["Score", "@Score"]];
    }
    else if (mode == 50) { // DIVE
        // width = 4; height = 4;
        TileNumAmount = 1;
        mode_vars = [0, false, 0, 0, 4n]; // For the first entry, 0 means seeds can be unlocked and eliminated, -1 means seeds can be unlocked but not eliminated, and a positive number does away with the seeds system and just makes the spawning tiles the first n primes. The second entry is whether 1s can spawn. The third entry controls the seed unlock testing rules: 0 is largest to smallest, 2 is smallest to largest, 3 is "whatever order the seeds happen to be in", and 1 guarantees the minimum result but runs in exponential time. The fourth entry controls random goals, and the fifth entry is the minimum for the first random goal.
        start_game_vars = [[2n], [2n], [], [], 0, 4n, 0, false, false, 4n, 0] // The first entry is the current seeds, the second entry is all seeds discovered, the third entry is the seeds that are currently being added, the fourth entry is the seeds that are currently being removed. The fifth entry matches the third entry of mode_vars, the sixth entry is the current random goal, the seventh entry is the amount of random goals met so far, and the eighth entry is whether a random goal has been met this turn. The ninth entry is used when tile text is hidden to replace the announcement numbers with question marks. The tenth entry is the minimum for the first random goal. The eleventh entry controls the display of "all seeds seen".
        TileTypes = [
            [true, "@This 0", "@ColorScheme", "DIVE", ["@This 0"]]
        ];
        if (modifiers[13] == "None") {
            MergeRules = [
                [2, [["@Next 1 0", "modB", ["@This 0", "absB", "max", 1n], "=", 0n], "&&", ["@This 0", "typeof", "=", "bigint"], "&&", ["@Next 1 0", "typeof", "=", "bigint"]], false, [[["@This 0", "+B", "@Next 1 0"]]], ["@This 0", "min", "@Next 1 0"], [false, true]]
            ];
            startTileSpawns = [[[["@GVar 0", "arr_elem", [0, "rand_bigint", ["@GVar 0", "arr_length", "-", 1]]]], 1]];
        }
        else {
            startTileSpawns = [[[["@GVar 0", "arr_elem", [0, "rand_bigint", ["@GVar 0", "arr_length", "-", 1]]]], modifiers[22]], [[["@GVar 0", "arr_elem", [0, "rand_bigint", ["@GVar 0", "arr_length", "-", 1]], "*B", -1n]], modifiers[23]]];
            if (modifiers[13] == "Non-Interacting") {
                MergeRules = [
                    [2, [["@Next 1 0", "modB", ["@This 0", "absB", "max", 1n], "=", 0n], "&&", ["@This 0", "typeof", "=", "bigint"], "&&", ["@Next 1 0", "typeof", "=", "bigint"], "&&", [["@This 0", "signB"], "=", ["@Next 1 0", "signB"]]], false, [[["@This 0", "+B", "@Next 1 0"]]], [["@This 0", "absB"], "min", ["@Next 1 0", "absB"]], [false, true]]
                ];
            }
            else {
                MergeRules = [
                    [2, ["@This 0", "*B", -1n, "=", "@Next 1 0"], true, [], 0],
                    [2, [["@Next 1 0", "modB", ["@This 0", "absB", "max", 1n], "=", 0n], "&&", ["@This 0", "typeof", "=", "bigint"], "&&", ["@Next 1 0", "typeof", "=", "bigint"]], false, [[["@This 0", "+B", "@Next 1 0"]]], [["@This 0", "absB"], "min", ["@Next 1 0", "absB"]], [false, true]]
                ];
            }
        }
        winRequirement = false;
        knownMergeMaxLength = 2;
        knownMergeLookbackDistance = 0;
        document.documentElement.style.setProperty("background-image", "radial-gradient(circle, #fff8 0%, #0000 19.666% 30.333%, #0008 38.888% 44.444%, #0000 53% 63.666%, #fff8 72.222% 77.777%, #0000 86.333%, #0008 100%), conic-gradient(#0000 0deg 10deg, #fff8 35deg 55deg, #0000 80deg 100deg, #0008 125deg 145deg, #0000 170deg 190deg, #fff8 215deg 235deg, #0000 260deg 280deg, #0008 305deg 325deg, #0000 350deg), linear-gradient(#69c, #69c)");
        document.documentElement.style.setProperty("--background-color", "repeating-radial-gradient(circle, #fff8 0%, #0000 5% 10%, #0008 15%, #0000 20% 25%, #fff8 30%), conic-gradient(#0000 0deg 10deg, #fff8 35deg 55deg, #0000 80deg 100deg, #0008 125deg 145deg, #0000 170deg 190deg, #fff8 215deg 235deg, #0000 260deg 280deg, #0008 305deg 325deg, #0000 350deg), radial-gradient(#b5cce4, #b5cce4)");
        document.documentElement.style.setProperty("--grid-color", "#7a9aba");
        document.documentElement.style.setProperty("--tile-color", "#9ec3e7");
        document.documentElement.style.setProperty("--text-color", "#16395a");
        displayRules("rules_text", ["h1", "DIVE"], ["p", "Tiles merge with their divisors. When two tiles merge, the score gained from the merge is only the smaller value out of the two tiles (rather than the value of the new tile). This mode has no win condition, so just try to get as high of a score as you can!"],
        ["p", "At first, only 2s spawn. When a new tile is made, if the value leftover after dividing that tile by all current spawning tiles as many times as you can is greater than 1, that leftover value is added as a new spawning tile. If there are no remaining multiples of a spawning tile on the board, that tile is removed from the spawn pool, and you gain points equal to its value."]);
        displayRules("gm_rules_text", ["h1", "DIVE"], ["p", "Tiles merge with their divisors. When two tiles merge, the score gained from the merge is only the smaller value out of the two tiles (rather than the value of the new tile). This mode has no win condition, so just try to get as high of a score as you can!"],
        ["p", "At first, only 2s spawn. When a new tile is made, if the value leftover after dividing that tile by all current spawning tiles as many times as you can is greater than 1, that leftover value is added as a new spawning tile. If there are no remaining multiples of a spawning tile on the board, that tile is removed from the spawn pool, and you gain points equal to its value."]);
        statBoxes = [["Score", "@Score", false, false, "Tile", "DIVE"], ["Seeds", "@GVar 0", false, false, "TileArray", "Self"], ["Seeds Seen", ["@GVar 1", "arr_length"], ...[,,,,], ["@GVar 10", "=", 0], [0, "@edit_gvar", 10, 1], true], ["All Seeds Seen", "@GVar 1", true, false, "TileArray", "Self", ["@GVar 10", "=", 1], [0, "@edit_gvar", 10, 0], true]];
        scripts = [
            [["@var_retain", ["@var_retain", "@Var -1", "arr_elem", 0, "arr_elem", 0], "@end_vars", "@Var -1", "absB", "DIVESeedUnlock", "@GVar 0", "@GVar 4", "@if", [["@Parent -3", ">", 1n], "&&", ["@GVar 2", "arr_indexOf", "@Parent -3", "=", -1]], "@edit_gvar", 2, ["@GVar 2", "arr_push", "@Parent -2"], "@end-if"], "Merge"],
            [["@GVar 0", 0, 0n, "@end_vars", true, "@repeat", ["@var_retain", "@Var 0", "arr_length"], "@edit_var", 2, ["@var_retain", "@Var 0", "arr_elem", "@Var 1"], "2nd", ["@var_retain", "@Grid", "arr_flat", 2, "arr_filter", ["@Var -1", "typeof", "=", "bigint", "&&", ["@var_retain", "@Var 1", "!=", 0n]], "arr_reduce", true, ["@var_retain", "@if", ["@var_retain", "@Var -1", "%B", "@Var 2", "=", 0n], "2nd", false, "@end-if"]], "@if", "@Parent -1", "@edit_gvar", 3, ["@var_retain", "@GVar 3", "arr_push", "@Var 1"], "@end-if", "@edit_var", 1, ["@var_retain", "@Var 1", "+", 1], "@end-repeat"], "EndMovement"],
            [[0, 0n, "@end_vars", 0, "@repeat", ["@GVar 2", "arr_length"], "@edit_var", 1, ["@var_retain", "@GVar 2", "arr_elem", "@Var 0"], "@edit_gvar", 0, ["@var_retain", "@GVar 0", "arr_push", "@Var 1"], "@if", ["@var_retain", "@GVar 1", "arr_indexOf", "@Var 1", "=", -1], "@edit_gvar", 1, ["@var_retain", "@GVar 1", "arr_push", "@Var 1", "arr_sort", ["@Var -2", "-B", "@Var -1", "Number"]], "@end-if", "@edit_var", 0, ["@var_retain", "@Var 0", "+", 1], "@end-repeat", "@if", ["@GVar 2", "arr_length", ">", 0], "@if", ["@GVar 2", "arr_length", "=", 1], "announce", ["@GVar 2", "arr_elem", 0, "String", "@if", "@GVar 8", "2nd", "?", "@end-if", "str_concat", " unlocked!"], 2500, "@end-if", "@else-if", ["@GVar 2", "arr_length", "=", 2], "announce", ["@GVar 2", "arr_elem", 0, "String", "@if", "@GVar 8", "2nd", "?", "@end-if", "str_concat", " and ", "str_concat", ["@GVar 2", "arr_elem", 1, "String", "@if", "@GVar 8", "2nd", "?", "@end-if"], "str_concat", " unlocked!"], 2500, "@end-else-if", "@else", "announce", ["@GVar 2", "arr_pop", "arr_reduce", "", ["str_concat", ["@var_retain", "@Var -1", "@if", "@GVar 8", "2nd", "?", "@end-if"], "str_concat", ", "], "str_concat", "and ", "str_concat", ["@GVar 2", "arr_elem", ["@GVar 2", "arr_length", "-", 1]], "@if", "@GVar 8", "2nd", "?", "@end-if", "str_concat", " unlocked!"], 2500, "@end-else", "@end-if", "@edit_gvar", 2, ["@Literal"]], "EndMovement"],
            [[0, 0, "@end_vars", 0, "@if", [["@GVar 3", "arr_length", ">", 0], "&&", [["@GVar 3", "arr_length"], "<", ["@GVar 0", "arr_length"]]], "@if", ["@GVar 3", "arr_length", "=", 1], "announce", ["@GVar 0", "arr_elem", ["@GVar 3", "arr_elem", 0], "String", "@if", "@GVar 8", "2nd", "?", "@end-if", "str_concat", " eliminated!"], 2500, "@end-if", "@else-if", ["@GVar 3", "arr_length", "=", 2], "announce", ["@GVar 0", "arr_elem", ["@GVar 3", "arr_elem", 0], "String", "@if", "@GVar 8", "2nd", "?", "@end-if", "str_concat", " and ", "str_concat", ["@GVar 0", "arr_elem", ["@GVar 3", "arr_elem", 1], "String", "@if", "@GVar 8", "2nd", "?", "@end-if"], "str_concat", " eliminated!"], 2500, "@end-else-if", "@else", "announce", ["@GVar 3", "arr_pop", "arr_reduce", "", ["str_concat", ["@var_retain", "@GVar 0", "arr_elem", "@Var -1", "@if", "@GVar 8", "2nd", "?", "@end-if"], "str_concat", ", "], "str_concat", "and ", "str_concat", ["@GVar 0", "arr_elem", ["@GVar 3", "arr_elem", ["@GVar 3", "arr_length", "-", 1]]], "@if", "@GVar 8", "2nd", "?", "@end-if", "str_concat", " eliminated!"], 2500, "@end-else", "@repeat", ["@GVar 3", "arr_length"], "@edit_var", 1, ["@var_retain", "@GVar 3", "arr_elem", "@Var 0"], "@add_score", ["@var_retain", "@GVar 0", "arr_elem", "@Var 1"], "@edit_gvar", 0, ["@var_retain", "@GVar 0", "arr_splice", ["@var_retain", "@Var 1", "-", "@Var 0"], 1, ["@Literal"]], "@edit_var", 0, ["@var_retain", "@Var 0", "+", 1], "@end-repeat", "@end-if", "@edit_gvar", 3, ["@Literal"]], "EndMovement"]
        ];
        document.getElementById("mode_vars_line").style.setProperty("display", "block");
        document.getElementById("DIVE_vars").style.setProperty("display", "flex");
    }
    else if (mode == 51) { // 1365 1366
        // width = 4; height = 4;
        TileNumAmount = 2;
        TileTypes = [
            [[0, 1], 1, "#ffffff", "#493243"], [[0, 2], 2, "#b4b4b4", "#f5dfef"],
            [[1, 1], 3, "#e7db88", "#493243"], [[1, 2], 6, "#ada25b", "#f5dfef"],
            [[2, 1], 5, "#cfea48", "#493243"], [[2, 2], 10, "#a3b937", "#f5dfef"],
            [[3, 1], 11, "#8aed4d", "#493243"], [[3, 2], 22, "#70bd41", "#f5dfef"],
            [[4, 1], 21, "#5bed5e", "#493243"], [[4, 2], 42, "#4cb94e", "#f5dfef"],
            [[5, 1], 43, "#49d871", "#493243"], [[5, 2], 86, "#38a657", "#f5dfef"],
            [[6, 1], 85, "#a683f2", "#493243"], [[6, 2], 170, "#896cc8", "#f5dfef"],
            [[7, 1], 171, "#904dee", "#493243"], [[7, 2], 342, "#713fb8", "#f5dfef"],
            [[8, 1], 341, "#b248eb", "#493243"], [[8, 2], 682, "#8939b5", "#f5dfef"],
            [[9, 1], 683, "#e554ef", "#493243"], [[9, 2], 1366, "#bb41c4", "#f5dfef"],
            [[10, 1], 1365, "#ea6fd9", "#493243"], [[10, 2], 2730, "#cf6dc2", "#f5dfef"],
            [[11, 1], 2731, "#ef74a9", "#493243"], [[11, 2], 5462, "#c1618b", "#f5dfef"],
            [[12, 1], 5461, "#ee7d8c", "#493243"], [[12, 2], 10922, "#d06e7b", "#f5dfef"],
            [[13, 1], 10923, "#f28e7f", "#493243"], [[13, 2], 21846, "#c47468", "#f5dfef"],
            [[14, 1], 21845, "#f1a47d", "#493243"], [[14, 2], 43690, "#d18f6e", "#f5dfef"],
            [[15, 1], 43691, "#eeba7e", "#493243"], [[15, 2], 87382, "#c79b69", "#f5dfef"],
            [["@This 1", "=", 1], [2, "^", "@This 0", "*", 4/3, "round", 1], ["@HSVA", [23, "*", "@This 0", "-", 200], [0.95, "^", ["@This 0", "-", 16], "*", 35], 90, 1], "#493243"],
            [["@This 1", "=", 2], [2, "^", "@This 0", "*", 4/3, "round", 1, "*", 2], ["@HSVA", [23, "*", "@This 0", "-", 200], [0.95, "^", ["@This 0", "-", 16], "*", 35], 65, 1], "#f5dfef"],
        ];
        MergeRules = [
            [2, [["@Next 1 0", "=", "@This 0"], "&&", ["@This 1", "=", 1], "&&", ["@Next 1 1", "=", 1]], true, [["@This 0", 2]], [2, "^", "@This 0", "*", 4/3, "round", 1, "*", 2], [false, true]],
            [2, [["@Next 1 0", "=", 0], "&&", ["@Next 1 1", "=", 2], "&&", ["@This 0", "=", 0], "&&", ["@This 1", "=", 1]], false, [[1, 1]], 3, [false, true]],
            [2, [["@Next 1 0", "-", 1, "=", "@This 0"], "&&", ["@This 1", "=", 2], "&&", ["@Next 1 1", "=", 1]], false, [[["@Next 1 0", "+", 1], 1]], [2, "^", "@Next 1 0", "*", 8/3, "round", 1], [false, true]]
        ];
        startTileSpawns = [[[0, 1], 85], [[0, 2], 10], [[1, 1], 5]];
        winConditions = [[10, 1], [9, 2]];
        winRequirement = 1;
        knownMergeMaxLength = 2;
        knownMergeLookbackDistance = 0;
        document.documentElement.style.setProperty("background-image", "radial-gradient(#c655a8 0%, #fff 150%)");
        document.documentElement.style.setProperty("--background-color", "#ebaedb");
        document.documentElement.style.setProperty("--grid-color", "#a9719a");
        document.documentElement.style.setProperty("--tile-color", "#cc8bbb");
        document.documentElement.style.setProperty("--text-color", "#493243");
        displayRules("rules_text", ["h1", "1365, 1366"], ["p", "Merges occur between two equal tiles that are an odd number, or between an even number tile and a tile that's 1 away from it. Get to the 1365 tile or the 1366 tile to win!"],
        ["p", "Spawning tiles: 1 (85%), 2 (10%), 3 (5%)"]);
        displayRules("gm_rules_text", ["h1", "1365, 1366"], ["p", "Merges occur between two equal tiles that are an odd number, or between an even number tile and a tile that's 1 away from it. Get to the 1365 tile or the 1366 tile to win!"],
        ["p", "Spawning tiles: 1 (85%), 2 (10%), 3 (5%)"]);
    }
    else if (mode == 52) { // 2583
        // width = 5; height = 5;
        TileNumAmount = 1;
        TileTypes = [[[1], 1, "#ffffff", "#373a30"], [[2], 2, "#ffa4bf", "#373a30"], [[3], 4, "#ff769f", "#373a30"],
        [[4], 7, "#ff2a6a", "#373a30"], [[5], 12, "#ee0047", "#373a30"], [[6], 20, "#bd0039", "#373a30"], [[7], 33, "#d1007e", "#373a30"],
        [[8], 54, "#f500b4", "#373a30"], [[9], 88, "#ff33dd", "#373a30"], [[10], 143, "#52ff7d", "#e1efd0"], [[11], 232, "#21ff58", "#e1efd0"],
        [[12], 376, "#00e238", "#e1efd0"], [[13], 609, "#21b600", "#e1efd0"], [[14], 986, "#339200", "#e1efd0"], [[15], 1596, "#649e1d", "#e1efd0"],
        [[16], 2583, "#9cbe36", "#e1efd0"], [[17], 4180, "#c8d54a", "#e1efd0"], [[18], 6764, "#eacd3e", "#e1efd0"], [[19], 10945, "#ff9900", "#e1efd0"],
        [[20], 17710, "#e67f19", "#e1efd0"], [[21], 28656, "#d0642e", "#e1efd0"], [[22], 46367, "#be5742", "#e1efd0"], [[23], 75024, "#ab5454", "#e1efd0"],
        [true, [[((1 + Math.sqrt(5))/2), "^", ["@This 0", "+", 2]], "-", [((1 + Math.sqrt(5))/-2), "^", ["@This 0", "*", -1, "-", 2]], "/", Math.sqrt(5), "round", 1, "-", 1], ["@HSLA", [-8.9, "*", "@This 0", "-", 175], ["@This 0", "-", 23, "%", 9, "*", -1, "+", 4, "abs", "*", -18, "+", 100], [0.99, "^", ["@This 0", "-", 24], "*", 50], 1], "#e1efd0"]];
        MergeRules = [
            [3, [["@This 0", "-", 1, "=", "@Next 1 0"], "&&", ["@Next 2 0", "=", 1]], false, [[["@This 0", "+", 1]]], [[((1 + Math.sqrt(5))/2), "^", ["@This 0", "+", 3]], "-", [((1 + Math.sqrt(5))/-2), "^", ["@This 0", "*", -1, "-", 3]], "/", Math.sqrt(5), "round", 1, "-", 1], [false, true, true]],
            [2, [["@Next 1 0", "=", 1], "&&", ["@This 0", "=", 1], "&&", ["@NextNE -1 0", "!=", 2]], true, [[2]], 2, [false, true]]
        ];
        startTileSpawns = [[[1], 93], [[2], 5], [[3], 2]];
        winConditions = [[16]];
        winRequirement = 1;
        knownMergeMaxLength = 3;
        knownMergeLookbackDistance = 1;
        document.documentElement.style.setProperty("background-image", "radial-gradient(#8ab153 0%, #fff 150%)");
        document.documentElement.style.setProperty("--background-color", "#cbdfaf");
        document.documentElement.style.setProperty("--grid-color", "#7b905e");
        document.documentElement.style.setProperty("--tile-color", "#aac486");
        document.documentElement.style.setProperty("--text-color", "#373a30");
        displayRules("rules_text", ["h2", "Fibonacci Sequence Minus 1"], ["h1", "2583"], ["p", "Merges occur between two 1s or between any tile above 1, the tile before that tile, and a 1. Get to the 2583 tile to win!"],
        ["p", "Spawning tiles: 1 (93%), 2 (5%), 4 (2%)"]);
        displayRules("gm_rules_text", ["h2", "Fibonacci Sequence Minus 1"], ["h1", "2583"], ["p", "Merges occur between two 1s or between any tile above 1, the tile before that tile, and a 1. Get to the 2583 tile to win!"],
        ["p", "Spawning tiles: 1 (93%), 2 (5%), 4 (2%)"]);
    }
    else if (mode == 53) { // 2131
        // width = 4; height = 4;
        TileNumAmount = 2;
        TileTypes = [
            [[0, 1], 1, "#ffffff", "#2c1610"], [[0, 3], 2, "#a9a9a9", "#cff4d1"],
            [[1, 1], 3, "#7cb6f1", "#2c1610"], [[1, 2], 6, "#1180ef", "#cde6ff"], [[1, 3], 8, "#084684", "#cff4d1"],
            [[2, 1], 11, "#f8cd79", "#2c1610"], [[2, 2], 22, "#eaa316", "#cde6ff"], [[2, 3], 30, "#a07010", "#cff4d1"],
            [[3, 1], 41, "#92f280", "#2c1610"], [[3, 2], 82, "#32ea12", "#cde6ff"], [[3, 3], 112, "#2b9e17", "#cff4d1"],
            [[4, 1], 153, "#9a6ee2", "#2c1610"], [[4, 2], 306, "#6c23e0", "#cde6ff"], [[4, 3], 418, "#43168c", "#cff4d1"],
            [[5, 1], 571, "#e57ee9", "#2c1610"], [[5, 2], 1142, "#ed0af5", "#cde6ff"], [[5, 3], 1560, "#941198", "#cff4d1"],
            [[6, 1], 2131, "#f1846e", "#2c1610"], [[6, 2], 4262, "#df4122", "#cde6ff"], [[6, 3], 5822, "#a2331c", "#cff4d1"],
            [[7, 1], 7953, "#70dede", "#2c1610"], [[7, 2], 15906, "#1ad0d0", "#cde6ff"], [[7, 3], 21728, "#188f8f", "#cff4d1"],
            [[8, 1], 29681, "#eaea79", "#2c1610"], [[8, 2], 59362, "#e6e620", "#cde6ff"], [[8, 3], 81090, "#b5b525", "#cff4d1"],
            [["@This 1", "=", 1], [1, 1, "@end_vars", 1, "@repeat", "@This 0", "*", 4, "-", "@Var 0", "@edit_var", 0, "@Var 1", "@edit_var", 1, "@Parent -1", "@end-repeat"], ["@HSLA", [137, "*", "@This 0", "+", 160], [0.87, "^", ["@This 0", "-", 8], "*", 80], 70, 1], "#2c1610"],
            [["@This 1", "=", 2], [1, 1, "@end_vars", 1, "@repeat", "@This 0", "*", 4, "-", "@Var 0", "@edit_var", 0, "@Var 1", "@edit_var", 1, "@Parent -1", "@end-repeat", "*", 2], ["@HSLA", [137, "*", "@This 0", "+", 160], [0.87, "^", ["@This 0", "-", 8], "*", 80], 50, 1], "#cde6ff"],
            [["@This 1", "=", 3], [1, 1, "@end_vars", 1, "@repeat", "@This 0", "*", 4, "-", "@Var 0", "@edit_var", 0, "@Var 1", "@edit_var", 1, "@Parent -1", "@end-repeat", "*", 3, "-", "@Var 0"], ["@HSLA", [137, "*", "@This 0", "+", 160], [0.87, "^", ["@This 0", "-", 8], "*", 80], 30, 1], "#cff4d1"],
        ];
        MergeRules = [
            [2, [["@Next 1 0", "=", 0], "&&", ["@Next 1 1", "=", 1], "&&", ["@This 0", "=", 0], "&&", ["@This 1", "=", 1]], false, [[0, 3]], 2, [false, true]],
            [2, [["@Next 1 0", "=", "@This 0"], "&&", ["@This 0", ">", 0], "&&", ["@This 1", "=", 1], "&&", ["@Next 1 1", "=", 1]], true, [["@This 0", 2]], [1, 1, "@end_vars", 1, "@repeat", "@This 0", "*", 4, "-", "@Var 0", "@edit_var", 0, "@Var 1", "@edit_var", 1, "@Parent -1", "@end-repeat", "*", 2], [false, true]],
            [2, [["@Next 1 0", "+", 1, "=", "@This 0"], "&&", ["@This 1", "=", 2], "&&", ["@Next 1 1", "=", 3]], false, [["@This 0", 3]], [1, 1, "@end_vars", 1, "@repeat", "@This 0", "*", 4, "-", "@Var 0", "@edit_var", 0, "@Var 1", "@edit_var", 1, "@Parent -1", "@end-repeat", "*", 3, "-", "@Var 0"], [false, true]],
            [2, [["@Next 1 0", "=", "@This 0"], "&&", ["@This 1", "=", 3], "&&", ["@Next 1 1", "=", 1]], false, [[["@This 0", "+", 1], 1]], [1, 1, "@end_vars", 1, "@repeat", ["@This 0", "+", 1], "*", 4, "-", "@Var 0", "@edit_var", 0, "@Var 1", "@edit_var", 1, "@Parent -1", "@end-repeat"], [false, true]],
        ];
        startTileSpawns = [[[0, 1], 85], [[0, 3], 10], [[1, 1], 5]];
        winConditions = [[6, 1]];
        winRequirement = 1;
        knownMergeMaxLength = 2;
        knownMergeLookbackDistance = 0;
        document.documentElement.style.setProperty("background-image", "radial-gradient(#b92500 0%, #fff 150%)");
        document.documentElement.style.setProperty("--background-color", "#f4b6a6");
        document.documentElement.style.setProperty("--grid-color", "#843b29");
        document.documentElement.style.setProperty("--tile-color", "#ba715e");
        document.documentElement.style.setProperty("--text-color", "#2c1610");
        displayRules("rules_text", ["h1", "2131"], ["p", "Merges occur between two equal tiles that are an odd number, or between an even number tile and the tile two before it. Get to the 2131 tile to win!"],
        ["p", "Spawning tiles: 1 (85%), 2 (10%), 3 (5%)"]);
        displayRules("gm_rules_text", ["h1", "2131"], ["p", "Merges occur between two equal tiles that are an odd number, or between an even number tile and the tile two before it. Get to the 2131 tile to win!"],
        ["p", "Spawning tiles: 1 (85%), 2 (10%), 3 (5%)"]);
    }
    else if (mode == 54) { // 3888
        // width = 4; height = 4;
        TileNumAmount = 2;
        mode_vars = [0, 16]; // The first entry controls the random goals, the second entry is the minimum for the first random goal
        start_game_vars = [[0, 0], 0, false, 0, 16, 0] // The first entry is the current random goal, the second entry is the amount of random goals met so far, the third entry is whether a random goal has been met this turn, the fourth entry is a random number used to randomize the random goals, and the fifth entry is the minimum for the first random goal. Sixth entry controls the display of Discovered Tiles.
        TileTypes = [
            [[0, 0], 1, "#000000", "#ffffff"],
            [["@This 0", "+", "@This 1", "<", 4], [[2, "^", "@This 0"], "*", [3, "^", "@This 1"]], ["@HSLA", [-300, "*", "@This 1", "/", ["@This 0", "+", "@This 1"]], 100, ["@This 0", "+", "@This 1", "*", 12.5], 1], "#ffffff"],
            [["@This 0", "+", "@This 1", ">=", 4], [[2, "^", "@This 0"], "*", [3, "^", "@This 1"]], ["@HSLA", [-300, "*", "@This 1", "/", ["@This 0", "+", "@This 1"]], 100, [0.75, "^", ["@This 0", "+", "@This 1", "-", 4], "*", -45, "+", 95], 1], "#000000"]
        ];
        MergeRules = [
            [2, [["@Next 1 0", "=", 0], "&&", ["@Next 1 1", "=", 0], "&&", ["@This 0", "=", 0], "&&", ["@This 1", "=", 0]], false, [[1, 0]], 2, [false, true]],
            [2, [["@This 0", "+", 1, "=", "@Next 1 0"], "&&", ["@This 1", "=", "@Next 1 1"]], false, [["@This 0", ["@This 1", "+", 1]]], [[2, "^", "@This 0"], "*", [3, "^", "@This 1"], "*", 3], [false, true]],
            [2, [["@This 0", "=", "@Next 1 0"], "&&", ["@This 1", "+", 1, "=", "@Next 1 1"]], false, [[["@This 0", "+", 2], "@This 1"]], [[2, "^", "@This 0"], "*", [3, "^", "@This 1"], "*", 4], [false, true]]
        ];
        startTileSpawns = [[[0, 0], 100]];
        winConditions = [[4, 5]];
        winRequirement = 1;
        knownMergeMaxLength = 2;
        knownMergeLookbackDistance = 0;
        document.documentElement.style.setProperty("background-image", "radial-gradient(#3399ff 0%, #ffffb6 70%, #fff 140%)");
        document.documentElement.style.setProperty("--background-color", "radial-gradient(#ffff8e 0% 40%, #9ecfff)");
        document.documentElement.style.setProperty("--grid-color", "#2f6398");
        document.documentElement.style.setProperty("--tile-color", "#dbdb86");
        document.documentElement.style.setProperty("--text-color", "#362020");
        displayRules("rules_text", ["h2", "Powers of 2 Times Powers of 3"], ["h1", "3888"], ["p", "Two 1s can merge into a 2, and merges occur between any tile and a tile that's exactly double that tile or triple that tile. Get to the 3888 tile to win!"],
        ["p", "Spawning tiles: 1 (100%)"]);
        displayRules("gm_rules_text", ["h2", "Powers of 2 Times Powers of 3"], ["h1", "3888"], ["p", "Two 1s can merge into a 2, and merges occur between any tile and a tile that's exactly double that tile or triple that tile. Get to the 3888 tile to win!"],
        ["p", "Spawning tiles: 1 (100%)"]);
        statBoxes = [["Discovered Tiles", ["@DiscTiles", "arr_length"], false, ...[,,,], ["@GVar 5", "=", 0], [0, "@edit_gvar", 5, 1], true], ["Discovered Tiles", ["@DiscTiles"], true, false, "TileArray", "Self", ["@GVar 5", "=", 1], [0, "@edit_gvar", 5, 0], true], ["Score", "@Score"]];
        document.getElementById("mode_vars_line").style.setProperty("display", "block");
        document.getElementById("3888_vars").style.setProperty("display", "flex");
    }
    else if (mode == 55) { // 2000
        // width = 5; height = 5;
        TileNumAmount = 2;
        mode_vars = [0, 25]; // The first entry controls the random goals, the second entry is the minimum for the first random goal
        start_game_vars = [[0, 0], 0, false, 0, 25, 0] // The first entry is the current random goal, the second entry is the amount of random goals met so far, the third entry is whether a random goal has been met this turn, the fourth entry is a random number used to randomize the random goals, and the fifth entry is the minimum for the first random goal. Sixth entry controls the display of Discovered Tiles.
        TileTypes = [
            [[0, 0], 1, "#000000", "#ffffff"],
            [["@This 0", "+", "@This 1", "<", 4], [[2, "^", "@This 0"], "*", [5, "^", "@This 1"]], ["@HSLA", [300, "*", "@This 1", "/", ["@This 0", "+", "@This 1"], "-", 60], 100, ["@This 0", "+", "@This 1", "*", 12.5], 1], "#ffffff"],
            [["@This 0", "+", "@This 1", ">=", 4], [[2, "^", "@This 0"], "*", [5, "^", "@This 1"]], ["@HSLA", [300, "*", "@This 1", "/", ["@This 0", "+", "@This 1"], "-", 60], 100, [0.75, "^", ["@This 0", "+", "@This 1", "-", 4], "*", -45, "+", 95], 1], "#000000"]
        ];
        MergeRules = [
            [2, [["@Next 1 0", "=", 0], "&&", ["@Next 1 1", "=", 0], "&&", ["@This 0", "=", 0], "&&", ["@This 1", "=", 0]], false, [[1, 0]], 2, [false, true]],
            [2, [["@Next 1 0", "=", 1], "&&", ["@Next 1 1", "=", 0], "&&", ["@This 0", "=", 1], "&&", ["@This 1", "=", 0]], false, [[2, 0]], 4, [false, true]],
            [2, [["@This 0", "+", 2, "=", "@Next 1 0"], "&&", ["@This 1", "=", "@Next 1 1"]], false, [["@This 0", ["@This 1", "+", 1]]], [[2, "^", "@This 0"], "*", [5, "^", "@This 1"], "*", 5], [false, true]],
            [3, [["@This 0", "+", 1, "=", "@Next 1 0"], "&&", ["@This 1", "=", "@Next 1 1"], "&&", ["@This 0", "=", "@Next 2 0"], "&&", ["@This 1", "+", 1, "=", "@Next 2 1"]], false, [[["@This 0", "+", 3], "@This 1"]], [[2, "^", "@This 0"], "*", [5, "^", "@This 1"], "*", 8], [false, true]]
        ];
        startTileSpawns = [[[0, 0], 100]];
        winConditions = [[4, 3]];
        winRequirement = 1;
        knownMergeMaxLength = 3;
        knownMergeLookbackDistance = 0;
        document.documentElement.style.setProperty("background-image", "radial-gradient(#99ff33 0%, #ffb8ff 70%, #fff 140%)");
        document.documentElement.style.setProperty("--background-color", "radial-gradient(#ff8fff 0% 40%, #cfff9e)");
        document.documentElement.style.setProperty("--grid-color", "#5d8833");
        document.documentElement.style.setProperty("--tile-color", "#eea8ee");
        document.documentElement.style.setProperty("--text-color", "#202037");
        displayRules("rules_text", ["h2", "Powers of 2 Times Powers of 5"], ["h1", "2000"], ["p", "Two 1s can merge into a 2 and two 2s can merge into a 4. Merges occur between any tile and a tile that's exactly quadruple that tile, or between any tile, a tile that's double that tile, and a tile that's quintuple that tile. Get to the 2000 tile to win!"],
        ["p", "Spawning tiles: 1 (100%)"]);
        displayRules("gm_rules_text", ["h2", "Powers of 2 Times Powers of 5"], ["h1", "2000"], ["p", "Two 1s can merge into a 2 and two 2s can merge into a 4. Merges occur between any tile and a tile that's exactly quadruple that tile, or between any tile, a tile that's double that tile, and a tile that's quintuple that tile. Get to the 2000 tile to win!"],
        ["p", "Spawning tiles: 1 (100%)"]);
        statBoxes = [["Discovered Tiles", ["@DiscTiles", "arr_length"], false, ...[,,,], ["@GVar 5", "=", 0], [0, "@edit_gvar", 5, 1], true], ["Discovered Tiles", ["@DiscTiles"], true, false, "TileArray", "Self", ["@GVar 5", "=", 1], [0, "@edit_gvar", 5, 0], true], ["Score", "@Score"]];
        document.getElementById("mode_vars_line").style.setProperty("display", "block");
        document.getElementById("2000_vars").style.setProperty("display", "flex");
    }
    else if (mode == 56) { // 3645
        // width = 5; height = 5;
        TileNumAmount = 2;
        mode_vars = [0, 75]; // The first entry controls the random goals, the second entry is the minimum for the first random goal
        start_game_vars = [[0, 0], 0, false, 0, 75, 0] // The first entry is the current random goal, the second entry is the amount of random goals met so far, the third entry is whether a random goal has been met this turn, the fourth entry is a random number used to randomize the random goals, and the fifth entry is the minimum for the first random goal. Sixth entry controls the display of Discovered Tiles.
        TileTypes = [
            [[0, 0], 1, "#000000", "#ffffff"],
            [["@This 0", "+", "@This 1", "<", 4], [[3, "^", "@This 0"], "*", [5, "^", "@This 1"]], ["@HSLA", [-300, "*", "@This 1", "/", ["@This 0", "+", "@This 1"], "+", 120], 100, ["@This 0", "+", "@This 1", "*", 12.5], 1], "#ffffff"],
            [["@This 0", "+", "@This 1", ">=", 4], [[3, "^", "@This 0"], "*", [5, "^", "@This 1"]], ["@HSLA", [-300, "*", "@This 1", "/", ["@This 0", "+", "@This 1"], "+", 120], 100, [0.75, "^", ["@This 0", "+", "@This 1", "-", 4], "*", -45, "+", 95], 1], "#000000"]
        ];
        MergeRules = [
            [3, [["@Next 1 0", "=", 0], "&&", ["@Next 1 1", "=", 0], "&&", ["@This 0", "=", 0], "&&", ["@This 1", "=", 0], "&&", ["@Next 2 0", "=", 0], "&&", ["@Next 2 1", "=", 0]], false, [[1, 0]], 3, [false, true]],
            [3, [["@This 0", "+", 1, "=", "@Next 1 0"], "&&", ["@This 1", "=", "@Next 1 1"], "&&", ["@This 0", "=", "@Next 2 0"], "&&", ["@This 1", "=", "@Next 2 1"]], false, [["@This 0", ["@This 1", "+", 1]]], [[3, "^", "@This 0"], "*", [5, "^", "@This 1"], "*", 5], [false, true]],
            [3, [["@This 0", "+", 1, "=", "@Next 1 0"], "&&", ["@This 1", "=", "@Next 1 1"], "&&", ["@This 0", "=", "@Next 2 0"], "&&", ["@This 1", "+", 1, "=", "@Next 2 1"]], false, [[["@This 0", "+", 2], "@This 1"]], [[3, "^", "@This 0"], "*", [5, "^", "@This 1"], "*", 9], [false, true]]
        ];
        startTileSpawns = [[[0, 0], 100]];
        winConditions = [[5, 1]];
        winRequirement = 1;
        knownMergeMaxLength = 3;
        knownMergeLookbackDistance = 0;
        document.documentElement.style.setProperty("background-image", "radial-gradient(#ff3399 0%, #b8ffff 70%, #fff 140%)");
        document.documentElement.style.setProperty("--background-color", "radial-gradient(#8fffff 0% 40%, #ff9ecf)");
        document.documentElement.style.setProperty("--grid-color", "#6b2548");
        document.documentElement.style.setProperty("--tile-color", "#8bd5d5");
        document.documentElement.style.setProperty("--text-color", "#203720");
        displayRules("rules_text", ["h2", "Powers of 3 Times Powers of 5"], ["h1", "3645"], ["p", "Three 1s can merge into a 3. Merges occur between two equal tiles and a tile that's triple those tiles, or between any tile, a tile that's triple that tile, and a tile that's quintuple that tile. Get to the 3645 tile to win!"],
        ["p", "Spawning tiles: 1 (100%)"]);
        displayRules("gm_rules_text", ["h2", "Powers of 3 Times Powers of 5"], ["h1", "3645"], ["p", "Three 1s can merge into a 3. Merges occur between two equal tiles and a tile that's triple those tiles, or between any tile, a tile that's triple that tile, and a tile that's quintuple that tile. Get to the 3645 tile to win!"],
        ["p", "Spawning tiles: 1 (100%)"]);
        statBoxes = [["Discovered Tiles", ["@DiscTiles", "arr_length"], false, ...[,,,], ["@GVar 5", "=", 0], [0, "@edit_gvar", 5, 1], true], ["Discovered Tiles", ["@DiscTiles"], true, false, "TileArray", "Self", ["@GVar 5", "=", 1], [0, "@edit_gvar", 5, 0], true], ["Score", "@Score"]];
        document.getElementById("mode_vars_line").style.setProperty("display", "block");
        document.getElementById("3645_vars").style.setProperty("display", "flex");
    }
    else if (mode == 57) { // 2700
        // width = 5; height = 5;
        TileNumAmount = 3;
        mode_vars = [1, 1, 0]; // First entry is the level, second entry controls the allowed special merges on Level 3
        start_game_vars = [0]; // Controls the display of Discovered Tiles
        TileTypes = [
            [[0, 0, 0], 1, "#000000", "#ffffff"],
            [[["@This 0", "=", "@This 1"], "&&", ["@This 0", "=", "@This 2"]], [[2, "^", "@This 0"], "*", [3, "^", "@This 1"], "*", [5, "^", "@This 2"]], ["@HSLA", 0, 0, [0, "@if", ["@This 0", "+", "@This 1", "+", "@This 2", "<", 4], "2nd", "@This 0", "+", "@This 1", "+", "@This 2", "*", 10, "@end-if", "@else", "2nd", 0.75, "^", ["@This 0", "+", "@This 1", "+", "@This 2", "-", 4], "*", -45, "+", 95, "@end-else"], 1], ["@HSLA", ["@This 0", "+", "@This 1", "+", "@This 2", "%", 2, "*", 120], 100, [85, "@if", ["@This 0", "+", "@This 1", "+", "@This 2", ">=", 4], "2nd", 15, "@end-if"], 1]],
            [[["@This 2", "<=", "@This 0"], "&&", ["@This 2", "<=", "@This 1"]], [[2, "^", "@This 0"], "*", [3, "^", "@This 1"], "*", [5, "^", "@This 2"]], ["@HSLA", [120, "*", ["@This 1", "-", "@This 2"], "/", ["@This 2", "*", -2, "+", "@This 0", "+", "@This 1"]], [0.7, "^", "@This 2", "*", 100], [0, "@if", ["@This 0", "+", "@This 1", "+", "@This 2", "<", 4], "2nd", "@This 0", "+", "@This 1", "+", "@This 2", "*", 10, "@end-if", "@else", "2nd", 0.75, "^", ["@This 0", "+", "@This 1", "+", "@This 2", "-", 4], "*", -45, "+", 95, "@end-else"], 1], ["@HSLA", ["@This 0", "+", "@This 1", "+", "@This 2", "%", 2, "*", 120], 100, [85, "@if", ["@This 0", "+", "@This 1", "+", "@This 2", ">=", 4], "2nd", 15, "@end-if"], 1]],
            [[["@This 1", "<=", "@This 0"], "&&", ["@This 1", "<=", "@This 2"]], [[2, "^", "@This 0"], "*", [3, "^", "@This 1"], "*", [5, "^", "@This 2"]], ["@HSLA", [120, "*", ["@This 0", "-", "@This 1"], "/", ["@This 1", "*", -2, "+", "@This 0", "+", "@This 2"], "+", 240], [0.7, "^", "@This 1", "*", 100], [0, "@if", ["@This 0", "+", "@This 1", "+", "@This 2", "<", 4], "2nd", "@This 0", "+", "@This 1", "+", "@This 2", "*", 10, "@end-if", "@else", "2nd", 0.75, "^", ["@This 0", "+", "@This 1", "+", "@This 2", "-", 4], "*", -45, "+", 95, "@end-else"], 1], ["@HSLA", ["@This 0", "+", "@This 1", "+", "@This 2", "%", 2, "*", 120], 100, [85, "@if", ["@This 0", "+", "@This 1", "+", "@This 2", ">=", 4], "2nd", 15, "@end-if"], 1]],
            [[["@This 0", "<=", "@This 1"], "&&", ["@This 0", "<=", "@This 2"]], [[2, "^", "@This 0"], "*", [3, "^", "@This 1"], "*", [5, "^", "@This 2"]], ["@HSLA", [120, "*", ["@This 2", "-", "@This 0"], "/", ["@This 0", "*", -2, "+", "@This 1", "+", "@This 2"], "+", 120], [0.7, "^", "@This 0", "*", 100], [0, "@if", ["@This 0", "+", "@This 1", "+", "@This 2", "<", 4], "2nd", "@This 0", "+", "@This 1", "+", "@This 2", "*", 10, "@end-if", "@else", "2nd", 0.75, "^", ["@This 0", "+", "@This 1", "+", "@This 2", "-", 4], "*", -45, "+", 95, "@end-else"], 1], ["@HSLA", ["@This 0", "+", "@This 1", "+", "@This 2", "%", 2, "*", 120], 100, [85, "@if", ["@This 0", "+", "@This 1", "+", "@This 2", ">=", 4], "2nd", 15, "@end-if"], 1]]
        ];
        MergeRules = [
            [2, [["@This 0", "=", 0], "&&", ["@This 1", "=", 0], "&&", ["@This 2", "=", 0], "&&", ["@Next 1 0", "=", 0], "&&", ["@Next 1 1", "=", 0], "&&", ["@Next 1 2", "=", 0]], true, [[1, 0, 0]], 2, [false, true]],
            [2, [["@This 0", "+", 1, "=", "@Next 1 0"], "&&", ["@This 1", "=", "@Next 1 1"], "&&", ["@This 2", "=", "@Next 1 2"]], false, [["@This 0", ["@This 1", "+", 1], "@This 2"]], [[2, "^", "@This 0"], "*", [3, "^", "@This 1"], "*", [5, "^", "@This 2"], "*", 3], [false, true]],
            [2, [["@This 0", "=", "@Next 1 0"], "&&", ["@This 1", "+", 1, "=", "@Next 1 1"], "&&", ["@This 2", "=", "@Next 1 2"]], false, [[["@This 0", "+", 2], "@This 1", "@This 2"]], [[2, "^", "@This 0"], "*", [3, "^", "@This 1"], "*", [5, "^", "@This 2"], "*", 4], [false, true]],
            [2, [["@This 0", "+", 1, "=", "@Next 1 0"], "&&", ["@This 1", "-", 1, "=", "@Next 1 1"], "&&", ["@This 2", "=", "@Next 1 2"]], false, [["@This 0", ["@This 1", "-", 1], ["@This 2", "+", 1]]], [[2, "^", "@This 0"], "*", [3, "^", ["@This 1", "-", 1]], "*", [5, "^", "@This 2"], "*", 5], [false, true]],
            [2, [["@This 0", "=", "@Next 1 0"], "&&", ["@This 1", "-", 1, "=", "@Next 1 1"], "&&", ["@This 2", "+", 1, "=", "@Next 1 2"]], false, [[["@This 0", "+", 3], ["@This 1", "-", 1], "@This 2"]], [[2, "^", "@This 0"], "*", [3, "^", ["@This 1", "-", 1]], "*", [5, "^", "@This 2"], "*", 8], [false, true]]
        ];
        startTileSpawns = [[[0, 0, 0], 100]];
        winConditions = [[2, 3, 2]];
        winRequirement = 1;
        knownMergeMaxLength = 2;
        knownMergeLookbackDistance = 0;
        document.documentElement.style.setProperty("background-image", "linear-gradient(#fff, #bbf, #9f9, #f77, #b0ff70 10%, #319761, #b0ff70 90%, #f77, #9f9, #bbf, #fff)");
        document.documentElement.style.setProperty("--background-color", "linear-gradient(90deg, #fff, #ddf, #bfb, #faa, #d3ffaf 10%, #80c8a1, #d3ffaf 90%, #faa, #bfb, #ddf, #fff)");
        document.documentElement.style.setProperty("--grid-color", "#1f781f");
        document.documentElement.style.setProperty("--tile-color", "#a1a1d1");
        document.documentElement.style.setProperty("--text-color", "#571d1d");
        displayRules("rules_text", ["h2", "Powers of 2 Times Powers of 3 Times Powers of 5"], ["h1", "2700 (Level 1)"], ["p", "Two 1s can merge into a 2. Merges occur between any tile and a tile that's double or triple it, between a 2n tile and a 3n tile (for the same n), or between a 3n tile and a 5n tile (for the same n). Get to the 2700 tile to win!"],
        ["p", "Spawning tiles: 1 (100%)"]);
        displayRules("gm_rules_text", ["h2", "Powers of 2 Times Powers of 3 Times Powers of 5"], ["h1", "2700 (Level 1)"], ["p", "Two 1s can merge into a 2. Merges occur between any tile and a tile that's double or triple it, between a 2n tile and a 3n tile (for the same n), or between a 3n tile and a 5n tile (for the same n). Get to the 2700 tile to win! (This level fits best on a 4x4 grid)"],
        ["p", "Spawning tiles: 1 (100%)"]);
        statBoxes = [["Discovered Tiles", ["@DiscTiles", "arr_length"], false, ...[,,,], ["@GVar 0", "=", 0], [0, "@edit_gvar", 0, 1], true], ["Discovered Tiles", ["@DiscTiles"], true, false, "TileArray", "Self", ["@GVar 0", "=", 1], [0, "@edit_gvar", 0, 0], true], ["Score", "@Score"]];
        document.getElementById("mode_vars_line").style.setProperty("display", "block");
        document.getElementById("2700_vars").style.setProperty("display", "flex");
    }
    else if (mode == 58) { // 10
        // width = 5; height = 5;
        TileNumAmount = 2;
        TileTypes = [
            [[1, 1], 1, "#ff6767", "#313625"], [[1, -1], -1, "#990000", "#ecf1e0"],
            [[2, 1], 2, "#ffb366", "#313625"], [[2, -1], -2, "#994d00", "#ecf1e0"],
            [[3, 1], 3, "#ffff66", "#313625"], [[3, -1], -3, "#999900", "#ecf1e0"],
            [[4, 1], 4, "#66ff66", "#313625"], [[4, -1], -4, "#009900", "#ecf1e0"],
            [[5, 1], 5, "#66adff", "#313625"], [[5, -1], -5, "#004799", "#ecf1e0"],
            [[6, 1], 6, "#bf66ff", "#313625"], [[6, -1], -6, "#590099", "#ecf1e0"],
            [[7, 1], 7, "#ff66ff", "#313625"], [[7, -1], -7, "#990099", "#ecf1e0"],
            [[8, 1], 8, "#ff9166", "#313625"], [[8, -1], -8, "#992b00", "#ecf1e0"],
            [[9, 1], 9, "#ffd966", "#313625"], [[9, -1], -9, "#997300", "#ecf1e0"],
            [[10, 1], 10, "#d3ff64", "#313625"], [[10, -1], -10, "#6e9a00", "#ecf1e0"],
            [[11, 1], 11, "#66ffc2", "#313625"], [[11, -1], -11, "#00995c", "#ecf1e0"],
            [[12, 1], 12, "#66ebff", "#313625"], [[12, -1], -12, "#008599", "#ecf1e0"],
            [[13, 1], 13, "#6666ff", "#313625"], [[13, -1], -13, "#000099", "#ecf1e0"],
            [[14, 1], 14, "#d966ff", "#313625"], [[14, -1], -14, "#730099", "#ecf1e0"],
            [[15, 1], 15, "#ff66b3", "#313625"], [[15, -1], -15, "#99004d", "#ecf1e0"],
            [["@This 1", "=", 1], ["@This 0"], ["@HSLA", [49, "*", "@This 0", "-", 777], 100, [0.97, "^", ["@This 0", "-", 16], "*", -20, "+", 100], 1], "#313625"],
            [["@This 1", "=", -1], ["@This 0", "*", -1], ["@HSLA", [49, "*", "@This 0", "-", 777], 100, [0.97, "^", ["@This 0", "-", 16], "*", 20], 1], "#ecf1e0"]
        ];
        MergeRules = [
            [2, [["@Next 1 1", "=", "@This 1"], "&&", ["@This 0", "=", 1], "&&", ["@Next 1 0", "=", 1]], true, [[2, "@This 1"]], 2, [false, true]],
            [3, [["@Next 1 1", "=", "@This 1"], "&&", ["@Next 1 0", "=", "@This 0"], "&&", ["@Next 2 1", "!=", "@This 1"], "&&", ["@Next 2 0", "+", 1, "=", "@This 0"]], false, [[["@This 0", "+", 1], "@This 1"]], ["@This 0", "+", 1], [false, true, true]]
        ];
        if (modifiers[13] == "Interacting") MergeRules.push([2, [["@Next 1 1", "!=", "@This 1"], "&&", ["@Next 1 0", "=", "@This 0"]], true, [], 0, [true, true]])
        startTileSpawns = [[[1, 1], 50], [[1, -1], 50]];
        winConditions = [[10, 1], [-10, 1]];
        if (modifiers[13] == "None") winRequirement = 1;
        else winRequirement = 2;
        knownMergeMaxLength = 3;
        knownMergeLookbackDistance = 0;
        document.documentElement.style.setProperty("background-image", "radial-gradient(#d2ff72 0%, #000 150%)");
        document.documentElement.style.setProperty("--background-color", "linear-gradient(#dcff91, #314800)");
        document.documentElement.style.setProperty("--grid-color", "#accc67");
        document.documentElement.style.setProperty("--tile-color", "#789240");
        document.documentElement.style.setProperty("--text-color", "#2a3217");
        displayRules("rules_text", ["h1", "10"], ["p", "There are both positive and negative tiles. Two 1s of either sign can merge into a 2 of that sign, and merges occur between two equal tiles and one tile of the opposite sign with an absolute value 1 smaller than the other two tiles. Get to the 10 (or -10) tile to win!"],
        ["p", "Spawning tiles: 1 (50%), -1 (50%)"]);
        displayRules("gm_rules_text", ["h1", "10"], ["p", "There are both positive and negative tiles. Two 1s of either sign can merge into a 2 of that sign, and merges occur between two equal tiles and one tile of the opposite sign with an absolute value 1 smaller than the other two tiles. Get to the 10 (or -10) tile to win!"],
        ["p", "Spawning tiles: 1 (50%), -1 (50%)"]);
    }
    else if (mode == 59) { // 1825
        // width = 5; height = 5;
        TileNumAmount = 2;
        mode_vars = [0, 3]; // The first entry controls the random goals, the second entry controls the size of the first random goal
        start_game_vars = [2, 0, false, 3, 0, 0] // The first entry is the current random goal, the second entry is the amount of random goals met so far, the third entry is whether a random goal has been met this turn, and the fourth entry is the first random goal minimum. The fifth entry controls the display of Discovered Tiles, and the sixth entry controls the display of Discovered Multiples of 8
        TileTypes = [
            [["@This 1", "=", 1], ["@This 0"], "#ffffff", ["#323136", "@if", ["@This 0", "expomod", 2, ">=", 2], "2nd", "#625893", "@end-if"], "none", 0, 0, ["PrimeImage", ["@ColorScheme", "1321", "@This 0"], ["@radial-gradient", "#000", "#0000"]]],
            [["@This 1", "=", -1], ["@This 0", "*", -1], "#000000", ["#e2def9", "@if", ["@This 0", "expomod", 2, ">=", 2], "2nd", "#625893", "@end-if"], "none", 0, 0, ["PrimeImage", ["@ColorScheme", "1321", "@This 0"], ["@radial-gradient", "#000", "#0000"]]],
        ];
        MergeRules = [
            [2, [["@This 0", "=", "@Next 1 0"], "&&", ["@This 1", "=", "@Next 1 1"], "&&", ["@This 0", "expomod", 2, "<", 2]], true, [[["@This 0", "+", "@Next 1 0"], "@This 1"]], ["@This 0", "+", "@Next 1 0"], [false, true]],
            [2, [["@This 1", "!=", "@Next 1 1"], "&&", ["@This 0", ">", "@Next 1 0"], "&&", ["@This 0", "expomod", 2, ">=", 2]], false, [[["@This 0", "-", "@Next 1 0"], "@This 1"]], ["@This 0", "-", "@Next 1 0"], [false, true]]
        ];
        if (modifiers[13] == "Interacting") MergeRules.push([2, [["@This 0", "=", "@Next 1 0"], "&&", ["@This 1", "!=", "@Next 1 1"]], true, [], 0, [true, true]])
        startTileSpawns = [[[1, 1], 50], [[1, -1], 50]];
        winConditions = [[1825, 1], [1825, -1]];
        if (modifiers[13] == "None") winRequirement = 1;
        else winRequirement = 2;
        knownMergeMaxLength = 2;
        knownMergeLookbackDistance = 0;
        document.documentElement.style.setProperty("background-image", "radial-gradient(#e1ddee 0%, #e1ddee88 75%, #0000 100%), conic-gradient(#fff, #ccc 70deg, #444 110deg, #000, #444 250deg, #ccc 290deg, #fff)");
        document.documentElement.style.setProperty("--background-color", "radial-gradient(#e1ddee 0%, #e1ddee88 80%, #0000 100%), linear-gradient(#fff, #000)");
        document.documentElement.style.setProperty("--grid-color", "#474356");
        document.documentElement.style.setProperty("--tile-color", "#cac4de");
        document.documentElement.style.setProperty("--text-color", "#1c1926");
        displayRules("rules_text", ["h1", "1825"], ["p", "There are both positive and negative tiles. Merges occur between two equal tiles that are not a multiple of four, or between a tile that is a multiple of four and a tile of opposite sign and smaller absolute value to the first one. Get to the 1825 tile to win (your first task is figuring out how to get there...). If you're looking for a different kind of challenge, see if you can make any multiples of 8..."],
        ["p", "Spawning tiles: 1 (50%), -1 (50%)"]);
        displayRules("gm_rules_text", ["h1", "1825"], ["p", "There are both positive and negative tiles. Merges occur between two equal tiles that are not a multiple of four, or between a tile that is a multiple of four and a tile of opposite sign and smaller absolute value to the first one. Get to the 1825 tile to win (your first task is figuring out how to get there...). If you're looking for a different kind of challenge, see if you can make any multiples of 8..."],
        ["p", "Spawning tiles: 1 (50%), -1 (50%)"]);
        statBoxes = [["Discovered Tiles", ["@DiscTiles", "arr_length"], false, ...[,,,], ["@GVar 4", "=", 0], [0, "@edit_gvar", 4, 1], true], ["Discovered Tiles", ["@DiscTiles"], true, false, "TileArray", "Self", ["@GVar 4", "=", 1], [0, "@edit_gvar", 4, 0], true], ["Score", "@Score"], ["Discovered Multiples of 8", ["@DiscTiles", "arr_reduce", 0, ["@if", ["@var_retain", "@Var -1", "arr_elem", "0", "expomod", 2, ">=", 3], "+", 1, "@end-if"]], false, ...[,,,], ["@GVar 5", "=", 0], [0, "@edit_gvar", 5, 1], true], ["Discovered Multiples of 8", ["@DiscTiles", "arr_filter", ["@Var -1", "arr_elem", "0", "expomod", 2, ">=", 3]], true, false, "TileArray", "Self", ["@GVar 5", "=", 1], [0, "@edit_gvar", 5, 0], true]];
        document.getElementById("mode_vars_line").style.setProperty("display", "block");
        document.getElementById("1825_vars").style.setProperty("display", "flex");
    }
    else if (mode == 60) { // 2295
        // width = 4; height = 4;
        TileNumAmount = 1;
        start_game_vars = [1] // The merge ratio
        TileTypes = [
            [true, "@This 0", "@ColorScheme", "2295", ["@This 0"]]
        ];
        if (modifiers[13] == "Interacting") {
            MergeRules = [
                [2, ["@This 0", "*", -1, "=", "@Next 1 0", "&&", ["@GVar 0", "=", 1]], true, [], 0, [true, true]],
                [2, [["@This 0", "abs"], "*", "@GVar 0", "=", ["@Next 1 0", "abs"]], false, [[["@This 0", "+", "@Next 1 0"]]], ["@This 0", "+", "@Next 1 0", "abs"], [false, true]]
            ];
        }
        else {
            MergeRules = [
                [2, ["@This 0", "*", "@GVar 0", "=", "@Next 1 0"], false, [[["@This 0", "+", "@Next 1 0"]]], ["@This 0", "+", "@Next 1 0"], [false, true]]
            ];
        }
        if (modifiers[13] == "None") {
            startTileSpawns = [[[1], 100]];
            winConditions = [[2295]];
            winRequirement = 1;
        }
        else {
            startTileSpawns = [[[1], 100 * modifiers[22]], [[-1], 100 * modifiers[23]]];
            winConditions = [[2295], [-2295]];
            winRequirement = 2;
        }
        mergeResultKnownLevel = 0;
        document.documentElement.style.setProperty("background-image", "linear-gradient(90deg, #80ffaa, #80d5ff, #f480ff)");
        document.documentElement.style.setProperty("--background-color", "linear-gradient(#dcffe8, #dcffe8, #d4f1ff, #d4f1ff, #fbceff, #fbceff)");
        document.documentElement.style.setProperty("--grid-color", "#4bcd76");
        document.documentElement.style.setProperty("--tile-color", "#d87ee0");
        document.documentElement.style.setProperty("--text-color", "#106793");
        displayRules("rules_text", ["h1", "2295"], ["p", "On odd-numbered turns, two equal tiles merge. On turns that are even but not a multiple of 4, a merge occurs between any tile and a tile that's double it. On turns that are multiples of 4 but not of 8, a merge occurs between any tile and a tile that's 4 times it. On turns that are multiples of 8 but not of 16, a merge occurs between any tile and a tile that's 8 times it. This pattern continues for all higher powers of 2. Get to the 2295 tile to win!"],
        ["p", "Spawning tiles: 1 (100%)"]);
        displayRules("gm_rules_text", ["h1", "2295"], ["p", "On odd-numbered turns, two equal tiles merge. On turns that are even but not a multiple of 4, a merge occurs between any tile and a tile that's double it. On turns that are multiples of 4 but not of 8, a merge occurs between any tile and a tile that's 4 times it. On turns that are multiples of 8 but not of 16, a merge occurs between any tile and a tile that's 8 times it. This pattern continues for all higher powers of 2. Get to the 2295 tile to win!"],
        ["p", "Spawning tiles: 1 (100%)"]);
        statBoxes = [["Turn Number", ["@Moves", "+", 1]], ["1s Merge With:", "@GVar 0"], ["Score", "@Score"]];
        scripts = [
            [[0, "@edit_gvar", 0, [2, "^", ["@Moves", "+", 1, "expomod", 2]]], "EndTurn"]
        ];
    }
    else if (mode == 61) { // 3069
        // width = 4; height = 4;
        TileNumAmount = 1; // This is kind of a lie. Tiles in this mode do only have one entry, but that entry is itself an array.
        mode_vars = [0, 4n, false] // mode_vars[0] is the random goals setting, mode_vars[1] is the minimum of the first random goal. mode_vars[2] switches between regular and odds-only.
        start_game_vars = [["@Literal"], [1n], 0, false, 4n, 0] // game_vars[0] is a storage used to make merges more efficient, game_vars[1] is the current random goal, game_vars[2] is the amount of random goals completed, game_vars[3] is whether the goal was finished this turn, and game_vars[4] is the minimum of the first random goal. game_vars[5] controls the display of Discovered Tiles.
        TileTypes = [
            [true, ["@This 0", "arr_reduce", 1n, ["*B", ["@var_retain", "@Var -1", "prime"]]], "@ColorScheme", "3069", [["@This 0", "arr_reduce", 1n, ["*B", ["@var_retain", "@Var -1", "prime"]]]]]
        ];
        MergeRules = [
            [2, ["@This 0", "=", "@Next 1 0"], false, [[["@This 0", "arr_unshift", 1n]]], ["@This 0", "arr_reduce", 1n, ["*B", ["@var_retain", "@Var -1", "prime"]], "*B", 2n, "Number"], [false, true]],
            [2, ["@This 0", [["@This 0", "arr_reduce", 1n, ["*B", ["@var_retain", "@Var -1", "prime"]]], "+B", ["@Next 1 0", "arr_reduce", 1n, ["*B", ["@var_retain", "@Var -1", "prime"]]]], 0, false, "@end_vars", false, "@repeat", ["@var_retain", "@Var 2", "<", ["@This 0", "arr_length"], "&&", ["@var_retain", "@Parent -3", "!"]], "@edit_gvar", 0, ["@var_retain", "@Var 0", "arr_copy", "arr_edit_elem", "@Var 2", ["@var_retain", "@Var 0", "arr_elem", "@Var 2", "+B", 1n], "arr_sort", ["@var_retain", "@Var -2", "-B", "@Var -1", "Number"]], "@if", ["@var_retain", ["@var_retain", "@GVar 0", "arr_reduce", 1n, ["*B", ["@var_retain", "@Var -1", "prime"]]], "=", "@Var 1"], "2nd", true, "@end-if", "@edit_var", 2, ["@var_retain", "@Var 2", "+", 1], "@end-repeat"], false, [[["@GVar 0"]]], ["@GVar 0", "arr_reduce", 1n, ["*B", ["@var_retain", "@Var -1", "prime"]], "Number"], [false, true]]
        ];
        startTileSpawns = [[[["@Literal"]], 100]];
        winConditions = [[[2n, 2n, 5n, 11n]]];
        winRequirement = 1;
        knownMergeMaxLength = 2;
        knownMergeLookbackDistance = 0;
        // gmDisplayVars handles the background and stuff
        statBoxes = [["Discovered Tiles", ["@DiscTiles", "arr_length"], false, ...[,,,], ["@GVar 5", "=", 0], [0, "@edit_gvar", 5, 1], true], ["Discovered Tiles", ["@DiscTiles"], true, false, "TileArray", "Self", ["@GVar 5", "=", 1], [0, "@edit_gvar", 5, 0], true], ["Score", "@Score"]];
        document.getElementById("mode_vars_line").style.setProperty("display", "block");
        document.getElementById("3069_vars").style.setProperty("display", "flex");
    }
    else if (mode == 62) { // Partial Absorb 361
        // width = 5; height = 5;
        TileNumAmount = 1;
        TileTypes = [
            [[1], 1, "#000000", "#f8e2db"],
            [[1.5], 2, "#666666", "#f8e2db"],
            [true, ["@This 0", "^", 2], ["@radial-gradient", ["@HSLA", [-38, "*", "@This 0", "+", 30], ["@This 0", "%", 320, "-", 160, "abs", "/", 2, "+", 20], ["@This 0", "%", 81, "-", 40, "abs", "*", -1.5, "+", 80], 1], ["@HSLA", [-38, "*", "@This 0", "*", 0.99, "+", 30], ["@This 0", "*", 0.99, "%", 320, "-", 160, "abs", "/", 2, "+", 20], ["@This 0", "*", 0.99, "%", 81, "-", 40, "abs", "*", -1.5, "+", 80], 1], ["@HSLA", [-38, "*", "@This 0", "*", 0.9899, "+", 30], ["@This 0", "*", 0.9899, "%", 320, "-", 160, "abs", "/", 2, "+", 20], ["@This 0", "*", 0.9899, "%", 81, "-", 40, "abs", "*", -1.5, "+", 80], 1]], "#000000"]
        ];
        MergeRules = [
            // [4, [["@This 0", "=", 1], "&&", ["@Next 1 0", "=", 1], "&&", ["@Next 2 0", "=", 1], "&&", ["@Next 3 0", "=", 1]], true, [[2]], 4, [false, true, true, true]],
            [2, [["@This 0", "=", 1], "&&", ["@Next 1 0", "=", 1]], true, [[1.5]], 2, [false, true]],
            [2, [["@This 0", "=", 1.5], "&&", ["@Next 1 0", "=", 1.5]], true, [[2]], 4, [false, true]],
            [3, [["@This 0", "=", 2], "&&", ["@Next 1 0", "=", 1], "&&", ["@Next 2 0", "=", 2]], false, [[3]], 9, [false, true, true]],
            [3, [["@This 0", "=", 2], "&&", ["@Next 1 0", "-", 1, "=", "@Next 2 0"]], false, [[["@Next 1 0", "+", 1]], [["@Next 2 0", "-", 1]]], [["@Next 1 0", "^", 2], "+", ["@Next 2 0", "^", 2], "+", 4], [false, false, true]]
        ];
        startTileSpawns = [[[1], 85], [[1.5], 10], [[2], 5]];
        winConditions = [[19]];
        winRequirement = 1;
        knownMergeMaxLength = 3;
        knownMergeLookbackDistance = 0;
        document.documentElement.style.setProperty("background-image", "radial-gradient(#ff9a60 0%, #000 150%)");
        document.documentElement.style.setProperty("--background-color", "linear-gradient(#ffe1cd, #936d61)");
        document.documentElement.style.setProperty("--grid-color", "#eeb765");
        document.documentElement.style.setProperty("--tile-color", "#e67d49");
        document.documentElement.style.setProperty("--text-color", "#483027");
        // displayRules("rules_text", ["h2", "Square Numbers"], ["h1", "Partial Absorb 361"], ["p", "Merges may occur between four 1s, between two 4s and a 1, or between an n^2 tile, an (n+1)^2 tile, and a 4 tile (for any positive integer n above 1). The latter case merges into two tiles: an (n+2)^2 tile and an (n-1)^2 tile. Get to the 361 tile to win!"],
        // ["p", "Spawning tiles: 1 (90%), 4 (10%)"]);
        // displayRules("rules_text", ["h2", "Square Numbers"], ["h1", "Partial Absorb 361"], ["p", "Merges may occur between four 1s, between two 4s and a 1, or between an n^2 tile, an (n+1)^2 tile, and a 4 tile (for any positive integer n above 1). The latter case merges into two tiles: an (n+2)^2 tile and an (n-1)^2 tile. Get to the 361 tile to win!"],
        // ["p", "Spawning tiles: 1 (90%), 4 (10%)"]);
        displayRules("rules_text", ["h2", "Square Numbers"], ["h1", "Partial Absorb 361"], ["p", "Merges may occur between two 1s, between two 2s, between two 4s and a 1, or between an n^2 tile, an (n+1)^2 tile, and a 4 tile (for any positive integer n above 1). The latter case merges into two tiles: an (n+2)^2 tile and an (n-1)^2 tile. Get to the 361 tile to win!"],
        ["p", "Spawning tiles: 1 (85%), 2 (10%), 4 (5%)"]);
        displayRules("gm_rules_text", ["h2", "Square Numbers"], ["h1", "Partial Absorb 361"], ["p", "Merges may occur between two 1s, between two 2s, between two 4s and a 1, or between an n^2 tile, an (n+1)^2 tile, and a 4 tile (for any positive integer n above 1). The latter case merges into two tiles: an (n+2)^2 tile and an (n-1)^2 tile. Get to the 361 tile to win!"],
        ["p", "Spawning tiles: 1 (85%), 2 (10%), 4 (5%)"]);
    }
    else if (mode == 63) { // Harder 3375
        // width = 5; height = 5;
        TileNumAmount = 2;
        TileTypes = [
        [[0, 1], 1, "#ffffff", "#665b57"], [[0, 3], 3, "#ecb3ff", "#665b57"], [[0, 7], 7, "#dd76ff", "#665b57"],
        [[1, 1], 15, "#c5f9ff", "#665b57"], [[1, 3], 45, "#71f1ff", "#665b57"], [[1, 7], 105, "#00e5ff", "#665b57"],
        [[2, 1], 225, "#f1ffb8", "#665b57"], [[2, 3], 675, "#e3ff71", "#665b57"], [[2, 7], 1575, "#ccff00", "#665b57"],
        [[3, 1], 3375, "#ffb096", "#665b57"], [[3, 3], 10125, "#ff855d", "#665b57"], [[3, 7], 23625, "#ff5821", "#665b57"],
        [[4, 1], 50625, "#9d9dff", "#665b57"], [[4, 3], 151875, "#5f5fff", "#665b57"], [[4, 7], 354375, "#1a1aff", "#665b57"],
        [[5, 1], 759375, "#fff5b5", "#665b57"], [[5, 3], 2278125, "#ffeb6c", "#665b57"], [[5, 7], 5315625, "#ffe015", "#665b57"],
        [[6, 1], 11390625, "#ffb7ff", "#665b57"], [[6, 3], 34171875, "#ff7bff", "#665b57"], [[6, 7], 79734375, "#ff00ff", "#665b57"],
        [["@This 1", "=", 1], [15, "^", "@This 0"], ["@HSVA", [-97, "*", "@This 0", "+", 889], 30, [0.9, "^", ["@This 0", "-", 6], "*", 100], 1], "#f0dfd8"],
        [["@This 1", "=", 3], [15, "^", "@This 0", "*", 3], ["@HSVA", [-97, "*", "@This 0", "+", 889], 60, [0.9, "^", ["@This 0", "-", 6], "*", 100], 1], "#f0dfd8"],
        [["@This 1", "=", 7], [15, "^", "@This 0", "*", 7], ["@HSVA", [-97, "*", "@This 0", "+", 889], 100, [0.9, "^", ["@This 0", "-", 6], "*", 100], 1], "#f0dfd8"],
        ]
        MergeRules = [
            [3, [["@Next 1 0", "=", "@This 0"], "&&", ["@Next 2 0", "=", "@This 0"], "&&", ["@Next 2 1", "=", 1], "&&", ["@Next 1 1", "=", 1], "&&", ["@This 1", "=", 1]], false, [["@This 0", 3]], [15, "^", "@This 0", "*", 3], [false, true, true]],
            [3, [["@Next 1 0", "=", "@This 0"], "&&", ["@Next 2 0", "=", "@This 0"], "&&", ["@Next 2 1", "=", 3], "&&", ["@Next 1 1", "=", 3], "&&", ["@This 1", "=", 1]], false, [["@This 0", 7]], [15, "^", "@This 0", "*", 7], [false, true, true]],
            [3, [["@Next 1 0", "=", "@This 0"], "&&", ["@Next 2 0", "=", "@This 0"], "&&", ["@Next 2 1", "=", 7], "&&", ["@Next 1 1", "=", 7], "&&", ["@This 1", "=", 1]], false, [[["@This 0", "+", 1], 1]], [15, "^", "@This 0", "*", 15], [false, true, true]]
        ]
        startTileSpawns = [[[0, 1], 92], [[0, 3], 8]];
        winConditions = [[3, 1]];
        winRequirement = 1;
        knownMergeMaxLength = 3;
        knownMergeLookbackDistance = 0;
        document.documentElement.style.setProperty("background-image", "radial-gradient(#df7855 0%, #fff 150%)");
        document.documentElement.style.setProperty("--background-color", "#f3d0c9");
        document.documentElement.style.setProperty("--grid-color", "#dfb09d");
        document.documentElement.style.setProperty("--tile-color", "#f1cec0");
        document.documentElement.style.setProperty("--text-color", "#665b57");
        displayRules("rules_text", ["h1", "Harder 3375"], ["p","Merges occur between a power of 15 and two equal tiles that are equal to, three times, or seven times that power of 15. Get to the 3375 tile to win!"],
        ["p", "Spawning tiles: 1 (92%), 3 (8%)"]);
        displayRules("gm_rules_text", ["h1", "Harder 3375"], ["p","Merges occur between a power of 15 and two equal tiles that are equal to, three times, or seven times that power of 15. Get to the 3375 tile to win!"],
        ["p", "Spawning tiles: 1 (92%), 3 (8%)"]);
    }
    else if (mode == 64) { // Interleaved 3125
        // width = 4; height = 4;
        TileNumAmount = 2;
        TileTypes = [
        [[-1, 5], 1, "#ffffff", "#505246"], [[-1, 10], 2, "#c6c6c6", "#505246"], [[-1, 15], 3, "#787878", "#505246"],
        [[0, 5], 5, "#ff9f9f", "#505246"], [[0, 7], 7, "#ff7272", "#505246"], [[0, 8], 8, "#ff3a3a", "#505246"],
        [[0, 10], 10, "#d50000", "#f4f7e9"], [[0, 15], 15, "#980000", "#f4f7e9"],
        [[1, 5], 25, "#9fa2ff", "#505246"], [[1, 7], 35, "#5e64ff", "#505246"], [[1, 8], 40, "#0d15ff", "#505246"],
        [[1, 10], 50, "#0006be", "#f4f7e9"], [[1, 15], 75, "#00058b", "#f4f7e9"],
        [[2, 5], 125, "#fffa9f", "#505246"], [[2, 7], 175, "#fff53f", "#505246"], [[2, 8], 200, "#ebdf00", "#505246"],
        [[2, 10], 250, "#b3aa00", "#f4f7e9"], [[2, 15], 375, "#878000", "#f4f7e9"],
        [[3, 5], 625, "#df9fff", "#505246"], [[3, 7], 875, "#cf6fff", "#505246"], [[3, 8], 1000, "#bc35ff", "#505246"],
        [[3, 10], 1250, "#9900e5", "#f4f7e9"], [[3, 15], 1875, "#650098", "#f4f7e9"],
        [[4, 5], 3125, "#e9ff9f", "#505246"], [[4, 7], 4375, "#dafe65", "#505246"], [[4, 8], 5000, "#c9ff16", "#505246"],
        [[4, 10], 6250, "#abe000", "#f4f7e9"], [[4, 15], 9375, "#87af00", "#f4f7e9"],
        [[5, 5], 15625, "#ff9fda", "#505246"], [[5, 7], 21875, "#ff69c5", "#505246"], [[5, 8], 25000, "#ff23ab", "#505246"],
        [[5, 10], 31250, "#eb0091", "#f4f7e9"], [[5, 15], 46875, "#ad006a", "#f4f7e9"],
        [[6, 5], 78125, "#9fffbf", "#505246"], [[6, 7], 109375, "#5aff91", "#505246"], [[6, 8], 125000, "#0aff5c", "#505246"],
        [[6, 10], 156250, "#00d547", "#f4f7e9"], [[6, 15], 234375, "#009f35", "#f4f7e9"],
        [[7, 5], 390625, "#ffc19f", "#505246"], [[7, 7], 546875, "#ff9a63", "#505246"], [[7, 8], 625000, "#ff772e", "#505246"],
        [[7, 10], 781250, "#ff5900", "#f4f7e9"], [[7, 15], 1171875, "#c14400", "#f4f7e9"],
        [[8, 5], 1953125, "#9ff4ff", "#505246"], [[8, 7], 2734375, "#63edff", "#505246"], [[8, 8], 3125000, "#00e1ff", "#505246"],
        [[8, 10], 3906250, "#00c7e1", "#f4f7e9"], [[8, 15], 5859375, "#009aae", "#f4f7e9"],
        [[9, 5], 9765625, "#ffe79f", "#505246"], [[9, 7], 13671875, "#ffd65d", "#505246"], [[9, 8], 15625000, "#ffcd36", "#505246"],
        [[9, 10], 19531250, "#ebb000", "#f4f7e9"], [[9, 15], 29296875, "#b28600", "#f4f7e9"],
        [[10, 5], 48828125, "#9fc2ff", "#505246"], [[10, 7], 68359375, "#659eff", "#505246"], [[10, 8], 78125000, "#1e71ff", "#505246"],
        [[10, 10], 97656250, "#0058ef", "#f4f7e9"], [[10, 15], 146484375, "#003ca4", "#f4f7e9"],
        [["@This 1", "=", 5], [5, "^", "@This 0", "*", 5], ["@HSLA", [23.5, "*", ["@This 0", "+", 1], "-", 212, "+", ["@This 0", "+", 1, "%", 2, "*", 156.5]], [0.95, "^", ["@This 0", "-", 11], "*", 75], 70, 1], "#505246"],
        [["@This 1", "=", 7], [5, "^", "@This 0", "*", 7], ["@HSLA", [23.5, "*", ["@This 0", "+", 1], "-", 212, "+", ["@This 0", "+", 1, "%", 2, "*", 156.5]], [0.95, "^", ["@This 0", "-", 11], "*", 75], 60, 1], "#505246"],
        [["@This 1", "=", 8], [5, "^", "@This 0", "*", 8], ["@HSLA", [23.5, "*", ["@This 0", "+", 1], "-", 212, "+", ["@This 0", "+", 1, "%", 2, "*", 156.5]], [0.95, "^", ["@This 0", "-", 11], "*", 75], 50, 1], "#505246"],
        [["@This 1", "=", 10], [5, "^", "@This 0", "*", 10], ["@HSLA", [23.5, "*", ["@This 0", "+", 1], "-", 212, "+", ["@This 0", "+", 1, "%", 2, "*", 156.5]], [0.95, "^", ["@This 0", "-", 11], "*", 75], 40, 1], "#f4f7e9"],
        [["@This 1", "=", 15], [5, "^", "@This 0", "*", 15], ["@HSLA", [23.5, "*", ["@This 0", "+", 1], "-", 212, "+", ["@This 0", "+", 1, "%", 2, "*", 156.5]], [0.95, "^", ["@This 0", "-", 11], "*", 75], 30, 1], "#f4f7e9"]
        ];
        MergeRules = [
            [2, [["@Next 1 0", "=", -1], "&&", ["@This 0", "=", -1], "&&", ["@This 1", "=", 5], "&&", ["@Next 1 1", "=", 10]], false, [["@This 0", 15]], 3, [false, true]],
            [2, [["@Next 1 0", "+", 1, "=", "@This 0"], "&&", ["@This 1", "=", 5], "&&", ["@Next 1 1", "=", 10]], false, [["@This 0", 7]], [5, "^", "@This 0", "*", 7, "round", 1], [false, true]],
            [2, [["@Next 1 0", "+", 1, "=", "@This 0"], "&&", ["@This 1", "=", 5], "&&", ["@Next 1 1", "=", 15]], false, [["@This 0", 8]], [5, "^", "@This 0", "*", 8, "round", 1], [false, true]],
            [2, [["@Next 1 0", "=", "@This 0"], "&&", ["@This 1", "=", 5], "&&", ["@Next 1 1", "=", 5]], false, [["@This 0", 10]], [5, "^", "@This 0", "*", 10, "round", 1], [false, true]],
            [2, [["@Next 1 0", "=", "@This 0"], "&&", ["@This 1", "=", 7], "&&", ["@Next 1 1", "=", 8]], false, [["@This 0", 15]], [5, "^", "@This 0", "*", 15, "round", 1], [false, true]],
            [2, [["@Next 1 0", "=", "@This 0"], "&&", ["@This 1", "=", 10], "&&", ["@Next 1 1", "=", 15]], false, [[["@This 0", "+", 1], 5]], [5, "^", "@This 0", "*", 25, "round", 1], [false, true]]
        ]
        startTileSpawns = [[[-1, 5], 85], [[-1, 10], 10], [[-1, 15], 5]];
        winConditions = [[4, 5]];
        winRequirement = 1;
        knownMergeMaxLength = 2;
        knownMergeLookbackDistance = 0;
        document.documentElement.style.setProperty("background-image", "repeating-linear-gradient(90deg, #e5ff91 0%, #b9cf73 20%, #e5ff91 40%)");
        document.documentElement.style.setProperty("--background-color", "repeating-linear-gradient(#f2ffc7 0%, #c7d599 15%, #f2ffc7 30%)");
        document.documentElement.style.setProperty("--grid-color", "#cadb80");
        document.documentElement.style.setProperty("--tile-color", "#9faf58");
        document.documentElement.style.setProperty("--text-color", "#505246");
        displayRules("rules_text", ["h1", "Interleaved 3125"], ["p","Two 1s can merge into a 2, and a 2 and a 1 can merge into a 3. Merges occur between a tile that's double a power of five and a tile that's triple that power of five, between a tile that's five times a power of five and a tile that's double, triple, or five times that power of five, or between a tile that's seven times a power of five and a tile that's eight times that power of five. Get to the 3125 tile to win!"],
        ["p", "Spawning tiles: 1 (85%), 2 (10%), 3 (5%)"]);
        displayRules("gm_rules_text", ["h1", "Interleaved 3125"], ["p","Two 1s can merge into a 2, and a 2 and a 1 can merge into a 3. Merges occur between a tile that's double a power of five and a tile that's triple that power of five, between a tile that's five times a power of five and a tile that's double, triple, or five times that power of five, or between a tile that's seven times a power of five and a tile that's eight times that power of five. Get to the 3125 tile to win!"],
        ["p", "Spawning tiles: 1 (85%), 2 (10%), 3 (5%)"]);
    }
    else if (mode == 65) { // Interleaved 3375
        // width = 5; height = 5;
        TileNumAmount = 2;
        TileTypes = [
        [[-1, 15], 1, "#ffffff", "#665b57"], [[-1, 30], 2, "#ecb3ff", "#665b57"], [[-1, 60], 4, "#dd76ff", "#f0dfd8"], [[-1, 75], 5, "#bf00ff", "#f0dfd8"],
        [[0, 15], 15, "#c5f9ff", "#665b57"], [[0, 20], 20, "#71f1ff", "#665b57"], [[0, 60], 60, "#00d3eb", "#f0dfd8"], [[0, 75], 75, "#00b1c5", "#f0dfd8"],
        [[1, 15], 225, "#f1ffb8", "#665b57"], [[1, 20], 300, "#e3ff71", "#665b57"], [[1, 60], 900, "#b2df00", "#f0dfd8"], [[1, 75], 1125, "#90b301", "#f0dfd8"],
        [[2, 15], 3375, "#ffb096", "#665b57"], [[2, 20], 4500, "#ff855d", "#665b57"], [[2, 60], 13500, "#ff4000", "#f0dfd8"], [[2, 75], 16875, "#ca3300", "#f0dfd8"],
        [[3, 15], 50625, "#9d9dff", "#665b57"], [[3, 20], 67500, "#5f5fff", "#665b57"], [[3, 60], 202500, "#0000ff", "#f0dfd8"], [[3, 75], 253125, "#0000c2", "#f0dfd8"],
        [[4, 15], 759375, "#fff5b5", "#665b57"], [[4, 20], 1012500, "#ffeb6c", "#665b57"], [[4, 60], 3037500, "#ebcc00", "#f0dfd8"], [[4, 75], 3796875, "#bba200", "#f0dfd8"],
        [[5, 15], 11390625, "#ffb7ff", "#665b57"], [[5, 20], 15187500, "#ff7bff", "#665b57"], [[5, 60], 45562500, "#e100e1", "#f0dfd8"], [[5, 75], 56953125, "#b000b0", "#f0dfd8"],
        [["@This 1", "=", 15], [15, "^", "@This 0", "*", 15], ["@HSLA", [-97, "*", "@This 0", "+", 792], [0.9, "^", ["@This 0", "-", 5], "*", 100], 75, 1], "#665b57"],
        [["@This 1", "=", 20], [15, "^", "@This 0", "*", 20], ["@HSLA", [-97, "*", "@This 0", "+", 792], [0.9, "^", ["@This 0", "-", 5], "*", 100], 60, 1], "#665b57"],
        [["@This 1", "=", 60], [15, "^", "@This 0", "*", 60], ["@HSLA", [-97, "*", "@This 0", "+", 792], [0.9, "^", ["@This 0", "-", 5], "*", 100], 45, 1], "#f0dfd8"],
        [["@This 1", "=", 75], [15, "^", "@This 0", "*", 75], ["@HSLA", [-97, "*", "@This 0", "+", 792], [0.9, "^", ["@This 0", "-", 5], "*", 100], 30, 1], "#f0dfd8"],
        ]
        MergeRules = [
            [2, [["@This 0", "=", -1], "&&", ["@Next 1 0", "=", -1], "&&", ["@This 1", "=", 15], "&&", ["@Next 1 1", "=", 15]], true, [[-1, 30]], 2, [false, true]],
            [2, [["@This 0", "=", -1], "&&", ["@Next 1 0", "=", -1], "&&", ["@This 1", "=", 30], "&&", ["@Next 1 1", "=", 30]], true, [[-1, 60]], 4, [false, true]],
            [2, [["@Next 1 0", "+", 1, "=", "@This 0"], "&&", ["@This 1", "=", 15], "&&", ["@Next 1 1", "=", 75]], false, [["@This 0", 20]], [15, "^", "@This 0", "*", 20, "round", 1], [false, true]],
            [3, [["@Next 1 0", "=", "@This 0"], "&&", ["@Next 2 0", "=", "@This 0"], "&&", ["@This 1", "=", 20], "&&", ["@Next 1 1", "=", 20], "&&", ["@Next 2 1", "=", 20]], false, [["@This 0", 60]], [15, "^", "@This 0", "*", 60, "round", 1], [false, true, true]],
            [2, [["@Next 1 0", "=", "@This 0"], "&&", ["@This 1", "=", 60], "&&", ["@Next 1 1", "=", 15]], false, [["@This 0", 75]], [15, "^", "@This 0", "*", 75, "round", 1], [false, true]],
            [3, [["@Next 1 0", "=", "@This 0"], "&&", ["@Next 2 0", "=", "@This 0"], "&&", ["@This 1", "=", 75], "&&", ["@Next 1 1", "=", 75], "&&", ["@Next 2 1", "=", 75]], false, [[["@This 0", "+", 1], 15]], [15, "^", "@This 0", "*", 225, "round", 1], [false, true, true]]
        ]
        startTileSpawns = [[[-1, 15], 85], [[-1, 30], 12], [[-1, 60], 3]];
        winConditions = [[2, 15]];
        winRequirement = 1;
        knownMergeMaxLength = 3;
        knownMergeLookbackDistance = 0;
        document.documentElement.style.setProperty("background-image", "repeating-linear-gradient(90deg, #f59879 0%, #ba7862 20%, #f59879 40%)");
        document.documentElement.style.setProperty("--background-color", "repeating-linear-gradient(#f9dcd7 0%, #e1aea5 15%, #f9dcd7 30%)");
        document.documentElement.style.setProperty("--grid-color", "#e7b9a7");
        document.documentElement.style.setProperty("--tile-color", "#cc9079");
        document.documentElement.style.setProperty("--text-color", "#665b57");
        displayRules("rules_text", ["h1", "Interleaved 3375"], ["p","Two 1s can merge into a 2, and two 2s can merge into a 4. Merges occur between a tile that's a power of fifteen and a tile that's either four times that power of fifteen or a third of that power of fifteen, or between three equal tiles that are five times a power of fifteen or twenty times a power of fifteen. Get to the 3375 tile to win!"],
        ["p", "Spawning tiles: 1 (85%), 2 (12%), 4 (3%)"]);
        displayRules("gm_rules_text", ["h1", "Interleaved 3375"], ["p","Two 1s can merge into a 2, and two 2s can merge into a 4. Merges occur between a tile that's a power of fifteen and a tile that's either four times that power of fifteen or a third of that power of fifteen, or between three equal tiles that are five times a power of fifteen or twenty times a power of fifteen. Get to the 3375 tile to win!"],
        ["p", "Spawning tiles: 1 (85%), 2 (12%), 4 (3%)"]);
    }
    else if (mode == 66) { // Interleaved 5832
        // width = 4; height = 4;
        TileNumAmount = 2;
        TileTypes = [
        [[0, 1], 1, "#a4ffd9", "#372e3a"], [[0, 2], 2, "#a4fff1", "#372e3a"], [[0, 3], 3, "#a4edff", "#372e3a"], [[0, 6], 6, "#a4d5ff", "#372e3a"], [[0, 9], 9, "#a4b3ff", "#372e3a"],
        [[1, 1], 18, "#ffffa4", "#372e3a"], [[1, 1.5], 27, "#e7ffa4", "#372e3a"], [[1, 3], 54, "#cbffa4", "#372e3a"], [[1, 4.5], 81, "#afffa4", "#372e3a"], [[1, 9], 162, "#a4ffbe", "#372e3a"],
        [[2, 1], 324, "#ffa4a4", "#372e3a"], [[2, 1.5], 486, "#ffbba4", "#372e3a"], [[2, 3], 972, "#ffd0a4", "#372e3a"], [[2, 4.5], 1458, "#ffdea4", "#372e3a"], [[2, 9], 2916, "#ffeaa4", "#372e3a"],
        [[3, 1], 5832, "#dca4ff", "#372e3a"], [[3, 1.5], 8748, "#eea4ff", "#372e3a"], [[3, 3], 17496, "#ffa4fa", "#372e3a"], [[3, 4.5], 26244, "#ffa4df", "#372e3a"], [[3, 9], 52488, "#ffa4c8", "#372e3a"],
        [[4, 1], 104976, "#46ffb2", "#372e3a"], [[4, 1.5], 157464, "#41ffe3", "#372e3a"], [[4, 3], 314928, "#3dd8ff", "#372e3a"], [[4, 4.5], 472392, "#3aa3ff", "#372e3a"], [[4, 9], 944784, "#2f52ff", "#372e3a"],
        [[5, 1], 1889568, "#ffff2c", "#372e3a"], [[5, 1.5], 2834352, "#c8ff2f", "#372e3a"], [[5, 3], 5668704, "#8eff37", "#372e3a"], [[5, 4.5], 8503056, "#56ff3f", "#372e3a"], [[5, 9], 17006112, "#30ff6b", "#372e3a"],
        [[6, 1], 34012224, "#ff2c2c", "#372e3a"], [[6, 1.5], 51018336, "#ff602b", "#372e3a"], [[6, 3], 102036672, "#ff9028", "#372e3a"], [[6, 4.5], 153055008, "#ffb22d", "#372e3a"], [[6, 9], 306110016, "#ffd034", "#372e3a"],
        [[7, 1], 612220032, "#b133ff", "#372e3a"], [[7, 1.5], 918330048, "#db3aff", "#372e3a"], [[7, 3], 1836660096, "#ff2df4", "#372e3a"], [[7, 4.5], 2754990144, "#ff35b8", "#372e3a"], [[7, 9], 5509980288, "#ff2f82", "#372e3a"],
        [["@This 1", "=", 1], [18, "^", "@This 0", "*", 1], ["@HSLA", [-90, "*", "@This 0", "+", 155], 100, [0.7, "^", ["@This 0", "-", 8, "floor", 4, "/", 4], "*", 40], 1], "#ebe0ef"],
        [["@This 1", "=", 1.5], [18, "^", "@This 0", "*", 3, "/", 2], ["@HSLA", [-90, "*", "@This 0", "+", 173], 100, [0.7, "^", ["@This 0", "-", 8, "floor", 4, "/", 4], "*", 40], 1], "#ebe0ef"],
        [["@This 1", "=", 3], [18, "^", "@This 0", "*", 3], ["@HSLA", [-90, "*", "@This 0", "+", 191], 100, [0.7, "^", ["@This 0", "-", 8, "floor", 4, "/", 4], "*", 40], 1], "#ebe0ef"],
        [["@This 1", "=", 4.5], [18, "^", "@This 0", "*", 9, "/", 2], ["@HSLA", [-90, "*", "@This 0", "+", 209], 100, [0.7, "^", ["@This 0", "-", 8, "floor", 4, "/", 4], "*", 40], 1], "#ebe0ef"],
        [["@This 1", "=", 9], [18, "^", "@This 0", "*", 9], ["@HSLA", [-90, "*", "@This 0", "+", 227], 100, [0.7, "^", ["@This 0", "-", 8, "floor", 4, "/", 4], "*", 40], 1], "#ebe0ef"]
        ]
        MergeRules = [
            [2, [["@This 0", "=", 0], "&&", ["@Next 1 0", "=", 0], "&&", ["@This 1", "=", 1], "&&", ["@Next 1 1", "=", 1]], false, [[0, 2]], 2, [false, true]],
            [2, [["@This 0", "=", 0], "&&", ["@Next 1 0", "=", 0], "&&", ["@This 1", "=", 2], "&&", ["@Next 1 1", "=", 1]], false, [[0, 3]], 3, [false, true]],
            [2, [["@This 0", "=", 0], "&&", ["@Next 1 0", "=", 0], "&&", ["@This 1", "=", 3], "&&", ["@Next 1 1", "=", 3]], false, [[0, 6]], 6, [false, true]],
            [2, [["@This 0", "=", 0], "&&", ["@Next 1 0", "=", 0], "&&", ["@This 1", "=", 6], "&&", ["@Next 1 1", "=", 3]], false, [[0, 9]], 9, [false, true]],
            [2, [["@Next 1 0", "+", 1, "=", "@This 0"], "&&", ["@This 1", "=", 1], "&&", ["@Next 1 1", "=", 9]], false, [["@This 0", 1.5]], [18, "^", "@This 0", "*", 3, "/", 2], [false, true]],
            [2, [["@Next 1 0", "=", "@This 0"], "&&", ["@This 1", "=", 1.5], "&&", ["@Next 1 1", "=", 1.5]], false, [["@This 0", 3]], [18, "^", "@This 0", "*", 3], [false, true]],
            [2, [["@Next 1 0", "=", "@This 0"], "&&", ["@This 1", "=", 3], "&&", ["@Next 1 1", "=", 1.5]], false, [["@This 0", 4.5]], [18, "^", "@This 0", "*", 9, "/", 2], [false, true]],
            [2, [["@Next 1 0", "=", "@This 0"], "&&", ["@This 1", "=", 4.5], "&&", ["@Next 1 1", "=", 4.5]], false, [["@This 0", 9]], [18, "^", "@This 0", "*", 9], [false, true]],
            [2, [["@Next 1 0", "=", "@This 0"], "&&", ["@This 1", "=", 9], "&&", ["@Next 1 1", "=", 9]], false, [[["@This 0", "+", 1], 1]], [18, "^", "@This 0", "*", 18], [false, true]],
        ]
        startTileSpawns = [[[0, 1], 85], [[0, 2], 9], [[0, 3], 6]];
        winConditions = [[3, 1]];
        winRequirement = 1;
        knownMergeMaxLength = 2;
        knownMergeLookbackDistance = 0;
        document.documentElement.style.setProperty("background-image", "repeating-linear-gradient(90deg, #b083cc 0%, #d99bff 20%, #b083cc 40%)");
        document.documentElement.style.setProperty("--background-color", "repeating-linear-gradient(#cbaadf 0%, #efd4ff 15%, #cbaadf 30%)");
        document.documentElement.style.setProperty("--grid-color", "#be86e0");
        document.documentElement.style.setProperty("--tile-color", "#a35dce");
        document.documentElement.style.setProperty("--text-color", "#372e3a");
        displayRules("rules_text", ["h1", "Interleaved 5832"], ["p","Two 1s can merge into a 2, a 2 and a 1 can merge into a 3, two 3s can merge into a 6, and a 6 and a 3 can merge into a 9. For tiles 9 and above, if that tile is a power of 18 or triple a power of eighteen, it merges with a tile that's half of itself. Otherwise, it merges with a tile equal to itself. Get to the 5832 tile to win!"],
        ["p", "Spawning tiles: 1 (85%), 2 (9%), 3 (6%)"]);
        displayRules("gm_rules_text", ["h1", "Interleaved 5832"], ["p","Two 1s can merge into a 2, a 2 and a 1 can merge into a 3, two 3s can merge into a 6, and a 6 and a 3 can merge into a 9. For tiles 9 and above, if that tile is a power of 18 or triple a power of eighteen, it merges with a tile that's half of itself. Otherwise, it merges with a tile equal to itself. Get to the 5832 tile to win!"],
        ["p", "Spawning tiles: 1 (85%), 2 (9%), 3 (6%)"]);
    }
    else if (mode == 67) { // 1762
        // width = 4; height = 4;
        TileNumAmount = 1;
        mode_vars = [0, 11n]; // mode_vars[0] controls the random goals, mode_vars[1] is the tier of tile that the first random goal is
        start_game_vars = [2n, 0, false, 11n, 0] // The first entry is the current random goal, the second entry is the amount of random goals met so far, the third entry is whether a random goal has been met this turn, and the fourth entry is the tier of tile that the first random goal is. The fifth entry controls the display of Discovered Tiles.
        TileTypes = [
        [[1n], 1, "#ffffff", "#46370d"], [[2n], 2, "#ffe4b8", "#46370d"],
        [["@This 0", "<=", 4n], ["@This 0"], ["@linear-gradient", ["@HSLA", [4, "-", "@This 0", "*", 300, "/", 1], 100, 60, 1], 0, "#ffc76c", 25, 75, ["@HSLA", [4, "-", "@This 0", "*", 300, "/", 1], 100, 60, 1], 100], "#46370d"],
        [["@This 0", "<=", 8n], ["@This 0"], ["@linear-gradient", ["@HSLA", [8, "-", "@This 0", "*", 300, "/", 3], 100, 60, 1], 0, "#ff9d00", 25, 75, ["@HSLA", [8, "-", "@This 0", "*", 300, "/", 3], 100, 60, 1], 100], "#46370d"],
        [["@This 0", "<=", 16n], ["@This 0"], ["@linear-gradient", ["@HSLA", [16, "-", "@This 0", "*", 300, "/", 7], 100, 60, 1], 0, "#ff6f00", 25, 75, ["@HSLA", [16, "-", "@This 0", "*", 300, "/", 7], 100, 60, 1], 100], "#46370d"],
        [["@This 0", "<=", 32n], ["@This 0"], ["@linear-gradient", ["@HSLA", [32, "-", "@This 0", "*", 300, "/", 15], 100, 60, 1], 0, "#ff3300", 25, 75, ["@HSLA", [32, "-", "@This 0", "*", 300, "/", 15], 100, 60, 1], 100], "#46370d"],
        [["@This 0", "<=", 64n], ["@This 0"], ["@linear-gradient", ["@HSLA", [64, "-", "@This 0", "*", 300, "/", 31], 100, 60, 1], 0, "#ff0051", 25, 75, ["@HSLA", [64, "-", "@This 0", "*", 300, "/", 31], 100, 60, 1], 100], "#46370d"],
        [["@This 0", "<=", 128n], ["@This 0"], ["@linear-gradient", ["@HSLA", [128, "-", "@This 0", "*", 300, "/", 63], 100, 60, 1], 0, "#fff8ae", 25, 75, ["@HSLA", [128, "-", "@This 0", "*", 300, "/", 63], 100, 60, 1], 100], "#46370d"],
        [["@This 0", "<=", 256n], ["@This 0"], ["@linear-gradient", ["@HSLA", [256, "-", "@This 0", "*", 300, "/", 127], 100, 60, 1], 0, "#fff26b", 25, 75, ["@HSLA", [256, "-", "@This 0", "*", 300, "/", 127], 100, 60, 1], 100], "#46370d"],
        [["@This 0", "<=", 512n], ["@This 0"], ["@linear-gradient", ["@HSLA", [512, "-", "@This 0", "*", 300, "/", 255], 100, 60, 1], 0, "#ffea00", 25, 75, ["@HSLA", [512, "-", "@This 0", "*", 300, "/", 255], 100, 60, 1], 100], "#46370d"],
        [["@This 0", "<=", 1024n], ["@This 0"], ["@linear-gradient", ["@HSLA", [1024, "-", "@This 0", "*", 300, "/", 511], 100, 60, 1], 0, "#d4c300", 25, 75, ["@HSLA", [1024, "-", "@This 0", "*", 300, "/", 511], 100, 60, 1], 100], "#fff7de"],
        [["@This 0", "<=", 2048n], ["@This 0"], ["@linear-gradient", ["@HSLA", [2048, "-", "@This 0", "*", 300, "/", 1023], 100, 60, 1], 0, "#a39600", 25, 75, ["@HSLA", [2048, "-", "@This 0", "*", 300, "/", 1023], 100, 60, 1], 100], "#fff7de"],
        [["@This 0", "<=", 4096n], ["@This 0"], ["@linear-gradient", ["@HSLA", [4096, "-", "@This 0", "*", 300, "/", 2047], 100, 60, 1], 0, "#f6b9ff", 25, 75, ["@HSLA", [4096, "-", "@This 0", "*", 300, "/", 2047], 100, 60, 1], 100], "#fff7de"],
        [["@This 0", "<=", 8192n], ["@This 0"], ["@linear-gradient", ["@HSLA", [8192, "-", "@This 0", "*", 300, "/", 4095], 100, 60, 1], 0, "#eb75fd", 25, 75, ["@HSLA", [8192, "-", "@This 0", "*", 300, "/", 4095], 100, 60, 1], 100], "#fff7de"],
        [["@This 0", "<=", 16384n], ["@This 0"], ["@linear-gradient", ["@HSLA", [16384, "-", "@This 0", "*", 300, "/", 8191], 100, 60, 1], 0, "#e229ff", 25, 75, ["@HSLA", [16384, "-", "@This 0", "*", 300, "/", 8191], 100, 60, 1], 100], "#fff7de"],
        [["@This 0", "<=", 32768n], ["@This 0"], ["@linear-gradient", ["@HSLA", [32768, "-", "@This 0", "*", 300, "/", 16383], 100, 60, 1], 0, "#b200ce", 25, 75, ["@HSLA", [32768, "-", "@This 0", "*", 300, "/", 16383], 100, 60, 1], 100], "#fff7de"],
        [["@This 0", "<=", 65536n], ["@This 0"], ["@linear-gradient", ["@HSLA", [65536, "-", "@This 0", "*", 300, "/", 32767], 100, 60, 1], 0, "#770089", 25, 75, ["@HSLA", [65536, "-", "@This 0", "*", 300, "/", 32767], 100, 60, 1], 100], "#fff7de"],
        [["@This 0", "<=", 131072n], ["@This 0"], ["@linear-gradient", ["@HSLA", [131072, "-", "@This 0", "*", 300, "/", 65535], 100, 60, 1], 0, "#635ef5", 25, 75, ["@HSLA", [131072, "-", "@This 0", "*", 300, "/", 65535], 100, 60, 1], 100], "#fff7de"],
        [["@This 0", "<=", 262144n], ["@This 0"], ["@linear-gradient", ["@HSLA", [262144, "-", "@This 0", "*", 300, "/", 131071], 100, 60, 1], 0, "#2c26e1", 25, 75, ["@HSLA", [262144, "-", "@This 0", "*", 300, "/", 131071], 100, 60, 1], 100], "#fff7de"],
        [["@This 0", "<=", 524288n], ["@This 0"], ["@linear-gradient", ["@HSLA", [524288, "-", "@This 0", "*", 300, "/", 262143], 100, 60, 1], 0, "#120e93", 25, 75, ["@HSLA", [524288, "-", "@This 0", "*", 300, "/", 262143], 100, 60, 1], 100], "#fff7de"],
        [true, ["@This 0"], ["@linear-gradient", ["@HSLA", [[2, "^", ["@This 0", "-B", 1n, "logB", 2n], "*", 2], "-", "@This 0", "*", 300, "/", [2, "^", ["@This 0", "-B", 1n, "logB", 2n], "-", 1]], 100, 60, 1], 0, ["@HSLA", [-34, "*", ["@This 0", "-B", 1n, "logB", 2n], "+", 495], 100, [0.95, "^", ["@This 0", "-B", 1n, "logB", 2n, "-", 19], "*", 36], 1], 25, 75, ["@HSLA", [[2, "^", ["@This 0", "-B", 1n, "logB", 2n], "*", 2], "-", "@This 0", "*", 300, "/", [2, "^", ["@This 0", "-B", 1n, "logB", 2n], "-", 1]], 100, 60, 1], 100], "#fff7de"]
        ];
        MergeRules = [
            [2, ["@Next 1 0", "-B", "@This 0", "absB", "<=", 1n], true, [[["@This 0", "+B", "@Next 1 0"]]], ["@This 0", "+", "@Next 1 0"], [false, true]]
        ];
        startTileSpawns = [[[1n], 90], [[2n], 10]];
        winConditions = [[1762n]];
        winRequirement = 1;
        knownMergeMaxLength = 2;
        knownMergeLookbackDistance = 0;
        document.documentElement.style.setProperty("background-image", "linear-gradient(#adff2a 0%, #b3a61d 15% 85%, #adff2a 100%");
        document.documentElement.style.setProperty("--background-color", "linear-gradient(90deg, #b2f14c 0%, #cfc558 12% 88%, #b2f14c 100%)");
        document.documentElement.style.setProperty("--grid-color", "#d7ca38");
        document.documentElement.style.setProperty("--tile-color", "#daea5d");
        document.documentElement.style.setProperty("--text-color", "#46370d");
        displayRules("rules_text", ["h1", "1762"], ["p", "Merges occur between two equal tiles or between two tiles with a difference of 1. Get to the 1762 tile to win (your first task is figuring out how to get there...), or just play and see what tiles you end up making!"],
        ["p", "Spawning tiles: 1 (90%), 2 (10%)"]);
        displayRules("gm_rules_text", ["h1", "1762"], ["p", "Merges occur between two equal tiles or between two tiles with a difference of 1. Get to the 1762 tile to win (your first task is figuring out how to get there...), or just play and see what tiles you end up making!"],
        ["p", "Spawning tiles: 1 (90%), 2 (10%)"]);
        statBoxes = [["Discovered Tiles", ["@DiscTiles", "arr_length"], false, ...[,,,], ["@GVar 4", "=", 0], [0, "@edit_gvar", 4, 1], true], ["Discovered Tiles", ["@DiscTiles"], true, false, "TileArray", "Self", ["@GVar 4", "=", 1], [0, "@edit_gvar", 4, 0], true], ["Score", "@Score"]];
        document.getElementById("mode_vars_line").style.setProperty("display", "block");
        document.getElementById("1762_vars").style.setProperty("display", "flex");
    }
    else if (mode == 68) { // 2205
        // width = 5; height = 5;
        TileNumAmount = 3;
        mode_vars = [1] // First entry is the level
        start_game_vars = [0]; // Controls the display of Discovered Tiles
        TileTypes = [
            [[0, 0, 0], 1, "#ffffff", "#000000"],
            [[["@This 0", "=", "@This 1"], "&&", ["@This 0", "=", "@This 2"]], [[3, "^", "@This 0"], "*", [5, "^", "@This 1"], "*", [7, "^", "@This 2"]], ["@HSLA", 0, 0, [0, "@if", ["@This 0", "+", "@This 1", "+", "@This 2", "<", 4], "2nd", "@This 0", "+", "@This 1", "+", "@This 2", "*", -10, "+", 100, "@end-if", "@else", "2nd", 0.75, "^", ["@This 0", "+", "@This 1", "+", "@This 2", "-", 4], "*", 45, "+", 5, "@end-else"], 1], ["#000000", "@if", ["@This 0", "+", "@This 1", "+", "@This 2", ">=", 4], "2nd", "#ffffff", "@end-if"]],
            [[["@This 2", "<=", "@This 0"], "&&", ["@This 2", "<=", "@This 1"]], [[3, "^", "@This 0"], "*", [5, "^", "@This 1"], "*", [7, "^", "@This 2"]], ["@HSLA", [120, "*", ["@This 1", "-", "@This 2"], "/", ["@This 2", "*", -2, "+", "@This 0", "+", "@This 1"], "+", 60], [0.7, "^", "@This 2", "*", 100], [100, "@if", ["@This 0", "+", "@This 1", "+", "@This 2", "<", 4], "2nd", "@This 0", "+", "@This 1", "+", "@This 2", "*", -10, "+", 100, "@end-if", "@else", "2nd", 0.75, "^", ["@This 0", "+", "@This 1", "+", "@This 2", "-", 4], "*", 45, "+", 5, "@end-else"], 1], ["#000000", "@if", ["@This 0", "+", "@This 1", "+", "@This 2", ">=", 4], "2nd", "#ffffff", "@end-if"]],
            [[["@This 1", "<=", "@This 0"], "&&", ["@This 1", "<=", "@This 2"]], [[3, "^", "@This 0"], "*", [5, "^", "@This 1"], "*", [7, "^", "@This 2"]], ["@HSLA", [120, "*", ["@This 0", "-", "@This 1"], "/", ["@This 1", "*", -2, "+", "@This 0", "+", "@This 2"], "+", 300], [0.7, "^", "@This 1", "*", 100], [100, "@if", ["@This 0", "+", "@This 1", "+", "@This 2", "<", 4], "2nd", "@This 0", "+", "@This 1", "+", "@This 2", "*", -10, "+", 100, "@end-if", "@else", "2nd", 0.75, "^", ["@This 0", "+", "@This 1", "+", "@This 2", "-", 4], "*", 45, "+", 5, "@end-else"], 1], ["#000000", "@if", ["@This 0", "+", "@This 1", "+", "@This 2", ">=", 4], "2nd", "#ffffff", "@end-if"]],
            [[["@This 0", "<=", "@This 1"], "&&", ["@This 0", "<=", "@This 2"]], [[3, "^", "@This 0"], "*", [5, "^", "@This 1"], "*", [7, "^", "@This 2"]], ["@HSLA", [120, "*", ["@This 2", "-", "@This 0"], "/", ["@This 0", "*", -2, "+", "@This 1", "+", "@This 2"], "+", 180], [0.7, "^", "@This 0", "*", 100], [100, "@if", ["@This 0", "+", "@This 1", "+", "@This 2", "<", 4], "2nd", "@This 0", "+", "@This 1", "+", "@This 2", "*", -10, "+", 100, "@end-if", "@else", "2nd", 0.75, "^", ["@This 0", "+", "@This 1", "+", "@This 2", "-", 4], "*", 45, "+", 5, "@end-else"], 1], ["#000000", "@if", ["@This 0", "+", "@This 1", "+", "@This 2", ">=", 4], "2nd", "#ffffff", "@end-if"]]
        ];
        MergeRules = [
            [3, [["@This 0", "=", 0], "&&", ["@This 1", "=", 0], "&&", ["@This 2", "=", 0], "&&", ["@Next 1 0", "=", 0], "&&", ["@Next 1 1", "=", 0], "&&", ["@Next 1 2", "=", 0], "&&", ["@Next 2 0", "=", 0], "&&", ["@Next 2 1", "=", 0], "&&", ["@Next 2 2", "=", 0]], true, [[1, 0, 0]], 3, [false, true, true]],
            [3, [["@This 0", "+", 1, "=", "@Next 1 0"], "&&", ["@This 1", "=", "@Next 1 1"], "&&", ["@This 2", "=", "@Next 1 2"], "&&", ["@This 0", "=", "@Next 2 0"], "&&", ["@This 1", "=", "@Next 2 1"], "&&", ["@This 2", "=", "@Next 2 2"]], false, [["@This 0", ["@This 1", "+", 1], "@This 2"]], [[3, "^", "@This 0"], "*", [5, "^", "@This 1"], "*", [7, "^", "@This 2"], "*", 5], [false, true, true]],
            [3, [["@This 0", "=", "@Next 1 0"], "&&", ["@This 1", "+", 1, "=", "@Next 1 1"], "&&", ["@This 2", "=", "@Next 1 2"], "&&", ["@This 0", "=", "@Next 2 0"], "&&", ["@This 1", "=", "@Next 2 1"], "&&", ["@This 2", "=", "@Next 2 2"]], false, [["@This 0", "@This 1", ["@This 2", "+", 1]]], [[3, "^", "@This 0"], "*", [5, "^", "@This 1"], "*", [7, "^", "@This 2"], "*", 7], [false, true, true]],
            [3, [["@This 0", "=", "@Next 1 0"], "&&", ["@This 1", "=", "@Next 1 1"], "&&", ["@This 2", "+", 1, "=", "@Next 1 2"], "&&", ["@This 0", "=", "@Next 2 0"], "&&", ["@This 1", "=", "@Next 2 1"], "&&", ["@This 2", "=", "@Next 2 2"]], false, [[["@This 0", "+", 2], "@This 1", "@This 2"]], [[3, "^", "@This 0"], "*", [5, "^", "@This 1"], "*", [7, "^", "@This 2"], "*", 9], [false, true, true]]
        ];
        startTileSpawns = [[[0, 0, 0], 100]];
        winConditions = [[2, 1, 2]];
        winRequirement = 1;
        knownMergeMaxLength = 3;
        knownMergeLookbackDistance = 0;
        document.documentElement.style.setProperty("background-image", "linear-gradient(#fff, #fbf, #9ff, #ff7, #ffdc5c 10%, #baba35, #ffdc5c 90%, #ff7, #9ff, #fbf, #fff)");
        document.documentElement.style.setProperty("--background-color", "linear-gradient(#fff, #fdf, #bff, #ffa, #ffe78f 10%, #dddd57, #ffe78f 90%, #ffa, #bff, #fdf, #fff)");
        document.documentElement.style.setProperty("--grid-color", "#781f78");
        document.documentElement.style.setProperty("--tile-color", "#a1d1d1");
        document.documentElement.style.setProperty("--text-color", "#333300");
        displayRules("rules_text", ["h2", "Powers of 3 Times Powers of 5 Times Powers of 7"], ["h1", "2205 (Level 1)"], ["p", "Merges occur between three 1s, or between any tile and two equal tiles that are each a third, a fifth, or a seventh of the larger tile. Get to the 2205 tile to win!"],
        ["p", "Spawning tiles: 1 (100%)"]);
        displayRules("gm_rules_text", ["h2", "Powers of 3 Times Powers of 5 Times Powers of 7"], ["h1", "2205 (Level 1)"], ["p", "Merges occur between three 1s, or between any tile and two equal tiles that are each a third, a fifth, or a seventh of the larger tile. Get to the 2205 tile to win!"],
        ["p", "Spawning tiles: 1 (100%)"]);
        statBoxes = [["Discovered Tiles", ["@DiscTiles", "arr_length"], false, ...[,,,], ["@GVar 0", "=", 0], [0, "@edit_gvar", 0, 1], true], ["Discovered Tiles", ["@DiscTiles"], true, false, "TileArray", "Self", ["@GVar 0", "=", 1], [0, "@edit_gvar", 0, 0], true], ["Score", "@Score"]];
        document.getElementById("mode_vars_line").style.setProperty("display", "block");
        document.getElementById("2205_vars").style.setProperty("display", "flex");
    }
    else if (mode == 69) { // (232, 240)
        // width = 4; height = 4;
        start_game_vars = [0]; // Controls the display of Discovered Tiles
        if (modifiers[13] == "None") {
            TileNumAmount = 2;
            TileTypes = [
                [true, ["(", "str_concat", ["@This 0", "defaultAbbrevB"], "str_concat", ", ", "str_concat", ["@This 1", "defaultAbbrevB"], "str_concat", ")"], "#000", "#ffffff", "none", 0, 0, ["PrimeImage", ["@ColorScheme", "1321", ["@This 0", "*", 2], 1, 0.44]], ["PrimeImage", ["@ColorScheme", "1321", ["@This 1", "*", 2], 1, 0.44], ["@linear-gradient", "#0000", "#0000", "#000", "#000"]]],
            ];
            MergeRules = [
                [2, [["@This 0", "=", "@Next 1 0"], "||", ["@This 1", "=", "@Next 1 1"]], true, [[["@This 0", "+B", "@Next 1 0"], ["@This 1", "+B", "@Next 1 1"]]], [["@This 0", "+", "@Next 1 0", "^", 2], "+", ["@This 1", "+", "@Next 1 1", "^", 2], "^", 1/2], [false, true]],
            ];
            startTileSpawns = [[[1n, 0n], 1], [[0n, 1n], 1], [[1n, 1n], 1]];
            winConditions = [[232n, 240n]];
            winRequirement = 1;
            displayRules("rules_text", ["h1", "(232, 240)"], ["p", "Tiles are ordered pairs, and two tiles can merge if they're equal in at least one of their two slots (but they must be equal in the same position; the first number of one tile being equal to the second number of the other tile doesn't count!). Get to the (232, 240) tile to win (your first task is figuring out how to get there...), or just play and see what tiles you end up making!"],
            ["p", "Spawning tiles: (1, 0) (33.33%), (0, 1) (33.33%), (1, 1) (33.33%)"]);
            displayRules("gm_rules_text", ["h1", "(232, 240)"], ["p", "Tiles are ordered pairs, and two tiles can merge if they're equal in at least one of their two slots (but they must be equal in the same position; the first number of one tile being equal to the second number of the other tile doesn't count!). Get to the (232, 240) tile to win (your first task is figuring out how to get there...), or just play and see what tiles you end up making!"],
            ["p", "Spawning tiles: (1, 0) (33.33%), (0, 1) (33.33%), (1, 1) (33.33%)"]);
        }
        else if (modifiers[13] == "Non-Interacting") {
            TileNumAmount = 2;
            TileTypes = [
                [[["@This 0", ">", 0n], "||", ["@This 1", ">", 0n]], ["(", "str_concat", ["@This 0", "defaultAbbrevB"], "str_concat", ", ", "str_concat", ["@This 1", "defaultAbbrevB"], "str_concat", ")"], "#000", "#ffffff", "none", 0, 0, ["PrimeImage", ["@ColorScheme", "1321", ["@This 0", "*B", 2n], 1, 0.44]], ["PrimeImage", ["@ColorScheme", "1321", ["@This 1", "*B", 2n], 1, 0.44], ["@linear-gradient", "#0000", "#0000", "#000", "#000"]]],
                [[["@This 0", "<", 0n], "||", ["@This 1", "<", 0n]], ["(", "str_concat", ["@This 0", "defaultAbbrevB"], "str_concat", ", ", "str_concat", ["@This 1", "defaultAbbrevB"], "str_concat", ")"], "#000", "#000000", "none", 0, 0, ["PrimeImage", ["@ColorScheme", "1321", ["@This 0", "*B", 2n], 1, 0.44]], ["PrimeImage", ["@ColorScheme", "1321", ["@This 1", "*B", 2n], 1, 0.44], ["@linear-gradient", "#0000", "#0000", "#000", "#000"]]],
            ];
            MergeRules = [
                [2, [["@This 0", "=", "@Next 1 0"], "||", ["@This 1", "=", "@Next 1 1"], "&&", [[[["@This 0", ">=", 0n], "&&", ["@This 1", ">=", 0n], "&&", ["@Next 1 0", ">=", 0n], "&&", ["@Next 1 1", ">=", 0n]]], "||", [[["@This 0", "<=", 0n], "&&", ["@This 1", "<=", 0n], "&&", ["@Next 1 0", "<=", 0n], "&&", ["@Next 1 1", "<=", 0n]]]]], true, [[["@This 0", "+B", "@Next 1 0"], ["@This 1", "+B", "@Next 1 1"]]], [["@This 0", "+", "@Next 1 0", "^", 2], "+", ["@This 1", "+", "@Next 1 1", "^", 2], "^", 1/2], [false, true]],
            ];
            startTileSpawns = [[[1n, 0n], modifiers[22]], [[0n, 1n], modifiers[22]], [[1n, 1n], modifiers[22]], [[-1n, 0n], modifiers[23]], [[0n, -1n], modifiers[23]], [[-1n, -1n], modifiers[23]]];
            winConditions = [[232n, 240n], [-232n, -240n]];
            winRequirement = 1;
            displayRules("rules_text", ["h1", "(232, 240)"], ["p", "Tiles are ordered pairs, and two tiles can merge if they're equal in at least one of their two slots (but they must be equal in the same position; the first number of one tile being equal to the second number of the other tile doesn't count!). Get to the (232, 240) tile to win (your first task is figuring out how to get there...), or just play and see what tiles you end up making!"],
            ["p", "Spawning tiles: (1, 0) (16.67%), (0, 1) (16.67%), (1, 1) (16.67%), (-1, 0) (16.67%), (0, -1) (16.67%), (-1, -1) (16.67%)"]);
            displayRules("gm_rules_text", ["h1", "(232, 240)"], ["p", "Tiles are ordered pairs, and two tiles can merge if they're equal in at least one of their two slots (but they must be equal in the same position; the first number of one tile being equal to the second number of the other tile doesn't count!). Get to the (232, 240) tile to win (your first task is figuring out how to get there...), or just play and see what tiles you end up making!"],
            ["p", "Spawning tiles: (1, 0) (16.67%), (0, 1) (16.67%), (1, 1) (16.67%), (-1, 0) (16.67%), (0, -1) (16.67%), (-1, -1) (16.67%)"]);
        }
        else {
            TileNumAmount = 2;
            TileTypes = [
                [
                    true, ["(", "str_concat", ["@This 0", "defaultAbbrevB"], "str_concat", ", ", "str_concat", ["@This 1", "defaultAbbrevB"], "str_concat", ")"],
                    "#000", ["@CalcArray", "#000000", "@if", [["@This 0", ">", 0n], "&&", ["@This 1", ">", 0n]], "2nd", "#ff0000", "@end-if", "@if", [["@This 0", "<", 0n], "&&", ["@This 1", ">", 0n]], "2nd", "#ff8000", "@end-if", "@if", [["@This 0", "<", 0n], "&&", ["@This 1", "<", 0n]], "2nd", "#00ffff", "@end-if", "@if", [["@This 0", ">", 0n], "&&", ["@This 1", "<", 0n]], "2nd", "#8000ff", "@end-if", "@if", [["@This 0", ">", 0n], "&&", ["@This 1", "=", 0n]], "2nd", "#ff00bf", "@end-if", "@if", [["@This 0", "=", 0n], "&&", ["@This 1", ">", 0n]], "2nd", "#ffbf00", "@end-if", "@if", [["@This 0", "<", 0n], "&&", ["@This 1", "=", 0n]], "2nd", "#00ff40", "@end-if", "@if", [["@This 0", "=", 0n], "&&", ["@This 1", "<", 0n]], "2nd", "#0040ff", "@end-if"],
                    "0px 0px 5px #000000", 0, 0, ["PrimeImage", ["@ColorScheme", "1321", ["@This 0", "*B", 2n], 1, 0.44]], ["PrimeImage", ["@ColorScheme", "1321", ["@This 1", "*B", 2n], 1, 0.44], ["@linear-gradient", "#0000", "#0000", "#000", "#000"]]
                ],
            ];
            MergeRules = [
                [2, [["@This 0", "*B", -1n, "=", "@Next 1 0"], "&&", ["@This 1", "*B", -1n, "=", "@Next 1 1"]], true, [], 0, [true, true]],
                [2, [["@This 0", "=", "@Next 1 0"], "||", ["@This 1", "=", "@Next 1 1"], "||", ["@This 0", "*B", -1n, "=", "@Next 1 0"], "||", ["@This 1", "*B", -1n, "=", "@Next 1 1"]], true, [[["@This 0", "+B", "@Next 1 0"], ["@This 1", "+B", "@Next 1 1"]]], [["@This 0", "+", "@Next 1 0", "^", 2], "+", ["@This 1", "+", "@Next 1 1", "^", 2], "^", 1/2], [false, true]]
            ];
            startTileSpawns = [[[1n, 0n], modifiers[22] * modifiers[22]], [[0n, 1n], modifiers[22] * modifiers[22]], [[1n, 1n], modifiers[22] * modifiers[22]], [[-1n, 0n], modifiers[22] * modifiers[23]], [[0n, -1n], modifiers[22] * modifiers[23]], [[1n, -1n], modifiers[22] * modifiers[23]], [[-1n, 1n], modifiers[22] * modifiers[23]], [[-1n, -1n], modifiers[23] * modifiers[23]]];
            winConditions = [[232n, 240n]];
            winRequirement = 1;
            displayRules("rules_text", ["h1", "(232, 240)"], ["p", "Tiles are ordered pairs, and two tiles can merge if they're equal or opposite in at least one of their two slots (but they must be equal in the same position; the first number of one tile being equal to the second number of the other tile doesn't count!). Get to the (232, 240) tile to win (your first task is figuring out how to get there...), or just play and see what tiles you end up making!"],
            ["p", "Spawning tiles: (1, 0) (12.5%), (0, 1) (12.5%), (1, 1) (12.5%), (-1, 0) (12.5%), (0, -1) (12.5%), (-1, -1) (12.5%), (1, -1) (12.5%), (-1, 1) (12.5%)"]);
            displayRules("gm_rules_text", ["h1", "(232, 240)"], ["p", "Tiles are ordered pairs, and two tiles can merge if they're equal or opposite in at least one of their two slots (but they must be equal in the same position; the first number of one tile being equal to the second number of the other tile doesn't count!). Get to the (232, 240) tile to win (your first task is figuring out how to get there...), or just play and see what tiles you end up making!"],
            ["p", "Spawning tiles: (1, 0) (12.5%), (0, 1) (12.5%), (1, 1) (12.5%), (-1, 0) (12.5%), (0, -1) (12.5%), (-1, -1) (12.5%), (1, -1) (12.5%), (-1, 1) (12.5%)"]);
        }
        knownMergeMaxLength = 2;
        knownMergeLookbackDistance = 0;
        document.documentElement.style.setProperty("background-image", "linear-gradient(90deg, #cbf270, #9c54db)");
        document.documentElement.style.setProperty("--background-color", "linear-gradient(#dbf2a5, #ab79d6)");
        document.documentElement.style.setProperty("--grid-color", "#829060");
        document.documentElement.style.setProperty("--tile-color", "#cab6dc");
        document.documentElement.style.setProperty("--text-color", "#220839");
        statBoxes = [["Discovered Tiles", ["@DiscTiles", "arr_length"], false, ...[,,,], ["@GVar 0", "=", 0], [0, "@edit_gvar", 0, 1], true], ["Discovered Tiles", ["@DiscTiles"], true, false, "TileArray", "Self", ["@GVar 0", "=", 1], [0, "@edit_gvar", 0, 0], true], ["Score", "@Score"]];
    }
    else if (mode == 70) { // 16+16i
        // width = 5; height = 5;
        TileNumAmount = 2;
        TileTypes = [
        [[0, 0], "1", ["@radial-gradient", "#000000", 0, 60, "#ff0000"], "#fff8e3"], [[0, 1], "1i", ["@radial-gradient", "#000000", 0, 60, "#80ff00"], "#fff8e3"],
        [[0, 2], "-1", ["@radial-gradient", "#000000", 0, 60, "#00ffff"], "#fff8e3"], [[0, 3], "-1i", ["@radial-gradient", "#000000", 0, 60, "#8000ff"], "#fff8e3"],
        [[1, 0], "1+1i", ["@radial-gradient", "#040031", 0, 60, "#ff0000"], "#fff8e3"], [[1, 1], "-1+1i", ["@radial-gradient", "#040031", 0, 60, "#80ff00"], "#fff8e3"],
        [[1, 2], "-1-1i", ["@radial-gradient", "#040031", 0, 60, "#00ffff"], "#fff8e3"], [[1, 3], "1-1i", ["@radial-gradient", "#040031", 0, 60, "#8000ff"], "#fff8e3"],
        [[2, 0], "2i", ["@radial-gradient", "#300049", 0, 60, "#ff0000"], "#fff8e3"], [[2, 1], "-2", ["@radial-gradient", "#300049", 0, 60, "#80ff00"], "#fff8e3"],
        [[2, 2], "-2i", ["@radial-gradient", "#300049", 0, 60, "#00ffff"], "#fff8e3"], [[2, 3], "2", ["@radial-gradient", "#300049", 0, 60, "#8000ff"], "#fff8e3"],
        [[3, 0], "-2+2i", ["@radial-gradient", "#49004d", 0, 60, "#ff0000"], "#fff8e3"], [[3, 1], "-2-2i", ["@radial-gradient", "#49004d", 0, 60, "#80ff00"], "#fff8e3"],
        [[3, 2], "2-2i", ["@radial-gradient", "#49004d", 0, 60, "#00ffff"], "#fff8e3"], [[3, 3], "2+2i", ["@radial-gradient", "#49004d", 0, 60, "#8000ff"], "#fff8e3"],
        [[4, 0], "-4", ["@radial-gradient", "#6e0054", 0, 60, "#ff0000"], "#fff8e3"], [[4, 1], "-4i", ["@radial-gradient", "#6e0054", 0, 60, "#80ff00"], "#fff8e3"],
        [[4, 2], "4", ["@radial-gradient", "#6e0054", 0, 60, "#00ffff"], "#fff8e3"], [[4, 3], "4i", ["@radial-gradient", "#6e0054", 0, 60, "#8000ff"], "#fff8e3"],
        [[5, 0], "-4-4i", ["@radial-gradient", "#930139", 0, 60, "#ff0000"], "#fff8e3"], [[5, 1], "4-4i", ["@radial-gradient", "#930139", 0, 60, "#80ff00"], "#fff8e3"],
        [[5, 2], "4+4i", ["@radial-gradient", "#930139", 0, 60, "#00ffff"], "#fff8e3"], [[5, 3], "-4+4i", ["@radial-gradient", "#930139", 0, 60, "#8000ff"], "#fff8e3"],
        [[6, 0], "-8i", ["@radial-gradient", "#bc1000", 0, 60, "#ff0000"], "#fff8e3"], [[6, 1], "8", ["@radial-gradient", "#bc1000", 0, 60, "#80ff00"], "#fff8e3"],
        [[6, 2], "8i", ["@radial-gradient", "#bc1000", 0, 60, "#00ffff"], "#fff8e3"], [[6, 3], "-8", ["@radial-gradient", "#bc1000", 0, 60, "#8000ff"], "#fff8e3"],
        [[7, 0], "8-8i", ["@radial-gradient", "#d15700", 0, 60, "#ff0000"], "#fff8e3"], [[7, 1], "8+8i", ["@radial-gradient", "#d15700", 0, 60, "#80ff00"], "#fff8e3"],
        [[7, 2], "-8+8i", ["@radial-gradient", "#d15700", 0, 60, "#00ffff"], "#fff8e3"], [[7, 3], "-8-8i", ["@radial-gradient", "#d15700", 0, 60, "#8000ff"], "#fff8e3"],
        [[8, 0], "16", ["@radial-gradient", "#de9400", 0, 60, "#ff0000"], "#fff8e3"], [[8, 1], "16i", ["@radial-gradient", "#de9400", 0, 60, "#80ff00"], "#fff8e3"],
        [[8, 2], "-16", ["@radial-gradient", "#de9400", 0, 60, "#00ffff"], "#fff8e3"], [[8, 3], "-16i", ["@radial-gradient", "#de9400", 0, 60, "#8000ff"], "#fff8e3"],
        [[9, 0], "16+16i", ["@radial-gradient", "#ffc400", 0, 60, "#ff0000"], "#fff8e3"], [[9, 1], "-16+16i", ["@radial-gradient", "#ffc400", 0, 60, "#80ff00"], "#fff8e3"],
        [[9, 2], "-16-16i", ["@radial-gradient", "#ffc400", 0, 60, "#00ffff"], "#fff8e3"], [[9, 3], "16-16i", ["@radial-gradient", "#ffc400", 0, 60, "#8000ff"], "#fff8e3"],
        [[10, 0], "32i", ["@radial-gradient", "#ffff36", 0, 60, "#ff0000"], "#201806"], [[10, 1], "-32", ["@radial-gradient", "#ffff36", 0, 60, "#80ff00"], "#201806"],
        [[10, 2], "-32i", ["@radial-gradient", "#ffff36", 0, 60, "#00ffff"], "#201806"], [[10, 3], "32", ["@radial-gradient", "#ffff36", 0, 60, "#8000ff"], "#201806"],
        [[11, 0], "-32+32i", ["@radial-gradient", "#b6ff56", 0, 60, "#ff0000"], "#201806"], [[11, 1], "-32-32i", ["@radial-gradient", "#b6ff56", 0, 60, "#80ff00"], "#201806"],
        [[11, 2], "32-32i", ["@radial-gradient", "#b6ff56", 0, 60, "#00ffff"], "#201806"], [[11, 3], "32+32i", ["@radial-gradient", "#b6ff56", 0, 60, "#8000ff"], "#201806"],
        [[12, 0], "-64", ["@radial-gradient", "#8aff78", 0, 60, "#ff0000"], "#201806"], [[12, 1], "-64i", ["@radial-gradient", "#8aff78", 0, 60, "#80ff00"], "#201806"],
        [[12, 2], "64", ["@radial-gradient", "#8aff78", 0, 60, "#00ffff"], "#201806"], [[12, 3], "64i", ["@radial-gradient", "#8aff78", 0, 60, "#8000ff"], "#201806"],
        [[13, 0], "-64-64i", ["@radial-gradient", "#94ffcd", 0, 60, "#ff0000"], "#201806"], [[13, 1], "64-64i", ["@radial-gradient", "#94ffcd", 0, 60, "#80ff00"], "#201806"],
        [[13, 2], "64+64i", ["@radial-gradient", "#94ffcd", 0, 60, "#00ffff"], "#201806"], [[13, 3], "-64+64i", ["@radial-gradient", "#94ffcd", 0, 60, "#8000ff"], "#201806"],
        [[14, 0], "-128i", ["@radial-gradient", "#aeffff", 0, 60, "#ff0000"], "#201806"], [[14, 1], "128", ["@radial-gradient", "#aeffff", 0, 60, "#80ff00"], "#201806"],
        [[14, 2], "128i", ["@radial-gradient", "#aeffff", 0, 60, "#00ffff"], "#201806"], [[14, 3], "-128", ["@radial-gradient", "#aeffff", 0, 60, "#8000ff"], "#201806"],
        [[15, 0], "128-128i", ["@radial-gradient", "#c9edff", 0, 60, "#ff0000"], "#201806"], [[15, 1], "128+128i", ["@radial-gradient", "#c9edff", 0, 60, "#80ff00"], "#201806"],
        [[15, 2], "-128+128i", ["@radial-gradient", "#c9edff", 0, 60, "#00ffff"], "#201806"], [[15, 3], "-128-128i", ["@radial-gradient", "#c9edff", 0, 60, "#8000ff"], "#201806"],
        [[16, 0], "256", ["@radial-gradient", "#e3e6ff", 0, 60, "#ff0000"], "#201806"], [[16, 1], "256i", ["@radial-gradient", "#e3e6ff", 0, 60, "#80ff00"], "#201806"],
        [[16, 2], "-256", ["@radial-gradient", "#e3e6ff", 0, 60, "#00ffff"], "#201806"], [[16, 3], "-256i", ["@radial-gradient", "#e3e6ff", 0, 60, "#8000ff"], "#201806"],
        [[["@This 0", "%", 2, "=", 0], "&&", ["@This 0", "/", 2, "+", "@This 1", "%", 4, "=", 0]], [[2, "^", ["@This 0", "/", 2], "defaultAbbrev"]], ["@radial-gradient", ["@HSLA", ["@This 0", "*", 29, "-", 450], [0.75, "^", ["@This 0", "-", 1, "floor", 16, "/", 16], "*", 100], ["@This 0", "-", 1, "%", 16, "*", 5.75, "+", 10], 1], 0, 60, ["@HSLA", ["@This 1", "*", 90], 100, 50, 1]], ["#fff8e3", "@if", ["@This 0", "-", 1, "%", 16, ">", 7], "2nd", "#201806", "@end-if"]],
        [[["@This 0", "%", 2, "=", 0], "&&", ["@This 0", "/", 2, "+", "@This 1", "%", 4, "=", 1]], [[2, "^", ["@This 0", "/", 2], "defaultAbbrev"], "str_concat", "i"], ["@radial-gradient", ["@HSLA", ["@This 0", "*", 29, "-", 450], [0.75, "^", ["@This 0", "-", 1, "floor", 16, "/", 16], "*", 100], ["@This 0", "-", 1, "%", 16, "*", 5.75, "+", 10], 1], 0, 60, ["@HSLA", ["@This 1", "*", 90], 100, 50, 1]], ["#fff8e3", "@if", ["@This 0", "-", 1, "%", 16, ">", 7], "2nd", "#201806", "@end-if"]],
        [[["@This 0", "%", 2, "=", 0], "&&", ["@This 0", "/", 2, "+", "@This 1", "%", 4, "=", 2]], ["-", "str_concat", [2, "^", ["@This 0", "/", 2], "defaultAbbrev"]], ["@radial-gradient", ["@HSLA", ["@This 0", "*", 29, "-", 450], [0.75, "^", ["@This 0", "-", 1, "floor", 16, "/", 16], "*", 100], ["@This 0", "-", 1, "%", 16, "*", 5.75, "+", 10], 1], 0, 60, ["@HSLA", ["@This 1", "*", 90], 100, 50, 1]], ["#fff8e3", "@if", ["@This 0", "-", 1, "%", 16, ">", 7], "2nd", "#201806", "@end-if"]],
        [[["@This 0", "%", 2, "=", 0], "&&", ["@This 0", "/", 2, "+", "@This 1", "%", 4, "=", 3]], ["-", "str_concat", [2, "^", ["@This 0", "/", 2], "defaultAbbrev"], "str_concat", "i"], ["@radial-gradient", ["@HSLA", ["@This 0", "*", 29, "-", 450], [0.75, "^", ["@This 0", "-", 1, "floor", 16, "/", 16], "*", 100], ["@This 0", "-", 1, "%", 16, "*", 5.75, "+", 10], 1], 0, 60, ["@HSLA", ["@This 1", "*", 90], 100, 50, 1]], ["#fff8e3", "@if", ["@This 0", "-", 1, "%", 16, ">", 7], "2nd", "#201806", "@end-if"]],
        [[["@This 0", "%", 2, "=", 1], "&&", ["@This 0", "-", 1, "/", 2, "+", "@This 1", "%", 4, "=", 0]], [[2, "^", ["@This 0", "-", 1, "/", 2], "defaultAbbrev"], "str_concat", "+", "str_concat", [2, "^", ["@This 0", "-", 1, "/", 2], "defaultAbbrev"], "str_concat", "i"], ["@radial-gradient", ["@HSLA", ["@This 0", "*", 29, "-", 450], [0.75, "^", ["@This 0", "-", 1, "floor", 16, "/", 16], "*", 100], ["@This 0", "-", 1, "%", 16, "*", 5.75, "+", 10], 1], 0, 60, ["@HSLA", ["@This 1", "*", 90], 100, 50, 1]], ["#fff8e3", "@if", ["@This 0", "-", 1, "%", 16, ">", 7], "2nd", "#201806", "@end-if"]],
        [[["@This 0", "%", 2, "=", 1], "&&", ["@This 0", "-", 1, "/", 2, "+", "@This 1", "%", 4, "=", 1]], ["-", "str_concat", [2, "^", ["@This 0", "-", 1, "/", 2], "defaultAbbrev"], "str_concat", "+", "str_concat", [2, "^", ["@This 0", "-", 1, "/", 2], "defaultAbbrev"], "str_concat", "i"], ["@radial-gradient", ["@HSLA", ["@This 0", "*", 29, "-", 450], [0.75, "^", ["@This 0", "-", 1, "floor", 16, "/", 16], "*", 100], ["@This 0", "-", 1, "%", 16, "*", 5.75, "+", 10], 1], 0, 60, ["@HSLA", ["@This 1", "*", 90], 100, 50, 1]], ["#fff8e3", "@if", ["@This 0", "-", 1, "%", 16, ">", 7], "2nd", "#201806", "@end-if"]],
        [[["@This 0", "%", 2, "=", 1], "&&", ["@This 0", "-", 1, "/", 2, "+", "@This 1", "%", 4, "=", 2]], ["-", "str_concat",[2, "^", ["@This 0", "-", 1, "/", 2], "defaultAbbrev"], "str_concat", "-", "str_concat", [2, "^", ["@This 0", "-", 1, "/", 2], "defaultAbbrev"], "str_concat", "i"], ["@radial-gradient", ["@HSLA", ["@This 0", "*", 29, "-", 450], [0.75, "^", ["@This 0", "-", 1, "floor", 16, "/", 16], "*", 100], ["@This 0", "-", 1, "%", 16, "*", 5.75, "+", 10], 1], 0, 60, ["@HSLA", ["@This 1", "*", 90], 100, 50, 1]], ["#fff8e3", "@if", ["@This 0", "-", 1, "%", 16, ">", 7], "2nd", "#201806", "@end-if"]],
        [[["@This 0", "%", 2, "=", 1], "&&", ["@This 0", "-", 1, "/", 2, "+", "@This 1", "%", 4, "=", 3]], [[2, "^", ["@This 0", "-", 1, "/", 2], "defaultAbbrev"], "str_concat", "-", "str_concat", [2, "^", ["@This 0", "-", 1, "/", 2], "defaultAbbrev"], "str_concat", "i"], ["@radial-gradient", ["@HSLA", ["@This 0", "*", 29, "-", 450], [0.75, "^", ["@This 0", "-", 1, "floor", 16, "/", 16], "*", 100], ["@This 0", "-", 1, "%", 16, "*", 5.75, "+", 10], 1], 0, 60, ["@HSLA", ["@This 1", "*", 90], 100, 50, 1]], ["#fff8e3", "@if", ["@This 0", "-", 1, "%", 16, ">", 7], "2nd", "#201806", "@end-if"]],
        ]
        MergeRules = [
            [2, [["@This 0", "=", "@Next 1 0"], "&&", ["@This 1", "+", 1, "%", 4, "=", "@Next 1 1"]], false, [[["@This 0", "+", 1], "@This 1"]], [2, "^", "@This 0", "*", 2], [false, true]],
        ];
        if (modifiers[13] == "Interacting") MergeRules.push([2, [["@This 0", "=", "@Next 1 0"], "&&", ["@This 1", "+", 2, "%", 4, "=", "@Next 1 1"]], false, [], 0, [false, true]])
        startTileSpawns = [["Box", 1, [0, 0], 1, [0, 1], 1, [0, 2], 1, [0, 3], 1]];
        winConditions = [[9, 0], [9, 1], [9, 2], [9, 3]];
        winRequirement = 1;
        knownMergeMaxLength = 2;
        knownMergeLookbackDistance = 0;
        document.documentElement.style.setProperty("background-image", "radial-gradient(#ffc400 0% 60%, #ff0000)");
        document.documentElement.style.setProperty("--background-color", "radial-gradient(#ffd752 0% 60%, #ff6b6b)");
        document.documentElement.style.setProperty("--grid-color", "#dbb228");
        document.documentElement.style.setProperty("--tile-color", "#ffb0b0");
        document.documentElement.style.setProperty("--text-color", "#7f3018");
        displayRules("rules_text", ["h2", "Powers of 1 + i"], ["h1", "16 + 16i"], ["p","Two tiles can merge if one of them is i times the other one. Get to the 16+16i tile (or any of its other unit multiples) to win! (Score increases by the norm, i.e. the squared absolute value, of the result tile)"],
        ["p", "Spawning tiles: Pulls from a \"box\" that starts with one 1, one i, one -1, and one -i, and only refills once it's empty."]);
        displayRules("gm_rules_text", ["h2", "Powers of 1 + i"], ["h1", "16 + 16i"], ["p","Two tiles can merge if one of them is i times the other one. Get to the 16+16i tile (or any of its other unit multiples) to win! (Score increases by the norm, i.e. the squared absolute value, of the result tile)"],
        ["p", "Spawning tiles: Pulls from a \"box\" that starts with one 1, one i, one -1, and one -i, and only refills once it's empty."]);
    }
    else if (mode == 71) { // 3,188,646
        // width = 5; height = 5;
        mode_vars = [true]; // Does the multiplication tile have to be in the middle?
        if (modifiers[13] == "None") {
            TileNumAmount = 2;
            TileTypes = [
                [["Multiply", "@Signless"], "&#215;", ["@radial-gradient", "#ff6f00", 0, 25, "#ffc800"], "#ff2200"],
                [["@This 1", "=", 2], [3, "^", "@This 0", "*", 2], ["@linear-gradient", ["@HSVA", ["@This 0", "*", 23, "+", 131], 100, 100, 1], ["@HSVA", ["@This 0", "*", 19, "+", 131], 100, [0.997, "^", "@This 0", "*", 100], 1]], "#f5ffba"],
                [["@This 1", "=", 4], [3, "^", "@This 0", "*", 4], ["@linear-gradient", ["@HSVA", ["@This 0", "*", 23, "+", 131], 60, 100, 1], ["@HSVA", ["@This 0", "*", 19, "+", 131], 60, [0.997, "^", "@This 0", "*", 100], 1]], "#2d3500"]
            ];
            MergeRules = [
                [2, [["@Next 1 0", "=", "@This 0"], "&&", ["@This 1", "=", 2], "&&", ["@Next 1 1", "=", 4]], false, [[["@This 0", "+", 1], 2]], [3, "^", "@This 0", "*", 6], [false, true]],
                [3, [["@Next 1 0", "=", "Multiply"], "&&", ["@This 1", "=", 2], "&&", ["@Next 2 1", "=", 2]], true, [[["@This 0", "+", "@Next 2 0"], 4]], 0, [false, true]],
                [2, [["@Next 1 0", "=", "Multiply"], "&&", ["@This 0", "=", "Multiply"]], true, [["Multiply", "@Signless"]], 0, [true, true]]
            ];
            startTileSpawns = [[[0, 2], 50], [["Multiply", "@Signless"], 50]];
            winConditions = [[13, 2]];
            winRequirement = 1;
        }
        else {
            TileNumAmount = 3;
            TileTypes = [
                [["Multiply", "@Signless", 0], "&#215;", ["@radial-gradient", "#ff6f00", 0, 25, "#ffc800"], "#ff2200"],
                [[["@This 1", "=", 2], "&&", ["@This 2", "=", 1]], [3, "^", "@This 0", "*", 2], ["@linear-gradient", ["@HSVA", ["@This 0", "*", 23, "+", 131], 100, 100, 1], ["@HSVA", ["@This 0", "*", 19, "+", 131], 100, [0.997, "^", "@This 0", "*", 100], 1]], "#f5ffba"],
                [[["@This 1", "=", 4], "&&", ["@This 2", "=", 1]], [3, "^", "@This 0", "*", 4], ["@linear-gradient", ["@HSVA", ["@This 0", "*", 23, "+", 131], 60, 100, 1], ["@HSVA", ["@This 0", "*", 19, "+", 131], 60, [0.997, "^", "@This 0", "*", 100], 1]], "#2d3500"],
                [[["@This 1", "=", 2], "&&", ["@This 2", "=", -1]], [3, "^", "@This 0", "*", -2], ["@rotate", 180, true, ["@linear-gradient", ["@HSVA", ["@This 0", "*", 23, "+", 131], 100, 100, 1], ["@HSVA", ["@This 0", "*", 19, "+", 131], 100, [0.997, "^", "@This 0", "*", 100], 1]]], "#0a0045"],
                [[["@This 1", "=", 4], "&&", ["@This 2", "=", -1]], [3, "^", "@This 0", "*", -4], ["@rotate", 180, true, ["@linear-gradient", ["@HSVA", ["@This 0", "*", 23, "+", 131], 60, 100, 1], ["@HSVA", ["@This 0", "*", 19, "+", 131], 60, [0.997, "^", "@This 0", "*", 100], 1]]], "#d2caff"]
            ];
            MergeRules = [
                [2, [["@Next 1 0", "=", "@This 0"], "&&", ["@Next 1 2", "=", "@This 2"], "&&", ["@This 1", "=", 2], "&&", ["@Next 1 1", "=", 4]], false, [[["@This 0", "+", 1], 2, "@This 2"]], [3, "^", "@This 0", "*", 6], [false, true]],
                [3, [["@Next 1 0", "=", "Multiply"], "&&", ["@This 1", "=", 2], "&&", ["@Next 2 1", "=", 2]], true, [[["@This 0", "+", "@Next 2 0"], 4, ["@This 2", "*", "@Next 2 2"]]], 0, [false, true]],
                [2, [["@Next 1 0", "=", "Multiply"], "&&", ["@This 0", "=", "Multiply"]], true, [["Multiply", "@Signless", 0]], 0, [true, true]]
            ];
            if (modifiers[13] == "Interacting") MergeRules.unshift([2, [["@Next 1 0", "=", "@This 0"], "&&", ["@Next 1 1", "=", "@This 1"], "&&", ["@Next 1 2", "!=", "@This 2"]], true, [], 0, [true, true]]);
            startTileSpawns = [[[0, 2, 1], modifiers[22]], [[0, 2, -1], modifiers[23]], [["Multiply", "@Signless", 0], modifiers[22] + modifiers[23]]];
            winConditions = [[13, 2, 1], [13, 2, -1]];
            winRequirement = 2;
        }
        knownMergeMaxLength = 3;
        knownMergeLookbackDistance = 0;
        document.documentElement.style.setProperty("background-image", "linear-gradient(90deg, #e0ff33, #ff6726)");
        document.documentElement.style.setProperty("--background-color", "linear-gradient(#edff86, #ff793f)");
        document.documentElement.style.setProperty("--grid-color", "#cae91e");
        document.documentElement.style.setProperty("--tile-color", "#f88250");
        document.documentElement.style.setProperty("--text-color", "#493500");
        displayRules("rules_text", ["h1", "3,188,646"], ["p","There are multiplication tiles. If you merge two tiles that are each double a power of three (they do not need to be double the <i>same</i> power of three) with a multiplication tile in the middle, those two tiles will be multiplied. A tile that's quadruple a power of three can merge with a tile that's half of itself (i.e. double that power of three); this is the only kind of merge that gives any score. Also, if two multiplication tiles collide, they merge (and this does not prevent that multiplication tile from merging again that turn) to save on space. Get to the 3,188,646 (2 &#215; 3<sup>13</sup>) tile to win!"],
        ["p", "Spawning tiles: 2 (50%), &#215; (50%)"]);
        displayRules("gm_rules_text", ["h1", "3,188,646"], ["p","There are multiplication tiles. If you merge two tiles that are each double a power of three (they do not need to be double the <i>same</i> power of three) with a multiplication tile in the middle, those two tiles will be multiplied. A tile that's quadruple a power of three can merge with a tile that's half of itself (i.e. double that power of three); this is the only kind of merge that gives any score. Also, if two multiplication tiles collide, they merge (and this does not prevent that multiplication tile from merging again that turn) to save on space. Get to the 3,188,646 (2 &#215; 3<sup>13</sup>) tile to win!"],
        ["p", "Spawning tiles: 2 (50%), &#215; (50%)"]);
        document.getElementById("mode_vars_line").style.setProperty("display", "block");
        document.getElementById("3188646_vars").style.setProperty("display", "flex");
    }
    else if (mode == 72) { // 3026
        // width = 4; height = 4;
        TileNumAmount = 2;
        mode_vars = [false, 0, 4]; // If mode_vars[0] is true, any merge that adds to a valid tile is valid. mode_vars[1] controls the random goals, and mode_vars[2] controls the size of the first random goal.
        start_game_vars = [[1n, 2n], 0, 0, 1, [1, 1], 0, false, 0.5, 4] // The first four of these are only used in the "any valid tile" mode: game_vars[0] is a list of Fibonacci numbers, game_vars[1], [2], and [3] store the values of the resulting tile for a merge. [4], [5], and [6] are the random goals variables, and [7] is a random variable between 0 and 1 used to make the random goals more random in the "build upon" case. [8] controls the size of the first random goal.
        TileTypes = [
            [
                true, 
                [[[((1 + Math.sqrt(5))/2), "^", ["@This 0", "+", 2]], "-", [((1 + Math.sqrt(5))/-2), "^", ["@This 0", "*", -1, "-", 2]], "/", Math.sqrt(5), "round", 1], "*", [[((1 + Math.sqrt(5))/2), "^", ["@This 1", "+", 2]], "-", [((1 + Math.sqrt(5))/-2), "^", ["@This 1", "*", -1, "-", 2]], "/", Math.sqrt(5), "round", 1]],
                ["@linear-gradient", ["@HSLA", ["@This 0", "*", 23, "+", 53], [0.8, "^", ["@This 1", "/", 30, "floor", 1], "*", 100], ["@This 0", "%", 10, "*", -6, "+", 85], 1], 0, 33, ["@HSLA", ["@This 1", "*", 23, "+", 53], [0.8, "^", ["@This 1", "/", 30, "floor", 1], "*", 100], ["@This 1", "%", 10, "*", -6, "+", 85], 1], 66, 100], 
                "#19202e", "none", 2.5, 0,
                ["Innerscript", [[[((1 + Math.sqrt(5))/2), "^", ["@This 0", "+", 2]], "-", [((1 + Math.sqrt(5))/-2), "^", ["@This 0", "*", -1, "-", 2]], "/", Math.sqrt(5), "round", 1, "defaultAbbrev"], "str_concat", " &#215; ", "str_concat", [[((1 + Math.sqrt(5))/2), "^", ["@This 1", "+", 2]], "-", [((1 + Math.sqrt(5))/-2), "^", ["@This 1", "*", -1, "-", 2]], "/", Math.sqrt(5), "round", 1, "defaultAbbrev"]], "bottom-center", 6, 0]
            ]
        ]
        MergeRules = [
            [2, [["@This 0", "=", 0], "&&", ["@Next 1 0", "=", 0], "&&", ["@Next 1 1", "=", 0], "&&", ["@This 1", "=", 0]], true, [[0, 1]], 2, [false, true]],
            [2, [["@This 0", "=", "@Next 1 0"], "&&", ["@Next 1 1", "=", 0], "&&", ["@This 1", "=", 0]], true, [["@This 0", 1]], [2, "*", [[((1 + Math.sqrt(5))/2), "^", ["@This 0", "+", 2]], "-", [((1 + Math.sqrt(5))/-2), "^", ["@This 0", "*", -1, "-", 2]], "/", Math.sqrt(5), "round", 1]], [false, true]],
            [2, [["@This 1", "=", "@Next 1 1"], "&&", ["@Next 1 0", "=", 0], "&&", ["@This 0", "=", 0]], true, [[1, "@This 1"]], [2, "*", [[((1 + Math.sqrt(5))/2), "^", ["@This 1", "+", 2]], "-", [((1 + Math.sqrt(5))/-2), "^", ["@This 1", "*", -1, "-", 2]], "/", Math.sqrt(5), "round", 1]], [false, true]],
            [2, [["@This 0", "=", "@This 1"], "&&", ["@This 1", "=", "@Next 1 1"], "&&", ["@Next 1 0", "+", 1, "=", "@This 0"]], false, [["@This 0", ["@This 1", "+", 1]]], [[[((1 + Math.sqrt(5))/2), "^", ["@This 0", "+", 2]], "-", [((1 + Math.sqrt(5))/-2), "^", ["@This 0", "*", -1, "-", 2]], "/", Math.sqrt(5), "round", 1], "*", [[((1 + Math.sqrt(5))/2), "^", ["@This 1", "+", 3]], "-", [((1 + Math.sqrt(5))/-2), "^", ["@This 1", "*", -1, "-", 3]], "/", Math.sqrt(5), "round", 1]], [false, true]],
            [2, [["@This 0", "=", "@Next 1 0"], "&&", ["@Next 1 1", "+", 1, "=", "@This 1"]], false, [["@This 0", ["@This 1", "+", 1]]], [[[((1 + Math.sqrt(5))/2), "^", ["@This 0", "+", 2]], "-", [((1 + Math.sqrt(5))/-2), "^", ["@This 0", "*", -1, "-", 2]], "/", Math.sqrt(5), "round", 1], "*", [[((1 + Math.sqrt(5))/2), "^", ["@This 1", "+", 3]], "-", [((1 + Math.sqrt(5))/-2), "^", ["@This 1", "*", -1, "-", 3]], "/", Math.sqrt(5), "round", 1]], [false, true]],
            [2, [["@This 1", "=", "@Next 1 1"], "&&", ["@Next 1 0", "+", 1, "=", "@This 0"]], false, [[["@This 0", "+", 1], "@This 1"]], [[[((1 + Math.sqrt(5))/2), "^", ["@This 0", "+", 3]], "-", [((1 + Math.sqrt(5))/-2), "^", ["@This 0", "*", -1, "-", 3]], "/", Math.sqrt(5), "round", 1], "*", [[((1 + Math.sqrt(5))/2), "^", ["@This 1", "+", 2]], "-", [((1 + Math.sqrt(5))/-2), "^", ["@This 1", "*", -1, "-", 2]], "/", Math.sqrt(5), "round", 1]], [false, true]]
        ];
        startTileSpawns = [[[0, 0], 90], [[0, 1], 10]];
        winConditions = [[7, 9]];
        winRequirement = 1;
        knownMergeMaxLength = 2;
        knownMergeLookbackDistance = 0;
        document.documentElement.style.setProperty("background-image", "linear-gradient(#77e8ff, #3e0a8b)");
        document.documentElement.style.setProperty("--background-color", "linear-gradient(#baf4ff, #6224bd)");
        document.documentElement.style.setProperty("--grid-color", "#4da5e5");
        document.documentElement.style.setProperty("--tile-color", "#7357e5");
        document.documentElement.style.setProperty("--text-color", "#19202e");
        displayRules("rules_text", ["h1", "3026"], ["p", "Tiles are products of two Fibonacci numbers. Two tiles can merge if they share one Fibonacci number in common, and either the other Fibonacci number is 1 for both of them or one tile's other Fibonacci number is the Fibonacci number right before the other tile's other Fibonacci number. For example, 5 &#215; 8 and 5 &#215; 13 can merge to make 5 &#215; 21. Get to the 3026 (34 &#215; 89) tile to win!"],
        ["p", "Spawning tiles: 1 (90%), 2 (10%)"]);
        displayRules("gm_rules_text", ["h1", "3026"], ["p", "Tiles are products of two Fibonacci numbers. Two tiles can merge if they share one Fibonacci number in common, and either the other Fibonacci number is 1 for both of them or one tile's other Fibonacci number is the Fibonacci number right before the other tile's other Fibonacci number. For example, 5 &#215; 8 and 5 &#215; 13 can merge to make 5 &#215; 21. Get to the 3026 (34 &#215; 89) tile to win!"],
        ["p", "Spawning tiles: 1 (90%), 2 (10%)"]);
        document.getElementById("mode_vars_line").style.setProperty("display", "block");
        document.getElementById("3026_vars").style.setProperty("display", "flex");
    }
    else if (mode == 73) { // SQUART
        // width = 4; height = 4;
        TileNumAmount = 1;
        mode_vars = [0, 1536n]; // Random goals: first entry is the random goals setting, second entry is the first goal minimum
        start_game_vars = [1n, 0, false, [1n, 2n, 4n], 1536n, 0] // The first entry is the current random goal, the second entry is the amount of random goals met so far, the third entry is whether a random goal has been met this turn, the fourth entry is an array of possible tiles found by the random goals so far, and the fifth entry is the first goal minimum. The sixth entry controls the display of Discovered Tiles.
        TileTypes = [
            [true, "@This 0", "@ColorScheme", "SQUART", ["@This 0"]]
        ];
        if (modifiers[13] == "None") {
            MergeRules = [
                [2, [["@This 0", ">=", "@Next 1 0"], "&&", ["@Next 1 0", "^B", 2, "%B", ["@This 0", "@if", ["@This 0", "BigInt", "=", 0n], "2nd", 1n, "@end-if"], "=", 0n]], false, [[["@This 0", "+B", "@Next 1 0"]]], ["@This 0", "+", "@Next 1 0"], [false, true]]
            ];
            startTileSpawns = [[[1n], 100]];
        }
        else {
            startTileSpawns = [[[1n], modifiers[22]], [[-1n], modifiers[23]]];
            if (modifiers[13] == "Non-Interacting") {
                MergeRules = [
                    [2, [[["@This 0", ">", 0n], "=", ["@Next 1 0", ">", 0n]], "&&", [["@This 0", "absB"], ">=", ["@Next 1 0", "absB"]], "&&", ["@Next 1 0", "^B", 2, "%B", ["@This 0", "@if", ["@This 0", "BigInt", "=", 0n], "2nd", 1n, "@end-if"], "=", 0n]], false, [[["@This 0", "+B", "@Next 1 0"]]], ["@This 0", "+", "@Next 1 0", "abs"], [false, true]]
                ];
            }
            else {
                MergeRules = [
                    [2, ["@This 0", "*B", -1n, "=", "@Next 1 0"], false, [], 0, [true, true]],
                    [2, [[["@This 0", "absB"], ">=", ["@Next 1 0", "absB"]], "&&", ["@Next 1 0", "^B", 2, "%B", ["@This 0", "@if", ["@This 0", "BigInt", "=", 0n], "2nd", 1n, "@end-if"], "=", 0n]], false, [[["@This 0", "+B", "@Next 1 0"]]], ["@This 0", "+", "@Next 1 0", "abs"], [false, true]]
                ];
            }
        }
        winRequirement = false;
        knownMergeMaxLength = 2;
        knownMergeLookbackDistance = 0;
        document.documentElement.style.setProperty("background-image", "linear-gradient(#0000, #770000), conic-gradient(#0000 0deg 10deg, #fff8 35deg 55deg, #0000 80deg 100deg, #0008 125deg 145deg, #0000 170deg 190deg, #fff8 215deg 235deg, #0000 260deg 280deg, #0008 305deg 325deg, #0000 350deg), linear-gradient(#ce8f23, #ce8f23)");
        document.documentElement.style.setProperty("--background-color", "linear-gradient(#0000, #ad2727), conic-gradient(#0000 0deg 10deg, #fff8 35deg 55deg, #0000 80deg 100deg, #0008 125deg 145deg, #0000 170deg 190deg, #fff8 215deg 235deg, #0000 260deg 280deg, #0008 305deg 325deg, #0000 350deg), radial-gradient(#e2a53b, #e2a53b)");
        document.documentElement.style.setProperty("--grid-color", "#956108");
        document.documentElement.style.setProperty("--tile-color", "#953737");
        document.documentElement.style.setProperty("--text-color", "#441802");
        displayRules("rules_text", ["h1", "SQUART"], ["p", 'Two tiles can merge if they are equal or if the square of the smaller tile is a multiple of the larger tile. For example, 6 and 9 can merge because 6<sup>2</sup> = 36 is a multiple of 9. (Another way of thinking about it is "two tiles can merge if both tiles are integer multiples of the ratio between the two": for example, 9 and 6\'s ratio is 1.5, and 9 and 6 are both multiples of 1.5. This rule is equivalent to the "square of the smaller one" rule). This mode has a lot of possible tiles, so it doesn\'t have a win condition. If you want some goals to strive for, then here are some handpicked ones, from (hopefully) easiest to hardest: 2520, 2310, 1890, 2184, 2380, 2618. Alternatively, turn on random goals and aim for whatever goal it gives you!'],
        ["p", "Spawning tiles: 1 (100%)"]);
        displayRules("gm_rules_text", ["h1", "SQUART"], ["p", 'Two tiles can merge if they are equal or if the square of the smaller tile is a multiple of the larger tile. For example, 6 and 9 can merge because 6<sup>2</sup> = 36 is a multiple of 9. (Another way of thinking about it is "two tiles can merge if both tiles are integer multiples of the ratio between the two": for example, 9 and 6\'s ratio is 1.5, and 9 and 6 are both multiples of 1.5. This rule is equivalent to the "square of the smaller one" rule). This mode has a lot of possible tiles, so it doesn\'t have a win condition. If you want some goals to strive for, then here are some handpicked ones, from (hopefully) easiest to hardest: 2520, 2310, 1890, 2184, 2380, 2618. Alternatively, turn on random goals and aim for whatever goal it gives you!'],
        ["p", "Spawning tiles: 1 (100%)"]);
        statBoxes = [["Discovered Tiles", ["@DiscTiles", "arr_length"], false, ...[,,,], ["@GVar 5", "=", 0], [0, "@edit_gvar", 5, 1], true], ["Discovered Tiles", ["@DiscTiles"], true, false, "TileArray", "Self", ["@GVar 5", "=", 1], [0, "@edit_gvar", 5, 0], true], ["Score", "@Score"]];
        document.getElementById("mode_vars_line").style.setProperty("display", "block");
        document.getElementById("SQUART_vars").style.setProperty("display", "flex");
    }
    else if (mode == 74) { // Turatin
        // width = 4; height = 4;
        TileNumAmount = 1;
        mode_vars = [4, false, 0] // mode_vars[0] is the amount of turns between merge changes, mode_vars[1] allows non-integer ratios if true, mode_vars[2] controls what statistic is used to change the merge number (like in 2592)
        start_game_vars = [1n, 4, 4] // game_vars[0] is the merge number, game_vars[1] is the amount of turns until the next merge change, and game_vars[2] is the amount of turns between merge changes
        TileTypes = [
            [true, "@This 0", "@ColorScheme", "Turatin", ["@This 0"]]
        ];
        if (modifiers[13] == "None") {
            MergeRules = [
                [2, [["@This 0", ">=", "@Next 1 0"], "&&", ["@This 0", "%B", ["@Next 1 0", "@if", ["@Next 1 0", "BigInt", "=", 0n], "2nd", 1n, "@end-if"], "=", 0n], "&&", [["@This 0", "/B", ["@Next 1 0", "@if", ["@Next 1 0", "BigInt", "=", 0n], "2nd", 1n, "@end-if"]], "@end_vars", false, "@if", ["@var_retain", "@Var 0", "!=", 0n], "2nd", "@GVar 0", "%B", "@Var 0", "@end-if", "=", 0n]], false, [[["@This 0", "+B", "@Next 1 0"]]], ["@This 0", "/", "@Next 1 0"], [false, true]]
            ]
            startTileSpawns = [[[1n], 1]];
        }
        else {
            startTileSpawns = [[[1n], modifiers[22]], [[-1n], modifiers[23]]];
            if (modifiers[13] == "Non-Interacting") {
                MergeRules = [
                    [2, [[["@This 0", ">", 0n], "=", ["@Next 1 0", ">", 0n]], "&&", [["@This 0", "absB"], ">=", ["@Next 1 0", "absB"]], "&&", ["@This 0", "%B", ["@Next 1 0", "@if", ["@Next 1 0", "BigInt", "=", 0n], "2nd", 1n, "@end-if"], "=", 0n], "&&", [[["@This 0", "absB"], "/B", [["@Next 1 0", "@if", ["@Next 1 0", "BigInt", "=", 0n], "2nd", 1n, "@end-if"], "absB"]], "@end_vars", false, "@if", ["@var_retain", "@Var 0", "!=", 0n], "2nd", "@GVar 0", "%B", "@Var 0", "@end-if", "=", 0n]], false, [[["@This 0", "+B", "@Next 1 0"]]], ["@This 0", "/", "@Next 1 0", "abs"], [false, true]]
                ]
            }
            else {
                MergeRules = [
                    [2, ["@This 0", "*B", -1n, "=", "@Next 1 0"], false, [], 0, [true, true]],
                    [2, [[["@This 0", "absB"], ">=", ["@Next 1 0", "absB"]], "&&", ["@This 0", "%B", ["@Next 1 0", "@if", ["@Next 1 0", "BigInt", "=", 0n], "2nd", 1n, "@end-if"], "=", 0n], "&&", [[["@This 0", "absB"], "/B", [["@Next 1 0", "@if", ["@Next 1 0", "BigInt", "=", 0n], "2nd", 1n, "@end-if"], "absB"]], "@end_vars", false, "@if", ["@var_retain", "@Var 0", "!=", 0n], "2nd", "@GVar 0", "%B", "@Var 0", "@end-if", "=", 0n]], false, [[["@This 0", "+B", "@Next 1 0"]]], ["@This 0", "/", "@Next 1 0", "abs"], [false, true]]
                ]
            }
        }
        winRequirement = false;
        mergeResultKnownLevel = 0;
        document.documentElement.style.setProperty("background-image", "conic-gradient(#0000 0deg 35deg, rgb(70.83333333333333, 0, 70.83333333333333, 0.75) 35deg, rgba(127.5, 0, 0, 0.75) 40deg 50deg, rgb(70.83333333333333, 0, 70.83333333333333, 0.75) 55deg, #0000 55deg), conic-gradient(#0000 0deg 215deg, rgb(70.83333333333333, 0, 70.83333333333333, 0.75) 215deg, rgba(0, 127.5, 0, 0.75) 220deg 230deg, rgb(70.83333333333333, 0, 70.83333333333333, 0.75) 235deg, #0000 235deg), conic-gradient(#0000 0deg 125deg, rgb(70.83333333333333, 0, 70.83333333333333, 0.75) 125deg, rgba(0, 0, 127.5, 0.75) 130deg 140deg, rgb(70.83333333333333, 0, 70.83333333333333, 0.75) 145deg, #0000 145deg), conic-gradient(#0000 0deg 305deg, rgb(70.83333333333333, 0, 70.83333333333333, 0.75) 305deg, rgba(127.5, 127.5, 0, 0.75) 310deg 320deg, rgb(70.83333333333333, 0, 70.83333333333333, 0.75) 325deg, #0000 325deg), radial-gradient(#8e008e 0% 33%, #ffc76c)");
        document.documentElement.style.setProperty("--background-color", "conic-gradient(#0000 0deg 35deg, rgb(70.83333333333333, 0, 70.83333333333333, 0.5) 35deg, rgba(127.5, 0, 0, 0.5) 40deg 50deg, rgb(70.83333333333333, 0, 70.83333333333333, 0.5) 55deg, #0000 55deg), conic-gradient(#0000 0deg 215deg, rgb(70.83333333333333, 0, 70.83333333333333, 0.5) 215deg, rgba(0, 127.5, 0, 0.5) 220deg 230deg, rgb(70.83333333333333, 0, 70.83333333333333, 0.5) 235deg, #0000 235deg), conic-gradient(#0000 0deg 125deg, rgb(70.83333333333333, 0, 70.83333333333333, 0.5) 125deg, rgba(0, 0, 127.5, 0.5) 130deg 140deg, rgb(70.83333333333333, 0, 70.83333333333333, 0.5) 145deg, #0000 145deg), conic-gradient(#0000 0deg 305deg, rgb(70.83333333333333, 0, 70.83333333333333, 0.5) 305deg, rgba(127.5, 127.5, 0, 0.5) 310deg 320deg, rgb(70.83333333333333, 0, 70.83333333333333, 0.5) 325deg, #0000 325deg), radial-gradient(#c243c2 0% 33%, #ffdfac)");
        document.documentElement.style.setProperty("--grid-color", "#630063");
        document.documentElement.style.setProperty("--tile-color", "#d1b27f");
        document.documentElement.style.setProperty("--text-color", "#815612");
        displayRules("rules_text", ["h1", "Turatin"], ["p", 'The "merge number" starts at 1 and increases by 1 every 4 turns. Two tiles can merge if the ratio between the larger tile and the smaller tile is a factor of the current merge number. This mode has no win condition - your goal is just to survive as long as you can! (When two tiles merge, the score gained is the larger tile divided by the smaller tile, so if you want to go for high score, you\'ll need to make trickier merges!)'],
        ["p", "Spawning tiles: 1 (100%)"]);
        displayRules("gm_rules_text", ["h1", "Turatin"], ["p", 'The "merge number" starts at 1 and increases by 1 every 4 turns. Two tiles can merge if the ratio between the larger tile and the smaller tile is a factor of the current merge number. This mode has no win condition - your goal is just to survive as long as you can! (When two tiles merge, the score gained is the larger tile divided by the smaller tile, so if you want to go for high score, you\'ll need to make trickier merges!)'],
        ["p", "Spawning tiles: 1 (100%)"]);
        statBoxes = [["Turns Until Merge Change", "@GVar 1"], ["Merge Number", "@GVar 0", false, false, "Tile", "Turatin"], ["Score", "@Score"]];
        scripts = [
            [[0, "@edit_gvar", 1, ["@GVar 1", "-", 1], "@if", ["@GVar 1", "=", 0], "@edit_gvar", 0, ["@GVar 0", "+B", 1n], "@edit_gvar", 1, "@GVar 2", "@end-if"], "EndTurn"]
        ];
        document.getElementById("mode_vars_line").style.setProperty("display", "block");
        document.getElementById("Turatin_vars").style.setProperty("display", "flex");
    }
    else if (mode == 75) { // 3307
        // width = 5; height = 5;
        TileNumAmount = 1;
        mode_vars = [0]; // mode_vars[0] controls the variant we're in: 0 is 3307 (two equal tiles), 1 is 3379 (three equal tiles), 2 is 2667 (both)
        start_game_vars = [0]; // Controls the display of Discovered Tiles
        TileTypes = [
            [true, "@This 0", "@ColorScheme", "3307", ["@This 0"]]
        ];
        MergeRules = [
            [2, ["@This 0", "=", "@Next 1 0"], true, [[["@This 0", "*B", 2]]], ["@This 0", "*", 2], [false, true]],
            [3, [["@This 0", "^B", 2], "=", ["@Next 1 0", "*B", "@Next 2 0"], "&&", ["@This 0", "!=", "@Next 1 0"]], false, [[["@This 0", "+B", "@Next 1 0", "+B", "@Next 2 0"]]], ["@This 0", "+", "@Next 1 0", "+", "@Next 2 0"], [false, true, true]]
        ];
        if (modifiers[13] == "None") { startTileSpawns = [[[1n], 100]]; winRequirement = 1; }
        else { startTileSpawns = [[[1n], modifiers[22]], [[-1n], modifiers[23]]]; winRequirement = 2; }
        winConditions = [[3307n]];
        knownMergeMaxLength = 3;
        knownMergeLookbackDistance = 1;
        document.documentElement.style.setProperty("background-image", "repeating-linear-gradient(#990080 0% 6%, #660033 6% 9%, #990080 9% 15%, #330066 15% 18%)");
        document.documentElement.style.setProperty("--background-color", "repeating-linear-gradient(#dc6fca 0% 6%, #ba3979 6% 9%, #dc6fca 9% 15%, #7b41b6 15% 18%)");
        document.documentElement.style.setProperty("--grid-color", "#620051");
        document.documentElement.style.setProperty("--tile-color", "#a12e68");
        document.documentElement.style.setProperty("--text-color", "#190032");
        displayRules("rules_text", ["h1", "3307"], ["p", 'Merges occur between two equal tiles, or between three different tiles such that the ratio between the middle-sized tile and the smallest tile is the same as the ratio between the largest tile and the middle-sized tile. Get to the 3307 tile to win, or see what other tiles you can make!'],
        ["p", "Spawning tiles: 1 (100%)"]);
        displayRules("gm_rules_text", ["h1", "3307"], ["p", 'Merges occur between two equal tiles, or between three different tiles such that the ratio between the middle-sized tile and the smallest tile is the same as the ratio between the largest tile and the middle-sized tile. Get to the 3307 tile to win, or see what other tiles you can make!'],
        ["p", "Spawning tiles: 1 (100%)"]);
        statBoxes = [["Discovered Tiles", ["@DiscTiles", "arr_length"], false, ...[,,,], ["@GVar 0", "=", 0], [0, "@edit_gvar", 0, 1], true], ["Discovered Tiles", ["@DiscTiles"], true, false, "TileArray", "Self", ["@GVar 0", "=", 1], [0, "@edit_gvar", 0, 0], true], ["Score", "@Score"]];
        document.getElementById("mode_vars_line").style.setProperty("display", "block");
        document.getElementById("3307_vars").style.setProperty("display", "flex");
    }
    else if (mode == 76) { // Easier 2401
        // width = 5; height = 5;
        TileNumAmount = 2;
        TileTypes = [[[0, 1], 1, "#d7d7d7", "#524b46"], [[0, 2], 2, "#afafaf", "#f1ebe7"], [[0, 4], 4, "#787878", "#f1ebe7"],
        [[1, 1], 7, "#00ff73", "#524b46"], [[1, 2], 14, "#00be55", "#f1ebe7"], [[1, 4], 28, "#00893e", "#f1ebe7"],
        [[2, 1], 49, "#6fff00", "#524b46"], [[2, 2], 98, "#59ce00", "#f1ebe7"], [[2, 4], 196, "#449c00", "#f1ebe7"],
        [[3, 1], 343, "#ffff00", "#524b46"], [[3, 2], 686, "#d2d200", "#f1ebe7"], [[3, 4], 1372, "#a0a000", "#f1ebe7"],
        [[4, 1], 2401, "#ff9d00", "#524b46"], [[4, 2], 4802, "#d58300", "#f1ebe7"], [[4, 4], 9604, "#a26400", "#f1ebe7"],
        [[5, 1], 16807, "#ff2600", "#524b46"], [[5, 2], 33614, "#cb1e00", "#f1ebe7"], [[5, 4], 67228, "#901600", "#f1ebe7"],
        [[6, 1], 117649, "#fc01df", "#524b46"], [[6, 2], 235298, "#cb00b4", "#f1ebe7"], [[6, 4], 470596, "#9a0088", "#f1ebe7"],
        [[7, 1], 823543, "#6f00ff", "#524b46"], [[7, 2], 1647086, "#5100bb", "#f1ebe7"], [[7, 4], 3294172, "#340078", "#f1ebe7"],
        [[8, 1], 5764801, "#0066ff", "#524b46"], [[8, 2], 11529602, "#0050c9", "#f1ebe7"], [[8, 4], 23059204, "#003c95", "#f1ebe7"],
        [[9, 1], 40353607, "#00eaff", "#524b46"], [[9, 2], 80707214, "#00c6d7", "#f1ebe7"], [[9, 4], 161414428, "#0097a5", "#f1ebe7"],
        [["@This 1", "=", 1], [7, "^", "@This 0"], ["@HSLA", [-37, "*", "@This 0", "-", 210], [0.95, "^", ["@This 0", "-", 10], "*", 75], 50, 1], "#524b46"],
        [["@This 1", "=", 2], [7, "^", "@This 0", "*", 2], ["@HSLA", [-37, "*", "@This 0", "-", 210], [0.95, "^", ["@This 0", "-", 10], "*", 75], 37.5, 1], "#f1ebe7"],
        [["@This 1", "=", 4], [7, "^", "@This 0", "*", 4], ["@HSLA", [-37, "*", "@This 0", "-", 210], [0.95, "^", ["@This 0", "-", 10], "*", 75], 25, 1], "#f1ebe7"]];
        MergeRules = [
            [2, [["@Next 1 0", "=", "@This 0"], "&&", ["@Next 1 1", "=", "@This 1"], "&&", ["@This 1", "=", 1]], true, [["@This 0", 2]], [7, "^", "@This 0", "*", 2], [false, true]],
            [2, [["@Next 1 0", "=", "@This 0"], "&&", ["@Next 1 1", "=", "@This 1"], "&&", ["@This 1", "=", 2]], true, [["@This 0", 4]], [7, "^", "@This 0", "*", 4], [false, true]],
            [3, [["@Next 1 0", "=", "@This 0"], "&&", ["@Next 1 1", "=", 4], "&&", ["@Next 2 0", "=", "@This 0"], "&&", ["@Next 2 1", "=", 2], "&&", ["@This 1", "=", 1]], false, [[["@This 0", "+", 1], 1]], [7, "^", "@This 0", "*", 7], [false, true, true]]
        ]
        startTileSpawns = [[[0, 1], 85], [[0, 2], 12], [[0, 4], 3]];
        winConditions = [[4, 1]];
        winRequirement = 1;
        knownMergeMaxLength = 3;
        knownMergeLookbackDistance = 0;
        document.documentElement.style.setProperty("background-image", "radial-gradient(#dda448 0%, #fff 150%)");
        document.documentElement.style.setProperty("--background-color", "#f2dfcc");
        document.documentElement.style.setProperty("--grid-color", "#c7b6a7");
        document.documentElement.style.setProperty("--tile-color", "#f7d6b2");
        document.documentElement.style.setProperty("--text-color", "#55463b");
        displayRules("rules_text", ["h1", "Easier 2401"], ["p","Merges occur between two equal tiles that are either a power of seven or double a power of seven, or between a tile that's a power of seven, a tile that's double that power of seven, and a tile that's quadruple that power of 7. Get to the 2401 tile to win!"],
        ["p", "Spawning tiles: 1 (85%), 2 (12%), 4 (3%)"]);
        displayRules("gm_rules_text", ["h1", "Easier 2401"], ["p","Merges occur between two equal tiles that are either a power of seven or double a power of seven, or between a tile that's a power of seven, a tile that's double that power of seven, and a tile that's quadruple that power of 7. Get to the 2401 tile to win!"],
        ["p", "Spawning tiles: 1 (85%), 2 (12%), 4 (3%)"]);
    }
    else if (mode == 77) { // 1668
        // width = 5; height = 5;
        TileNumAmount = 1;
        mode_vars = [0, 7n]; // mode_vars[0] controls the random goals, mode_vars[1] is the tier of tile that the first random goal is
        start_game_vars = [2n, 0, false, 7n, 0] // The first entry is the current random goal, the second entry is the amount of random goals met so far, the third entry is whether a random goal has been met this turn, and the fourth entry is the tier of tile that the first random goal is. The fifth entry controls the display of Discovered Tiles.
        TileTypes = [
        [[1n], 1, "#ffffff", "#371d35"],
        [["@This 0", "<", 5n], ["@This 0"], ["@linear-gradient", ["@HSLA", [9/2, "-", "@This 0", "*", -300, "/", 3, "+", 270], 100, 40, 1], 0, ["@HSVA", 60, [9/2, "-", "@This 0", "/", 3, "*", -50, "+", 100], 100, 1], 25, 75, ["@HSLA", [9/2, "-", "@This 0", "*", -300, "/", 3, "+", 270], 100, 40, 1], 100], "#371d35"],
        [["@This 0", "<", 14n], ["@This 0"], ["@linear-gradient", ["@HSLA", [27/2, "-", "@This 0", "*", -300, "/", 9, "+", 270], 100, 40, 1], 0, ["@HSVA", 105, [27/2, "-", "@This 0", "/", 9, "*", -50, "+", 100], 100, 1], 25, 75, ["@HSLA", [27/2, "-", "@This 0", "*", -300, "/", 9, "+", 270], 100, 40, 1], 100], "#371d35"],
        [["@This 0", "<", 41n], ["@This 0"], ["@linear-gradient", ["@HSLA", [81/2, "-", "@This 0", "*", -300, "/", 27, "+", 270], 100, 40, 1], 0, ["@HSVA", 160, [81/2, "-", "@This 0", "/", 27, "*", -50, "+", 100], 100, 1], 25, 75, ["@HSLA", [81/2, "-", "@This 0", "*", -300, "/", 27, "+", 270], 100, 40, 1], 100], "#371d35"],
        [["@This 0", "<", 122n], ["@This 0"], ["@linear-gradient", ["@HSLA", [243/2, "-", "@This 0", "*", -300, "/", 81, "+", 270], 100, 40, 1], 0, ["@HSVA", 200, [243/2, "-", "@This 0", "/", 81, "*", -50, "+", 100], 100, 1], 25, 75, ["@HSLA", [243/2, "-", "@This 0", "*", -300, "/", 81, "+", 270], 100, 40, 1], 100], "#371d35"],
        [["@This 0", "<", 365n], ["@This 0"], ["@linear-gradient", ["@HSLA", [729/2, "-", "@This 0", "*", -300, "/", 243, "+", 270], 100, 40, 1], 0, ["@HSVA", 230, [729/2, "-", "@This 0", "/", 243, "*", -50, "+", 100], 100, 1], 25, 75, ["@HSLA", [729/2, "-", "@This 0", "*", -300, "/", 243, "+", 270], 100, 40, 1], 100], "#371d35"],
        [["@This 0", "<", 1094n], ["@This 0"], ["@linear-gradient", ["@HSLA", [2187/2, "-", "@This 0", "*", -300, "/", 729, "+", 270], 100, 40, 1], 0, ["@HSVA", 275, [2187/2, "-", "@This 0", "/", 729, "*", -50, "+", 100], 100, 1], 25, 75, ["@HSLA", [2187/2, "-", "@This 0", "*", -300, "/", 729, "+", 270], 100, 40, 1], 100], "#371d35"],
        [["@This 0", "<", 3281n], ["@This 0"], ["@linear-gradient", ["@HSLA", [6561/2, "-", "@This 0", "*", -300, "/", 2187, "+", 270], 100, 40, 1], 0, ["@HSVA", 310, [6561/2, "-", "@This 0", "/", 2187, "*", -50, "+", 100], 100, 1], 25, 75, ["@HSLA", [6561/2, "-", "@This 0", "*", -300, "/", 2187, "+", 270], 100, 40, 1], 100], "#371d35"],
        [["@This 0", "*B", 2n, "logB", 3n], "@end_vars", true, ["@This 0"], ["@global_var_retain", "@linear-gradient", ["@HSLA", [[3, "^", "@Var 0", "*", 3/2], "-", "@This 0", "*", -300, "/", [3, "^", "@Var 0"], "+", 270], 100, 40, 1], 0, ["@HSVA", ["@Var 0", "*", 47, "-", 30], [[3, "^", "@Var 0", "*", 3/2], "-", "@This 0", "*", -50, "/", [3, "^", "@Var 0"], "+", 100], [0.95, "^", ["@Var 0", "-", 7], "*", 100], 1], 25, 75, ["@HSLA", [[3, "^", "@Var 0", "*", 3/2], "-", "@This 0", "*", -300, "/", [3, "^", "@Var 0"], "+", 270], 100, 40, 1], 100], "#ffdff6"]
        ];
        MergeRules = [
            [3, [["@Next 1 0", "=", "@This 0"], "&&", ["@Next 2 0", "-B", "@This 0", "absB", "<=", 1n]], false, [[["@This 0", "+B", "@Next 1 0", "+B", "@Next 2 0"]]], ["@This 0", "+", "@Next 1 0", "+", "@Next 2 0"], [false, true, true]],
            [2, [["@This 0", "=", 1n], "&&", ["@Next 1 0", "=", 1n], "&&", ["@NextNE -1 0", "!=", 1n], "&&", ["@NextNE -1 0", "!=", 2n]], true, [[2n]], 2, [false, true]]
        ];
        startTileSpawns = [[[1n], 84], [[2n], 8], [[3n], 8]];
        winConditions = [[1668n]];
        winRequirement = 1;
        knownMergeMaxLength = 3;
        knownMergeLookbackDistance = 1;
        document.documentElement.style.setProperty("background-image", "linear-gradient(#cda405 0%, #ff95ed 15% 85%, #cda405 100%");
        document.documentElement.style.setProperty("--background-color", "linear-gradient(90deg,#ebc942 0%,#ffbdf4 12% 88%, #ebc942 100%)");
        document.documentElement.style.setProperty("--grid-color", "#b22f9a");
        document.documentElement.style.setProperty("--tile-color", "#ddba59");
        document.documentElement.style.setProperty("--text-color", "#371720");
        displayRules("rules_text", ["h1", "1668"], ["p", "Two 1s can merge, and merges occur between three tiles, two of which are equal and the third of which is either equal to the other two or has a difference of 1 with the other two. Get to the 1668 tile to win (your first task is figuring out how to get there...), or just play and see what tiles you end up making!"],
        ["p", "Spawning tiles: 1 (84%), 2 (8%), 3 (8%)"]);
        displayRules("gm_rules_text", ["h1", "1668"], ["p", "Two 1s can merge, and merges occur between three tiles, two of which are equal and the third of which is either equal to the other two or has a difference of 1 with the other two. Get to the 1668 tile to win (your first task is figuring out how to get there...), or just play and see what tiles you end up making!"],
        ["p", "Spawning tiles: 1 (84%), 2 (8%), 3 (8%)"]);
        statBoxes = [["Discovered Tiles", ["@DiscTiles", "arr_length"], false, ...[,,,], ["@GVar 4", "=", 0], [0, "@edit_gvar", 4, 1], true], ["Discovered Tiles", ["@DiscTiles"], true, false, "TileArray", "Self", ["@GVar 4", "=", 1], [0, "@edit_gvar", 4, 0], true], ["Score", "@Score"]];
        document.getElementById("mode_vars_line").style.setProperty("display", "block");
        document.getElementById("1668_vars").style.setProperty("display", "flex");
    }
    else if (mode == 78) { // 1847
        // width = 4; height = 4;
        TileNumAmount = 1;
        mode_vars = [0, 19n]; // mode_vars[0] controls the random goals, mode_vars[1] is the tier of tile that the first random goal is
        start_game_vars = [2n, 0, false, 19n, 0] // The first entry is the current random goal, the second entry is the amount of random goals met so far, the third entry is whether a random goal has been met this turn, and the fourth entry is the tier of tile that the first random goal is. The fifth entry controls the display of Discovered Tiles.
        TileTypes = [
        [[1n], 1, "#ffffff", "#3a1711"], [[2n], 2, "#c6c6c6", "#3a1711"], [[3n], 3, "#888888", "#3a1711"],
        [["@This 0", "<", 1.5**4], ["@This 0"], ["@linear-gradient", ["@HSLA", [1.5**4, "-", "@This 0", "*", 300, "/", 1.5**3 / 2, "+", 60], 65, 50, 1], 0, "#baeaff", 25, 75, ["@HSLA", [1.5**4, "-", "@This 0", "*", 300, "/", 1.5**3 / 2, "+", 60], 65, 50, 1], 100], "#3a1711"],
        [["@This 0", "<", 1.5**5], ["@This 0"], ["@linear-gradient", ["@HSLA", [1.5**5, "-", "@This 0", "*", 300, "/", 1.5**4 / 2, "+", 60], 65, 50, 1], 0, "#7cd8ff", 25, 75, ["@HSLA", [1.5**5, "-", "@This 0", "*", 300, "/", 1.5**4 / 2, "+", 60], 65, 50, 1], 100], "#3a1711"],
        [["@This 0", "<", 1.5**6], ["@This 0"], ["@linear-gradient", ["@HSLA", [1.5**6, "-", "@This 0", "*", 300, "/", 1.5**5 / 2, "+", 60], 65, 50, 1], 0, "#21bcff", 25, 75, ["@HSLA", [1.5**6, "-", "@This 0", "*", 300, "/", 1.5**5 / 2, "+", 60], 65, 50, 1], 100], "#3a1711"],
        [["@This 0", "<", 1.5**7], ["@This 0"], ["@linear-gradient", ["@HSLA", [1.5**7, "-", "@This 0", "*", 300, "/", 1.5**6 / 2, "+", 60], 65, 50, 1], 0, "#008ac5", 25, 75, ["@HSLA", [1.5**7, "-", "@This 0", "*", 300, "/", 1.5**6 / 2, "+", 60], 65, 50, 1], 100], "#f0dfdd"],
        [["@This 0", "<", 1.5**8], ["@This 0"], ["@linear-gradient", ["@HSLA", [1.5**8, "-", "@This 0", "*", 300, "/", 1.5**7 / 2, "+", 60], 65, 50, 1], 0, "#005072", 25, 75, ["@HSLA", [1.5**8, "-", "@This 0", "*", 300, "/", 1.5**7 / 2, "+", 60], 65, 50, 1], 100], "#f0dfdd"],
        [["@This 0", "<", 1.5**9], ["@This 0"], ["@linear-gradient", ["@HSLA", [1.5**9, "-", "@This 0", "*", 300, "/", 1.5**8 / 2, "+", 60], 65, 50, 1], 0, "#00344a", 25, 75, ["@HSLA", [1.5**9, "-", "@This 0", "*", 300, "/", 1.5**8 / 2, "+", 60], 65, 50, 1], 100], "#f0dfdd"],
        [["@This 0", "<", 1.5**10], ["@This 0"], ["@linear-gradient", ["@HSLA", [1.5**10, "-", "@This 0", "*", 300, "/", 1.5**9 / 2, "+", 60], 65, 50, 1], 0, "#f09eff", 25, 75, ["@HSLA", [1.5**10, "-", "@This 0", "*", 300, "/", 1.5**9 / 2, "+", 60], 65, 50, 1], 100], "#3a1711"],
        [["@This 0", "<", 1.5**11], ["@This 0"], ["@linear-gradient", ["@HSLA", [1.5**11, "-", "@This 0", "*", 300, "/", 1.5**10 / 2, "+", 60], 65, 50, 1], 0, "#e65bff", 25, 75, ["@HSLA", [1.5**11, "-", "@This 0", "*", 300, "/", 1.5**10 / 2, "+", 60], 65, 50, 1], 100], "#3a1711"],
        [["@This 0", "<", 1.5**12], ["@This 0"], ["@linear-gradient", ["@HSLA", [1.5**12, "-", "@This 0", "*", 300, "/", 1.5**11 / 2, "+", 60], 65, 50, 1], 0, "#cb00ef", 25, 75, ["@HSLA", [1.5**12, "-", "@This 0", "*", 300, "/", 1.5**11 / 2, "+", 60], 65, 50, 1], 100], "#3a1711"],
        [["@This 0", "<", 1.5**13], ["@This 0"], ["@linear-gradient", ["@HSLA", [1.5**13, "-", "@This 0", "*", 300, "/", 1.5**12 / 2, "+", 60], 65, 50, 1], 0, "#8c00a4", 25, 75, ["@HSLA", [1.5**13, "-", "@This 0", "*", 300, "/", 1.5**12 / 2, "+", 60], 65, 50, 1], 100], "#f0dfdd"],
        [["@This 0", "<", 1.5**14], ["@This 0"], ["@linear-gradient", ["@HSLA", [1.5**14, "-", "@This 0", "*", 300, "/", 1.5**13 / 2, "+", 60], 65, 50, 1], 0, "#51005f", 25, 75, ["@HSLA", [1.5**14, "-", "@This 0", "*", 300, "/", 1.5**13 / 2, "+", 60], 65, 50, 1], 100], "#f0dfdd"],
        [["@This 0", "<", 1.5**15], ["@This 0"], ["@linear-gradient", ["@HSLA", [1.5**15, "-", "@This 0", "*", 300, "/", 1.5**14 / 2, "+", 60], 65, 50, 1], 0, "#ff9d82", 25, 75, ["@HSLA", [1.5**15, "-", "@This 0", "*", 300, "/", 1.5**14 / 2, "+", 60], 65, 50, 1], 100], "#3a1711"],
        [["@This 0", "<", 1.5**16], ["@This 0"], ["@linear-gradient", ["@HSLA", [1.5**16, "-", "@This 0", "*", 300, "/", 1.5**15 / 2, "+", 60], 65, 50, 1], 0, "#ff7650", 25, 75, ["@HSLA", [1.5**16, "-", "@This 0", "*", 300, "/", 1.5**15 / 2, "+", 60], 65, 50, 1], 100], "#3a1711"],
        [["@This 0", "<", 1.5**17], ["@This 0"], ["@linear-gradient", ["@HSLA", [1.5**17, "-", "@This 0", "*", 300, "/", 1.5**16 / 2, "+", 60], 65, 50, 1], 0, "#ff3700", 25, 75, ["@HSLA", [1.5**17, "-", "@This 0", "*", 300, "/", 1.5**16 / 2, "+", 60], 65, 50, 1], 100], "#3a1711"],
        [["@This 0", "<", 1.5**18], ["@This 0"], ["@linear-gradient", ["@HSLA", [1.5**18, "-", "@This 0", "*", 300, "/", 1.5**17 / 2, "+", 60], 65, 50, 1], 0, "#b52700", 25, 75, ["@HSLA", [1.5**18, "-", "@This 0", "*", 300, "/", 1.5**17 / 2, "+", 60], 65, 50, 1], 100], "#f0dfdd"],
        [["@This 0", "<", 1.5**19], ["@This 0"], ["@linear-gradient", ["@HSLA", [1.5**19, "-", "@This 0", "*", 300, "/", 1.5**18 / 2, "+", 60], 65, 50, 1], 0, "#6c1700", 25, 75, ["@HSLA", [1.5**19, "-", "@This 0", "*", 300, "/", 1.5**18 / 2, "+", 60], 65, 50, 1], 100], "#f0dfdd"],
        [["@This 0", "log", 1.5, "floor", 1], "@end_vars", true, ["@This 0"], ["@global_var_retain", "@linear-gradient", ["@HSLA", [[1.5, "^", ["@Var 0", "+", 1]], "-", "@This 0", "*", 300, "/", [1.5, "^", "@Var 0", "/", 2], "+", 60], 65, 50, 1], 0, ["@HSLA", ["@Var 0", "+", 1, "floor", 5, "/", 5, "*", 73, "-", 247], [0.95, "^", ["@Var 0", "+", 1, "floor", 5, "/", 5, "-", 3], "*", 100], ["@Var 0", "+", 1, "mod", 5, "*", -15, "+", 80], 1], 25, 75, ["@HSLA", [[1.5, "^", ["@Var 0", "+", 1]], "-", "@This 0", "*", 300, "/", [1.5, "^", "@Var 0", "/", 2], "+", 60], 65, 50, 1], 100], ["@global_var_retain", "#3a1711", "@if", ["@Var 0", "+", 1, "mod", 5, ">", 2], "2nd", "#f0dfdd", "@end-if"]]
        ];
        MergeRules = [
            [2, [["@This 0", "*B", 2n, "-B", "@Next 1 0", "absB", "<=", 1n]], false, [[["@This 0", "+B", "@Next 1 0"]]], ["@This 0", "+", "@Next 1 0"], [false, true, true]]
        ];
        startTileSpawns = [[[1n], 85], [[2n], 10], [[3n], 5]];
        winConditions = [[1847n]];
        winRequirement = 1;
        knownMergeMaxLength = 2;
        knownMergeLookbackDistance = 0;
        document.documentElement.style.setProperty("background-image", "linear-gradient(#2d80d2 0%, #8a2f23 25% 75%, #2d80d2 100%)");
        document.documentElement.style.setProperty("--background-color", "linear-gradient(#8fbfef 0%, #d86d5f 12% 88%, #8fbfef 100%)");
        document.documentElement.style.setProperty("--grid-color", "#95412a");
        document.documentElement.style.setProperty("--tile-color", "#7dabd8");
        document.documentElement.style.setProperty("--text-color", "#3d1c4c");
        displayRules("rules_text", ["h1", "1847"], ["p", "Two tiles can merge if one tile is equal to double the other tile or at a distance of 1 from double the other tile. Get to the 1847 tile to win (your first task is figuring out how to get there...), or just play and see what tiles you end up making!"],
        ["p", "Spawning tiles: 1 (85%), 2 (10%), 3 (5%)"]);
        displayRules("gm_rules_text", ["h1", "1847"], ["p", "Two tiles can merge if one tile is equal to double the other tile or at a distance of 1 from double the other tile. Get to the 1847 tile to win (your first task is figuring out how to get there...), or just play and see what tiles you end up making!"],
        ["p", "Spawning tiles: 1 (85%), 2 (10%), 3 (5%)"]);
        statBoxes = [["Discovered Tiles", ["@DiscTiles", "arr_length"], false, ...[,,,], ["@GVar 4", "=", 0], [0, "@edit_gvar", 4, 1], true], ["Discovered Tiles", ["@DiscTiles"], true, false, "TileArray", "Self", ["@GVar 4", "=", 1], [0, "@edit_gvar", 4, 0], true], ["Score", "@Score"]];
        document.getElementById("mode_vars_line").style.setProperty("display", "block");
        document.getElementById("1847_vars").style.setProperty("display", "flex");
    }
    else if (mode == 79) { // 3240
        // width = 4; height = 4;
        TileNumAmount = 6;
        start_game_vars = [0]; // Controls the display of Discovered Tiles
        TileTypes = [
            [[0, 0, 0, 0, 0, 0], 1, "#000000", "#ffffff"],
            [[0.5, 0, 0, 0, 0, 0], 2, "#5e5e5e", "#ffffff"],
            [
                true, [[4, "^", "@This 0"], "*", [6, "^", "@This 1"], "*", [9, "^", "@This 2"], "*", [10, "^", "@This 3"], "*", [14, "^", "@This 4"], "*", [15, "^", "@This 5"]],
                ["@conic-gradient",
                    ["@HSLA", ["@This 1", "*", -288, "/", ["@This 0", "+", "@This 1", "max", 1]], 100, [0, "@if", ["@This 0", "+", "@This 1", "<", 4], "2nd", [["@Literal", 0, 25, 35, 50], "arr_elem", ["@This 0", "+", "@This 1"]], "@end-if", "@else", "2nd", [0.75, "^", ["@This 0", "+", "@This 1", "-", 3], "*", -40, "+", 90], "@end-else"], 1], 0, 60,
                    ["@HSLA", ["@This 3", "*", -288, "/", ["@This 2", "+", "@This 3", "max", 1], "+", 144], 100, [0, "@if", ["@This 2", "+", "@This 3", "<", 4], "2nd", [["@Literal", 0, 25, 35, 50], "arr_elem", ["@This 2", "+", "@This 3"]], "@end-if", "@else", "2nd", [0.75, "^", ["@This 2", "+", "@This 3", "-", 3], "*", -40, "+", 90], "@end-else"], 1], 120, 180,
                    ["@HSLA", ["@This 5", "*", -252, "/", ["@This 4", "+", "@This 5", "max", 1], "+", 288], 100, [0, "@if", ["@This 4", "+", "@This 5", "<", 4], "2nd", [["@Literal", 0, 25, 35, 50], "arr_elem", ["@This 4", "+", "@This 5"]], "@end-if", "@else", "2nd", [0.75, "^", ["@This 4", "+", "@This 5", "-", 3], "*", -40, "+", 90], "@end-else"], 1], 240, 300,
                    ["@HSLA", ["@This 1", "*", -288, "/", ["@This 0", "+", "@This 1", "max", 1]], 100, [0, "@if", ["@This 0", "+", "@This 1", "<", 4], "2nd", [["@Literal", 0, 25, 35, 50], "arr_elem", ["@This 0", "+", "@This 1"]], "@end-if", "@else", "2nd", [0.75, "^", ["@This 0", "+", "@This 1", "-", 3], "*", -40, "+", 90], "@end-else"], 1], 360
                ], "#ffffff", "0px 0px 5px #000", [2, "@if", ["@This", "arr_slice", 0, 6, "arr_reduce", 0, ["+", "@Var -1"], ">", 1], "2nd", 2.5, "@end-if"], 0,
                ["Innerscript", [-1, "@end_vars", ["@global_var_retain", "", "@if", [["@This", "arr_slice", 0, 6, "arr_reduce", 0, ["+", "@Var -1"], ">", 1]], "@repeat", 6, "@edit_var", 0, ["@Var 0", "+", 1], "@repeat", ["@This", "arr_elem", "@Var 0"], "@if", ["@Parent -2", "!=", ""], "str_concat", "&#215;", "@end-if", "str_concat", [["@Literal", 4, 6, 9, 10, 14, 15], "arr_elem", "@Var 0", "defaultAbbrev"], "@end-repeat", "@end-repeat", "@end-if"]], "bottom-center", 6, 0]
            ]
        ];
        MergeRules = [
            [
                3, [["@Next 1", "arr_slice", 0, 6, "=", ["@Literal", ["@CalcArray", "@This 0", "-", 1], ["@CalcArray", "@This 1"], ["@CalcArray", "@This 2"], ["@CalcArray", "@This 3"], ["@CalcArray", "@This 4"], ["@CalcArray", "@This 5"]]], "&&", ["@Next 2", "arr_slice", 0, 6, "=", ["@Literal", ["@CalcArray", "@This 0", "-", 1], ["@CalcArray", "@This 1"], ["@CalcArray", "@This 2"], ["@CalcArray", "@This 3"], ["@CalcArray", "@This 4"], ["@CalcArray", "@This 5"]]]], false, 
                [[["@This 0", "-", 1], ["@This 1", "+", 1], "@This 2", "@This 3", "@This 4", "@This 5"]], [[4, "^", "@This 0"], "*", [6, "^", "@This 1"], "*", [9, "^", "@This 2"], "*", [10, "^", "@This 3"], "*", [14, "^", "@This 4"], "*", [15, "^", "@This 5"], "*", 6, "/", 4], [false, true, true]
            ],
            [
                3, [["@Next 1", "arr_slice", 0, 6, "=", ["@Literal", ["@CalcArray", "@This 0"], ["@CalcArray", "@This 1"], ["@CalcArray", "@This 2"], ["@CalcArray", "@This 3"], ["@CalcArray", "@This 4"], ["@CalcArray", "@This 5"]]], "&&", ["@Next 2", "arr_slice", 0, 6, "=", ["@Literal", ["@CalcArray", "@This 0", "-", 1], ["@CalcArray", "@This 1"], ["@CalcArray", "@This 2"], ["@CalcArray", "@This 3"], ["@CalcArray", "@This 4"], ["@CalcArray", "@This 5"]]]], false, 
                [[["@This 0", "-", 1], "@This 1", ["@This 2", "+", 1], "@This 3", "@This 4", "@This 5"]], [[4, "^", "@This 0"], "*", [6, "^", "@This 1"], "*", [9, "^", "@This 2"], "*", [10, "^", "@This 3"], "*", [14, "^", "@This 4"], "*", [15, "^", "@This 5"], "*", 9, "/", 4], [false, true, true]
            ],
            [
                2, [["@Next 1", "arr_slice", 0, 6, "=", ["@Literal", ["@CalcArray", "@This 0", "+", 1], ["@CalcArray", "@This 1", "-", 1], ["@CalcArray", "@This 2"], ["@CalcArray", "@This 3"], ["@CalcArray", "@This 4"], ["@CalcArray", "@This 5"]]]], false, 
                [["@This 0", ["@This 1", "-", 1], "@This 2", ["@This 3", "+", 1], "@This 4", "@This 5"]], [[4, "^", "@This 0"], "*", [6, "^", "@This 1"], "*", [9, "^", "@This 2"], "*", [10, "^", "@This 3"], "*", [14, "^", "@This 4"], "*", [15, "^", "@This 5"], "*", 10, "/", 6], [false, true, true]
            ],
            [
                2, [["@Next 1", "arr_slice", 0, 6, "=", ["@Literal", ["@CalcArray", "@This 0", "+", 1], ["@CalcArray", "@This 1"], ["@CalcArray", "@This 2"], ["@CalcArray", "@This 3", "-", 1], ["@CalcArray", "@This 4"], ["@CalcArray", "@This 5"]]]], false, 
                [["@This 0", "@This 1", "@This 2", ["@This 3", "-", 1], ["@This 4", "+", 1], "@This 5"]], [[4, "^", "@This 0"], "*", [6, "^", "@This 1"], "*", [9, "^", "@This 2"], "*", [10, "^", "@This 3"], "*", [14, "^", "@This 4"], "*", [15, "^", "@This 5"], "*", 14, "/", 10], [false, true, true]
            ],
            [
                2, [["@Next 1", "arr_slice", 0, 6, "=", ["@Literal", ["@CalcArray", "@This 0"], ["@CalcArray", "@This 1"], ["@CalcArray", "@This 2"], ["@CalcArray", "@This 3"], ["@CalcArray", "@This 4", "-", 1], ["@CalcArray", "@This 5"]]]], false, 
                [["@This 0", "@This 1", "@This 2", "@This 3", ["@This 4", "-", 1], ["@This 5", "+", 1]]], [[4, "^", "@This 0"], "*", [6, "^", "@This 1"], "*", [9, "^", "@This 2"], "*", [10, "^", "@This 3"], "*", [14, "^", "@This 4"], "*", [15, "^", "@This 5"], "*", 15, "/", 14], [false, true, true]
            ],
            [
                2, [["@Next 1", "arr_slice", 0, 6, "=", ["@Literal", ["@CalcArray", "@This 0"], ["@CalcArray", "@This 1", "+", 1], ["@CalcArray", "@This 2", "-", 1], ["@CalcArray", "@This 3"], ["@CalcArray", "@This 4"], ["@CalcArray", "@This 5"]]]], false, 
                [["@This 0", "@This 1", ["@This 2", "-", 1], "@This 3", "@This 4", ["@This 5", "+", 1]]], [[4, "^", "@This 0"], "*", [6, "^", "@This 1"], "*", [9, "^", "@This 2"], "*", [10, "^", "@This 3"], "*", [14, "^", "@This 4"], "*", [15, "^", "@This 5"], "*", 15, "/", 9], [false, true, true]
            ],
            [
                2, [["@Next 1", "arr_slice", 0, 6, "=", ["@Literal", ["@CalcArray", "@This 0"], ["@CalcArray", "@This 1"], ["@CalcArray", "@This 2"], ["@CalcArray", "@This 3"], ["@CalcArray", "@This 4"], ["@CalcArray", "@This 5", "-", 1]]]], false, 
                [[["@This 0", "+", 2], "@This 1", "@This 2", "@This 3", "@This 4", ["@This 5", "-", 1]]], [[4, "^", "@This 0"], "*", [6, "^", "@This 1"], "*", [9, "^", "@This 2"], "*", [10, "^", "@This 3"], "*", [14, "^", "@This 4"], "*", [15, "^", "@This 5"], "*", 16, "/", 15], [false, true, true]
            ],
            [2, [["@This", "arr_slice", 0, 6, "=", ["@Literal", 0, 0, 0, 0, 0, 0]], "&&", ["@Next 1", "arr_slice", 0, 6, "=", ["@Literal", 0, 0, 0, 0, 0, 0]], "&&", ["@NextNE -1", "arr_slice", 0, 6, "!=", ["@Literal", 1, 0, 0, 0, 0, 0]]], true, [[0.5, 0, 0, 0, 0, 0]], 2, [false, true]],
            [2, [["@This", "arr_slice", 0, 6, "=", ["@Literal", 0.5, 0, 0, 0, 0, 0]], "&&", ["@Next 1", "arr_slice", 0, 6, "=", ["@Literal", 0.5, 0, 0, 0, 0, 0]]], true, [[1, 0, 0, 0, 0, 0]], 4, [false, true]]
        ];
        startTileSpawns = [[[0, 0, 0, 0, 0, 0], 100]];
        winConditions = [[[4, "^", "@This 0"], "*", [6, "^", "@This 1"], "*", [9, "^", "@This 2"], "*", [10, "^", "@This 3"], "*", [14, "^", "@This 4"], "*", [15, "^", "@This 5"], "=", 3240]];
        winRequirement = 1;
        knownMergeMaxLength = 3;
        knownMergeLookbackDistance = 1;
        document.documentElement.style.setProperty("background-image", "radial-gradient(#0000, #fff 150%), conic-gradient(#005eeb 0deg 60deg, #00d856 120deg 180deg, #d98200 240deg 300deg, #005eeb 360deg)");
        document.documentElement.style.setProperty("--background-color", "linear-gradient(#80b3ff, #96ffc0, #ffd390)");
        document.documentElement.style.setProperty("--grid-color", "#1f781f");
        document.documentElement.style.setProperty("--tile-color", "#6fa6f9");
        document.documentElement.style.setProperty("--text-color", "#3e2500");
        displayRules("rules_text", ["h2", "Products of Semiprimes up to 15"], ["h1", "3240"], ["p", "1+1=2 and 2+2=4 are valid merges. For a given n, the following merges are valid: 4n+1n+1n, 4n+4n+1n, 6n+4n, 10n+4n, 14n+1n, 9n+6n, and 15n+1n. However, a tile will only act based on the way it was formed: for example, a 60 formed as 6&#215;10 will not also act as 4&#215;15. Get to a 3240 tile to win!"],
        ["p", "Spawning tiles: 1 (100%)"]);
        displayRules("gm_rules_text", ["h2", "Products of Semiprimes up to 15"], ["h1", "3240"], ["p", "1+1=2 and 2+2=4 are valid merges. For a given n, the following merges are valid: 4n+1n+1n, 4n+4n+1n, 6n+4n, 10n+4n, 14n+1n, 9n+6n, and 15n+1n. However, a tile will only act based on the way it was formed: for example, a 60 formed as 6&#215;10 will not also act as 4&#215;15. Get to a 3240 tile to win!"],
        ["p", "Spawning tiles: 1 (100%)"]);
        statBoxes = [["Discovered Tiles", ["@DiscTiles", "arr_length"], false, ...[,,,], ["@GVar 0", "=", 0], [0, "@edit_gvar", 0, 1], true], ["Discovered Tiles", ["@DiscTiles"], true, false, "TileArray", "Self", ["@GVar 0", "=", 1], [0, "@edit_gvar", 0, 0], true], ["Score", "@Score"]];
    }
    else if (mode == 80) { // 1429
        // width = 4; height = 4;
        TileNumAmount = 2;
        mode_vars = [0, 11n]; // mode_vars[0] controls the random goals, mode_vars[1] is the tier of tile that the first random goal is
        start_game_vars = [2n, 0, false, 11n, 0] // The first entry is the current random goal, the second entry is the amount of random goals met so far, the third entry is whether a random goal has been met this turn, and the fourth entry is the tier of tile that the first random goal is. The fifth entry controls the display of Discovered Tiles.
        TileTypes = [
            [[1n, 1n], 1, "#ffffff", "#302431"], [[3n, 1n], 3, "#d8ffb6", "#302431"], [[1n, -1n], -1, "#000000", "#cfdbce"], [[3n, -1n], -3, "#270049", "#cfdbce"],
            [true, ["@This 0", "*B", "@This 1"], ["@rotate", [0, "@if", ["@This 1", "=", -1n], "2nd", 180, "@end-if"], ["@This 1", "=", -1n], ["@linear-gradient", ["@HSLA", [[2, "^", ["@This 0", "-B", 1n, "logB", 2n], "*", 2, "-", 1], "-", "@This 0", "*", 300, "/", [2, "^", ["@This 0", "-B", 1n, "logB", 2n], "-", 1], "+", 180], 100, 60, 1], 0, [0, "@if", ["@This 0", "-B", 1n, "logB", 2n, "<", 19n], "2nd", [["@Literal", "#ffffff", "#d8ffb6", "#a7ff5a", "#37ff00", "#00ff91", "#00ffff", "#00a2ff", "#dba6ff", "#bb55ff", "#9900ff", "#6f00b9", "#ff82c2", "#ff40a3", "#e30075", "#aa0058", "#650034", "#ff7b4f", "#ff4000", "#bf3000"], "arr_elem", ["@This 0", "-B", 1n, "logB", 2n]], "@end-if", "@else", "2nd", ["@Literal", "@HSLA", ["@CalcArray", 34, "*", ["@This 0", "-B", 1n, "logB", 2n], "-", 611], 100, ["@CalcArray", 0.9, "^", ["@This 0", "-B", 1n, "logB", 2n, "-", 19], "*", 36], 1], "@end-else"], 25, 75, ["@HSLA", [[2, "^", ["@This 0", "-B", 1n, "logB", 2n], "*", 2, "-", 1], "-", "@This 0", "*", 300, "/", [2, "^", ["@This 0", "-B", 1n, "logB", 2n], "-", 1], "+", 180], 100, 60, 1], 100]], ["@rotate", [0, "@if", ["@This 1", "=", -1n], "2nd", 180], ["@This 1", "=", -1n], ["#302431", "@if", ["@This 0", "-B", 1n, "logB", 2n, ">=", 9n], "2nd", "#fcd8ff"]]]
        ];
        if (modifiers[13] == "None") {
            MergeRules = [
                [2, [["@This 0", "=", "@Next 1 0"], "&&", ["@This 1", "!=", "@Next 1 1"]], true, [], 0, [true, true]],
                [3, [["@This 1", "=", 1n], "&&", ["@Next 1 1", "=", 1n], "&&", ["@This 0", "=", "@Next 1 0"], "&&", ["@Next 2", "arr_slice", 0, 2, "=", ["@Literal", 1n, 1n]]], false, [[["@This 0", "*B", 2n, "+B", 1n], 1n]], ["@This 0", "*", 2, "+", 1], [false, true, true]],
                [3, [["@This 1", "=", 1n], "&&", ["@Next 1 1", "=", 1n], "&&", ["@This 0", "=", "@Next 1 0"], "&&", ["@Next 2", "arr_slice", 0, 2, "=", ["@Literal", 1n, -1n]]], false, [[["@This 0", "*B", 2n, "-B", 1n], 1n]], ["@This 0", "*", 2, "-", 1], [false, true, true]]
            ];
            startTileSpawns = [[[1n, 1n], 75], [[1n, -1n], 25]];
            winConditions = [[1429n]];
            winRequirement = 1;
            displayRules("rules_text", ["h1", "1429"], ["p", "Merges occur between three tiles, two of which are equal and positive, and one of which is either a 1 or a -1. 1s and -1s will annihilate if they collide. Get to the 1429 tile to win (your first task is figuring out how to get there...), or just play and see what tiles you end up making!"],
            ["p", "Spawning tiles: 1 (75%), -1 (25%)"]);
            displayRules("gm_rules_text", ["h1", "1429"], ["p", "Merges occur between three tiles, two of which are equal and positive, and one of which is either a 1 or a -1. 1s and -1s will annihilate if they collide. Get to the 1429 tile to win (your first task is figuring out how to get there...), or just play and see what tiles you end up making!"],
            ["p", "Spawning tiles: 1 (75%), -1 (25%)"]);
        }
        else {
            MergeRules = [
                [3, [["@This 1", "=", "@Next 1 1"], "&&", ["@This 0", "=", "@Next 1 0"], "&&", ["@Next 2 0", "=", 1n], "&&", ["@Next 2 1", "=", "@This 1"]], false, [[["@This 0", "*B", 2n, "+B", 1n], "@This 1"]], ["@This 0", "*", 2, "+", 1], [false, true, true]],
                [3, [["@This 1", "=", "@Next 1 1"], "&&", ["@This 0", "=", "@Next 1 0"], "&&", ["@Next 2 0", "=", 1n], "&&", ["@Next 2 1", "!=", "@This 1"]], false, [[["@This 0", "*B", 2n, "-B", 1n], "@This 1"]], ["@This 0", "*", 2, "-", 1], [false, true, true]]
            ];
            if (modifiers[13] == "Interacting") MergeRules.unshift([2, [["@This 0", "=", "@Next 1 0"], "&&", ["@This 1", "!=", "@Next 1 1"]], true, [], 0, [true, true]]);
            startTileSpawns = [[[1n, 1n], modifiers[22]], [[1n, -1n], modifiers[23]]];
            winConditions = [[1429n], [-1429n]];
            winRequirement = 2;
            displayRules("rules_text", ["h1", "1429"], ["p", "Merges occur between three tiles, two of which are equal, and one of which is either a 1 or a -1. Get to the 1429 tile to win (your first task is figuring out how to get there...), or just play and see what tiles you end up making!"],
            ["p", "Spawning tiles: 1 (50%), -1 (50%)"]);
            displayRules("gm_rules_text", ["h1", "1429"], ["p", "Merges occur between three tiles, two of which are equal, and one of which is either a 1 or a -1. Get to the 1429 tile to win (your first task is figuring out how to get there...), or just play and see what tiles you end up making!"],
            ["p", "Spawning tiles: 1 (50%), -1 (50%)"]);
        }
        knownMergeMaxLength = 3;
        knownMergeLookbackDistance = 0;
        document.documentElement.style.setProperty("background-image", "linear-gradient(#ff3333 0%, #6f00b9 15% 85%, #ff3333 100%)");
        document.documentElement.style.setProperty("--background-color", "linear-gradient(90deg,#ff7c7c 0%,#9b47d3 15% 85%, #ff7c7c 100%)");
        document.documentElement.style.setProperty("--grid-color", "#7d31af");
        document.documentElement.style.setProperty("--tile-color", "#e46d6d");
        document.documentElement.style.setProperty("--text-color", "#2e004c");
        statBoxes = [["Discovered Tiles", ["@DiscTiles", "arr_length"], false, ...[,,,], ["@GVar 4", "=", 0], [0, "@edit_gvar", 4, 1], true], ["Discovered Tiles", ["@DiscTiles"], true, false, "TileArray", "Self", ["@GVar 4", "=", 1], [0, "@edit_gvar", 4, 0], true], ["Score", "@Score"]];
        document.getElementById("mode_vars_line").style.setProperty("display", "block");
        document.getElementById("1429_vars").style.setProperty("display", "flex");
    }
    else if (mode == 81) { // 2058
        // width = 4; height = 4;
        TileNumAmount = 3;
        mode_vars = [3, 2]; // The power required to increase the maximum number and the starting maximum number
        start_game_vars = [2, 0]; // The maximum number and the amount of disappeared tiles
        TileTypes = [
            [[2, 0, 0], 1, "#ffffff", "#000000"],
            [["@This 2", "=", 0], [["@This 0", "^", "@This 1"], "*", ["@This 0", "+", 1, "^", "@This 2"]], ["@HSLA", [222.49223595, "*", "@This 0", "-", 444.9844719], [0.7, "^", ["@This 0", "log", 2], "*", 300], [100, "-", ["@This 1", "*", 12.5], "@if", ["@This 1", ">", 4], "2nd", [0.85, "^", ["@This 1", "-", 4], "*", 50], "@end-if"], 1], ["#000000", "@if", ["@This 1", "+", "@This 2", ">", 5], "2nd", "#ffffff", "@end-if"], "none", 2.5, 0, ["Innerscript", [["@This 0", "defaultAbbrev"], "str_concat", "<sup>", "str_concat", ["@This 1", "defaultAbbrev"], "str_concat", "</sup> &#215; ", "str_concat", ["@This 0", "+", 1, "defaultAbbrev"], "str_concat", "<sup>", "str_concat", ["@This 2", "defaultAbbrev"], "str_concat", "</sup>"], "bottom-center", 6, 0], ["PrimeImage", ["@radial-gradient", ["@HSLA", ["@This 1", "+", "@This 2", "*", -79, "+", 79], 50, [100, "-", [0.95, "^", "@This 0", "*", 50]], 1], 0, "#0000", 50]]],
            [true, [["@This 0", "^", "@This 1"], "*", ["@This 0", "+", 1, "^", "@This 2"]], ["@linear-gradient", ["@HSLA", [222.49223595, "*", "@This 0", "-", 444.9844719], [0.7, "^", ["@This 0", "log", 2], "*", 300], [100, "-", ["@This 1", "*", 12.5], "@if", ["@This 1", ">", 4], "2nd", [0.85, "^", ["@This 1", "-", 4], "*", 50], "@end-if"], 1], ["@HSLA", [222.49223595, "*", "@This 0", "-", 222.49223595], [0.7, "^", ["@This 0", "+", 1, "log", 2], "*", 300], [100, "-", ["@This 2", "*", 12.5], "@if", ["@This 2", ">", 4], "2nd", [0.85, "^", ["@This 2", "-", 4], "*", 50], "@end-if"], 1]], ["#000000", "@if", ["@This 1", "+", "@This 2", ">", 5], "2nd", "#ffffff", "@end-if"], "none", 2.5, 0, ["Innerscript", [["@This 0", "defaultAbbrev"], "str_concat", "<sup>", "str_concat", ["@This 1", "defaultAbbrev"], "str_concat", "</sup> &#215; ", "str_concat", ["@This 0", "+", 1, "defaultAbbrev"], "str_concat", "<sup>", "str_concat", ["@This 2", "defaultAbbrev"], "str_concat", "</sup>"], "bottom-center", 6, 0], ["PrimeImage", ["@radial-gradient", ["@HSLA", ["@This 1", "+", "@This 2", "*", -79, "+", 79], [100, "-", [0.95, "^", "@This 0", "*", 50]], 50, 1], 0, "#0000", 50]]]
        ];
        MergeRules = [
            [2, [["@This", "arr_slice", 0, 3, "=", ["@Literal", 2, 0, 0]], "&&", ["@Next 1", "arr_slice", 0, 3, "=", ["@Literal", 2, 0, 0]]], true, [[2, 1, 0]], 0, [false, true]],
            [2, [["@This 0", "=", 2], "&&", ["@This 2", "=", 0], "&&", [["@This", "arr_slice", 0, 3,], "=", ["@Next 1", "arr_slice", 0, 3]]], true, [[2, ["@This 1", "+", 1], 0]], [2, "^", "@This 1", "*", 2], [false, true]],
            [2, [["@This 1", "=", 1], "&&", ["@This 2", "=", 0], "&&", ["@Next 1", "arr_slice", 0, 3, "=", ["@Literal", 2, 0, 0]], "&&", ["@This 0", ">=", "@GVar 0"]], false, [], [0, "@edit_gvar", 1, ["@GVar 1", "+", 1]], [false, true]],
            [2, [["@This 1", "=", 1], "&&", ["@This 2", "=", 0], "&&", ["@Next 1", "arr_slice", 0, 3, "=", ["@Literal", 2, 0, 0]]], false, [[["@This 0", "+", 1], 1, 0]], 0, [false, true]],
            [2, [["@This 0", "=", "@Next 1 0"], "&&", ["@This 1", "-", 1, "=", "@Next 1 1"], "&&", ["@This 2", "=", "@Next 1 2"], "&&", ["@This 1", ">", 1], "&&", ["@This 0", ">=", "@GVar 0"]], false, [], [0, "@edit_gvar", 1, ["@GVar 1", "+", 1]], [true, true]],
            [2, [["@This 0", "=", "@Next 1 0"], "&&", ["@This 1", "-", 1, "=", "@Next 1 1"], "&&", ["@This 2", "=", "@Next 1 2"], "&&", ["@This 1", ">", 1]], false, [["@This 0", ["@This 1", "-", 1], ["@This 2", "+", 1]]], ["@This 0", "^", ["@This 1", "-", 1], "*", ["@This 0", "+", 1, "^", ["@This 2", "+", 1]]], [false, true]],
            [2, [["@This 1", "=", 1], "&&", ["@This 0", "+", 1, "=", "@Next 1 0"], "&&", ["@Next 1 2", "=", 0], "&&", ["@This 2", "=", "@Next 1 1"], "&&", ["@This 0", ">=", "@GVar 0"]], false, [], [0, "@edit_gvar", 1, ["@GVar 1", "+", 1]], [true, true]],
            [2, [["@This 1", "=", 1], "&&", ["@This 0", "+", 1, "=", "@Next 1 0"], "&&", ["@Next 1 2", "=", 0], "&&", ["@This 2", "=", "@Next 1 1"]], false, [[["@This 0", "+", 1], ["@This 2", "+", 1], 0]], ["@This 0", "+", 1, "^", ["@This 2", "+", 1]], [false, true]],
            [0, [[["@This 0", "=", "@GVar 0"], "&&", ["@This 1", ">=", 3]], "||", [["@This 0", "+", 1, "=", "@GVar 0"], "&&", ["@This 2", ">=", 3]]], true, [["@This 0", "@This 1", "@This 2"]], [0, "@edit_gvar", 0, ["@GVar 0", "+", 1]]]
        ];
        startTileSpawns = [[[2, 0, 0], 70], [[2, 1, 0], 30]];
        winConditions = [[6, 1, 3]];
        winRequirement = 1;
        knownMergeMaxLength = 2;
        knownMergeLookbackDistance = 0;
        document.documentElement.style.setProperty("background-image", "radial-gradient(#33d039 0%, #0000 65%), linear-gradient(90deg, #bffff3, #fea842)");
        document.documentElement.style.setProperty("--background-color", "radial-gradient(#60ed64 0%, #0000 70%), linear-gradient( #dafff8,#ffc37a)");
        document.documentElement.style.setProperty("--grid-color", "#e99b3c");
        document.documentElement.style.setProperty("--tile-color", "#7cf4de");
        document.documentElement.style.setProperty("--text-color", "#11441d");
        statBoxes = [["Maximum Number", "@GVar 0"], ["Disappeared Tiles", "@GVar 1"]];
        displayRules("rules_text", ["h2", "Powers of n Times Powers of n+1"], ["h1", "2058"], ["p", "Two equal tiles can merge if they are a power of 2. A tile of the form n<sup>a</sup> &#215; (n + 1)<sup>b</sup> can merge with an n<sup>a - 1</sup> &#215; (n + 1)<sup>b</sup> tile to make an n<sup>a - 1</sup> &#215; (n + 1)<sup>b + 1</sup> tile. If this would result in the first exponent being 0, the bases are increased by 1 to shift the exponents over: for example, 2<sup>0</sup> &#215; 3<sup>2</sup> becomes 3<sup>2</sup> &#215; 4<sup>0</sup>. Get to the 2058 (6<sup>1</sup> &#215; 7<sup>3</sup>) tile to win!"],
        ["p", "Spawning tiles: 1 (70%), 2 (30%)"]);
        displayRules("gm_rules_text", ["h2", "Powers of n Times Powers of n+1"], ["h1", "2058"], ["p", "Two equal tiles can merge if they are a power of 2. A tile of the form n<sup>a</sup> &#215; (n + 1)<sup>b</sup> can merge with an n<sup>a - 1</sup> &#215; (n + 1)<sup>b</sup> tile to make an n<sup>a - 1</sup> &#215; (n + 1)<sup>b + 1</sup> tile. If this would result in the first exponent being 0, the bases are increased by 1 to shift the exponents over: for example, 2<sup>0</sup> &#215; 3<sup>2</sup> becomes 3<sup>2</sup> &#215; 4<sup>0</sup>. Get to the 2058 (6<sup>1</sup> &#215; 7<sup>3</sup>) tile to win!"],
        ["p", "Spawning tiles: 1 (70%), 2 (30%)"]);
        document.getElementById("mode_vars_line").style.setProperty("display", "block");
        document.getElementById("2058_vars").style.setProperty("display", "flex");
    }
    else if (mode == 82) { // 1716
        // width = 4; height = 4;
        TileNumAmount = 3;
        mode_vars = [true]; // Whether equal tile merges disappear or not
        start_game_vars = [0]; // Amount of disappeared tiles
        TileTypes = [
            [[["@This 0", "=", 1], "&&", ["@This 1", "=", 1]], ["@This 2"], "#ffffff", "#000000"],
            [true, ["@This 2"], ["@linear-gradient", 45, ["@HSLA", ["@This 0", "*", 37, "-", 245], 100, [0.8, "^", ["@This 0", "-", 1, "^", 0.5], "*", 90, "+", 10], 1], 0, 25, ["@HSLA", ["@This 1", "*", 37, "-", 245], 100, [0.8, "^", ["@This 1", "-", 1, "^", 0.5], "*", 90, "+", 10], 1], 75, 100], "#000000", "none", 2.5, 0, ["Innerscript", ["(", "str_concat", ["@This 0", "defaultAbbrev"], "str_concat", ", ", "str_concat", ["@This 1", "defaultAbbrev"], "str_concat", ")"], "bottom-center", 6, 0]]
        ];
        MergeRules = [
            [2, [["@This 0", "=", 1], "&&", ["@This 1", "=", 1], "&&", ["@Next 1 0", "=", 1], "&&", ["@Next 1 1", "=", 1]], true, [[2, 2, ["@This 2", "+", "@Next 1 2"]]], 0, [false, true]],
            [2, [["@This 0", "=", 2], "&&", ["@Next 1 0", "=", 1], "&&", ["@Next 1 1", "=", 1]], false, [[2, ["@This 1", "+", 1], ["@This 2", "+", "@Next 1 2"]]], 0, [false, true]],
            [2, [["@This 0", "-", 1, "=", "@Next 1 0"], "&&", ["@This 1", "+", 1, "=", "@Next 1 1"]], false, [["@This 0", ["@This 1", "+", 1], ["@This 2", "+", "@Next 1 2"]]], ["@This 2", "+", "@Next 1 2"], [false, true]],
            [2, [["@This 0", "+", 1, "=", "@Next 1 0"], "&&", ["@This 1", "-", 1, "=", "@Next 1 1"]], false, [[["@This 0", "+", 1], "@This 1", ["@This 2", "+", "@Next 1 2"]]], ["@This 2", "+", "@Next 1 2"], [false, true]],
            [2, [["@This 0", "+", 1, "=", "@This 1"], "&&", ["@This 0", "=", "@Next 1 0"], "&&", ["@This 1", "=", "@Next 1 1"]], false, [[["@This 0", "+", 1], "@This 1", ["@This 2", "+", "@Next 1 2"]]], ["@This 2", "+", "@Next 1 2"], [false, true]],
        ];
        startTileSpawns = [[[1, 1, 1], 84], [[2, 2, 2], 8], [[2, 3, 3], 8]];
        winConditions = [[7, 8]];
        winRequirement = 1;
        knownMergeMaxLength = 2;
        knownMergeLookbackDistance = 0;
        document.documentElement.style.setProperty("background-image", "linear-gradient(45deg, #ff8560 0% 25%, #ffeb78 75% 100%)");
        document.documentElement.style.setProperty("--background-color", "linear-gradient(135deg, #ffb7a1 0% 25%, #fff2ac 75% 100%)");
        document.documentElement.style.setProperty("--grid-color", "#ffe75f");
        document.documentElement.style.setProperty("--tile-color", "#ff693b");
        document.documentElement.style.setProperty("--text-color", "#4f3b1a");
        displayRules("rules_text", ["h2", "Pascal's Triangle"], ["h1", "1716"], ["p", "Tiles can be thought of as (unordered) pairs. An (a, b) tile can merge with an (a - 1, b + 1) tile to make a (a, b + 1) tile, or with an (a + 1, b - 1) tile to make an (a + 1, b) tile. Also, two equal (n, n + 1) tiles can merge into an (n + 1, n + 1 tile), and a 1 tile can serve as (1, n) for any n, meaning a (2, n) tile merges with a 1 to make a (2, n + 1) tile. Get to the 1716 (7, 8) tile to win!"],
        ["p", "Spawning tiles: 1 (85%), 2 (8%), 3 (8%)"]);
        displayRules("gm_rules_text", ["h2", "Pascal's Triangle"], ["h1", "1716"], ["p", "Tiles can be thought of as (unordered) pairs. An (a, b) tile can merge with an (a - 1, b + 1) tile to make a (a, b + 1) tile, or with an (a + 1, b - 1) tile to make an (a + 1, b) tile. Also, two equal (n, n + 1) tiles can merge into an (n + 1, n + 1 tile), and a 1 tile can serve as (1, n) for any n, meaning a (2, n) tile merges with a 1 to make a (2, n + 1) tile. Get to the 1716 (7, 8) tile to win!"],
        ["p", "Spawning tiles: 1 (85%), 2 (8%), 3 (8%)"]);
        document.getElementById("mode_vars_line").style.setProperty("display", "block");
        document.getElementById("1716_vars").style.setProperty("display", "flex");
    }
    else if (mode == 83) { // Ratio-Fill 1296
        // width = 4; height = 4;
        TileNumAmount = 3;
        start_game_vars = [0]; // Used to help with merges
        TileTypes = [
        [["@This 2", "<", 6n], ["@This 2", "Number"], ["@HSLA", 0, 0, ["@This 2", "*", -15, "+", 115], 1], "#464d52"],
        [true, ["@This 2", "Number"], ["@CalcArray", 0, "@if", ["@This 0", "<", 7], "2nd", [["@Literal", "#ffffff", "#c300ff", "#00ff00", "#ff9d00", "#00a6ff", "#ff00bf", "#ffff00"], "arr_elem", "@This 0"], "@end-if", "@else", "2nd", ["@Literal", "@HSLA", [97, "*", "@This 0", "-", 553], 100, [0.9, "^", ["@This 0", "-", 7], "*", 40], 1], "@end-else", "evaluateColor"], ["#464d52", "@if", ["@This 0", ">", 6], "2nd", "#e2ebf1", "@end-if"], "none", 2, 0, 
            ["PrimeImage", ["@linear-gradient", ["@HSLA", 0, 100, [15, "@if", ["@This 1", "arr_elem", 0], "2nd", 75, "@end-if"], 1], 0, "#0000", 25, 75, ["@HSLA", 0, 100, [15, "@if", ["@This 1", "arr_elem", 0], "2nd", 75, "@end-if"], 1], 100], ["@linear-gradient", 90, "#0000", 0, 0, "#000", 0, 20, "#0000", 20]],
            ["PrimeImage", ["@linear-gradient", ["@HSLA", 43, 100, [15, "@if", ["@This 1", "arr_elem", 1], "2nd", 75, "@end-if"], 1], 0, "#0000", 25, 75, ["@HSLA", 43, 100, [15, "@if", ["@This 1", "arr_elem", 1], "2nd", 75, "@end-if"], 1], 100], ["@linear-gradient", 90, "#0000", 0, 20, "#000", 20, 40, "#0000", 40]],
            ["PrimeImage", ["@linear-gradient", ["@HSLA", 86, 100, [15, "@if", ["@This 1", "arr_elem", 2], "2nd", 75, "@end-if"], 1], 0, "#0000", 25, 75, ["@HSLA", 86, 100, [15, "@if", ["@This 1", "arr_elem", 2], "2nd", 75, "@end-if"], 1], 100], ["@linear-gradient", 90, "#0000", 0, 40, "#000", 40, 60, "#0000", 60]],
            ["PrimeImage", ["@linear-gradient", ["@HSLA", 129, 100, [15, "@if", ["@This 1", "arr_elem", 3], "2nd", 75, "@end-if"], 1], 0, "#0000", 25, 75, ["@HSLA", 129, 100, [15, "@if", ["@This 1", "arr_elem", 3], "2nd", 75, "@end-if"], 1], 100], ["@linear-gradient", 90, "#0000", 0, 60, "#000", 60, 80, "#0000", 80]],
            ["PrimeImage", ["@linear-gradient", ["@HSLA", 172, 100, [15, "@if", ["@This 1", "arr_elem", 4], "2nd", 75, "@end-if"], 1], 0, "#0000", 25, 75, ["@HSLA", 172, 100, [15, "@if", ["@This 1", "arr_elem", 4], "2nd", 75, "@end-if"], 1], 100], ["@linear-gradient", 90, "#0000", 0, 80, "#000", 80, 100, "#0000", 100]]
        ]
        ];
        MergeRules = [
            [2, [["@This 2", "+B", "@Next 1 2", "<", 6n], "&&", ["@This 2", "%B", "@Next 1 2", "=", 0n]], false, [[0, "@This 1", ["@This 2", "+B", "@Next 1 2"]]], ["@This 2", "+", "@Next 1 2"], [false, true]],
            [2, [["@This 2", "+B", "@Next 1 2", "=", 6n], "&&", ["@This 2", "%B", "@Next 1 2", "=", 0n]], false, [[1, ["@Literal", false, false, false, false, false], 6n]], 6, [false, true]],
            [2, [["@Next 1 1", "arr_reduce", 0, ["+", "@Var -1"], "=", 4], "&&", ["@This 2", "*B", ["@Next 1 1", "arr_indexOf", false, "+B", 1n], "=", "@Next 1 2"]], false, [[["@Next 1 0", "+", 1], [["@Literal"], "@repeat", 5, "arr_push", false, "@end-repeat"], ["@This 2", "+B", "@Next 1 2"]]], ["@This 2", "+", "@Next 1 2"], [false, true]],
            [2, [false, "@edit_gvar", 0, ["@Next 1 2", "/BR", "@This 2"], "@if", [["@This 2", "typeof", "!=", "bigint"], "||", ["@Next 1 2", "typeof", "!=", "bigint"], "||", ["@GVar 0", "modBR", 1n, "!=", new BigRational(0)]], "2nd", false, "@end-if", "@else", "@edit_gvar", 0, ["@GVar 0", "BigInt", "-B", 1n], "2nd", [["@GVar 0", ">", -1n], "&&", ["@GVar 0", "<", 5n], "&&", ["@Next 1 1", "arr_elem", "@GVar 0", "!"]], "@end-else"], false, [["@Next 1 0", ["@Next 1 1", "arr_edit_elem", "@GVar 0", true], ["@This 2", "+B", "@Next 1 2"]]], ["@This 2", "+", "@Next 1 2"], [false, true]]
        ]
        startTileSpawns = [[[0, ["@Literal", true, true, true, true, true], 1n], 85], [[0, ["@Literal", true, true, true, true, true], 2n], 10], [[0, ["@Literal", true, true, true, true, true], 3n], 5]];
        winConditions = [[4, [false, false, false, false, false], 1296n]];
        winRequirement = 1;
        knownMergeMaxLength = 2;
        knownMergeLookbackDistance = 0;
        document.documentElement.style.setProperty("background-image", "linear-gradient(90deg, #0000 0%, #00a6ff 20% 80%, #0000 100%), linear-gradient( #ff8080 0% 20%, #ffdb80 20% 40%, #c8ff80 40% 60%, #80ff93 60% 80%, #80ffee 80% 100%)");
        document.documentElement.style.setProperty("--background-color", "linear-gradient(#0000 0%,#72ceff 20% 80%, #0000 100%), linear-gradient(90deg, #ff8080, #ffdb80, #c8ff80, #80ff93, #80ffee)");
        document.documentElement.style.setProperty("--grid-color", " #2a66cd");
        document.documentElement.style.setProperty("--tile-color", " #51dbe8");
        document.documentElement.style.setProperty("--text-color", "#005786");
        displayRules("rules_text", ["h1", "Ratio-Fill 1296"], ["p","Two tiles less than 6 can merge if one tile is a multiple of the other tile and their sum is not greater than 6. To get from one power of six to the next, a tile must merge with a tile equal to itself, merge with a tile that's half of itself, merge with a tile that's a third of itself, merge with a tile that's a fourth of itself, and merge with a tile that's a fifth of itself, once each in any order. Get to the 1296 tile to win!"],
        ["p", "Spawning tiles: 1 (85%), 2 (10%), 3 (5%)"]);
        displayRules("gm_rules_text", ["h1", "Ratio-Fill 1296"], ["p","Two tiles less than 6 can merge if one tile is a multiple of the other tile and their sum is not greater than 6. To get from one power of six to the next, a tile must merge with a tile equal to itself, merge with a tile that's half of itself, merge with a tile that's a third of itself, merge with a tile that's a fourth of itself, and merge with a tile that's a fifth of itself, once each in any order. Get to the 1296 tile to win!"],
        ["p", "Spawning tiles: 1 (85%), 2 (10%), 3 (5%)"]);
    }
    else if (mode == 84) { // Ratio-Fill 1024
        // width = 4; height = 4;
        TileNumAmount = 3;
        start_game_vars = [0]; // Used to help with merges
        TileTypes = [
        [["@This 2", "<", 4n], ["@This 2", "Number"], ["@HSLA", 0, 0, ["@This 2", "*", -15, "+", 115], 1], "#564040"],
        [true, ["@This 2", "Number"], ["@CalcArray", 0, "@if", ["@This 0", "<", 12], "2nd", [["@Literal", "#ffffff", "#00ff00", "#bbff00", "#ffc800", "#ff7300", "#ff0000", "#ff009d", "#f900fe", "#6f00ff", "#004cff", "#01d0ff", "#00ffae"], "arr_elem", "@This 0"], "@end-if", "@else", "2nd", ["@HSLA", [-31, "*", "@This 0", "+", 491], [0.95, "^", ["@This 0", "-", 12], "*", 75], 70, 1], "@end-else", "evaluateColor"], "#564040", "none", 2, 0, 
            ["PrimeImage", ["@linear-gradient", ["@HSLA", 43, 100, [15, "@if", ["@This 1", "arr_elem", 0], "2nd", 75, "@end-if"], 1], 0, "#0000", 25, 75, ["@HSLA", 43, 100, [15, "@if", ["@This 1", "arr_elem", 0], "2nd", 75, "@end-if"], 1], 100], ["@linear-gradient", 90, "#0000", 0, 0, "#000", 0, 100/6, "#0000", 100/6]],
            ["PrimeImage", ["@linear-gradient", ["@HSLA", 86, 100, [15, "@if", ["@This 1", "arr_elem", 1], "2nd", 75, "@end-if"], 1], 0, "#0000", 25, 75, ["@HSLA", 86, 100, [15, "@if", ["@This 1", "arr_elem", 1], "2nd", 75, "@end-if"], 1], 100], ["@linear-gradient", 90, "#0000", 0, 100/6, "#000", 100/6, 200/6, "#0000", 200/6]],
            ["PrimeImage", ["@linear-gradient", ["@HSLA", 129, 100, [15, "@if", ["@This 1", "arr_elem", 2], "2nd", 75, "@end-if"], 1], 0, "#0000", 25, 75, ["@HSLA", 129, 100, [15, "@if", ["@This 1", "arr_elem", 2], "2nd", 75, "@end-if"], 1], 100], ["@linear-gradient", 90, "#0000", 0, 200/6, "#000", 200/6, 300/6, "#0000", 300/6]],
            ["PrimeImage", ["@linear-gradient", ["@HSLA", 172, 100, [15, "@if", ["@This 1", "arr_elem", 3], "2nd", 75, "@end-if"], 1], 0, "#0000", 25, 75, ["@HSLA", 172, 100, [15, "@if", ["@This 1", "arr_elem", 3], "2nd", 75, "@end-if"], 1], 100], ["@linear-gradient", 90, "#0000", 0, 300/6, "#000", 300/6, 400/6, "#0000", 400/6]],
            ["PrimeImage", ["@linear-gradient", ["@HSLA", 215, 100, [15, "@if", ["@This 1", "arr_elem", 4], "2nd", 75, "@end-if"], 1], 0, "#0000", 25, 75, ["@HSLA", 215, 100, [15, "@if", ["@This 1", "arr_elem", 4], "2nd", 75, "@end-if"], 1], 100], ["@linear-gradient", 90, "#0000", 0, 400/6, "#000", 400/6, 500/6, "#0000", 500/6]],
            ["PrimeImage", ["@linear-gradient", ["@HSLA", 258, 100, [15, "@if", ["@This 1", "arr_elem", 5], "2nd", 75, "@end-if"], 1], 0, "#0000", 25, 75, ["@HSLA", 258, 100, [15, "@if", ["@This 1", "arr_elem", 5], "2nd", 75, "@end-if"], 1], 100], ["@linear-gradient", 90, "#0000", 0, 500/6, "#000", 500/6, 100, "#0000", 100]]
        ]
        ];
        MergeRules = [
            [2, [["@This 2", "+B", "@Next 1 2", "<", 4n]], false, [[0, "@This 1", ["@This 2", "+B", "@Next 1 2"]]], ["@This 2", "+", "@Next 1 2"], [false, true]],
            [2, [["@This 2", "+B", "@Next 1 2", "=", 4n]], false, [[1, ["@Literal", false, false, false, false, false, false], 4n]], 4, [false, true]],
            [2, [["@Next 1 1", "arr_reduce", 0, ["+", "@Var -1"], "=", 5], "&&", ["@This 2", "*B", ["@Next 1 1", "arr_indexOf", false, "+B", 2n], "=", "@Next 1 2"]], false, [[["@Next 1 0", "+", 1], [["@Literal"], "@repeat", 6, "arr_push", false, "@end-repeat"], ["@This 2", "+B", "@Next 1 2"]]], ["@This 2", "+", "@Next 1 2"], [false, true]],
            [2, [false, "@edit_gvar", 0, ["@Next 1 2", "/BR", "@This 2"], "@if", [["@This 2", "typeof", "!=", "bigint"], "||", ["@Next 1 2", "typeof", "!=", "bigint"], "||", ["@GVar 0", "modBR", 1n, "!=", new BigRational(0)]], "2nd", false, "@end-if", "@else", "@edit_gvar", 0, ["@GVar 0", "BigInt", "-B", 2n], "2nd", [["@GVar 0", ">", -1n], "&&", ["@GVar 0", "<", 6n], "&&", ["@Next 1 1", "arr_elem", "@GVar 0", "!"]], "@end-else"], false, [["@Next 1 0", ["@Next 1 1", "arr_edit_elem", "@GVar 0", true], ["@This 2", "+B", "@Next 1 2"]]], ["@This 2", "+", "@Next 1 2"], [false, true]]
        ]
        startTileSpawns = [[[0, ["@Literal", true, true, true, true, true, true], 1n], 85], [[0, ["@Literal", true, true, true, true, true, true], 2n], 8], [[0, ["@Literal", true, true, true, true, true, true], 3n], 5], [[1, ["@Literal", false, false, false, false, false, false], 4n], 2]];
        winConditions = [[5, [false, false, false, false, false, false], 1024n]];
        winRequirement = 1;
        knownMergeMaxLength = 2;
        knownMergeLookbackDistance = 0;
        document.documentElement.style.setProperty("background-image", "linear-gradient(90deg, #0000 0%, #ff0000 20% 80%, #0000 100%), linear-gradient( #ffdb80 0% 16.666%, #c8ff80 16.666% 33.333%, #80ff93 33.333% 50%, #80ffee 50% 66.666%, #80b5ff 66.666% 83.333%, #a680ff 83.333% 100%)");
        document.documentElement.style.setProperty("--background-color", "linear-gradient(#0000 0%,#ff5050 25% 75%, #0000 100%), linear-gradient(90deg, #ffdb80, #c8ff80, #80ff93, #80ffee, #80b5ff, #a680ff)");
        document.documentElement.style.setProperty("--grid-color", "#dc273c");
        document.documentElement.style.setProperty("--tile-color", "#f37650");
        document.documentElement.style.setProperty("--text-color", "#8f0000");
        displayRules("rules_text", ["h1", "Ratio-Fill 1024"], ["p","Two tiles less than 4 can merge if their sum is not greater than 4. To get from one power of four to the next, a tile must merge with a tile that's half of itself, merge with a tile that's a third of itself, merge with a tile that's a fourth of itself, merge with a tile that's a fifth of itself, merge with a tile that's a sixth of itself, and merge with a tile that's a seventh of itself, once each in any order. Get to the 1024 tile to win!"],
        ["p", "Spawning tiles: 1 (85%), 2 (8%), 3 (5%), 4 (2%)"]);
        displayRules("gm_rules_text", ["h1", "Ratio-Fill 1024"], ["p","Two tiles less than 4 can merge if their sum is not greater than 4. To get from one power of four to the next, a tile must merge with a tile that's half of itself, merge with a tile that's a third of itself, merge with a tile that's a fourth of itself, merge with a tile that's a fifth of itself, merge with a tile that's a sixth of itself, and merge with a tile that's a seventh of itself, once each in any order. Get to the 1024 tile to win!"],
        ["p", "Spawning tiles: 1 (85%), 2 (8%), 3 (5%), 4 (2%)"]);
    }
    else if (mode == 85) { // 2669
        // width = 4; height = 4;
        TileNumAmount = 4;
        mode_vars = [0, 7n]; // mode_vars[0] controls the random goals, mode_vars[1] is the first random goal minimum
        start_game_vars = [7n, 0, false, [5n, 2n, 2], 7n, 0] // The first entry is the current random goal, the second entry is the amount of random goals met so far, the third entry is whether a random goal has been met this turn, the fourth entry stores information for future random goals, and the fifth entry is the first random goal minimum. The sixth entry controls the display of Discovered Tiles.
        TileTypes = [
            [[1n, 1n, 0n, 1], 1, "#ffffff", "#000000"],
            [true, ["@This 0"], ["@radial-gradient", ["@HSLA", ["@This 0", "log", 2, "*", -67, "+", 60], 100, ["@This 1", "^", -0.12, "*", 80, "+", 10], 1], 0, 35, ["@HSLA", ["@This 0", "/", "@This 1", "*", 360], 50, [2/3, "^", ["@This 0", "/", "@This 1", "-", 1], "*", 100], 1], 90], ["@HSLA", ["@This 3", "*", -240, "+", 480], 100, [20, "@if", ["@This 0", ">=", 377], "2nd", 95, "@end-if"], 1], [0, 0, 0.2, ["@HSLA", [240, "@if", ["@This 3", "=", 2], "2nd", 0, "@end-if"], 75, 50, 1]], 2.5, 0, ["Innerscript", [["@This 1", "defaultAbbrevB"], "str_concat", " + ", "str_concat", ["@This 2", "defaultAbbrevB"]], "bottom-center", 6, 0]]
        ];
        MergeRules = [
            [2, [["@Next 1 0", "=", "@This 2"], "&&", ["@This 3", "<", 2]], false, [[["@This 0", "+B", "@Next 1 0"], "@This 0", "@This 2", ["@This 3", "+", 1]]], ["@This 0", "+", "@Next 1 0"], [false, true]],
            [2, [["@Next 1 0", "=", "@This 1"]], false, [[["@This 0", "+B", "@Next 1 0"], "@This 0", "@This 1", 1]], ["@This 0", "+", "@Next 1 0"], [false, true]]
        ];
        startTileSpawns = [[[1n, 1n, 0n, 1], 85], [[2n, 1n, 1n, 1], 10], [[3n, 2n, 1n, 2], 5]];
        winConditions = [["@This 0", "=", 2669n]];
        winRequirement = 1;
        knownMergeMaxLength = 2;
        knownMergeLookbackDistance = 0;
        document.documentElement.style.setProperty("background-image", "radial-gradient(#d73d00 0%, #9eb1ff 80%, #fff 110%)");
        document.documentElement.style.setProperty("--background-color", "radial-gradient(#e36d3e 0% 10%, #d0d8f6 80%, #fff 110%)");
        document.documentElement.style.setProperty("--grid-color", "#b64316");
        document.documentElement.style.setProperty("--tile-color", "#899ce4");
        document.documentElement.style.setProperty("--text-color", "#111835");
        displayRules("rules_text", ["h1", "2669"], ["p", "A larger tile can merge with a smaller tile if that smaller tile has the same number as one of the two tiles that the larger tile was created from, unless the larger tile already merged with that same number for its last two merges. Get to the 2669 tile to win (your first task is figuring out how to get there...), or just play and see what tiles you end up making!"],
        ["p", "Spawning tiles: 1 (85%), 2 (10%), 3 (5%)"]);
        displayRules("gm_rules_text", ["h1", "2669"], ["p", "A larger tile can merge with a smaller tile if that smaller tile has the same number as one of the two tiles that the larger tile was created from, unless the larger tile already merged with that same number for its last two merges. Get to the 2669 tile to win (your first task is figuring out how to get there...), or just play and see what tiles you end up making!"],
        ["p", "Spawning tiles: 1 (85%), 2 (10%), 3 (5%)"]);
        statBoxes = [["Discovered Tiles", ["@DiscTiles", "arr_length"], false, ...[,,,], ["@GVar 5", "=", 0], [0, "@edit_gvar", 5, 1], true], ["Discovered Tiles", ["@DiscTiles"], true, false, "TileArray", "Self", ["@GVar 5", "=", 1], [0, "@edit_gvar", 5, 0], true], ["Score", "@Score"]];
        document.getElementById("mode_vars_line").style.setProperty("display", "block");
        document.getElementById("2669_vars").style.setProperty("display", "flex");
    }
    else if (mode == 86) { // Bitwise 2048
        // width = 3; height = 3;
        TileNumAmount = 1;
        TileTypes = [
            [true, ["@This 0"], "@ColorScheme", "Bitwise 2048", ["@This 0", 2n]]
        ];
        if (modifiers[13] == "None") {
            MergeRules = [
                [2, [["@This 0", "+B", "@Next 1 0"], "=", ["@This 0", "bit^B", "@Next 1 0"]], true, [[["@This 0", "+B", "@Next 1 0"]]], ["@This 0", "+", "@Next 1 0"], [false, true]],
                [2, [[2n, "^B", ["@This 0", "+B", 1n, "expomodB", 2n], "=", ["@This 0", "+B", 1n]], "&&", ["@Next 1 0", "=", 1n]], false, [[["@This 0", "+B", 1n]]], ["@This 0", "+", 1n], [false, true]]
            ];
            startTileSpawns = [[[1n], 95], [[2n], 5]];
            winConditions = [[2048n]];
            winRequirement = 1;
        }
        else {
            MergeRules = [
                [2, [[["@This 0", "signB"], "=", ["@Next 1 0", "signB"]], "&&", [[["@This 0", "absB"], "+B", ["@Next 1 0", "absB"]], "=", [["@This 0", "absB"], "bit^B", ["@Next 1 0", "absB"]]]], true, [[["@This 0", "+B", "@Next 1 0"]]], ["@This 0", "+", "@Next 1 0", "abs"], [false, true]],
                [2, [["@This 0", ">", 0n], "&&", [2n, "^B", ["@This 0", "+B", 1n, "expomodB", 2n, "absB"], "=", ["@This 0", "+B", 1n]], "&&", ["@Next 1 0", "=", 1n]], false, [[["@This 0", "+B", 1n]]], ["@This 0", "+", 1n], [false, true]],
                [2, [["@This 0", "<", 0n], "&&", [2n, "^B", ["@This 0", "-B", 1n, "expomodB", 2n, "absB"], "=", ["@This 0", "-B", 1n, "*B", -1n]], "&&", ["@Next 1 0", "=", -1n]], false, [[["@This 0", "-B", 1n]]], ["@This 0", "abs", "+", 1n], [false, true]]
            ];
            if (modifiers[13] == "Interacting") MergeRules.push(
                [2, ["@This 0", "*B", -1n, "=", "@Next 1 0"], true, [], 0, [true, true]],
                [2, [[["@This 0", "signB"], "!=", ["@Next 1 0", "signB"]], "&&", [["@This 0", "absB"], ">", ["@Next 1 0", "absB"]], "&&", [[["@This 0", "absB"], "-B", ["@Next 1 0", "absB"]], "=", [["@This 0", "absB"], "bit^B", ["@Next 1 0", "absB"]]]], false, [[["@This 0", "+B", "@Next 1 0"]]], ["@This 0", "+", "@Next 1 0", "abs"], [false, true]]
            )
            startTileSpawns = [[[1n], 95 * modifiers[22]], [[2n], 5 * modifiers[22]], [[-1n], 95 * modifiers[23]], [[-2n], 5 * modifiers[23]]];
            winConditions = [[2048n], [-2048n]];
            winRequirement = 2;
        }
        knownMergeMaxLength = 2;
        knownMergeLookbackDistance = 0;
        document.documentElement.style.setProperty("background-image", "linear-gradient(#9447ff, #99c9ff, #00a36a, #39f500, #ffea47, #ff9999)");
        document.documentElement.style.setProperty("--background-color", "linear-gradient(#c49bff,#c0ddff,#5dd9ae,#9cff7e,#fff49e,#ffc4c4)");
        document.documentElement.style.setProperty("--grid-color", "#7ef35a");
        document.documentElement.style.setProperty("--tile-color", "#2ec892");
        document.documentElement.style.setProperty("--text-color", "#00191e");
        displayRules("rules_text", ["h1", "Bitwise 2048"], ["p", "Two tiles can merge if those two numbers, when added in binary, add without any carries. A tile that is 1 less than a power of 2 can merge with a 1. Get to the 2048 tile to win!"],
        ["p", "Spawning tiles: 1 (95%), 2 (5%)"]);
        displayRules("gm_rules_text", ["h1", "Bitwise 2048"], ["p", "Two tiles can merge if those two numbers, when added in binary, add without any carries. A tile that is 1 less than a power of 2 can merge with a 1. Get to the 2048 tile to win!"],
        ["p", "Spawning tiles: 1 (95%), 2 (5%)"]);
    }
    else if (mode == 87) { // 3120
        // width = 4; height = 4;
        TileNumAmount = 2;
        start_game_vars = [[2, 3]] // Stores the Fibonacci sequence to help with the numbers on tiles
        TileTypes = [
            [true, [1, "@repeat", ["@GVar 0", "arr_length", "<", ["@This 0", "+", 1]], "@edit_gvar", 0, ["@GVar 0", "arr_push", [["@GVar 0", "arr_elem", -1], "+", ["@GVar 0", "arr_elem", -2]]], "@end-repeat", "@if", ["@This 0", ">", 0], "2nd", "@GVar 0", "arr_slice", 1, "@This 0", "arr_reduce", 1, ["*", "@Var -1"], "*", ["@GVar 0", "arr_elem", "@This 1"], "@end-if"], ["@radial-gradient", ["@HSLA", [37, "*", "@This 1", "+", 80], 100, ["@This 1", "%", 7, "-", 3, "*", -8, "+", 50], 1], 0, 25, ["@HSLA", [37, "*", "@This 0", "+", 80], 100, ["@This 0", "%", 7, "-", 3, "*", -8, "+", 50], 1], 90], ["#18072f", "@if", ["@This 0", "=", "@This 1"], "2nd", "#45430b", "@end-if"], "none", 2.5, 0, ["Innerscript", ["@This 1", "str_concat", " / ", "str_concat", "@This 0"], "bottom-center", 6, 0]],
        ];
        MergeRules = [
            [2, [["@This 0", "=", "@This 1"], "&&", ["@Next 1 0", "=", "@This 0"], "&&", ["@Next 1 1", "=", "@This 1"]], false, [[["@This 0", "+", 1], 0]], [1, "@repeat", ["@GVar 0", "arr_length", "<", ["@This 0", "+", 2]], "@edit_gvar", 0, ["@GVar 0", "arr_push", [["@GVar 0", "arr_elem", -1], "+", ["@GVar 0", "arr_elem", -2]]], "@end-repeat", "@if", ["@This 0", "+", 1, ">", 0], "2nd", "@GVar 0", "arr_slice", 1, ["@This 0", "+", 1], "arr_reduce", 1, ["*", "@Var -1"], "*", 2, "@end-if"], [false, true]],
            [2, [["@This 1", "=", 0], "&&", ["@This 0", "-", 1, "=", "@Next 1 0"], "&&", ["@This 0", "-", 1, "=", "@Next 1 1"]], false, [["@This 0", 1]], [1, "@repeat", ["@GVar 0", "arr_length", "<", ["@This 0", "+", 1]], "@edit_gvar", 0, ["@GVar 0", "arr_push", [["@GVar 0", "arr_elem", -1], "+", ["@GVar 0", "arr_elem", -2]]], "@end-repeat", "@if", ["@This 0", ">", 0], "2nd", "@GVar 0", "arr_slice", 1, "@This 0", "arr_reduce", 1, ["*", "@Var -1"], "*", 3, "@end-if"], [false, true]],
            [2, [["@This 0", ">", "@This 1"], "&&", ["@This 0", "=", "@Next 1 0"], "&&", ["@This 1", "-", 1, "=", "@Next 1 1"]], false, [["@This 0", ["@This 1", "+", 1]]], [1, "@repeat", ["@GVar 0", "arr_length", "<", ["@This 0", "+", 1]], "@edit_gvar", 0, ["@GVar 0", "arr_push", [["@GVar 0", "arr_elem", -1], "+", ["@GVar 0", "arr_elem", -2]]], "@end-repeat", "@if", ["@This 0", ">", 0], "2nd", "@GVar 0", "arr_slice", 1, "@This 0", "arr_reduce", 1, ["*", "@Var -1"], "*", ["@GVar 0", "arr_elem", ["@This 1", "+", 1]], "@end-if"], [false, true]],
        ];
        startTileSpawns = [[[0, 0], 85], [[1, 0], 10], [[1, 1], 5]];
        winConditions = [[5, 0]];
        winRequirement = 1;
        knownMergeMaxLength = 2;
        knownMergeLookbackDistance = 0;
        document.documentElement.style.setProperty("background-image", "radial-gradient(#4800ad 0%, #d3ff7a 100%)");
        document.documentElement.style.setProperty("--background-color", "radial-gradient(#d3ff7a 0%, #4800ad 150%)");
        document.documentElement.style.setProperty("--grid-color", "#1d0088");
        document.documentElement.style.setProperty("--tile-color", "#dff09c");
        document.documentElement.style.setProperty("--text-color", "#1a2727");
        displayRules("rules_text", ["h2", "Products of First n Fibonacci Numbers"], ["h1", "3120"], ["p", "Each tile can merge with the tile before it, unless that larger tile has merged with the tile before it N previous times in a row, in which case that tile merges with an equal tile instead. The 1 tile's N is 0, and a tile's N increases by 1 each time that tile merges with an equal tile. Get to the 3120 tile to win!"],
        ["p", "Spawning tiles: 1 (85%), 2 (10%), 3 (5%)"]);
        displayRules("gm_rules_text", ["h2", "Products of First n Fibonacci Numbers"], ["h1", "3120"], ["p", "Each tile can merge with the tile before it, unless that larger tile has merged with the tile before it N previous times in a row, in which case that tile merges with an equal tile instead. The 1 tile's N is 0, and a tile's N increases by 1 each time that tile merges with an equal tile. Get to the 3120 tile to win!"],
        ["p", "Spawning tiles: 1 (85%), 2 (10%), 3 (5%)"]);
    }
    else if (mode == 88) { // FACTUP
        // width = 4; height = 4;
        TileNumAmount = 1;
        mode_vars = [false, 0, 1680n]; // First entry enables Crazy FACTUP. Next two entries are random goals: second entry is the random goals setting, third entry is the first goal minimum
        start_game_vars = [1n, 0, false, [1n, 2n], 1680n, [1n], 0, 0] // The first entry is the current random goal, the second entry is the amount of random goals met so far, the third entry is whether a random goal has been met this turn, the fourth entry is an array of possible tiles found by the random goals so far, and the fifth entry is the first goal minimum. The sixth entry is the list of discovered amounts of factors, seventh entry controls this list's display. The eighth entry controls the display of Discovered Tiles.
        if (modifiers[13] == "None") {
            TileTypes = [
                [true, ["@This 0"], ["@linear-gradient", ["@HSLA", ["@This 0", "log", 2, "*", 141], 75, [0.9, "^", ["@This 0", "log", 2], "*", 70, "+", 15], 1], 0, ["@HSLA", ["@This 0", "factorAmountB", "+", 15, "log", 2, "*", -403, "+", 1672], 100, [0.7, "^", ["@This 0", "factorAmountB", "+", 15, "log", 2, "-", 3], "*", 80, "+", 10], 1], 25, 75, ["@HSLA", ["@This 0", "log", 2, "*", 141], 75, [0.9, "^", ["@This 0", "log", 2], "*", 70, "+", 15], 1], 100], "#000000", "0px 0px 5px #fff"]
            ];
            MergeRules = [
                [2, [["@This 0", "+B", "@Next 1 0", "factorAmountB"], ">", [["@This 0", "factorAmountB"], "max", ["@Next 1 0", "factorAmountB"]]], true, [[["@This 0", "+B", "@Next 1 0"]]], ["@This 0", "+", "@Next 1 0"], [false, true]],
            ];
            startTileSpawns = [[[1n], 100]];
        }
        else {
            TileTypes = [
                [["@This 0", ">", 0n], ["@This 0"], ["@linear-gradient", ["@HSLA", ["@This 0", "log", 2, "*", 141], 75, [0.9, "^", ["@This 0", "log", 2], "*", 70, "+", 15], 1], 0, ["@HSLA", ["@This 0", "factorAmountB", "+", 15, "log", 2, "*", -403, "+", 1672], 100, [0.7, "^", ["@This 0", "factorAmountB", "+", 15, "log", 2, "-", 3], "*", 80, "+", 10], 1], 25, 75, ["@HSLA", ["@This 0", "log", 2, "*", 141], 75, [0.9, "^", ["@This 0", "log", 2], "*", 70, "+", 15], 1], 100], "#000", "0px 0px 5px #fff", 0, 0, ["PrimeImage", ["@linear-gradient", 90, "#fff", 0, "#0000", 20, 80, "#fff", 100]]],
                [["@This 0", "<", 0n], ["@This 0"], ["@linear-gradient", ["@HSLA", ["@This 0", "abs", "log", 2, "*", 141], 75, [0.9, "^", ["@This 0", "abs", "log", 2], "*", 70, "+", 15], 1], 0, ["@HSLA", ["@This 0", "absB", "factorAmountB", "+", 15, "log", 2, "*", -403, "+", 1672], 100, [0.7, "^", ["@This 0", "absB", "factorAmountB", "+", 15, "log", 2, "-", 3], "*", 80, "+", 10], 1], 25, 75, ["@HSLA", ["@This 0", "abs", "log", 2, "*", 141], 75, [0.9, "^", ["@This 0", "abs", "log", 2], "*", 70, "+", 15], 1], 100], "#fff", "0px 0px 5px #000", 0, 0, ["PrimeImage", ["@linear-gradient", 90, "#000", 0, "#0000", 20, 80, "#000", 100]]],
            ];
            MergeRules = [
                [2, [[["@This 0", "signB"], "=", ["@Next 1 0", "signB"]], "&&", [["@This 0", "+B", "@Next 1 0", "absB", "factorAmountB"], ">", [["@This 0", "absB", "factorAmountB"], "max", ["@Next 1 0", "absB", "factorAmountB"]]]], true, [[["@This 0", "+B", "@Next 1 0"]]], ["@This 0", "+", "@Next 1 0", "abs"], [false, true]]
            ];
            if (modifiers[13] == "Interacting") MergeRules.push(
                [2, ["@This 0", "*B", -1n, "=", "@Next 1 0"], true, [], 0, [true, true]],
                [2, [[["@This 0", "signB"], "!=", ["@Next 1 0", "signB"]], "&&", [["@This 0", "absB"], ">", ["@Next 1 0", "absB"]], "&&", [["@This 0", "+B", "@Next 1 0", "absB", "factorAmountB"], ">", [["@This 0", "absB", "factorAmountB"], "max", ["@Next 1 0", "absB", "factorAmountB"]]]], false, [[["@This 0", "+B", "@Next 1 0"]]], ["@This 0", "+", "@Next 1 0", "abs"], [false, true]]
            )
            startTileSpawns = [[[1n], modifiers[22]], [[-1n], modifiers[23]]];
        }
        winRequirement = false;
        knownMergeMaxLength = 2;
        knownMergeLookbackDistance = 0;
        document.documentElement.style.setProperty("background-image", "linear-gradient( #9ef0b8, #ff9449 15%, #ff415c 85%, #cc81ed)");
        document.documentElement.style.setProperty("--background-color", "linear-gradient(90deg,#c1f5d1,#ffb783 15%,#ff6b82 85%,#dba9f0)");
        document.documentElement.style.setProperty("--grid-color", "#f67a22");
        document.documentElement.style.setProperty("--tile-color", "#f54d66");
        document.documentElement.style.setProperty("--text-color", "#931400");
        displayRules("rules_text", ["h1", "FACTUP"], ["p", "Two tiles can merge if their sum has more factors than either of the two tiles themselves. This mode has a lot of possible tiles, so it doesn't have a win condition. If you want a goal to strive for, see how many tiles with different amounts of factors you can make."],
        ["p", "Spawning tiles: 1 (100%)"]);
        displayRules("gm_rules_text", ["h1", "FACTUP"], ["p", "Two tiles can merge if their sum has more factors than either of the two tiles themselves. This mode has a lot of possible tiles, so it doesn't have a win condition. If you want a goal to strive for, see how many tiles with different amounts of factors you can make."],
        ["p", "Spawning tiles: 1 (100%)"]);
        statBoxes = [["Discovered Tiles", ["@DiscTiles", "arr_length"], false, ...[,,,], ["@GVar 7", "=", 0], [0, "@edit_gvar", 7, 1], true], ["Discovered Tiles", ["@DiscTiles"], true, false, "TileArray", "Self", ["@GVar 7", "=", 1], [0, "@edit_gvar", 7, 0], true], ["Score", "@Score"], ["Discovered Factor Amounts", ["@GVar 5", "arr_length"], ...[,,,,], ["@GVar 6", "=", 0], [0, "@edit_gvar", 6, 1], true], ["Discovered Factor Amounts", ["@GVar 5", "arr_reduce", "", ["str_concat", "@Var -1", "str_concat", ", "], "str_slice", 0, ["@Parent -2", "str_length", "-", 2]], true, ...[,,,], ["@GVar 6", "=", 1], [0, "@edit_gvar", 6, 0], true]];
        scripts = [
            [["@var_retain", 0, "@if", ["@var_retain", "@GVar 5", "arr_binarySearch", ["@var_retain", "@Var -1", "arr_elem", 0, "arr_elem", 0, "factorAmountB"], "=", -1], "@edit_gvar", 5, ["@var_retain", "@GVar 5", "arr_binaryInsert", ["@var_retain", "@Var -1", "arr_elem", 0, "arr_elem", 0, "factorAmountB"]], "@end-if"], "Merge"]
        ]
        document.getElementById("mode_vars_line").style.setProperty("display", "block");
        document.getElementById("FACTUP_vars").style.setProperty("display", "flex");
    }
    else if (mode == 89) { // 2496
        // width = 4; height = 4;
        TileNumAmount = 2;
        mode_vars = [0, 12n]; // mode_vars[0] controls the random goals, mode_vars[1] is the tier of tile that the first random goal is
        start_game_vars = [[2n, 3n], 0, false, 12n, 0] // The first entry is the current random goal, the second entry is the amount of random goals met so far, the third entry is whether a random goal has been met this turn, and the fourth entry is the tier of tile that the first random goal is. The fifth entry controls the display of Discovered Tiles.
        if (modifiers[13] == "None") {
            TileTypes = [
                [true, ["@This 0", "*B", "@This 1"], ["@linear-gradient", ["@HSLA", ["@This 0", "log", 2, "*", 360], 50, 60, 1], 0, ["@HSLA", ["@This 0", "log", 2, "*", -29, "+", 150], 100, ["@This 0", "log", 2, "%", 8, "-", 4, "abs", "*", 10, "+", 30], 1], 25, 75, ["@HSLA", ["@This 0", "log", 2, "*", 360], 50, 60, 1], 100], "#000", "0px 0px 5px #fff", 2.5, 0, ["PrimeImage", ["@linear-gradient", ["@HSLA", ["@This 1", "log", 2, "*", 360], 50, 60, 1], 0, ["@HSLA", ["@This 1", "log", 2, "*", -29, "+", 150], 100, ["@This 1", "log", 2, "%", 8, "-", 4, "abs", "*", 10, "+", 30], 1], 25, 75, ["@HSLA", ["@This 1", "log", 2, "*", 360], 50, 60, 1], 100], ["@linear-gradient", 90, "#0000", 0, 30, "#000", 70, 100]], ["Innerscript", [["@This 0", "defaultAbbrevB"], "str_concat", "  ", "str_concat", ["@This 1", "defaultAbbrevB"]], "bottom-center", 6, 0]]
            ];
            MergeRules = [
                [2, ["@This 1", "=", "@Next 1 1"], true, [[["@This 0", "+B", "@Next 1 0", "min", "@This 1"], ["@This 0", "+B", "@Next 1 0", "max", "@This 1"]]], ["@This 0", "+", "@Next 1 0", "*", "@This 1"], [false, true]]
            ];
            startTileSpawns = [[[1n, 1n], 90], [[1n, 2n], 10]];
            winConditions = [[39n, 64n]];
            winRequirement = 1;
        }
        else {
            TileTypes = [
                [["@This 0", ">", 0n], ["@This 0", "*B", "@This 1"], ["@linear-gradient", ["@HSLA", ["@This 0", "log", 2, "*", 360], 50, 60, 1], 0, ["@HSLA", ["@This 0", "log", 2, "*", -29, "+", 150], 100, ["@This 0", "log", 2, "%", 8, "-", 4, "abs", "*", 10, "+", 30], 1], 25, 75, ["@HSLA", ["@This 0", "log", 2, "*", 360], 50, 60, 1], 100], "#000", "0px 0px 5px #fff", 2.5, 0, ["PrimeImage", ["@linear-gradient", ["@HSLA", ["@This 1", "log", 2, "*", 360], 50, 60, 1], 0, ["@HSLA", ["@This 1", "log", 2, "*", -29, "+", 150], 100, ["@This 1", "log", 2, "%", 8, "-", 4, "abs", "*", 10, "+", 30], 1], 25, 75, ["@HSLA", ["@This 1", "log", 2, "*", 360], 50, 60, 1], 100], ["@linear-gradient", 90, "#0000", 0, 30, "#000", 70, 100]], ["Innerscript", [["@This 0", "defaultAbbrevB"], "str_concat", "  ", "str_concat", ["@This 1", "defaultAbbrevB"]], "bottom-center", 6, 0]],
                [["@This 0", "<", 0n], ["@This 0", "*B", "@This 1"], ["@linear-gradient", ["@HSLA", ["@This 0", "abs", "log", 2, "*", 360, "+", 180], 50, 40, 1], 0, ["@HSLA", ["@This 0", "abs", "log", 2, "*", -29, "+", 330], 100, ["@This 0", "abs", "log", 2, "%", 8, "-", 4, "abs", "*", -10, "+", 70], 1], 25, 75, ["@HSLA", ["@This 0", "abs", "log", 2, "*", 360, "+", 180], 50, 40, 1], 100], "#fff", "0px 0px 5px #000", 2.5, 0, ["PrimeImage", ["@linear-gradient", ["@HSLA", ["@This 1", "log", 2, "*", 360], 50, 60, 1], 0, ["@HSLA", ["@This 1", "log", 2, "*", -29, "+", 150], 100, ["@This 1", "log", 2, "%", 8, "-", 4, "abs", "*", 10, "+", 30], 1], 25, 75, ["@HSLA", ["@This 1", "log", 2, "*", 360], 50, 60, 1], 100], ["@linear-gradient", 90, "#0000", 0, 30, "#000", 70, 100]], ["Innerscript", [["@This 0", "defaultAbbrevB"], "str_concat", "  ", "str_concat", ["@This 1", "defaultAbbrevB"]], "bottom-center", 6, 0]]
            ];
            if (modifiers[13] == "Non-Interacting") {
                MergeRules = [
                    [2, [[["@This 0", "signB"], "=", ["@Next 1 0", "signB"]], "&&", ["@This 1", "=", "@Next 1 1"]], true, [[["@This 0", "+B", "@Next 1 0", "absB", "min", "@This 1", "*B", ["@This 0", "+", "@Next 1 0", "signB"]], ["@This 0", "+B", "@Next 1 0", "absB", "max", "@This 1"]]], ["@This 0", "+", "@Next 1 0", "*", "@This 1", "abs"], [false, true]]
                ];
            }
            else {
                MergeRules = [
                    [2, [["@This 0", "*B", -1n, "=", "@Next 1 0"], "&&", ["@This 1", "=", "@Next 1 1"]], true, [], 0, [true, true]],
                    [2, [["@This 1", "=", "@Next 1 1"]], true, [[["@This 0", "+B", "@Next 1 0", "absB", "min", "@This 1", "*B", ["@This 0", "+", "@Next 1 0", "signB"]], ["@This 0", "+B", "@Next 1 0", "absB", "max", "@This 1"]]], ["@This 0", "+", "@Next 1 0", "*", "@This 1", "abs"], [false, true]]
                ];
            }
            startTileSpawns = [[[1n, 1n], 90 * modifiers[22]], [[1n, 2n], 10 * modifiers[22]], [[-1n, 1n], 90 * modifiers[23]], [[-1n, 2n], 10 * modifiers[23]]];
            winConditions = [[39n, 64n], [-39n, 64n]];
            winRequirement = 2;
        }
        knownMergeMaxLength = 2;
        knownMergeLookbackDistance = 0;
        document.documentElement.style.setProperty("background-image", "linear-gradient( #83cb66, #ef3c45 15%, #ff5498 85%, #cc6666)");
        document.documentElement.style.setProperty("--background-color", "linear-gradient(90deg,#afe798,#ff7c82 12%,#ff8dba 88%,#ffd9d9)");
        document.documentElement.style.setProperty("--grid-color", "#a70008");
        document.documentElement.style.setProperty("--tile-color", "#f95798");
        document.documentElement.style.setProperty("--text-color", "#3e1515");
        displayRules("rules_text", ["h1", "2496"], ["p", "Tiles are products of two integers, and two tiles can merge if the larger number of their products is the same: for example, a 2  6 tile and a 3  6 tile can merge into a 5  6 tile. Get to the 2496 (39  64) tile to win!"],
        ["p", "Spawning tiles: 1 (90%), 2 (10%)"]);
        displayRules("gm_rules_text", ["h1", "2496"], ["p", "Tiles are products of two integers, and two tiles can merge if the larger number of their products is the same: for example, a 2  6 tile and a 3  6 tile can merge into a 5  6 tile. Get to the 2496 (39  64) tile to win!"],
        ["p", "Spawning tiles: 1 (90%), 2 (10%)"]);
        statBoxes = [["Discovered Tiles", ["@DiscTiles", "arr_length"], false, ...[,,,], ["@GVar 4", "=", 0], [0, "@edit_gvar", 4, 1], true], ["Discovered Tiles", ["@DiscTiles"], true, false, "TileArray", "Self", ["@GVar 4", "=", 1], [0, "@edit_gvar", 4, 0], true], ["Score", "@Score"]];
        document.getElementById("mode_vars_line").style.setProperty("display", "block");
        document.getElementById("2496_vars").style.setProperty("display", "flex");
    }
    else if (mode == 90) { // Ratio-Fill 3375
        // width = 5; height = 5;
        TileNumAmount = 3;
        start_game_vars = [0]; // Used to help with merges
        TileTypes = [
        [["@This 2", "<", 15n], ["@This 2", "Number"], ["@HSLA", [43, "*", "@This 2", "-", 43], 65, ["@This 2", "*", -4, "+", 104], 1], "#464d52"],
        [true, ["@This 2", "Number"], ["@CalcArray", 0, "@if", ["@This 0", "<", 7], "2nd", [["@Literal", "#ffffff", "#71f1ff", "#e3ff71", "#ff855d", "#5f5fff", "#ffeb6c", "#ff7bff"], "arr_elem", "@This 0"], "@end-if", "@else", "2nd", ["@Literal", "@HSVA", [-97, "*", "@This 0", "+", 889], 60, [0.9, "^", ["@This 0", "-", 6], "*", 100], 1], "@end-else", "evaluateColor"], ["#665b57", "@if", ["@This 0", ">", 6], "2nd", "#f0dfd8", "@end-if"], "none", 2, 0, 
            ["PrimeImage", ["@linear-gradient", ["@HSLA", 0, 60, [15, "@if", ["@This 1", "arr_elem", 0], "2nd", 75, "@end-if"], 1], 0, "#0000", 25, 75, ["@HSLA", 0, 60, [15, "@if", ["@This 1", "arr_elem", 0], "2nd", 75, "@end-if"], 1], 100], ["@linear-gradient", 90, "#0000", 0, 0, "#000", 0, 100/7, "#0000", 100/7]],
            ["PrimeImage", ["@linear-gradient", ["@HSLA", 86, 60, [15, "@if", ["@This 1", "arr_elem", 1], "2nd", 75, "@end-if"], 1], 0, "#0000", 25, 75, ["@HSLA", 86, 60, [15, "@if", ["@This 1", "arr_elem", 1], "2nd", 75, "@end-if"], 1], 100], ["@linear-gradient", 90, "#0000", 0, 100/7, "#000", 100/7, 200/7, "#0000", 200/7]],
            ["PrimeImage", ["@linear-gradient", ["@HSLA", 172, 60, [15, "@if", ["@This 1", "arr_elem", 2], "2nd", 75, "@end-if"], 1], 0, "#0000", 25, 75, ["@HSLA", 172, 60, [15, "@if", ["@This 1", "arr_elem", 2], "2nd", 75, "@end-if"], 1], 100], ["@linear-gradient", 90, "#0000", 0, 200/7, "#000", 200/7, 300/7, "#0000", 300/7]],
            ["PrimeImage", ["@linear-gradient", ["@HSLA", 258, 60, [15, "@if", ["@This 1", "arr_elem", 3], "2nd", 75, "@end-if"], 1], 0, "#0000", 25, 75, ["@HSLA", 258, 60, [15, "@if", ["@This 1", "arr_elem", 3], "2nd", 75, "@end-if"], 1], 100], ["@linear-gradient", 90, "#0000", 0, 300/7, "#000", 300/7, 400/7, "#0000", 400/7]],
            ["PrimeImage", ["@linear-gradient", ["@HSLA", 344, 60, [15, "@if", ["@This 1", "arr_elem", 4], "2nd", 75, "@end-if"], 1], 0, "#0000", 25, 75, ["@HSLA", 344, 60, [15, "@if", ["@This 1", "arr_elem", 4], "2nd", 75, "@end-if"], 1], 100], ["@linear-gradient", 90, "#0000", 0, 400/7, "#000", 400/7, 500/7, "#0000", 500/7]],
            ["PrimeImage", ["@linear-gradient", ["@HSLA", 70, 60, [15, "@if", ["@This 1", "arr_elem", 5], "2nd", 75, "@end-if"], 1], 0, "#0000", 25, 75, ["@HSLA", 70, 60, [15, "@if", ["@This 1", "arr_elem", 5], "2nd", 75, "@end-if"], 1], 100], ["@linear-gradient", 90, "#0000", 0, 500/7, "#000", 500/7, 600/7, "#0000", 600/7]],
            ["PrimeImage", ["@linear-gradient", ["@HSLA", 156, 60, [15, "@if", ["@This 1", "arr_elem", 6], "2nd", 75, "@end-if"], 1], 0, "#0000", 25, 75, ["@HSLA", 156, 60, [15, "@if", ["@This 1", "arr_elem", 6], "2nd", 75, "@end-if"], 1], 100], ["@linear-gradient", 90, "#0000", 0, 600/7, "#000", 600/7, 100, "#0000", 100]],
        ]
        ];
        MergeRules = [
            [3, [["@This 2", "+B", "@Next 1 2", "+B", "@Next 2 2", "<", 15n], "&&", ["@This 2", "%B", "@Next 1 2", "=", 0n], "&&", ["@This 2", "%B", "@Next 2 2", "=", 0n]], false, [[0, "@This 1", ["@This 2", "+B", "@Next 1 2", "+B", "@Next 2 2"]]], ["@This 2", "+", "@Next 1 2", "+", "@Next 2 2"], [false, true, true]],
            [3, [["@This 2", "+B", "@Next 1 2", "+B", "@Next 2 2", "=", 15n], "&&", ["@This 2", "%B", "@Next 1 2", "=", 0n], "&&", ["@This 2", "%B", "@Next 2 2", "=", 0n]], false, [[1, ["@Literal", false, false, false, false, false, false, false], 15n]], 6, [false, true, true]],
            [3, [["@Next 2 1", "arr_reduce", 0, ["+", "@Var -1"], "=", 6], "&&", [["@This 2", "<=", "@Next 2 2"], "&&", ["@Next 1 2", "<=", "@Next 2 2"]], "&&", ["@This 2", "+B", "@Next 1 2", "%B", 2n, "=", 0n], "&&", ["@This 2", "+B", "@Next 1 2", "*B", ["@Next 2 1", "arr_indexOf", false, "*B", 2n, "+B", 1n], "/B", 2n, "=", "@Next 2 2"]], false, [[["@Next 2 0", "+", 1], [["@Literal"], "@repeat", 7, "arr_push", false, "@end-repeat"], ["@This 2", "+B", "@Next 1 2", "+B", "@Next 2 2"]]], ["@This 2", "+", "@Next 1 2", "+", "@Next 2 2"], [false, true, true]],
            [3, [false, "@edit_gvar", 0, ["@Next 2 2", "/BR", ["@This 2", "+B", "@Next 1 2"], "*BR", 2n], "@if", [["@This 2", "typeof", "!=", "bigint"], "||", ["@Next 1 2", "typeof", "!=", "bigint"], "||", ["@Next 2 2", "typeof", "!=", "bigint"], "||", ["@GVar 0", "modBR", 2n, "!=", new BigRational(1)]], "2nd", false, "@end-if", "@else", "@edit_gvar", 0, ["@GVar 0", "BigInt", "-B", 1n, "/B", 2n], "2nd", [["@GVar 0", ">", -1n], "&&", ["@GVar 0", "<", 7n], "&&", ["@Next 2 1", "arr_elem", "@GVar 0", "!"]], "@end-else"], false, [["@Next 2 0", ["@Next 2 1", "arr_edit_elem", "@GVar 0", true], ["@This 2", "+B", "@Next 1 2", "+B", "@Next 2 2"]]], ["@This 2", "+", "@Next 1 2", "+", "@Next 2 2"], [false, true, true]]
        ]
        startTileSpawns = [[[0, ["@Literal", true, true, true, true, true, true, true], 1n], 90], [[0, ["@Literal", true, true, true, true, true, true, true], 3n], 10]];
        winConditions = [[3, [false, false, false, false, false, false, false], 3375n]];
        winRequirement = 1;
        knownMergeMaxLength = 3;
        knownMergeLookbackDistance = 0;
        document.documentElement.style.setProperty("background-image", "linear-gradient(90deg, #0000 0%, #ff8258 20% 80%, #0000 100%), linear-gradient(#df9f9f 0% 14.28%, #c3df9f 14.28% 28.57%, #9fdfd7 28.57% 42.86%, #b39fdf 42.86% 57.14%, #df9fb0 57.14% 71.43%, #d4df9f 71.43% 85.71%, #9fdfc6 85.71% 100%)");
        document.documentElement.style.setProperty("--background-color", "linear-gradient(#0000 0%,#ff9f7f 20% 80%, #0000 100%), linear-gradient(90deg, #df9f9f, #c3df9f, #9fdfd7, #b39fdf, #df9fb0, #d4df9f, #9fdfc6)");
        document.documentElement.style.setProperty("--grid-color", "#dd5043");
        document.documentElement.style.setProperty("--tile-color", "#edbc8b");
        document.documentElement.style.setProperty("--text-color", "#8f381a");
        displayRules("rules_text", ["h1", "Ratio-Fill 3375"], ["p","Three tiles less than 15 can merge if one of them is a multiple of the other two and their sum is not greater than 15. To get from one power of 15 to the next, a tile must merge with two tiles not larger than itself that add up to double itself, two-thirds of itself, two-fifths of itself, two-sevenths of itself, two-ninths of itself, two-elevenths of itself, or two-thirteenths of itself, once each in any order. Get to the 3375 tile to win!"],
        ["p", "Spawning tiles: 1 (90%), 3 (10%)"]);
        displayRules("gm_rules_text", ["h1", "Ratio-Fill 3375"], ["p","Three tiles less than 15 can merge if one of them is a multiple of the other two and their sum is not greater than 15. To get from one power of 15 to the next, a tile must merge with two tiles not larger than itself that add up to double itself, two-thirds of itself, two-fifths of itself, two-sevenths of itself, two-ninths of itself, two-elevenths of itself, or two-thirteenths of itself, once each in any order. Get to the 3375 tile to win!"],
        ["p", "Spawning tiles: 1 (90%), 3 (10%)"]);
    }
    else if (mode == 91) { // 1845
        // width = 4; height = 4;
        TileNumAmount = 1;
        mode_vars = [0, 3n]; // mode_vars[0] controls the random goals, mode_vars[1] is the first random goal minimum
        start_game_vars = [3n, 0, false, 3n, 0] // The first entry is the current random goal, the second entry is the amount of random goals met so far, the third entry is whether a random goal has been met this turn, and the fourth entry is the first random goal minimum. The fifth entry controls the display of Discovered Tiles.
        TileTypes = [
            [true, ["@This 0"], "@ColorScheme", "1845", ["@This 0"]]
        ];
        MergeRules = [
            [2, [["@This 0", "=", "@Next 1 0"]], true, [[["@This 0", "+B", "@Next 1 0"]]], ["@This 0", "+", "@Next 1 0"], [false, true]],
            [2, [["@This 0", "-B", "@Next 1 0"], "/B", ["@This 0", "gcdB", "@Next 1 0", "max", 1n], "absB", "=", 1n], true, [[["@This 0", "+B", "@Next 1 0"]]], ["@This 0", "+", "@Next 1 0"], [false, true]]
        ];
        startTileSpawns = [[[1n], 1]];
        winConditions = [[1845n]];
        winRequirement = 1;
        knownMergeMaxLength = 2;
        knownMergeLookbackDistance = 0;
        document.documentElement.style.setProperty("background-image", "linear-gradient( #e1f2ff, #00ff00, #e1f2ff, #ff00aa, #ff00aa, #e1f2ff, #45adff, #45adff, #45adff, #e1f2ff, #ff00aa, #ff00aa, #e1f2ff, #00ff00, #e1f2ff)");
        document.documentElement.style.setProperty("--background-color", "linear-gradient(#0000, #00ff00aa,#0000, #ff00aaaa, #ff00aaaa,#0000, #45adff, #45adff, #45adff,#0000, #ff00aaaa, #ff00aaaa,#0000, #00ff00aa,#0000), linear-gradient(#b0ddff,#b0ddff)");
        document.documentElement.style.setProperty("--grid-color", "#89c5f4");
        document.documentElement.style.setProperty("--tile-color", "#e04daf");
        document.documentElement.style.setProperty("--text-color", "#0f361f");
        displayRules("rules_text", ["h1", "1845"], ["p", "Two equal tiles can merge. Two nonequal tiles can merge if, when you divide both of them by their greatest common divisor, the difference between the two is 1. Get to the 1845 tile to win (your first task is figuring out how to get there...), or just play and see what tiles you end up making!"],
        ["p", "Spawning tiles: 1 (100%)"]);
        displayRules("gm_rules_text", ["h1", "1845"], ["p", "Two equal tiles can merge. Two nonequal tiles can merge if, when you divide both of them by their greatest common divisor, the difference between the two is 1. Get to the 1845 tile to win (your first task is figuring out how to get there...), or just play and see what tiles you end up making!"],
        ["p", "Spawning tiles: 1 (100%)"]);
        statBoxes = [["Discovered Tiles", ["@DiscTiles", "arr_length"], false, ...[,,,], ["@GVar 4", "=", 0], [0, "@edit_gvar", 4, 1], true], ["Discovered Tiles", ["@DiscTiles"], true, false, "TileArray", "Self", ["@GVar 4", "=", 1], [0, "@edit_gvar", 4, 0], true], ["Score", "@Score"]];
        document.getElementById("mode_vars_line").style.setProperty("display", "block");
        document.getElementById("1845_vars").style.setProperty("display", "flex");
    }
    else if (mode == 92) { // SCAPRIM
        // width = 4; height = 4;
        TileNumAmount = 1;
        mode_vars = [0, 3n]; // mode_vars[0] controls the random goals, mode_vars[1] is the first random goal minimum
        start_game_vars = [3n, 0, false, 3n, 0, 0] // The first entry is the current random goal, the second entry is the amount of random goals met so far, the third entry is whether a random goal has been met this turn, and the fourth entry is the first random goal minimum. The fifth entry controls the display of Discovered Tiles, the sixth entry controls the display of Discovered Composite Tiles.
        TileTypes = [
            [true, ["@This 0"], "@ColorScheme", "SCAPRIM", ["@This 0"]]
        ];
        if (modifiers[13] == "None") {
            MergeRules = [
                [2, [["@This 0", "+B", "@Next 1 0"], "/B", ["@This 0", "gcdB", "@Next 1 0", "max", 1n], "primeFactorizeB", 2, "arr_length", "<", 2], true, [[["@This 0", "+B", "@Next 1 0"]]], ["@This 0", "+", "@Next 1 0"], [false, true]]
            ];
            startTileSpawns = [[[1n], 1]];
        }
        else {
            startTileSpawns = [[[1n], modifiers[22]], [[-1n], modifiers[23]]];
            if (modifiers[13] == "Non-Interacting") {
                MergeRules = [
                    [2, [[["@This 0", "signB"], "=", ["@Next 1 0", "signB"]], "&&", [["@This 0", "+B", "@Next 1 0"], "/B", ["@This 0", "gcdB", "@Next 1 0", "max", 1n], "primeFactorizeB", 2, "arr_length", "<", 2]], true, [[["@This 0", "+B", "@Next 1 0"]]], ["@This 0", "+", "@Next 1 0"], [false, true]]
                ];
            }
            else {
                MergeRules = [
                    [2, ["@This 0", "*B", -1n, "=", "@Next 1 0"], true, [], 0, [true, true]],
                    [2, [["@This 0", "+B", "@Next 1 0", "absB"], "/B", ["@This 0", "gcdB", "@Next 1 0", "absB", "max", 1n], "primeFactorizeB", 2, "arr_length", "<", 2], true, [[["@This 0", "+B", "@Next 1 0"]]], ["@This 0", "+", "@Next 1 0"], [false, true]]
                ];
            }
        }
        winRequirement = false;
        knownMergeMaxLength = 2;
        knownMergeLookbackDistance = 0;
        document.documentElement.style.setProperty("background-image", "linear-gradient(#0000, #0000, #f00, #0000, #0000, #0f0, #0000, #0000, #00f, #0000, #0000, #ff0, #0000, #0000), linear-gradient(90deg, #00723b,#16ff8e,#00723b)");
        document.documentElement.style.setProperty("--background-color", "linear-gradient(#0000, #0000, #f00a, #0000, #0000, #0f0a, #0000, #0000, #00fa, #0000, #0000, #ff0a, #0000, #0000), linear-gradient(90deg,#003e20,#00cb69,#003e20)");
        document.documentElement.style.setProperty("--grid-color", "#007e63");
        document.documentElement.style.setProperty("--tile-color", "#445500");
        document.documentElement.style.setProperty("--text-color", "#aeecce");
        displayRules("rules_text", ["h1", "SCAPRIM"], ["p", "Two tiles can merge if, when you divide their sum by their greatest common divisor, you get either 1 or a prime number. (Another way of thinking about it is \"two tiles can merge if they're equal or their sum is prime, and if a + b = c is a valid merge, so is na + nb = nc for any integer n\"). This mode has a lot of possible tiles, so it doesn't have a win condition - instead, try to discover as many tiles as you can. If you're looking for a different kind of challenge, see how many <i>composite</i> tiles you can make!"],
        ["p", "Spawning tiles: 1 (100%)"]);
        displayRules("gm_rules_text", ["h1", "SCAPRIM"], ["p", "Two tiles can merge if, when you divide their sum by their greatest common divisor, you get either 1 or a prime number. (Another way of thinking about it is \"two tiles can merge if they're equal or their sum is prime, and if a + b = c is a valid merge, so is na + nb = nc for any integer n\"). This mode has a lot of possible tiles, so it doesn't have a win condition - instead, try to discover as many tiles as you can. If you're looking for a different kind of challenge, see how many <i>composite</i> tiles you can make!"],
        ["p", "Spawning tiles: 1 (100%)"]);
        statBoxes = [["Discovered Tiles", ["@DiscTiles", "arr_length"], false, ...[,,,], ["@GVar 4", "=", 0], [0, "@edit_gvar", 4, 1], true], ["Discovered Tiles", ["@DiscTiles"], true, false, "TileArray", "Self", ["@GVar 4", "=", 1], [0, "@edit_gvar", 4, 0], true], ["Score", "@Score"], ["Discovered Composite Tiles", ["@DiscTiles", "arr_filter", ["@Var -1", "arr_elem", 0, "primeFactorizeB", 2, "arr_length", ">", 1], "arr_length"], false, ...[,,,], ["@GVar 5", "=", 0], [0, "@edit_gvar", 5, 1], true], ["Discovered Composite Tiles", ["@DiscTiles", "arr_filter", ["@Var -1", "arr_elem", 0, "primeFactorizeB", 2, "arr_length", ">", 1]], true, false, "TileArray", "Self", ["@GVar 5", "=", 1], [0, "@edit_gvar", 5, 0], true]];
        document.getElementById("mode_vars_line").style.setProperty("display", "block");
        document.getElementById("SCAPRIM_vars").style.setProperty("display", "flex");
    }
    else if (mode == 93) { // TRIGAT
        // width = 4; height = 4;
        TileNumAmount = 1;
        mode_vars = [0, 4374n]; // Random goals: first entry is the random goals setting, second entry is the first goal minimum
        start_game_vars = [3n, 0, false, [3n, 6n], 4374n, [1n, 2n], 0, 0] // The first entry is the current random goal, the second entry is the amount of random goals met so far, the third entry is whether a random goal has been met this turn, the fourth entry is an array of possible tiles found by the random goals so far, and the fifth entry is the first goal minimum. Sixth entry is list of triangular factors discovered, seventh entry controls this list's display. The eighth entry controls the display of Discovered Tiles.
        TileTypes = [
            [true, "@This 0", "@ColorScheme", "TRIGAT", ["@This 0"]]
        ];
        if (modifiers[13] == "None") {
            MergeRules = [
                [2, [["@This 0", ">=", "@Next 1 0"], "&&", ["@Next 1 0", "^B", 2, "%B", ["@This 0", "*B", 2n, "-B", "@Next 1 0", "@if", ["@Parent -2", "=", 0n], "2nd", ["@Next 1 0", "^B", 2n, "*B", 2n], "@end-if"], "=", 0n]], false, [[["@This 0", "+B", "@Next 1 0"]]], ["@This 0", "+", "@Next 1 0"], [false, true]]
            ];
            startTileSpawns = [[[3n], 100]];
        }
        else {
            startTileSpawns = [[[3n], modifiers[22]], [[-3n], modifiers[23]]];
            if (modifiers[13] == "Non-Interacting") {
                MergeRules = [
                    [2, [[["@This 0", ">", 0n], "=", ["@Next 1 0", ">", 0n]], "&&", [["@This 0", "absB"], ">=", ["@Next 1 0", "absB"]], "&&", ["@Next 1 0", "^B", 2, "%B", [["@This 0", "absB"], "*B", 2n, "-B", ["@Next 1 0", "absB"], "@if", ["@Parent -2", "=", 0n], "2nd", ["@Next 1 0", "^B", 2n, "*B", 2n], "@end-if"], "=", 0n]], false, [[["@This 0", "+B", "@Next 1 0"]]], ["@This 0", "+", "@Next 1 0", "abs"], [false, true]]
                ];
            }
            else {
                MergeRules = [
                    [2, ["@This 0", "*B", -1n, "=", "@Next 1 0"], false, [], 0, [true, true]],
                    [2, [[["@This 0", "absB"], ">=", ["@Next 1 0", "absB"]], "&&", ["@Next 1 0", "^B", 2, "%B", [["@This 0", "absB"], "*B", 2n, "-B", ["@Next 1 0", "absB"], "@if", ["@Parent -2", "=", 0n], "2nd", ["@Next 1 0", "^B", 2n, "*B", 2n], "@end-if"], "=", 0n]], false, [[["@This 0", "+B", "@Next 1 0"]]], ["@This 0", "+", "@Next 1 0", "abs"], [false, true]]
                ];
            }
        }
        winRequirement = false;
        knownMergeMaxLength = 2;
        knownMergeLookbackDistance = 0;
        document.documentElement.style.setProperty("background-image", "conic-gradient(from -36deg, #ffbe19 0deg 12deg, #990000 16.8deg 55.2deg, #ffbe19 60deg 84deg, #957100 88.8deg 127.2deg, #ffbe19 132deg 156deg, #6bab00 160.8deg 199.2deg, #ffbe19 204deg 228deg, #16d800 232.8deg 271.2deg, #ffbe19 276deg 300deg, #00c645 304.8deg 343.2deg, #ffbe19 348deg)");
        document.documentElement.style.setProperty("--background-color", "conic-gradient(from -36deg, #ffbe19, #990000, #ffbe19, #957100, #ffbe19, #6bab00, #ffbe19, #16d800, #ffbe19, #00c645, #ffbe19)");
        document.documentElement.style.setProperty("--grid-color", "#8cca18");
        document.documentElement.style.setProperty("--tile-color", "#f6ec5e");
        document.documentElement.style.setProperty("--text-color", "#484808");
        displayRules("rules_text", ["h1", "TRIGAT"], ["p", 'Two tiles can merge if they are equal or if the smaller tile is a multiple of (the ratio between the two tiles * 2 - 1): for example, 30 and 12 can merge because 12 is a multiple of (30/12 * 2 - 1 = 4). (Another way of thinking about it is "a smaller tile can merge with its triangular number, even if they\'re not integers, and if a + b = c is a valid merge, then so is na + nb = nc for an integer n". This rule is equivalent to the "ratio * 2 - 1" rule). This mode has a lot of possible tiles, so it doesn\'t have a win condition. If you want a goal to strive for, see how many triangular numbers you can make multiples of.'],
        ["p", "Spawning tiles: 3 (100%)"]);
        displayRules("gm_rules_text", ["h1", "TRIGAT"], ["p", 'Two tiles can merge if they are equal or if the smaller tile is a multiple of (the ratio between the two tiles * 2 - 1): for example, 30 and 12 can merge because 12 is a multiple of (30/12 * 2 - 1 = 4). (Another way of thinking about it is "a smaller tile can merge with its triangular number, even if they\'re not integers, and if a + b = c is a valid merge, then so is na + nb = nc for an integer n". This rule is equivalent to the "ratio * 2 - 1" rule). This mode has a lot of possible tiles, so it doesn\'t have a win condition. If you want a goal to strive for, see how many triangular numbers you can make multiples of.'],
        ["p", "Spawning tiles: 3 (100%)"]);
        statBoxes = [["Discovered Tiles", ["@DiscTiles", "arr_length"], false, ...[,,,], ["@GVar 7", "=", 0], [0, "@edit_gvar", 7, 1], true], ["Discovered Tiles", ["@DiscTiles"], true, false, "TileArray", "Self", ["@GVar 7", "=", 1], [0, "@edit_gvar", 7, 0], true], ["Score", "@Score"], ["Discovered Triangular Numbers", ["@GVar 5", "arr_length"], ...[,,,,], ["@GVar 6", "=", 0], [0, "@edit_gvar", 6, 1], true], ["Discovered Triangular Numbers", ["@GVar 5", "arr_reduce", "", ["str_concat", "@Var -1", "str_concat", ", "], "str_slice", 0, ["@Parent -2", "str_length", "-", 2]], true, ...[,,,], ["@GVar 6", "=", 1], [0, "@edit_gvar", 6, 0], true]];
        scripts = [
            [["@var_retain", 1n, ["@var_retain", "@Var -2", "arr_elem", 0, "arr_elem", 0], "@end_vars", ["@global_var_retain", 1, "@if", ["@DiscTiles", "arr_indexOf", ["@Var -1", "Array"], "=", -1], "@add_var", ["@Var -1", "factorListB"], "@repeat", ["@Parent -2", "<", ["@Var -1", "arr_length"]], "@edit_var", -3, ["@Var -1", "arr_elem", "@Parent -2"], "@if", [["@Var -3", "%B", 2n, "=", 1n], "&&", ["@Var -2", "%B", ["@Var -3", "^B", 2n, "-B", "@Var -3", "/B", 2n], "=", 0n], "&&", ["@GVar 5", "arr_binarySearch", ["@Var -3", "-B", 1n], "=", -1]], "@edit_gvar", 5, ["@GVar 5", "arr_binaryInsert", ["@Var -3", "-B", 1n]], "@end-if", "@if", [["@Var -3", "%B", 2n, "=", 1n], "&&", ["@Var -2", "%B", ["@Var -3", "^B", 2n, "+B", "@Var -3", "/B", 2n], "=", 0n], "&&", ["@GVar 5", "arr_binarySearch", "@Var -3", "=", -1]], "@edit_gvar", 5, ["@GVar 5", "arr_binaryInsert", "@Var -3"], "@end-if", "+", 1, "@end-repeat", "@end-if"]], "Merge"]
        ]
        document.getElementById("mode_vars_line").style.setProperty("display", "block");
        document.getElementById("TRIGAT_vars").style.setProperty("display", "flex");
    }
    else if (mode == 94) { // Ratio-Fill 9261
        TileNumAmount = 3;
        start_game_vars = [0]; // Used to help with merges
        TileTypes = [
        [true, ["@This 2", "Number"], ["@CalcArray", 0, "@if", ["@This 0", "<", 6], "2nd", [["@Literal", "#c6ffc6", "#ffff80", "#6bddff", "#ff72ff", "#ff6363", "#6767ff"], "arr_elem", "@This 0"], "@end-if", "@else", "2nd", ["@Literal", "@HSVA", [113, "*", "@This 0", "-", 648], 66, [0.9, "^", ["@This 0", "-", 5], "*", 100], 1], "@end-else", "evaluateColor"], ["#554051", "@if", ["@This 0", ">", 5], "2nd", "#f3e7f1", "@end-if"], "none", 2, 0, 
            ["PrimeImage", ["@linear-gradient", ["@HSLA", 0, 60, [15, "@if", ["@This 1", "arr_elem", 0], "2nd", 75, "@end-if"], 1], 0, "#0000", 25, 75, ["@HSLA", 0, 60, [15, "@if", ["@This 1", "arr_elem", 0], "2nd", 75, "@end-if"], 1], 100], ["@linear-gradient", 90, "#0000", 0, 0, "#000", 0, 20, "#0000", 20]],
            ["PrimeImage", ["@linear-gradient", ["@HSLA", 43, 60, [15, "@if", ["@This 1", "arr_elem", 1], "2nd", 75, "@end-if"], 1], 0, "#0000", 25, 75, ["@HSLA", 43, 60, [15, "@if", ["@This 1", "arr_elem", 1], "2nd", 75, "@end-if"], 1], 100], ["@linear-gradient", 90, "#0000", 0, 20, "#000", 20, 40, "#0000", 40]],
            ["PrimeImage", ["@linear-gradient", ["@HSLA", 86, 60, [15, "@if", ["@This 1", "arr_elem", 2], "2nd", 75, "@end-if"], 1], 0, "#0000", 25, 75, ["@HSLA", 86, 60, [15, "@if", ["@This 1", "arr_elem", 2], "2nd", 75, "@end-if"], 1], 100], ["@linear-gradient", 90, "#0000", 0, 40, "#000", 40, 60, "#0000", 60]],
            ["PrimeImage", ["@linear-gradient", ["@HSLA", 129, 60, [15, "@if", ["@This 1", "arr_elem", 3], "2nd", 75, "@end-if"], 1], 0, "#0000", 25, 75, ["@HSLA", 129, 60, [15, "@if", ["@This 1", "arr_elem", 3], "2nd", 75, "@end-if"], 1], 100], ["@linear-gradient", 90, "#0000", 0, 60, "#000", 60, 80, "#0000", 80]],
            ["PrimeImage", ["@linear-gradient", ["@HSLA", 172, 60, [15, "@if", ["@This 1", "arr_elem", 4], "2nd", 75, "@end-if"], 1], 0, "#0000", 25, 75, ["@HSLA", 172, 60, [15, "@if", ["@This 1", "arr_elem", 4], "2nd", 75, "@end-if"], 1], 100], ["@linear-gradient", 90, "#0000", 0, 80, "#000", 80, 100, "#0000", 100]]
        ]
        ];
        MergeRules = [
            [3, [["@Next 2 1", "arr_reduce", 0, ["+", "@Var -1"], "=", 4], "&&", [["@This 2", "<=", "@Next 2 2"], "&&", ["@Next 1 2", "<=", "@Next 2 2"]], "&&", [["@This 2", "+B", "@Next 1 2", "%B", 2n, "=", 0n], "||", ["@Next 2 1", "arr_indexOf", false, "%", 2, "=", 1]], "&&", ["@This 2", "+B", "@Next 1 2", "*B", ["@Next 2 1", "arr_indexOf", false, "+B", 1n], "/B", 2n, "=", "@Next 2 2"]], false, [[["@Next 2 0", "+", 1], [["@Literal"], "@repeat", 5, "arr_push", false, "@end-repeat"], ["@This 2", "+B", "@Next 1 2", "+B", "@Next 2 2"]]], ["@This 2", "+", "@Next 1 2", "+", "@Next 2 2"], [false, true, true]],
            [3, [false, "@edit_gvar", 0, ["@Next 2 2", "/BR", ["@This 2", "+B", "@Next 1 2"], "*BR", 2n], "@if", [["@This 2", "typeof", "!=", "bigint"], "||", ["@Next 1 2", "typeof", "!=", "bigint"], "||", ["@Next 2 2", "typeof", "!=", "bigint"], "||", ["@GVar 0", "modBR", 1n, "!=", new BigRational(0)]], "2nd", false, "@end-if", "@else", "@edit_gvar", 0, ["@GVar 0", "BigInt", "-B", 1n], "2nd", [["@GVar 0", ">", -1n], "&&", ["@GVar 0", "<", 5n], "&&", ["@Next 2 1", "arr_elem", "@GVar 0", "!"]], "@end-else"], false, [["@Next 2 0", ["@Next 2 1", "arr_edit_elem", "@GVar 0", true], ["@This 2", "+B", "@Next 1 2", "+B", "@Next 2 2"]]], ["@This 2", "+", "@Next 1 2", "+", "@Next 2 2"], [false, true, true]],
            [2, [["@Next 1 1", "arr_reduce", 0, ["+", "@Var -1"], "=", 4], "&&", ["@This 2", "<=", "@Next 1 2"], "&&", [["@This 2", "%B", 2n, "=", 0n], "||", ["@Next 1 1", "arr_indexOf", false, "%", 2, "=", 1]], "&&", ["@This 2", "*B", ["@Next 1 1", "arr_indexOf", false, "+B", 1n], "/B", 2n, "=", "@Next 1 2"], "&&", [[0, "mergeRuleApplies", -1, "!"], "&&", [1, "mergeRuleApplies", -1, "!"]]], false, [[["@Next 1 0", "+", 1], [["@Literal"], "@repeat", 5, "arr_push", false, "@end-repeat"], ["@This 2", "+B", "@Next 1 2"]]], ["@This 2", "+", "@Next 1 2"], [false, true]],
            [2, [[false, "@edit_gvar", 0, ["@Next 1 2", "/BR", "@This 2", "*BR", 2n], "@if", [["@This 2", "typeof", "!=", "bigint"], "||", ["@Next 1 2", "typeof", "!=", "bigint"], "||", ["@GVar 0", "modBR", 1n, "!=", new BigRational(0)]], "2nd", false, "@end-if", "@else", "@edit_gvar", 0, ["@GVar 0", "BigInt", "-B", 1n], "2nd", [["@GVar 0", ">", -1n], "&&", ["@GVar 0", "<", 5n], "&&", ["@Next 1 1", "arr_elem", "@GVar 0", "!"]], "@end-else"], "@add_var", "@GVar 0", "&&", [[0, "mergeRuleApplies", -1, "!"], "&&", [1, "mergeRuleApplies", -1, "!"]], "@edit_gvar", 0, "@Var 0"], false, [["@Next 1 0", ["@Next 1 1", "arr_edit_elem", "@GVar 0", true], ["@This 2", "+B", "@Next 1 2"]]], ["@This 2", "+", "@Next 1 2"], [false, true]]
        ]
        startTileSpawns = [[[0, ["@Literal", false, false, false, false, false], 1n], 100]];
        winConditions = [[3, [false, false, false, false, false], 9261n]];
        winRequirement = 1;
        knownMergeMaxLength = 3;
        knownMergeLookbackDistance = 1;
        document.documentElement.style.setProperty("background-image", "linear-gradient(90deg, #0000 0%, #ff8cf5 20% 80%, #0000 100%), linear-gradient( #e69999 0% 20%, #e6d099 20% 40%, #c4e699 40% 60%, #99e6a4 60% 80%, #99e6db 80% 100%)");
        document.documentElement.style.setProperty("--background-color", "linear-gradient(#0000 0%, #ff8cf5 20% 80%, #0000 100%), linear-gradient(90deg, #e69999, #e6d099, #c4e699, #99e6a4, #99e6db)");
        document.documentElement.style.setProperty("--grid-color", "#db6cf5");
        document.documentElement.style.setProperty("--tile-color", "#ffbbe0");
        document.documentElement.style.setProperty("--text-color", "#791371");
        displayRules("rules_text", ["h1", "Ratio-Fill 9261"], ["p","To get from one power of 21 to the next, a tile must merge with one or two tiles not larger than itself that add up to double itself, equal to itself, two-thirds of itself, two-fourths of itself, or two-fifths of itself, once each in any order. Get to the 9261 tile to win!"],
        ["p", "Spawning tiles: 1 (100%)"]);
        displayRules("gm_rules_text", ["h1", "Ratio-Fill 9261"], ["p","To get from one power of 21 to the next, a tile must merge with one or two tiles not larger than itself that add up to double itself, equal to itself, two-thirds of itself, two-fourths of itself, or two-fifths of itself, once each in any order. Get to the 9261 tile to win!"],
        ["p", "Spawning tiles: 1 (100%)"]);
    }
    else if (mode == 95) { // 3385
        // width = 4; height = 4;
        TileNumAmount = 1;
        start_game_vars = [0]; // Controls the display of Discovered Tiles
        TileTypes = [
            [true, ["@This 0"], "@ColorScheme", "3385", ["@This 0"]]
        ];
        MergeRules = [
            [2, [["@This 0", "/BR", "@Next 1 0", "perfectPowerFormBR", 2n, "arr_elem", 1, "!=", 1n]], true, [[["@This 0", "+B", "@Next 1 0"]]], ["@This 0", "+", "@Next 1 0"], [false, true]]
        ];
        startTileSpawns = [[[1n], 1]];
        winConditions = [[3385n]];
        winRequirement = 1;
        knownMergeMaxLength = 2;
        knownMergeLookbackDistance = 0;
        document.documentElement.style.setProperty("background-image", "linear-gradient(90deg, #0000ff, #0000, #0000, #0000ff), linear-gradient( #a090e0, #0e0047)");
        document.documentElement.style.setProperty("--background-color", "linear-gradient(#4f4fff,#baaafb, #19007d, #baaafb, #4f4fff)");
        document.documentElement.style.setProperty("--grid-color", "#4d32ba");
        document.documentElement.style.setProperty("--tile-color", "#231460");
        document.documentElement.style.setProperty("--text-color", "#000035");
        displayRules("rules_text", ["h1", "3385"], ["p", "Two tiles can merge if their ratio is the square of some rational number. Get to the 3385 tile to win, or see what other tiles you can make!"],
        ["p", "Spawning tiles: 1 (100%)"]);
        displayRules("gm_rules_text", ["h1", "3385"], ["p", "Two tiles can merge if their ratio is the square of some rational number. Get to the 3385 tile to win, or see what other tiles you can make!"],
        ["p", "Spawning tiles: 1 (100%)"]);
        statBoxes = [["Discovered Tiles", ["@DiscTiles", "arr_length"], false, ...[,,,], ["@GVar 0", "=", 0], [0, "@edit_gvar", 0, 1], true], ["Discovered Tiles", ["@DiscTiles"], true, false, "TileArray", "Self", ["@GVar 0", "=", 1], [0, "@edit_gvar", 0, 0], true], ["Score", "@Score"]];
    }
    else if (mode == 96) { // LOCEF
        // width = 5; height = 5;
        TileNumAmount = 1;
        mode_vars = [false, 0, 1701n]; // First entry enables Extended mode. Next two entries are random goals: second entry is the random goals setting, third entry is the first goal minimum
        start_game_vars = [1n, 0, false, [1n, 2n], 1701n, 0] // The first entry is the current random goal, the second entry is the amount of random goals met so far, the third entry is whether a random goal has been met this turn, the fourth entry is an array of possible tiles found by the random goals so far, and the fifth entry is the first goal minimum. Sixth entry controls the display of Discovered Tiles.
        TileTypes = [
            [true, ["@This 0"], "@ColorScheme", "LOCEF", ["@This 0"]]
        ];
        // Some things are handled by gmDisplayVars
        if (modifiers[13] == "None") {
            startTileSpawns = [[[1n], 1]];
        }
        else {
            startTileSpawns = [[[1n], modifiers[22]], [[-1n], modifiers[23]]];
        }
        winRequirement = false;
        knownMergeMaxLength = 3;
        knownMergeLookbackDistance = 0;
        document.documentElement.style.setProperty("--tile-color", "#b7a8e2");
        document.documentElement.style.setProperty("--text-color", "#1f1031");
        statBoxes = [["Discovered Tiles", ["@DiscTiles", "arr_length"], false, ...[,,,], ["@GVar 5", "=", 0], [0, "@edit_gvar", 5, 1], true], ["Discovered Tiles", ["@DiscTiles"], true, false, "TileArray", "Self", ["@GVar 5", "=", 1], [0, "@edit_gvar", 5, 0], true], ["Score", "@Score"]];
        document.getElementById("mode_vars_line").style.setProperty("display", "block");
        document.getElementById("LOCEF_vars").style.setProperty("display", "flex");
    }
    else if (mode == 97) { // Pro-Add-Uct
        // width = 5; height = 5;
        start_game_vars = [0]; // Controls the display of Discovered Tiles
        if (modifiers[13] == "None") {
            TileNumAmount = 2;
            TileTypes = [
                [true, [["@This 0", "defaultAbbrev"], "str_concat", "  ", "str_concat", ["@This 1", "defaultAbbrev"]], "#000", "#000000", "none", 2.5, 0, ["PrimeImage", ["@ColorScheme", "1321", [["@This 0", "max", 1n], "*B", ["@This 1", "max", 1n], "*B", 2n], 1]], ["PrimeImage", ["@ColorScheme", "1321", ["@This 0", "*B", 2n], 1], ["@conic-gradient", -90, "#0000", 0, 15, "#000", 60, 120, "#0000", 165]], ["PrimeImage", ["@ColorScheme", "1321", ["@This 1", "*B", 2n], 1], ["@conic-gradient", 90, "#0000", 0, 15, "#000", 60, 120, "#0000", 165]], ["Innerscript", [["@This 0", "max", 1n], "*B", ["@This 1", "max", 1n], "defaultAbbrevB"], "bottom-center", 6, 0]]
            ];
            MergeRules = [
                [2, [[["@This 0", "max", 1n], "*B", ["@This 1", "max", 1n]], "=", [["@Next 1 0", "max", 1n], "*B", ["@Next 1 1", "max", 1n]]], true, [[["@This 0", "+B", "@Next 1 0"], ["@This 1", "+B", "@Next 1 1"]]], [["@This 0", "*", "@This 1", "abs"], "+", ["@Next 1 0", "*", "@Next 1 1", "abs"], "/", ["@This 0", "gcdB", "@Next 1 0", "abs"], "/", ["@This 1", "gcdB", "@Next 1 1", "abs"]], [false, true]]
            ];
            startTileSpawns = [[[1n, 0n], 1], [[0n, 1n], 1], [[1n, 1n], 1]];
            displayRules("rules_text", ["h1", "Pro-Add-Uct"], ["p", "Tiles include two integers. Two tiles can merge if the product of one tile's two integers and the product of the other tile's two integers are equal. For the purposes of this comparison only, 0 is treated as 1. When tiles merge, their left two numbers are added and their right two numbers are added. The score gained from a merge is \"the sum of the product of the first tile's two integers and the product of the second tile's two integers, divided by the GCD of the tiles' left integers, divided by the GCD of the tiles' right integers\"; in short, this gives bigger points for merges where the tiles' products are big and the numbers being added have less factors in common. This mode has a lot of possible tiles, so it doesn't have a win condition."],
            ["p", "Spawning tiles: 0  1 (33.33%), 1  0 (33.33%), 1  1 (33.33%)"]);
            displayRules("gm_rules_text", ["h1", "Pro-Add-Uct"], ["p", "Tiles include two integers. Two tiles can merge if the product of one tile's two integers and the product of the other tile's two integers are equal. For the purposes of this comparison only, 0 is treated as 1. When tiles merge, their left two numbers are added and their right two numbers are added. The score gained from a merge is \"the sum of the product of the first tile's two integers and the product of the second tile's two integers, divided by the GCD of the tiles' left integers, divided by the GCD of the tiles' right integers\"; in short, this gives bigger points for merges where the tiles' products are big and the numbers being added have less factors in common. This mode has a lot of possible tiles, so it doesn't have a win condition."],
            ["p", "Spawning tiles: 0  1 (33.33%), 1  0 (33.33%), 1  1 (33.33%)"]);
        }
        else if (modifiers[13] == "Non-Interacting") {
            TileNumAmount = 3;
            TileTypes = [
                [["@This 2", "=", 1n], [["@This 0", "defaultAbbrev"], "str_concat", "  ", "str_concat", ["@This 1", "defaultAbbrev"]], "#000", "#000000", "none", 2.5, 0, ["PrimeImage", ["@ColorScheme", "1321", [["@This 0", "max", 1n], "*B", ["@This 1", "max", 1n], "*B", 2n], 1]], ["PrimeImage", ["@ColorScheme", "1321", ["@This 0", "*B", 2n], 1], ["@conic-gradient", -90, "#0000", 0, 15, "#000", 60, 120, "#0000", 165]], ["PrimeImage", ["@ColorScheme", "1321", ["@This 1", "*B", 2n], 1], ["@conic-gradient", 90, "#0000", 0, 15, "#000", 60, 120, "#0000", 165]], ["Innerscript", [["@This 0", "max", 1n], "*B", ["@This 1", "max", 1n], "defaultAbbrevB"], "bottom-center", 6, 0]],
                [["@This 2", "=", -1n], ["-", "str_concat", ["@This 0", "defaultAbbrev"], "str_concat", "  ", "str_concat", ["@This 1", "defaultAbbrev"]], "#000", "#ffffff", "none", 2.5, 0, ["PrimeImage", ["@ColorScheme", "1321", [["@This 0", "max", 1n], "*B", ["@This 1", "max", 1n], "*B", -2n], 1]], ["PrimeImage", ["@ColorScheme", "1321", ["@This 0", "*B", -2n], 1], ["@conic-gradient", -90, "#0000", 0, 15, "#000", 60, 120, "#0000", 165]], ["PrimeImage", ["@ColorScheme", "1321", ["@This 1", "*B", -2n], 1], ["@conic-gradient", 90, "#0000", 0, 15, "#000", 60, 120, "#0000", 165]], ["Innerscript", [["@This 0", "max", 1n], "*B", ["@This 1", "max", 1n], "*B", -1n, "defaultAbbrevB"], "bottom-center", 6, 0]]
            ];
            MergeRules = [
                [2, [[["@This 0", "max", 1n], "*B", ["@This 1", "max", 1n]], "=", [["@Next 1 0", "max", 1n], "*B", ["@Next 1 1", "max", 1n]], "&&", ["@This 2", "=", "@Next 1 2"]], true, [[["@This 0", "+B", "@Next 1 0"], ["@This 1", "+B", "@Next 1 1"], "@This 2"]], [["@This 0", "*", "@This 1", "abs"], "+", ["@Next 1 0", "*", "@Next 1 1", "abs"], "/", ["@This 0", "gcdB", "@Next 1 0", "abs"], "/", ["@This 1", "gcdB", "@Next 1 1", "abs"]], [false, true]]
            ];
            startTileSpawns = [[[1n, 0n, 1n], modifiers[22]], [[0n, 1n, 1n], modifiers[22]], [[1n, 1n, 1n], modifiers[22]], [[1n, 0n, -1n], modifiers[23]], [[0n, 1n, -1n], modifiers[23]], [[1n, 1n, -1n], modifiers[23]]];
            displayRules("rules_text", ["h1", "Pro-Add-Uct"], ["p", "Tiles include two integers. Two tiles can merge if the product of one tile's two integers and the product of the other tile's two integers are equal. For the purposes of this comparison only, 0 is treated as 1. When tiles merge, their left two numbers are added and their right two numbers are added. The score gained from a merge is \"the sum of the product of the first tile's two integers and the product of the second tile's two integers, divided by the GCD of the tiles' left integers, divided by the GCD of the tiles' right integers\"; in short, this gives bigger points for merges where the tiles' products are big and the numbers being added have less factors in common. This mode has a lot of possible tiles, so it doesn't have a win condition."],
            ["p", "Spawning tiles: 0  1 (16.66%), 1  0 (16.66%), 1  1 (16.66%), -0  1 (16.66%), -1  0 (16.66%), -1  1 (16.66%)"]);
            displayRules("gm_rules_text", ["h1", "Pro-Add-Uct"], ["p", "Tiles include two integers. Two tiles can merge if the product of one tile's two integers and the product of the other tile's two integers are equal. For the purposes of this comparison only, 0 is treated as 1. When tiles merge, their left two numbers are added and their right two numbers are added. The score gained from a merge is \"the sum of the product of the first tile's two integers and the product of the second tile's two integers, divided by the GCD of the tiles' left integers, divided by the GCD of the tiles' right integers\"; in short, this gives bigger points for merges where the tiles' products are big and the numbers being added have less factors in common. This mode has a lot of possible tiles, so it doesn't have a win condition."],
            ["p", "Spawning tiles: 0  1 (16.66%), 1  0 (16.66%), 1  1 (16.66%), -0  1 (16.66%), -1  0 (16.66%), -1  1 (16.66%)"]);
        }
        else {
            TileNumAmount = 2;
            TileTypes = [
                [true, [["@This 0", "defaultAbbrev"], "str_concat", "  ", "str_concat", ["@This 1", "defaultAbbrev"]], "#000", 
                ["@CalcArray", "#000000", "@if", [["@This 0", ">", 0n], "&&", ["@This 1", ">", 0n]], "2nd", "#ff0000", "@end-if", "@if", [["@This 0", "<", 0n], "&&", ["@This 1", ">", 0n]], "2nd", "#ff8000", "@end-if", "@if", [["@This 0", "<", 0n], "&&", ["@This 1", "<", 0n]], "2nd", "#00ffff", "@end-if", "@if", [["@This 0", ">", 0n], "&&", ["@This 1", "<", 0n]], "2nd", "#8000ff", "@end-if", "@if", [["@This 0", ">", 0n], "&&", ["@This 1", "=", 0n]], "2nd", "#ff00bf", "@end-if", "@if", [["@This 0", "=", 0n], "&&", ["@This 1", ">", 0n]], "2nd", "#ffbf00", "@end-if", "@if", [["@This 0", "<", 0n], "&&", ["@This 1", "=", 0n]], "2nd", "#00ff40", "@end-if", "@if", [["@This 0", "=", 0n], "&&", ["@This 1", "<", 0n]], "2nd", "#0040ff", "@end-if"],
                "0px 0px 5px #000000", 2.5, 0, ["PrimeImage", ["@ColorScheme", "1321", [["@This 0", "absB", "max", 1n], "*B", ["@This 1", "absB", "max", 1n], "*B", 2n], 1]], ["PrimeImage", ["@ColorScheme", "1321", ["@This 0", "*B", 2n], 1], ["@conic-gradient", -90, "#0000", 0, 15, "#000", 60, 120, "#0000", 165]], ["PrimeImage", ["@ColorScheme", "1321", ["@This 1", "*B", 2n], 1], ["@conic-gradient", 90, "#0000", 0, 15, "#000", 60, 120, "#0000", 165]], ["Innerscript", [["@This 0", "absB", "max", 1n], "*B", ["@This 1", "absB", "max", 1n], "defaultAbbrevB"], "bottom-center", 6, 0]]
            ];
            MergeRules = [
                [2, [["@This 0", "*B", -1n, "=", "@Next 1 0"], "&&", ["@This 1", "*B", -1n, "=", "@Next 1 1"]], true, [], 0, [true, true]],
                [2, [[["@This 0", "absB", "max", 1n], "*B", ["@This 1", "absB", "max", 1n]], "=", [["@Next 1 0", "absB", "max", 1n], "*B", ["@Next 1 1", "absB", "max", 1n]]], true, [[["@This 0", "+B", "@Next 1 0"], ["@This 1", "+B", "@Next 1 1"]]], [["@This 0", "*", "@This 1", "abs"], "+", ["@Next 1 0", "*", "@Next 1 1", "abs"], "/", ["@This 0", "gcdB", "@Next 1 0", "abs"], "/", ["@This 1", "gcdB", "@Next 1 1", "abs"]], [false, true]]
            ];
            startTileSpawns = [[[1n, 0n], modifiers[22] * modifiers[22]], [[0n, 1n], modifiers[22] * modifiers[22]], [[1n, 1n], modifiers[22] * modifiers[22]], [[-1n, 0n], modifiers[22] * modifiers[23]], [[0n, -1n], modifiers[22] * modifiers[23]], [[1n, -1n], modifiers[22] * modifiers[23]], [[-1n, 1n], modifiers[22] * modifiers[23]], [[-1n, -1n], modifiers[23] * modifiers[23]]];
            displayRules("rules_text", ["h1", "Pro-Add-Uct"], ["p", "Tiles include two integers. Two tiles can merge if the product of one tile's two integers and the product of the other tile's two integers are equal. For the purposes of this comparison only, 0 is treated as 1. When tiles merge, their left two numbers are added and their right two numbers are added. The score gained from a merge is \"the sum of the product of the first tile's two integers and the product of the second tile's two integers, divided by the GCD of the tiles' left integers, divided by the GCD of the tiles' right integers\"; in short, this gives bigger points for merges where the tiles' products are big and the numbers being added have less factors in common. This mode has a lot of possible tiles, so it doesn't have a win condition."],
            ["p", "Spawning tiles: 1  0 (12.5%), 0  1 (12.5%), 1  1 (12.5%), -1  0 (12.5%), 0  -1 (12.5%), -1  -1 (12.5%), 1  -1 (12.5%), -1  1 (12.5%)"]);
            displayRules("gm_rules_text", ["h1", "Pro-Add-Uct"], ["p", "Tiles include two integers. Two tiles can merge if the product of one tile's two integers and the product of the other tile's two integers are equal. For the purposes of this comparison only, 0 is treated as 1. When tiles merge, their left two numbers are added and their right two numbers are added. The score gained from a merge is \"the sum of the product of the first tile's two integers and the product of the second tile's two integers, divided by the GCD of the tiles' left integers, divided by the GCD of the tiles' right integers\"; in short, this gives bigger points for merges where the tiles' products are big and the numbers being added have less factors in common. This mode has a lot of possible tiles, so it doesn't have a win condition."],
            ["p", "Spawning tiles: 1  0 (12.5%), 0  1 (12.5%), 1  1 (12.5%), -1  0 (12.5%), 0  -1 (12.5%), -1  -1 (12.5%), 1  -1 (12.5%), -1  1 (12.5%)"]);
        }
        winRequirement = false;
        knownMergeMaxLength = 2;
        knownMergeLookbackDistance = 0;
        document.documentElement.style.setProperty("background-image", "conic-gradient(from -90deg, #9a65b3, #90e6aa, #9a65b3, #e7b9c0, #9a65b3)");
        document.documentElement.style.setProperty("--background-color", "conic-gradient( #9a65b3, #90e6aa, #9a65b3, #e7b9c0, #9a65b3)");
        document.documentElement.style.setProperty("--grid-color", "#72bd89");
        document.documentElement.style.setProperty("--tile-color", "#e27989");
        document.documentElement.style.setProperty("--text-color", "#2d1f33");
        statBoxes = [["Discovered Tiles", ["@DiscTiles", "arr_length"], false, ...[,,,], ["@GVar 0", "=", 0], [0, "@edit_gvar", 0, 1], true], ["Discovered Tiles", ["@DiscTiles"], true, false, "TileArray", "Self", ["@GVar 0", "=", 1], [0, "@edit_gvar", 0, 0], true], ["Score", "@Score"]];
    }
    else if (mode == 98) { // Partial Absorb 377
        // width = 6; height = 6;
        TileNumAmount = 1;
        TileTypes = [[[0], 1, "#ffffff", "#2d2b31"], [[1], 2, "#b3ffe8", "#2d2b31"], [[2], 3, "#52ffcb", "#2d2b31"], [[3], 5, "#00ff99", "#2d2b31"],
        [[4], 8, "#00c777", "#2d2b31"], [[5], 13, "#008b53", "#2d2b31"], [[6], 21, "#008b00", "#2d2b31"], [[7], 34, "#00e200", "#2d2b31"],
        [[8], 55, "#4aff4a", "#2d2b31"], [[9], 89, "#94ff94", "#2d2b31"], [[10], 144, "#8ac4ff", "#dddbe1"], [[11], 233, "#50a8ff", "#dddbe1"],
        [[12], 377, "#0180ff", "#dddbe1"], [[13], 610, "#0055a9", "#dddbe1"], [[14], 987, "#0030a9", "#dddbe1"], [[15], 1597, "#2d0087", "#dddbe1"],
        [[16], 2584, "#1a004f", "#dddbe1"], [[17], 4181, "#3d004f", "#dddbe1"], [[18], 6765, "#750099", "#dddbe1"], [[19], 10946, "#c300ff", "#dddbe1"],
        [[20], 17711, "#d85aff", "#dddbe1"], [[21], 28657, "#e591ff", "#dddbe1"],
        [true, [[((1 + Math.sqrt(5))/2), "^", ["@This 0", "+", 2]], "-", [((1 + Math.sqrt(5))/-2), "^", ["@This 0", "*", -1, "-", 2]], "/", Math.sqrt(5), "round", 1], ["@HSLA", [6.5, "*", "@This 0", "+", 157], [0.99, "^", ["@This 0", "-", 22], "*", 100], ["@This 0", "-", 21, "%", 9, "*", -1, "+", 4, "abs", "*", 10, "+", 30], 1], "#dddbe1"]];
        MergeRules = [
            [3, [["@Next 1 0", "=", 0], "&&", ["@This 0", "=", 0], "&&", ["@Next 2 0", "=", 0]], true, [[2]], 3, [false, true, true]],
            [3, [["@Next 1 0", "=", "@This 0"], "&&", ["@Next 2 0", "=", "@This 0"]], true, [[["@This 0", "+", 2]], [["@This 0", "-", 2]]], [[((1 + Math.sqrt(5))/2), "^", ["@This 0", "+", 2]], "-", [((1 + Math.sqrt(5))/-2), "^", ["@This 0", "*", -1, "-", 2]], "/", Math.sqrt(5), "round", 1, "*", 3], [false, false, true]]
        ];
        startTileSpawns = [[[0], 95], [[2], 5]];
        winConditions = [[12]];
        winRequirement = 1;
        knownMergeMaxLength = 3;
        knownMergeLookbackDistance = 0;
        document.documentElement.style.setProperty("background-image", "radial-gradient(#4930da 0%, #000 150%)");
        document.documentElement.style.setProperty("--background-color", "linear-gradient(#cdcaec,#4e4b6b)");
        document.documentElement.style.setProperty("--grid-color", "#645f71");
        document.documentElement.style.setProperty("--tile-color", "#9f94b4");
        document.documentElement.style.setProperty("--text-color", "#2d2b31");
        displayRules("rules_text", ["h1", "Partial Absorb 377"], ["p", "Merges occur between three equal tiles. Three 1s will merge into a single 3, but three larger tiles will merge into one of the next tile and one of the previous tile. Get to the 377 tile to win!"],
        ["p", "Spawning tiles: 1 (95%), 3 (5%)"]);
        displayRules("gm_rules_text", ["h1", "Partial Absorb 377"], ["p", "Merges occur between three equal tiles. Three 1s will merge into a single 3, but three larger tiles will merge into one of the next tile and one of the previous tile. Get to the 377 tile to win!"],
        ["p", "Spawning tiles: 1 (95%), 3 (5%)"]);
    }
    else if (mode == 99) { // Four-Sides 625
        // width = 5; height = 5;
        // This one's rules depend on the directions, so they're loaded in in gmDisplayVars and loadModifiers.
        document.documentElement.style.setProperty("background-image", "linear-gradient(90deg, #000a, #0000 25% 75%, #000a), linear-gradient(#fffa, #0000 25% 75%, #fffa), linear-gradient(#c7e471, #c7e471)");
        document.documentElement.style.setProperty("--background-color", "linear-gradient(#000a, #0000 25% 75%, #000a), linear-gradient(90deg, #fffa, #0000 25% 75%, #fffa), linear-gradient(#add23c,#add23c)");
        document.documentElement.style.setProperty("--grid-color", "#34391f");
        document.documentElement.style.setProperty("--tile-color", "#d9e0b6");
        document.documentElement.style.setProperty("--text-color", "#f3f7e1");
    }
    else if (mode == 100) { // Alternate 5040
        TileNumAmount = 2;
        // width = 4; height = 4;
        mode_vars = [0, true]; // mode_vars[0] is which variant is chosen: 0 is the 1762 variant, 1 is the 2047 variant, 2 is the 1668 variant, 3 is the Partial Absorb variant
        // Most of this depends on what variant you've chosen, so gmDisplayVars handles this mode for the most part
        document.documentElement.style.setProperty("--grid-color", "#f3ed83");
        document.documentElement.style.setProperty("--tile-color", "#c4bd36");
        document.documentElement.style.setProperty("--text-color", "#fffdd2");
        document.getElementById("mode_vars_line").style.setProperty("display", "block");
        document.getElementById("Alternate5040_vars").style.setProperty("display", "flex");
    }
    
    else if (mode == 50.1) { // Gaussian DIVE
        // width = 4; height = 4;
        TileNumAmount = 1;
        mode_vars = [0, true, true, [1, 0, 0, 0], 0]; // The first entry controls the starting seeds (1+i, 1+i and 1-i, all four associates of 1+i, 1 and i, all four associates of 1, 1), the second entry is whether seeds can be eliminated, the third entry is whether seeds are rotated into the first quadrant, the fourth entry is the four quadrant spawn ratios, the fifth entry controls how the seeds are checked.
        start_game_vars = [[new GaussianBigInt(1n, 1n)], [new GaussianBigInt(1n, 1n)], [], [], 0, false] // The first entry is the current seeds, the second entry is all seeds discovered, the third entry is the seeds that are currently being added, the fourth entry is the seeds that are currently being removed. The fifth entry controls the display of "All Seeds Seen". The sixth entry is used when tile text is hidden to replace the announcement numbers with question marks.
        TileTypes = [
            [true, "@This 0", "@ColorScheme", "Gaussian DIVE", ["@This 0"]]
        ];
        MergeRules = [
            [2, ["@This 0", "*GB", -1n, "=", "@Next 1 0"], true, [], 0],
            [2, [["@Next 1 0", "modGB", ["@This 0", "@if", ["@This 0", "GaussianBigInt", "=", new GaussianBigInt(0n, 0n)], "2nd", new GaussianBigInt(1n, 0n), "@end-if"], "=", new GaussianBigInt(0n, 0n)], "&&", ["@This 0", "typeof", "=", "gaussianbigint"], "&&", ["@Next 1 0", "typeof", "=", "gaussianbigint"]], false, [[["@This 0", "+GB", "@Next 1 0"]]], [["@This 0", "normGB", "^", 1/2], "min", ["@Next 1 0", "normGB", "^", 1/2]], [false, true]]
        ];
        startTileSpawns = [[[["@GVar 0", "arr_elem", [0, "rand_bigint", ["@GVar 0", "arr_length", "-", 1]]]], 1]];
        winRequirement = false;
        knownMergeMaxLength = 2;
        knownMergeLookbackDistance = 0;
        document.documentElement.style.setProperty("background-image", "conic-gradient(at 50% -10%, #0000 0% 35%, #0008 40% 45%, #fff8 47.5% 52.5%, #0008 55% 60%, #0000 65%), conic-gradient(from 180deg at 50% 110%, #0000 0% 35%, #0008 40% 45%, #fff8 47.5% 52.5%, #0008 55% 60%, #0000 65%), conic-gradient(from 90deg at 110% 50%, #0000 0% 35%, #0008 40% 45%, #fff8 47.5% 52.5%, #0008 55% 60%, #0000 65%), conic-gradient(from 270deg at -10% 50%, #0000 0% 35%, #0008 40% 45%, #fff8 47.5% 52.5%, #0008 55% 60%, #0000 65%), linear-gradient(#485988, #485988, #7b894f, #7b894f)");
        document.documentElement.style.setProperty("--background-color", "conic-gradient(at 50% -10%, #0000 0% 35%, #0008 40% 45%, #fff8 47.5% 52.5%, #0008 55% 60%, #0000 65%), conic-gradient(from 180deg at 50% 110%, #0000 0% 35%, #0008 40% 45%, #fff8 47.5% 52.5%, #0008 55% 60%, #0000 65%), conic-gradient(from 90deg at 110% 50%, #0000 0% 35%, #0008 40% 45%, #fff8 47.5% 52.5%, #0008 55% 60%, #0000 65%), conic-gradient(from 270deg at -10% 50%, #0000 0% 35%, #0008 40% 45%, #fff8 47.5% 52.5%, #0008 55% 60%, #0000 65%), linear-gradient(#5c78c8, #5c78c8, #a3be49, #a3be49)");
        document.documentElement.style.setProperty("--grid-color", "#406666");
        document.documentElement.style.setProperty("--tile-color", "#a7b579");
        document.documentElement.style.setProperty("--text-color", "#181e31");
        displayRules("rules_text", ["h1", "Gaussian DIVE"], ["p", "DIVE, but the tiles are complex integers instead of just real integers."],
        ["p", "At first, only 1+1i tiles spawn. When a new tile is made, if the value leftover after dividing that tile by all current spawning tiles as many times as you can is not a unit, that leftover value (rotated into the first quadrant) is added as a new spawning tile. If there are no remaining multiples of a spawning tile on the board, that tile is removed from the spawn pool, and you gain points based on its value."]);
        displayRules("gm_rules_text", ["p", "You found a hidden mode!"], ["h1", "Gaussian DIVE"], ["p", "DIVE, but the tiles are complex integers instead of just real integers."],
        ["p", "At first, only 1+1i tiles spawn. When a new tile is made, if the value leftover after dividing that tile by all current spawning tiles as many times as you can is not a unit, that leftover value (rotated into the first quadrant) is added as a new spawning tile. If there are no remaining multiples of a spawning tile on the board, that tile is removed from the spawn pool, and you gain points based on its value."]);
        statBoxes = [["Score", "@Score"], ["Seeds", "@GVar 0", false, false, "TileArray", "Self"], ["Seeds Seen", ["@GVar 1", "arr_length"], ...[,,,,], ["@GVar 4", "=", 0], [0, "@edit_gvar", 4, 1], true], ["All Seeds Seen", "@GVar 1", true, false, "TileArray", "Self", ["@GVar 4", "=", 1], [0, "@edit_gvar", 4, 0], true]];
        scripts = [
            [["@var_retain", ["@var_retain", "@Var -1", "arr_elem", 0, "arr_elem", 0], "@end_vars", "@Var -1", "GaussianDIVESeedUnlock", "@GVar 0", "@GVar 4", true, "@if", [["@Parent -3", "normGB", ">", 1n], "&&", ["@GVar 2", "arr_indexOf", "@Parent -3", "=", -1]], "@edit_gvar", 2, ["@GVar 2", "arr_push", "@Parent -2"], "@end-if"], "Merge"],
            [["@GVar 0", 0, new GaussianBigInt(0n, 0n), "@end_vars", true, "@repeat", ["@var_retain", "@Var 0", "arr_length"], "@edit_var", 2, ["@var_retain", "@Var 0", "arr_elem", "@Var 1"], "2nd", ["@var_retain", "@Grid", "arr_flat", 2, "arr_filter", ["@Var -1", "typeof", "=", "gaussianbigint", "&&", ["@var_retain", "@Var 1", "!=", new GaussianBigInt(0n, 0n)]], "arr_reduce", true, ["@var_retain", "@if", ["@var_retain", "@Var -1", "modGB", "@Var 2", "=", new GaussianBigInt(0n, 0n)], "2nd", false, "@end-if"]], "@if", "@Parent -1", "@edit_gvar", 3, ["@var_retain", "@GVar 3", "arr_push", "@Var 1"], "@end-if", "@edit_var", 1, ["@var_retain", "@Var 1", "+", 1], "@end-repeat"], "EndMovement"],
            [[0, new GaussianBigInt(0n, 0n), "@end_vars", 0, "@repeat", ["@GVar 2", "arr_length"], "@edit_var", 1, ["@var_retain", "@GVar 2", "arr_elem", "@Var 0"], "@edit_gvar", 0, ["@var_retain", "@GVar 0", "arr_push", "@Var 1"], "@if", ["@var_retain", "@GVar 1", "arr_indexOf", "@Var 1", "=", -1], "@edit_gvar", 1, ["@var_retain", "@GVar 1", "arr_push", "@Var 1", "arr_sort", ["@Var -2", "gaussianSort", "@Var -1"]], "@end-if", "@edit_var", 0, ["@var_retain", "@Var 0", "+", 1], "@end-repeat", "@if", ["@GVar 2", "arr_length", ">", 0], "@if", ["@GVar 2", "arr_length", "=", 1], "announce", ["@GVar 2", "arr_elem", 0, "String", "@if", "@GVar 5", "2nd", "?", "@end-if", "str_concat", " unlocked!"], 2500, "@end-if", "@else-if", ["@GVar 2", "arr_length", "=", 2], "announce", ["@GVar 2", "arr_elem", 0, "String", "@if", "@GVar 5", "2nd", "?", "@end-if", "str_concat", " and ", "str_concat", ["@GVar 2", "arr_elem", 1, "String", "@if", "@GVar 5", "2nd", "?", "@end-if"], "str_concat", " unlocked!"], 2500, "@end-else-if", "@else", "announce", ["@GVar 2", "arr_pop", "arr_reduce", "", ["str_concat", ["@var_retain", "@Var -1", "@if", "@GVar 5", "2nd", "?", "@end-if"], "str_concat", ", "], "str_concat", "and ", "str_concat", ["@GVar 2", "arr_elem", ["@GVar 2", "arr_length", "-", 1], "@if", "@GVar 5", "2nd", "?", "@end-if"], "str_concat", " unlocked!"], 2500, "@end-else", "@end-if", "@edit_gvar", 2, ["@Literal"]], "EndMovement"],
            [[0, 0, "@end_vars", 0, "@if", [["@GVar 3", "arr_length", ">", 0], "&&", [["@GVar 3", "arr_length"], "<", ["@GVar 0", "arr_length"]]], "@if", ["@GVar 3", "arr_length", "=", 1], "announce", ["@GVar 0", "arr_elem", ["@GVar 3", "arr_elem", 0], "String", "@if", "@GVar 5", "2nd", "?", "@end-if", "str_concat", " eliminated!"], 2500, "@end-if", "@else-if", ["@GVar 3", "arr_length", "=", 2], "announce", ["@GVar 0", "arr_elem", ["@GVar 3", "arr_elem", 0], "String", "@if", "@GVar 5", "2nd", "?", "@end-if", "str_concat", " and ", "str_concat", ["@GVar 0", "arr_elem", ["@GVar 3", "arr_elem", 1], "String", "@if", "@GVar 5", "2nd", "?", "@end-if", "@end-if"], "str_concat", " eliminated!"], 2500, "@end-else-if", "@else", "announce", ["@GVar 3", "arr_pop", "arr_reduce", "", ["str_concat", ["@var_retain", "@GVar 0", "arr_elem", "@Var -1", "@if", "@GVar 5", "2nd", "?", "@end-if"], "str_concat", ", "], "str_concat", "and ", "str_concat", ["@GVar 0", "arr_elem", ["@GVar 3", "arr_elem", ["@GVar 3", "arr_length", "-", 1]], "@if", "@GVar 5", "2nd", "?", "@end-if"], "str_concat", " eliminated!"], 2500, "@end-else", "@repeat", ["@GVar 3", "arr_length"], "@edit_var", 1, ["@var_retain", "@GVar 3", "arr_elem", "@Var 0"], "@add_score", ["@var_retain", "@GVar 0", "arr_elem", "@Var 1", "normGB", "^", 1/2], "@edit_gvar", 0, ["@var_retain", "@GVar 0", "arr_splice", ["@var_retain", "@Var 1", "-", "@Var 0"], 1, ["@Literal"]], "@edit_var", 0, ["@var_retain", "@Var 0", "+", 1], "@end-repeat", "@end-if", "@edit_gvar", 3, ["@Literal"]], "EndMovement"]
        ];
        document.getElementById("mode_vars_line").style.setProperty("display", "block");
        document.getElementById("GaussianDIVE_vars").style.setProperty("display", "flex");
        document.getElementById("GaussianDIVE_quadrantSpawnRatios").style.setProperty("display", "flex");
    }
    else if (mode == 37.71) { // 839,808
        // width = 5; height = 5;
        TileNumAmount = 2;
        mode_vars = [(secretsFound[6]) ? 0 : -9];
        TileTypes = [
            [["Mul2", "@Signless"], "&#215;2", ["@linear-gradient", "#e9dc90", "#655d2e"], "#b36721"],
            [true, [[2, "^", "@This 0"], "*", [3, "^", "@This 1"]], ["@linear-gradient", ["@HSLA", ["@This 0", "*", -23, "+", 83], 100, [0.925, "^", "@This 0", "*", 95], 1], 0, 25, ["@HSLA", ["@This 1", "*", -23, "+", 83], 100, [0.925, "^", "@This 1", "*", 95], 1], 75, 100], "#170036", "0px 0px 5px #dfc6ff"]
        ];
        MergeRules = [
            [2, [["@Next 1 0", "=", "Mul2"], "&&", ["@This 0", "=", "Mul2"]], true, [["Mul2", "@Signless"]], 0, [false, false]],
            [2, [["@Next 1 0", "=", "Mul2"], "&&", ["@This 0", "typeof", "=", "number"]], false, [[["@This 0", "+", 1], "@This 1"]], 0, [false, true]],
            [2, [["@This 0", "typeof", "=", "number"], "&&", ["@This 1", "=", "@Next 1 1"], "&&", ["@This 0", "+", 1, "=", "@Next 1 0"]], false, [["@This 0", ["@This 1", "+", 1]]], [3, "^", "@This 1", "*", 3], [false, true]],
        ];
        startTileSpawns = [[[0, 0], 50], [["Mul2", "@Signless"], 50]];
        winConditions = [[7, 8]];
        winRequirement = 1;
        knownMergeMaxLength = 2;
        knownMergeLookbackDistance = 0;
        document.documentElement.style.setProperty("background-image", "linear-gradient(#d063ff,#8c56ff)");
        document.documentElement.style.setProperty("--background-color", "linear-gradient(#e5a9ff,#b999ff)");
        document.documentElement.style.setProperty("--grid-color", "#8960e0");
        document.documentElement.style.setProperty("--tile-color", "#8e47ac");
        document.documentElement.style.setProperty("--text-color", "#3b123e");
        displayRules("rules_text", ["h1", "839,808"], ["p", "Any tile can merge with a &#215;2 tile (if both tiles are &#215;2 tiles, they'll just combine into one &#215;2 tile to reduce clutter), and a merge can occur between any tile and a tile that's double it (only this type of merge gives score, and the score it gives is based on the power of 3 part of the result). Get to the 839,808 (2<sup>7</sup> &#215; 3<sup>8</sup>) tile to win!"],
        ["p", "Spawning tiles: 1 (50%), &#215;2 (50%)"]);
        displayRules("gm_rules_text", ["p", "You found a hidden mode!"], ["h1", "839,808"], ["p", "Any tile can merge with a &#215;2 tile (if both tiles are &#215;2 tiles, they'll just combine into one &#215;2 tile to reduce clutter), and a merge can occur between any tile and a tile that's double it (only this type of merge gives score, and the score it gives is based on the power of 3 part of the result). Get to the 839,808 (2<sup>7</sup> &#215; 3<sup>8</sup>) tile to win!"],
        ["p", "Spawning tiles: 1 (50%), &#215;2 (50%)"]);
    }
    else if (mode == 71.37) { // 145.965
        // width = 5; height = 5;
        mode_vars = [true]; // Does the division tile have to be in the middle?
        if (modifiers[13] == "None") {
            TileNumAmount = 2;
            TileTypes = [
                [["Divide", "@Signless"], "&#247;", ["@radial-gradient", "#0095ff", 0, 25, "#6f00ff"], "#1c00b9"],
                [true, [1.5, "^", "@This 0", "*", "@This 1"], ["@linear-gradient", ["@HSLA", ["@This 0", "*", 23, "+", 131], [100, "/", [1.5, "^", ["@This 0", "<", 0]]], ["@This 1", "log", 2, "*", 15, "+", 50], 1], ["@HSLA", ["@This 0", "*", 19, "+", 131], [0.997, "^", ["@This 0", "abs"], "*", 100, "/", [1.5, "^", ["@This 0", "<", 0]]], ["@This 1", "log", 2, "*", 15, "+", 50], 1]], ["#262d00", "@if", [["@This 1", "=", 2], "||", ["@This 1", "=", 0.5]], "2nd", " #f5ffba", "@end-if"]],
            ];
            MergeRules = [
                [2, [["@Next 1 0", "=", "@This 0"], "&&", ["@This 1", "/", 2, "=", "@Next 1 1"]], false, [[["@This 0", "+", 1], "@This 1"]], [3, "^", "@This 0", "*", "@This 1"], [false, true]],
                [3, [["@Next 1 0", "=", "Divide"], "&&", [[["@This 1", "=", 2], "||", ["@This 1", "=", 0.5]], "&&", [["@Next 2 1", "=", 2], "||", ["@Next 2 1", "=", 0.5]], "||", [["@This 0", "=", 0], "&&", ["@This 1", "=", 1], "&&", ["@Next 2 0", "!=", "Divide"]], "||", [["@Next 2 0", "=", 0], "&&", ["@Next 2 1", "=", 1], "&&", ["@This 0", "!=", "Divide"]]]], true, [[["@This 0", "-", "@Next 2 0"], ["@This 1", "/", "@Next 2 1"]]], 0, [false, true]],
                [2, [["@Next 1 0", "=", "Divide"], "&&", ["@This 0", "=", "Divide"]], true, [["Divide", "@Signless"]], 0, [true, true]]
            ];
            startTileSpawns = [[[0, 2], 50], [["Divide", "@Signless"], 50]];
            winConditions = [[14, 0.5]];
            winRequirement = 1;
        }
        else {
            TileNumAmount = 3;
            TileTypes = [
                [["Divide", "@Signless", 0], "&#247;", ["@radial-gradient", "#0095ff", 0, 25, "#6f00ff"], "#1c00b9"],
                [["@This 2", "=", 1], [1.5, "^", "@This 0", "*", "@This 1"], ["@linear-gradient", ["@HSLA", ["@This 0", "*", 23, "+", 131], [100, "/", [1.5, "^", ["@This 0", "<", 0]]], ["@This 1", "log", 2, "*", 15, "+", 50], 1], ["@HSLA", ["@This 0", "*", 19, "+", 131], [0.997, "^", ["@This 0", "abs"], "*", 100, "/", [1.5, "^", ["@This 0", "<", 0]]], ["@This 1", "log", 2, "*", 15, "+", 50], 1]], ["#262d00", "@if", [["@This 1", "=", 2], "||", ["@This 1", "=", 0.5]], "2nd", " #f5ffba", "@end-if"]],
                [["@This 2", "=", -1], [1.5, "^", "@This 0", "*", "@This 1", "*", -1], ["@linear-gradient", ["@HSLA", ["@This 0", "*", 23, "+", 291], [100, "/", [1.5, "^", ["@This 0", "<", 0]]], ["@This 1", "log", 2, "*", -15, "+", 50], 1], ["@HSLA", ["@This 0", "*", 19, "+", 291], [0.997, "^", ["@This 0", "abs"], "*", 100, "/", [1.5, "^", ["@This 0", "<", 0]]], ["@This 1", "log", 2, "*", -15, "+", 50], 1]], ["#d9d2ff", "@if", [["@This 1", "=", 2], "||", ["@This 1", "=", 0.5]], "2nd", " #0a0045", "@end-if"]],
            ];
            MergeRules = [
                [2, [["@Next 1 0", "=", "@This 0"], "&&", ["@This 1", "/", 2, "=", "@Next 1 1"], "&&", ["@This 2", "=", "@Next 1 2"]], false, [[["@This 0", "+", 1], "@This 1", "@This 2"]], [3, "^", "@This 0", "*", "@This 1"], [false, true]],
                [3, [["@Next 1 0", "=", "Divide"], "&&", [[["@This 1", "=", 2], "||", ["@This 1", "=", 0.5]], "&&", [["@Next 2 1", "=", 2], "||", ["@Next 2 1", "=", 0.5]], "||", [["@This 0", "=", 0], "&&", ["@This 1", "=", 1], "&&", ["@Next 2 0", "!=", "Divide"]], "||", [["@Next 2 0", "=", 0], "&&", ["@Next 2 1", "=", 1], "&&", ["@Next 2 0", "!=", "Divide"]]]], true, [[["@This 0", "-", "@Next 2 0"], ["@This 1", "/", "@Next 2 1"], ["@This 2", "*", "@Next 2 2"]]], 0, [false, true]],
                [2, [["@Next 1 0", "=", "Divide"], "&&", ["@This 0", "=", "Divide"]], true, [["Divide", "@Signless", 0]], 0, [true, true]]
            ];
            if (modifiers[13] == "Interacting") MergeRules.unshift([2, [["@Next 1 0", "=", "@This 0"], "&&", ["@Next 1 1", "=", "@This 1"], "&&", ["@Next 1 2", "!=", "@This 2"]], true, [], 0, [true, true]]);
            startTileSpawns = [[[0, 2, 1], modifiers[22]], [[0, 2, -1], modifiers[23]], [["Divide", "@Signless", 0], modifiers[22] + modifiers[23]]];
            winConditions = [[14, 0.5, 1], [14, 0.5, -1]];
            winRequirement = 2;
        }
        knownMergeMaxLength = 3;
        knownMergeLookbackDistance = 0;
        document.documentElement.style.setProperty("background-image", "linear-gradient(90deg, #50b300, #ae6e04)");
        document.documentElement.style.setProperty("--background-color", "linear-gradient(#97d266,#d7aa62)");
        document.documentElement.style.setProperty("--grid-color", "#78541b");
        document.documentElement.style.setProperty("--tile-color", "#75b144");
        document.documentElement.style.setProperty("--text-color", "#423c14");
        displayRules("rules_text", ["h1", "145.965"], ["p","There are division tiles. If you merge two tiles that are each double a power of 1.5 or half a power of 1.5 (they do not need to be double or half the <i>same</i> power of 1.5) with a divison tile in the middle, those two tiles will be divided. Also, a 1 tile can be divided in this way with any other tile, and any tile can merge normally with a tile that's double itself. Get to the 145.965 (0.5 &#215; 1.5<sup>14</sup>) tile to win!"],
        ["p", "Spawning tiles: 2 (50%), &#247; (50%)"]);
        displayRules("gm_rules_text", ["p", "You found a hidden mode!"], ["h1", "145.965"], ["p","There are division tiles. If you merge two tiles that are each double a power of 1.5 or half a power of 1.5 (they do not need to be double or half the <i>same</i> power of 1.5) with a divison tile in the middle, those two tiles will be divided. Also, a 1 tile can be divided in this way with any other tile, and any tile can merge normally with a tile that's double itself. Get to the 145.965 (0.5 &#215; 1.5<sup>14</sup>) tile to win!"],
        ["p", "Spawning tiles: 2 (50%), &#247; (50%)"]);
        document.getElementById("mode_vars_line").style.setProperty("display", "block");
        document.getElementById("3188646_vars").style.setProperty("display", "flex");
    }
    else if (mode == 3.24) { // Merge Overflow 256
        // width = 5; height = 5;
        TileNumAmount = 2;
        TileTypes = [[[0, 1], 1, "#ffffff", "#564040"], [[0, 3], 3, "#777777", "#f4ecec"], [[1, 1], 4, "#00ff00", "#564040"], [[1, 3], 12, "#008a00", "#f4ecec"],
        [[2, 1], 16, "#bbff00", "#564040"], [[2, 3], 48, "#78a400", "#f4ecec"], [[3, 1], 64, "#ffc800", "#564040"], [[3, 3], 192, "#997800", "#f4ecec"],
        [[4, 1], 256, "#ff7300", "#564040"], [[4, 3], 768, "#924200", "#f4ecec"], [[5, 1], 1024, "#ff0000", "#564040"], [[5, 3], 3072, "#950000", "#f4ecec"],
        [[6, 1], 4096, "#ff009d", "#564040"], [[6, 3], 12288, "#870053", "#f4ecec"], [[7, 1], 16384, "#f900fe", "#564040"], [[7, 3], 49152, "#88008a", "#f4ecec"],
        [[8, 1], 65536, "#6f00ff", "#564040"], [[8, 3], 196608, "#3c008a", "#f4ecec"], [[9, 1], 262144, "#004cff", "#564040"], [[9, 3], 786432, "#002886", "#f4ecec"],
        [[10, 1], 1048576, "#01d0ff", "#564040"], [[10, 3], 3145728, "#00748e", "#f4ecec"], [[11, 1], 4194304, "#00ffae", "#564040"],
        [[11, 3], 12582912, "#009969", "#f4ecec"],
        [["@This 1", "=", 1], [4, "^", "@This 0"], ["@HSLA", [-31, "*", "@This 0", "+", 491], [0.95, "^", ["@This 0", "-", 12], "*", 75], 70, 1], "#564040"],
        [["@This 1", "=", 3], [4, "^", "@This 0", "*", 3], ["@HSLA", [-31, "*", "@This 0", "+", 491], [0.95, "^", ["@This 0", "-", 12], "*", 75], 35, 1], "#f4ecec"]];
        MergeRules = [
            [3, [["@Next 1 0", "=", "@This 0"], "&&", ["@Next 2 0", "=", "@This 0"], "&&", ["@Next 1 1", "=", 1], "&&", ["@Next 2 1", "=", 1], "&&", ["@This 1", "=", 1]], true, [["@This 0", 3]], [4, "^", "@This 0", "*", 3], [false, true, true]],
            [2, [["@Next 1 0", "=", "@This 0"], "&&", ["@Next 1 1", "=", 3], "&&", ["@This 1", "=", 3]], false, ["@MergeOverflowOverwrite", [["@This 0", "+", 1], 1], ["@This 0", 1], ["@This 0", 1]], [4, "^", "@This 0", "*", 6], [false, false, false]]];
        startTileSpawns = [[[0, 1], 85], [[0, 3], 10], [[1, 1], 5]];
        winConditions = [[4, 1]];
        winRequirement = 1;
        mergeResultKnownLevel = 0; // Merge result saving is currently buggy with merge overflow and I don't feel it's necessary to deal with that at this time
        document.documentElement.style.setProperty("background-image", "radial-gradient(#ff0000 0%, #0000 100%), linear-gradient(#fff, #000)");
        document.documentElement.style.setProperty("--background-color", "linear-gradient(#0000, #ffffffee, #0000), linear-gradient(#ee8686, #882424)");
        document.documentElement.style.setProperty("--grid-color", "#c7a7a7");
        document.documentElement.style.setProperty("--tile-color", "#ecc2c2");
        document.documentElement.style.setProperty("--text-color", "#564040");
        displayRules("rules_text", ["h1", "Merge Overflow 256"], ["p","Three tiles that are both the same number and a power of 4 will merge completely. Two tiles that are both the same number and triple a power of four will merge into one tile that's the next power of four and two tiles that are each the original power of four (this will overwrite whatever's in the space behind the two inputs!). Get to the 256 tile to win!"],
        ["p", "Spawning tiles: 1 (85%), 3 (10%), 4 (5%)"]);
        displayRules("gm_rules_text", ["p", "You found a hidden mode!"], ["h1", "Merge Overflow 256"], ["p","Three tiles that are both the same number and a power of 4 will merge completely. Two tiles that are both the same number and triple a power of four will merge into one tile that's the next power of four and two tiles that are each the original power of four (this will overwrite whatever's in the space behind the two inputs!). Get to the 256 tile to win!"],
        ["p", "Spawning tiles: 1 (85%), 3 (10%), 4 (5%)"]);
    }
    else if (mode == 1.5) { // 1/512
        // width = 4; height = 4;
        TileNumAmount = 2;
        start_game_vars = [0, 0]; // Tracks highest and lowest tile
        TileTypes = [
            [["@This 0", "=", 0], 1, "#ffffff", "#776e65"], [["@This 0", "=", 1], 2, "#f9eee3", "#776e65"],
            [["@This 0", "=", 2], 4, "#ede0c8", "#776e65"], [["@This 0", "=", 3], 8, "#f2b179", "#f9f6f2"], [["@This 0", "=", 4], 16, "#f59563", "#f9f6f2"],
            [["@This 0", "=", 5], 32, "#f67c5f", "#f9f6f2"], [["@This 0", "=", 6], 64, " #f65e3b", "#f9f6f2"], [["@This 0", "=", 7], 128, "#edcf72", "#f9f6f2"],
            [["@This 0", "=", 8], 256, "#edcc61", "#f9f6f2"], [["@This 0", "=", 9], 512, "#edc850", "#f9f6f2"], [["@This 0", "=", 10], 1024, "#edc53f", "#f9f6f2"],
            [["@This 0", "=", 11], 2048, "#edc22e", "#f9f6f2"], [["@This 0", "=", 12], 4096, "#f29eff", "#f9f6f2"], [["@This 0", "=", 13], 8192, "#eb75fd", "#f9f6f2"],
            [["@This 0", "=", 14], 16384, "#e53bff", "#f9f6f2"], [["@This 0", "=", 15], 32768, "#bd00db", "#f9f6f2"], [["@This 0", "=", 16], 65536, "#770089", "#f9f6f2"],
            [["@This 0", "=", 17], 131072, "#534de8", "#f9f6f2"], [["@This 0", "=", 18], 262144, "#2922e1", "#f9f6f2"], [["@This 0", "=", 19], 524288, "#0a05b6", "#f9f6f2"],
            [["@This 0", ">", 19], [2, "^", "@This 0"], ["@HSLA", [-15, "*", "@This 0", "+", 520], 100, [0.9, "^", ["@This 0", "-", 20], "*", 36], 1], "#f9f6f2"],
            [["@This 0", "=", -1], "1/2", "#b8f7ff", "#776e65"],
            [["@This 0", "=", -2], "1/4", "#77efff", "#776e65"], [["@This 0", "=", -3], "1/8", "#17dbf5", "#f9f6f2"], [["@This 0", "=", -4], "1/16", "#28b7eb", "#f9f6f2"],
            [["@This 0", "=", -5], "1/32", "#378def", "#f9f6f2"], [["@This 0", "=", -6], "1/64", "#3856ec", "#f9f6f2"], [["@This 0", "=", -7], "1/128", "#f09bf5", "#f9f6f2"],
            [["@This 0", "=", -8], "1/256", "#e676ec", "#f9f6f2"], [["@This 0", "=", -9], "1/512", "#dc44e4", "#f9f6f2"], [["@This 0", "=", -10], "1/1024", "#e819dd", "#f9f6f2"],
            [["@This 0", "=", -11], "1/2048", "#ee0fba", "#f9f6f2"], [["@This 0", "=", -12], "1/4096", "#afffd5", "#f9f6f2"], [["@This 0", "=", -13], "1/8192", "#67ffb1", "#f9f6f2"],
            [["@This 0", "=", -14], "1/16,384", "#00f576", "#f9f6f2"], [["@This 0", "=", -15], "1/32,768", "#00b457", "#f9f6f2"], [["@This 0", "=", -16], "1/65,536", "#007237", "#f9f6f2"],
            [["@This 0", "=", -17], "1/131,072", "#c8c86b", "#f9f6f2"], [["@This 0", "=", -18], "1/262,144", "#bebe3c", "#f9f6f2"], [["@This 0", "=", -19], "1/524,288", "#9b9b1e", "#f9f6f2"],
            [["@This 0", "<", -19], [2, "^", ["@This 0", "abs"], "defaultAbbrev", "str_concat_front", "1/"], ["@HSLA", [-15, "*", ["@This 0", "abs"], "+", 340], 100, [0.9, "^", ["@This 0", "abs", "-", 20], "*", 36], 1], "#f9f6f2"]
        ];
        MergeRules = [
            [2, ["@Next 1 0", "=", "@This 0"], true, [[["@This 0", "+", 1], 1]], [2, "^", ["@This 0", "+", 1], "@edit_gvar", 0, ["@This 0", "+", 1, "max", "@GVar 0"]], [false, true]],
            [0, ["@This 1", "=", 0], true, ["@MergeOverflowEmpty", [["@This 0", "-", 1], 1], [["@This 0", "-", 1], 1]], [0, "@edit_gvar", 1, ["@This 0", "-", 1, "*", -1, "max", "@GVar 1"]]],
            [0, ["@This 1", "=", 1], true, [["@This 0", 0]], 0]
        ];
        startTileSpawns = [[[0, 0], 1]];
        winConditions = [["@This 0", "=", 9], ["@This 0", "=", -9]];
        winRequirement = 1;
        mergeResultKnownLevel = 0; // Merge result saving is currently buggy with merge overflow and I don't feel it's necessary to deal with that at this time
        document.documentElement.style.setProperty("background-image", "linear-gradient( #edc850, #dc44e4)");
        document.documentElement.style.setProperty("--background-color", "linear-gradient(90deg, #ffe591,#f296f7)");
        document.documentElement.style.setProperty("--grid-color", "#f191ee");
        document.documentElement.style.setProperty("--tile-color", "#e4cb8a");
        document.documentElement.style.setProperty("--text-color", "#5a382a");
        statBoxes = [["Largest Tile", [2, "^", "@GVar 0"]], ["Smallest Tile", [2, "^", "@GVar 1", "@if", ["@GVar 1", ">", 0], "str_concat_front", "1/", "@end-if"]]];
        displayRules("rules_text", ["h1", "1/512"], ["p", "Merges occur between two tiles of the same number. If, at the end of a move, the space behind a tile (relative to the direction the move was in) is empty and that tile did not come from a merge this turn, that tile splits in two. Get to the 512 tile or the 1/512 tile to win!"],
        ["p", "Spawning tiles: 1 (100%)"]);
        displayRules("gm_rules_text", ["p", "You found a hidden mode!"], ["h1", "1/512"], ["p", "Merges occur between two tiles of the same number. If, at the end of a move, the space behind a tile (relative to the direction the move was in) is empty and that tile did not come from a merge this turn, that tile splits in two. Get to the 512 tile or the 1/512 tile to win!"],
        ["p", "Spawning tiles: 1 (100%)"]);
    }
    else if (mode == 34.39) { // Partial Absorb 19,683
        TileNumAmount = 2;
        TileTypes = [
            [[0, 1], 1, "#ffffff", "#361733"], [[0, -1], -1, "#000000", "#c9e8cc"], [[1, 1], 3, "#f3fac8", "#361733"], [[1, -1], -3, "#0c0537", "#c9e8cc"],
            [[2, 1], 9, "#e3f37f", "#361733"], [[2, -1], -9, "#1c0c80", "#c9e8cc"], [[3, 1], 27, "#cce814", "#361733"], [[3, -1], -27, "#3317eb", "#c9e8cc"],
            [[4, 1], 81, "#72e400", "#361733"], [[4, -1], -81, "#8d1bff", "#c9e8cc"], [[5, 1], 243, "#09be00", "#f0e0ee"], [[5, -1], -243, "#f641ff", "#0f1f11"],
            [[6, 1], 729, "#00a349", "#f0e0ee"], [[6, -1], -729, "#ff5cb6", "#0f1f11"], [[7, 1], 2187, "#f5b7f4", "#f0e0ee"], [[7, -1], -2187, "#0a480b", "#0f1f11"],
            [[8, 1], 6561, "#ef8bed", "#f0e0ee"], [[8, -1], -6561, "#107412", "#0f1f11"], [[9, 1], 19683, "#e649e3", "#f0e0ee"], [[9, -1], -19683, "#19b61c", "#0f1f11"],
            [[10, 1], 59049, "#cc29c9", "#f0e0ee"], [[10, -1], -59049, "#33d636", "#0f1f11"], [[11, 1], 177147, "#aa15a7", "#f0e0ee"], [[11, -1], -177147, "#55ea58", "#0f1f11"],
            [[12, 1], 531441, "#ffaa8e", "#f0e0ee"], [[12, -1], -531441, "#005571", "#0f1f11"], [[13, 1], 3**13, "#ff8156", "#f0e0ee"], [[13, -1], -(3**13), "#007ea9", "#0f1f11"],
            [[14, 1], 3**14, "#f74d14", "#f0e0ee"], [[14, -1], -(3**14), "#08b2eb", "#0f1f11"], [[15, 1], 3**15, "#ba3307", "#f0e0ee"], [[15, -1], -(3**15), "#45ccf8", "#0f1f11"],
            [[16, 1], 3**16, "#732004", "#f0e0ee"], [[16, -1], -(3**16), "#8cdffb", "#0f1f11"], [[17, 1], 3**17, "#e6b269", "#f0e0ee"], [[17, -1], -(3**17), "#194d96", "#0f1f11"],
            [[18, 1], 3**18, "#d48e2d", "#f0e0ee"], [[18, -1], -(3**18), "#2b71d2", "#0f1f11"], [[19, 1], 3**19, "#ca7600", "#f0e0ee"], [[19, -1], -(3**19), "#3589ff", "#0f1f11"],
            [["@This 0", "=", 1], [3, "^", "@This 0"], ["@HSLA", ["@This 0", "*", 15, "+", 252], 100, [0.9, "^", ["@This 0", "-", 20], "*", 36], 1], "#f0e0ee"],
            [["@This 0", "=", -1], [3, "^", "@This 0", "*", -1], ["@HSLA", ["@This 0", "*", 15, "+", 72], 100, [0.9, "^", ["@This 0", "-", 20], "*", -36, "+", 100], 1], "#0f1f11"]
        ];
        if (modifiers[13] == "None") {
            MergeRules = [
                [2, [["@This 0", "=", "@Next 1 0"], "&&", ["@This 1", "=", 1], "&&", ["@Next 1 1", "=", 1]], true, [[["@This 0", "+", 1], "@This 1"], ["@This 0", ["@This 1", "*", -1]]], [3, "^", "@This 0", "*", 2], [false, false]],
                [2, [["@This 0", "=", "@Next 1 0"], "&&", ["@This 1", "!=", "@Next 1 1"]], true, [], 0, [true, true]]
            ];
            startTileSpawns = [[[0, 1], 90], [[1, 1], 10]];
            winConditions = [[9, 1]];
            winRequirement = 1;
        }
        else {
            startTileSpawns = [[[0, 1], 90 * modifiers[22]], [[1, 1], 10 * modifiers[22]], [[0, -1], 90 * modifiers[23]], [[1, -1], 10 * modifiers[23]]];
            winConditions = [[9, 1], [9, -1]];
            winRequirement = 2;
            MergeRules = [
                [2, [["@This 0", "=", "@Next 1 0"], "&&", ["@This 1", "=", "@Next 1 1"]], true, [[["@This 0", "+", 1], "@This 1"], ["@This 0", ["@This 1", "*", -1]]], [3, "^", "@This 0", "*", 2], [false, false]],
            ];
            if (modifiers[13] == "Interacting") MergeRules.push([2, [["@This 0", "=", "@Next 1 0"], "&&", ["@This 1", "!=", "@Next 1 1"]], true, [], 0, [true, true]]);
        }
        knownMergeMaxLength = 2;
        knownMergeLookbackDistance = 0;
        document.documentElement.style.setProperty("background-image", "radial-gradient(#ff5cb6,#aa15a7)");
        document.documentElement.style.setProperty("--background-color", "linear-gradient(#f29dcc,#9f419d)");
        document.documentElement.style.setProperty("--grid-color", "#540d53");
        document.documentElement.style.setProperty("--tile-color", "#c23d86");
        document.documentElement.style.setProperty("--text-color", "#ffcdf6");
        if (modifiers[13] == "Non-Interacting") {
            displayRules("rules_text", ["h1", "Partial Absorb 19,683"], ["p", "Two equal tiles merge, creating a tile that's triple themselves and a tile that's their negative. Get to the 19,683 tile to win!"],
            ["p", "Spawning tiles: 1 (45%), 3 (5%), -1 (45%), -3 (5%)"]);
            displayRules("gm_rules_text", ["p", "You found a hidden mode!"], ["h1", "Partial Absorb 19,683"], ["p", "Two equal tiles merge, creating a tile that's triple themselves and a tile that's their negative. Get to the 19,683 tile to win!"],
            ["p", "Spawning tiles: 1 (45%), 3 (5%), -1 (45%), -3 (5%)"]);
        }
        else if (modifiers[13] == "Interacting") {
            displayRules("rules_text", ["h1", "Partial Absorb 19,683"], ["p", "Two equal tiles merge, creating a tile that's triple themselves and a tile that's their negative. When a tile and its own negative collide, they're both destroyed. Get to the 19,683 tile to win!"],
            ["p", "Spawning tiles: 1 (45%), 3 (5%), -1 (45%), -3 (5%)"]);
            displayRules("gm_rules_text", ["p", "You found a hidden mode!"], ["h1", "Partial Absorb 19,683"], ["p", "Two equal tiles merge, creating a tile that's triple themselves and a tile that's their negative. When a tile and its own negative collide, they're both destroyed. Get to the 19,683 tile to win!"],
            ["p", "Spawning tiles: 1 (45%), 3 (5%), -1 (45%), -3 (5%)"]);
        }
        else {
            displayRules("rules_text", ["h1", "Partial Absorb 19,683"], ["p", "Two equal positive tiles merge, creating a tile that's triple themselves and a tile that's their negative. When a tile and its own negative collide, they're both destroyed. Get to the 19,683 tile to win!"],
            ["p", "Spawning tiles: 1 (90%), 3 (10%)"]);
            displayRules("gm_rules_text", ["p", "You found a hidden mode!"], ["h1", "Partial Absorb 19,683"], ["p", "Two equal positive tiles merge, creating a tile that's triple themselves and a tile that's their negative. When a tile and its own negative collide, they're both destroyed. Get to the 19,683 tile to win!"],
            ["p", "Spawning tiles: 1 (90%), 3 (10%)"]);
        }
    }

    else if (mode == -1) { // Custom Mode
        makeCustomModePlayable();
    }

    if (modifiers[5] != "Custom") loadGridSize(mode, mode_vars);
    gmDisplayVars();
}

function loadGridSize(mode, mvars = []) {
    if (modifiers[5] == "Custom") return;
    let size3 = [31, 86];
    let size4 = [1, 2, 4, 7, 16, 17, 26, 27, 29, 30, 32, 40, 42, 47, 48, 50, 51, 53, 54, 60, 64, 66, 67, 69, 72, 73, 74, 78, 79, 81, 82, 83, 84, 85, 87, 88, 89, 91, 92, 93, 95, 50.1];
    let size5 = [3, 5, 6, 9, 10, 11, 12, 13, 14, 15, 18, 19, 20, 21, 23, 24, 28, 33, 34, 35, 41, 43, 44, 46, 49, 52, 55, 56, 58, 59, 62, 63, 65, 68, 70, 71, 75, 76, 77, 80, 90, 94, 96, 97, 99, 37.71, 71.37, 1.5, 34.39];
    let size6 = [8, 25, 39, 45, 98, 3.24];
    let size7 = [22, 38];
    let size8 = [36];
    let defaultSize;
    if (size3.indexOf(mode) != -1) defaultSize = 3;
    else if (size4.indexOf(mode) != -1) defaultSize = 4;
    else if (size5.indexOf(mode) != -1) defaultSize = 5;
    else if (size6.indexOf(mode) != -1) defaultSize = 6;
    else if (size7.indexOf(mode) != -1) defaultSize = 7;
    else if (size8.indexOf(mode) != -1) defaultSize = 8;
    else if (mode == 37) { // 2216.8378200531005859375
        if (mvars[0] == 0) defaultSize = 8;
        else if (mvars[0] == 1) defaultSize = 5;
        else defaultSize = 6;
    }
    else if (mode == 57) { // 2700
        if (mvars[0] == 1) defaultSize = 4;
        else defaultSize = 5;
    }
    else if (mode == 61) { // 3069
        if (mvars[2]) defaultSize = 5;
        else defaultSize = 4;
    }
    else if (mode == 100) { // Alternate 5040
        if (mvars[0] == 0) defaultSize = 4;
        else defaultSize = 5;
    }
    else if (mode == -1) { // Custom Modes
        if (customRulesText[3] == 0) {
            defaultSize = 3;
            for (let m = 0; m < customMerges.length; m++) {
                defaultSize = max(defaultSize, customMerges[m][2].length + 3);
            }
        }
        else defaultSize = customRulesText[3];
    }
    else defaultSize = 4; // Error-handling case
    if (modifiers[5] == "Diamond" || modifiers[5] == "Hexagon") modifiers[6] = defaultSize - 2;
    if (modifiers[5] == "HexaTriangle") modifiers[6] = Math.floor(defaultSize * Math.sqrt(2));
    else if (modifiers[5] == "4D") {
        let default4Size = Math.max(defaultSize - 2, 2);
        modifiers[6] = default4Size;
        modifiers[7] = default4Size;
        modifiers[8] = default4Size;
        if (defaultSize == 4) modifiers[9] = 2;
        else modifiers[9] = 1;
    }
    else {
        width = defaultSize;
        height = defaultSize;
    }
}

function gmDisplayVars() {
    if (modifiers[5] == "Diamond") {
        document.getElementById("gm_diamond_counter").innerHTML = modifiers[6];
        if (modifiers[6] >= 0) document.getElementById("gm_diamond_minus").style.setProperty("display", "inline-block");
        else document.getElementById("gm_diamond_minus").style.setProperty("display", "none");
        if (modifiers[6] <= 9999) document.getElementById("gm_diamond_plus").style.setProperty("display", "inline-block");
        else document.getElementById("gm_diamond_plus").style.setProperty("display", "none");
    }
    if (modifiers[5] == "Hexagon") {
        document.getElementById("gm_diamond_counter").innerHTML = modifiers[6];
        if (modifiers[6] > 0) document.getElementById("gm_diamond_minus").style.setProperty("display", "inline-block");
        else document.getElementById("gm_diamond_minus").style.setProperty("display", "none");
        if (modifiers[6] <= 9999) document.getElementById("gm_diamond_plus").style.setProperty("display", "inline-block");
        else document.getElementById("gm_diamond_plus").style.setProperty("display", "none");
    }
    if (modifiers[5] == "HexaTriangle") {
        document.getElementById("gm_diamond_counter").innerHTML = modifiers[6];
        if (modifiers[6] > 1) document.getElementById("gm_diamond_minus").style.setProperty("display", "inline-block");
        else document.getElementById("gm_diamond_minus").style.setProperty("display", "none");
        if (modifiers[6] <= 9999) document.getElementById("gm_diamond_plus").style.setProperty("display", "inline-block");
        else document.getElementById("gm_diamond_plus").style.setProperty("display", "none");
    }
    if (modifiers[5] == "4D") {
        document.getElementById("gm_4D_width_counter").innerHTML = modifiers[6];
        if (modifiers[6] > 1) document.getElementById("gm_4D_width_minus").style.setProperty("display", "inline-block");
        else document.getElementById("gm_4D_width_minus").style.setProperty("display", "none");
        if (modifiers[6] < 99) document.getElementById("gm_4D_width_plus").style.setProperty("display", "inline-block");
        else document.getElementById("gm_4D_width_plus").style.setProperty("display", "none");
        document.getElementById("gm_4D_height_counter").innerHTML = modifiers[7];
        if (modifiers[7] > 1) document.getElementById("gm_4D_height_minus").style.setProperty("display", "inline-block");
        else document.getElementById("gm_4D_height_minus").style.setProperty("display", "none");
        if (modifiers[7] < 99) document.getElementById("gm_4D_height_plus").style.setProperty("display", "inline-block");
        else document.getElementById("gm_4D_height_plus").style.setProperty("display", "none");
        document.getElementById("gm_4D_length_counter").innerHTML = modifiers[8];
        if (modifiers[8] > 1) document.getElementById("gm_4D_length_minus").style.setProperty("display", "inline-block");
        else document.getElementById("gm_4D_length_minus").style.setProperty("display", "none");
        if (modifiers[8] < 99) document.getElementById("gm_4D_length_plus").style.setProperty("display", "inline-block");
        else document.getElementById("gm_4D_length_plus").style.setProperty("display", "none");
        document.getElementById("gm_4D_depth_counter").innerHTML = modifiers[9];
        if (modifiers[9] > 1) document.getElementById("gm_4D_depth_minus").style.setProperty("display", "inline-block");
        else document.getElementById("gm_4D_depth_minus").style.setProperty("display", "none");
        if (modifiers[9] < 99) document.getElementById("gm_4D_depth_plus").style.setProperty("display", "inline-block");
        else document.getElementById("gm_4D_depth_plus").style.setProperty("display", "none");
    }
    else if (modifiers[5] != "Custom") {
        document.getElementById("gm_width_counter").innerHTML = width;
        document.getElementById("gm_height_counter").innerHTML = height;
        if (width > 1) document.getElementById("gm_width_minus").style.setProperty("display", "inline-block");
        else document.getElementById("gm_width_minus").style.setProperty("display", "none");
        if (height > 1) document.getElementById("gm_height_minus").style.setProperty("display", "inline-block");
        else document.getElementById("gm_height_minus").style.setProperty("display", "none");
        if (width < 9999) document.getElementById("gm_width_plus").style.setProperty("display", "inline-block");
        else document.getElementById("gm_width_plus").style.setProperty("display", "none");
        if (height < 9999) document.getElementById("gm_height_plus").style.setProperty("display", "inline-block");
        else document.getElementById("gm_height_plus").style.setProperty("display", "none");
    }
    if (gamemode == 50 && (modifiers[13] == "Interacting" || secretsFound[1])) {
        document.getElementById("GaussianDIVE_enter_button").style.setProperty("display", "block");
    }
    else {
        document.getElementById("GaussianDIVE_enter_button").style.setProperty("display", "none");
    }
    if (gamemode == 3 && (otherSecretStats[4] === 4 || secretsFound[4])) {
        document.getElementById("MergeOverflow256_enter_button").style.setProperty("display", "block");
    }
    else {
        document.getElementById("MergeOverflow256_enter_button").style.setProperty("display", "none");
    }
    if (gamemode == 1 && (mode_vars[1] >= 16 || secretsFound[5])) {
        document.getElementById("reciprocal512_enter_button").style.setProperty("display", "block");
    }
    else {
        document.getElementById("reciprocal512_enter_button").style.setProperty("display", "none");
    }
    if (gamemode == 34 && (modifiers[24] || secretsFound[6])) {
        document.getElementById("PA19683_enter_button").style.setProperty("display", "block");
    }
    else {
        document.getElementById("PA19683_enter_button").style.setProperty("display", "none");
    }
    if (gamemode == 1) { // 2048
        if (mode_vars[0]) {
            document.getElementById("2048_spawn_text").innerHTML = "To match the original 2048, 2s are the primary spawning tile.";
            document.getElementById("2048_spawn_text").style.setProperty("color", "#f9eee3");
            displayRules("rules_text", ["h2", "Powers of 2"], ["h1", "2048"], ["p", "Merges occur between two tiles of the same number. Get to the 2048 tile to win!"],
            [ "p", "Spawning tiles: 2 (90%), 4 (10%)"]);
            displayRules("gm_rules_text", ["h2", "Powers of 2"], ["h1", "2048"], ["p", "Merges occur between two tiles of the same number. Get to the 2048 tile to win!"],
            ["p", "Spawning tiles: 2 (90%), 4 (10%)"]);
        }
        else {
            document.getElementById("2048_spawn_text").innerHTML = "To match the rest of the 2048 Power Compendium modes, 1s are the primary spawning tile.";
            document.getElementById("2048_spawn_text").style.setProperty("color", "#ffffff");
            displayRules("rules_text", ["h2", "Powers of 2"], ["h1", "2048"], ["p", "Merges occur between two tiles of the same number. Get to the 2048 tile to win!"],
            ["p", "Spawning tiles: 1 (85%), 2 (12%), 4 (3%)"]);
            displayRules("gm_rules_text", ["h2", "Powers of 2"], ["h1", "2048"], ["p", "Merges occur between two tiles of the same number. Get to the 2048 tile to win!"],
            ["p", "Spawning tiles: 1 (85%), 2 (12%), 4 (3%)"]);
        }
        let spawnButtonClicks = mode_vars[1] - 1;
        if (spawnButtonClicks < 0 || spawnButtonClicks >= 15 || secretsFound[5]) spawnButtonClicks = 0;
        document.getElementById("2048_spawn_button").style.setProperty("background-color", evaluateColor(["@HSLA", 154, 100, 50 - spawnButtonClicks, 1]));
    }
    if (gamemode == 4) { // 3125
        if (mode_vars[0]) {
            document.getElementById("3125_3-1_text").innerHTML = "Any merge adding up to a number equal to, double, triple, or quadruple a power of five is allowed.";
            document.getElementById("3125_3-1_text").style.setProperty("color", "#f7ffe6");
            displayRules("rules_text", ["h2", "Powers of 5"], ["h1", "3125"], ["p","Merges occur between any two tiles that add to a power of five, double a power of five, triple a power of five, or quadruple a power of five. Get to the 3125 tile to win!"],
            ["p", "Spawning tiles: 1 (80%), 2 (8%), 3 (6%), 4 (4%), 5 (2%)"]);
            displayRules("gm_rules_text", ["h2", "Powers of 5"], ["h1", "3125"], ["p","Merges occur between any two tiles that add to a power of five, double a power of five, triple a power of five, or quadruple a power of five. Get to the 3125 tile to win!"],
            ["p", "Spawning tiles: 1 (80%), 2 (8%), 3 (6%), 4 (4%), 5 (2%)"]);
        }
        else {
            document.getElementById("3125_3-1_text").innerHTML = "Merges do not occur between a tile that's a power of five and a tile that's three times that power of five.";
            document.getElementById("3125_3-1_text").style.setProperty("color", "#669600");
            displayRules("rules_text", ["h2", "Powers of 5"], ["h1", "3125"], ["p","Merges occur between two equal tiles that are either a power of five or double a power of five, between a tile that's a power of five and a tile that's double that power of five, between a tile that's double a power of five and a tile that's triple that power of five, or between a tile that's a power of five and a tile that's quadruple that power of 5. Get to the 3125 tile to win!"],
            ["p", "Spawning tiles: 1 (80%), 2 (10%), 3 (4%), 4 (4%), 5 (2%)"]);
            displayRules("gm_rules_text", ["h2", "Powers of 5"], ["h1", "3125"], ["p","Merges occur between two equal tiles that are either a power of five or double a power of five, between a tile that's a power of five and a tile that's double that power of five, between a tile that's double a power of five and a tile that's triple that power of five, or between a tile that's a power of five and a tile that's quadruple that power of 5. Get to the 3125 tile to win!"],
            ["p", "Spawning tiles: 1 (80%), 2 (10%), 3 (4%), 4 (4%), 5 (2%)"]);
        }
    }
    else if (gamemode == 25) { // XXXX
        if (mode_vars[0] > Math.max(width, height, 2)) mode_vars[0] = Math.max(width, height, 2);
        if (mode_vars[1] > Math.max(width, height, 3) && mode_vars[1] != Infinity) mode_vars[1] = Math.max(width, height, 3);
        document.getElementById("XXXX_min_counter").innerHTML = mode_vars[0];
        if (mode_vars[1] == Infinity) document.getElementById("XXXX_max_counter").innerHTML = "&infin;";
        else document.getElementById("XXXX_max_counter").innerHTML = mode_vars[1];
        if (mode_vars[0] < 3) document.getElementById("XXXX_min_minus").style.setProperty("display", "none");
        else document.getElementById("XXXX_min_minus").style.setProperty("display", "inline-block");
        if (mode_vars[0] >= Math.max(width, height)) document.getElementById("XXXX_min_plus").style.setProperty("display", "none");
        else document.getElementById("XXXX_min_plus").style.setProperty("display", "inline-block");
        if (mode_vars[1] == Infinity) document.getElementById("XXXX_max_minus").style.setProperty("display", "none");
        else document.getElementById("XXXX_max_minus").style.setProperty("display", "inline-block");
        if (mode_vars[1] >= Math.max(width, height) && mode_vars[1] != Infinity) document.getElementById("XXXX_max_plus").style.setProperty("display", "none");
        else document.getElementById("XXXX_max_plus").style.setProperty("display", "inline-block");
    }
    if (gamemode == 26) { // 2584
        if (mode_vars[0] == 0) {
            if (modifiers[13] == "Interacting") document.getElementById("2584_previousNegative_text").innerHTML = "The only tiles of opposite signs that can merge are those with equal absolute value.";
            else document.getElementById("2584_previousNegative_text").innerHTML = "The only tiles of opposite signs cannot merge.";
            document.getElementById("2584_previousNegative_text").style.setProperty("color", "#0b4c00");
            displayRules("rules_text", ["h2", "Fibonacci Sequence"], ["h1", "2584"], ["p", "Merges occur between two 1s or between any tile above 1 and the tile before it. Get to the 2584 tile to win!"],
            ["p", "Spawning tiles: 1 (85%), 2 (10%), 3 (5%)"]);
            displayRules("gm_rules_text", ["h2", "Fibonacci Sequence"], ["h1", "2584"], ["p", "Merges occur between two 1s or between any tile above 1 and the tile before it. Get to the 2584 tile to win!"],
            ["p", "Spawning tiles: 1 (85%), 2 (10%), 3 (5%)"]);
        }
        else if (mode_vars[0] == 1) {
            document.getElementById("2584_previousNegative_text").innerHTML = "A tile of one sign can merge with the previous tile of the other sign.";
            document.getElementById("2584_previousNegative_text").style.setProperty("color", "#00444c");
            displayRules("rules_text", ["h2", "Fibonacci Sequence"], ["h1", "2584"], ["p", "Merges occur between two 1s, or between any tile above 1 and the tile before it (where either tile could be either sign). Get to the 2584 tile to win!"],
            ["p", "Spawning tiles: 1 (85%), 2 (10%), 3 (5%)"]);
            displayRules("gm_rules_text", ["h2", "Fibonacci Sequence"], ["h1", "2584"], ["p", "Merges occur between two 1s, or between any tile above 1 and the tile before it (where either tile could be either sign). Get to the 2584 tile to win!"],
            ["p", "Spawning tiles: 1 (85%), 2 (10%), 3 (5%)"]);
        }
        else if (mode_vars[0] == 2) {
            document.getElementById("2584_previousNegative_text").innerHTML = "A tile of one sign can merge with the previous tile of the other sign, but only if the negative tile is actually in the Fibonacci sequence as a negative term.";
            document.getElementById("2584_previousNegative_text").style.setProperty("color", "#0e004c");
            displayRules("rules_text", ["h2", "Fibonacci Sequence"], ["h1", "2584"], ["p", "Merges occur between two 1s or between any tile above 1 and the tile before it. The tiles could be opposite signs, but only if the negative tile's position in the tile order is odd (1, 3, 8, 21, 55, etc.) and the positive tile's position in the tile order is even (2, 5, 13, 34, 89, etc.). Get to the 2584 tile to win!"],
            ["p", "Spawning tiles: 1 (85%), 2 (10%), 3 (5%)"]);
            displayRules("gm_rules_text", ["h2", "Fibonacci Sequence"], ["h1", "2584"], ["p", "Merges occur between two 1s or between any tile above 1 and the tile before it. The tiles could be opposite signs, but only if the negative tile's position in the tile order is odd (1, 3, 8, 21, 55, etc.) and the positive tile's position in the tile order is even (2, 5, 13, 34, 89, etc.). Get to the 2584 tile to win!"],
            ["p", "Spawning tiles: 1 (85%), 2 (10%), 3 (5%)"]);
        }
    }
    else if (gamemode == 31) { // Isotopic 256
        document.getElementById("Isotopic256_halfLife_change").value = mode_vars[0];
    }
    else if (gamemode == 37) { // 2216.8378200531005859375
        document.getElementById("ThreeHalves_partialModeMerges").style.setProperty("display", "none");
        if (mode_vars[0] == 0) {
            document.getElementById("ThreeHalves_mode_text").innerHTML = "Two of the same power of 1.5 merge partially, with half of the colliding tile being absorbed into the resulting tile.";
            document.getElementById("ThreeHalves_mode_text").style.setProperty("color", "#406abf");
            document.getElementById("ThreeHalves_partialModeMerges").style.setProperty("display", "block");
            if (mode_vars[1] == 0) {
                document.getElementById("ThreeHalves_partialModeMerges_text").innerHTML = "0.5 + 0.5 = 1 is a valid merge, 1 + 0.5 = 1.5 is not.";
                document.getElementById("ThreeHalves_partialModeMerges_text").style.setProperty("color", "#ea7656");
                displayRules("rules_text", ["h2", "Powers of 1.5"], ["h1", "2216.8378200531005859375"], ["p","Merges occur between two tiles that are the same number. Tiles that are a power of 1.5 will only merge partially, with only half of the colliding tile absorbed into the result, so two 1s merge into a 1.5 and a 0.5, while two 1.5s merge into a 2.25 and a 0.75. If the tiles are not powers of 1.5, they merge entirely, so two 0.5s merge into a 1. Get to the 2216.838 (1.5<sup>19</sup>) tile to win!"],
                ["p", "Spawning tiles: 1 (80%), 0.5 (10%), 1.5 (10%)"]);
                displayRules("gm_rules_text", ["h2", "Powers of 1.5"], ["h1", "2216.8378200531005859375"], ["p","Merges occur between two tiles that are the same number. Tiles that are a power of 1.5 will only merge partially, with only half of the colliding tile absorbed into the result, so two 1s merge into a 1.5 and a 0.5, while two 1.5s merge into a 2.25 and a 0.75. If the tiles are not powers of 1.5, they merge entirely, so two 0.5s merge into a 1. Get to the 2216.838 (1.5<sup>19</sup>) tile to win!"],
                ["p", "Spawning tiles: 1 (80%), 0.5 (10%), 1.5 (10%)"]);
            }
            else if (mode_vars[1] == 1) {
                document.getElementById("ThreeHalves_partialModeMerges_text").innerHTML = "1 + 0.5 = 1.5 is a valid merge, 0.5 + 0.5 = 1 is not.";
                document.getElementById("ThreeHalves_partialModeMerges_text").style.setProperty("color", "#d1ea56");
                displayRules("rules_text", ["h2", "Powers of 1.5"], ["h1", "2216.8378200531005859375"], ["p","Merges occur between two tiles that are the same number and a power of 1.5. Tiles that are a power of 1.5 will only merge partially, with only half of the colliding tile absorbed into the result, so two 1s merge into a 1.5 and a 0.5, while two 1.5s merge into a 2.25 and a 0.75. A tile that is a power of 1.5 can also merge with the tile that's half of it, and those two tiles will merge entirely. Get to the 2216.838 (1.5<sup>19</sup>) tile to win!"],
                ["p", "Spawning tiles: 1 (80%), 0.5 (10%), 1.5 (10%)"]);
                displayRules("gm_rules_text", ["h2", "Powers of 1.5"], ["h1", "2216.8378200531005859375"], ["p","Merges occur between two tiles that are the same number and a power of 1.5. Tiles that are a power of 1.5 will only merge partially, with only half of the colliding tile absorbed into the result, so two 1s merge into a 1.5 and a 0.5, while two 1.5s merge into a 2.25 and a 0.75. A tile that is a power of 1.5 can also merge with the tile that's half of it, and those two tiles will merge entirely. Get to the 2216.838 (1.5<sup>19</sup>) tile to win!"],
                ["p", "Spawning tiles: 1 (80%), 0.5 (10%), 1.5 (10%)"]);
            }
            else if (mode_vars[1] == 2) {
                document.getElementById("ThreeHalves_partialModeMerges_text").innerHTML = "0.5 + 0.5 = 1 and 1 + 0.5 = 1.5 are both valid merges.";
                document.getElementById("ThreeHalves_partialModeMerges_text").style.setProperty("color", "#c0853d");
                displayRules("rules_text", ["h2", "Powers of 1.5"], ["h1", "2216.8378200531005859375"], ["p","Merges occur between two tiles that are the same number. Tiles that are a power of 1.5 will only merge partially, with only half of the colliding tile absorbed into the result, so two 1s merge into a 1.5 and a 0.5, while two 1.5s merge into a 2.25 and a 0.75. If the tiles are not powers of 1.5, they merge entirely, so two 0.5s merge into a 1. A tile that is a power of 1.5 can also merge with the tile that's half of it, and those two tiles will merge entirely. Get to the 2216.838 (1.5<sup>19</sup>) tile to win!"],
                ["p", "Spawning tiles: 1 (80%), 0.5 (10%), 1.5 (10%)"]);
                displayRules("gm_rules_text", ["h2", "Powers of 1.5"], ["h1", "2216.8378200531005859375"], ["p","Merges occur between two tiles that are the same number. Tiles that are a power of 1.5 will only merge partially, with only half of the colliding tile absorbed into the result, so two 1s merge into a 1.5 and a 0.5, while two 1.5s merge into a 2.25 and a 0.75. If the tiles are not powers of 1.5, they merge entirely, so two 0.5s merge into a 1. A tile that is a power of 1.5 can also merge with the tile that's half of it, and those two tiles will merge entirely. Get to the 2216.838 (1.5<sup>19</sup>) tile to win!"],
                ["p", "Spawning tiles: 1 (80%), 0.5 (10%), 1.5 (10%)"]);
            }
        }
        else if (mode_vars[0] == 1) {
            document.getElementById("ThreeHalves_mode_text").innerHTML = "There are &#247;2 tiles that can merge with any power of 1.5, and merges occur between a tile that's a power of 1.5 and a tile that's half of it, or between two equal tiles that are not a power of 1.5.";
            document.getElementById("ThreeHalves_mode_text").style.setProperty("color", "#a83fce");
            displayRules("rules_text", ["h2", "Powers of 1.5"], ["h1", "2216.8378200531005859375"], ["p", "Merges occur between a tile that's a power of 1.5 and a tile that's half of that power of 1.5, or between two equal tiles that are not a power of 1.5. There are also &#247;2 tiles, which can merge with any power of 1.5 (or with themselves to reduce clutter). Get to the 2216.838 (1.5<sup>19</sup>) tile to win!"],
            ["p", "Spawning tiles: 1 (50%), &#247;2 (50%)"])
            displayRules("gm_rules_text", ["h2", "Powers of 1.5"], ["h1", "2216.8378200531005859375"], ["p", "Merges occur between a tile that's a power of 1.5 and a tile that's half of that power of 1.5, or between two equal tiles that are not a power of 1.5. There are also &#247;2 tiles, which can merge with any power of 1.5 (or with themselves to reduce clutter). Get to the 2216.838 (1.5<sup>19</sup>) tile to win!"],
            ["p", "Spawning tiles: 1 (50%), &#247;2 (50%)"]);
        }
        else if (mode_vars[0] == 2) {
            document.getElementById("ThreeHalves_mode_text").innerHTML = "Three of the same power of 1.5 merge into two of the next power of 1.5.";
            document.getElementById("ThreeHalves_mode_text").style.setProperty("color", "#b53353");
            displayRules("rules_text", ["h2", "Powers of 1.5"], ["h1", "2216.8378200531005859375"], ["p", "Three equal tiles merge into two of the next tile. Get to the 2216.838 (1.5<sup>19</sup>) tile to win!"],
            ["p", "Spawning tiles: 1 (72%), 1.5 (16%), 2.25 (8%), 3.375 (4%)"])
            displayRules("gm_rules_text", ["h2", "Powers of 1.5"], ["h1", "2216.8378200531005859375"], ["p", "Three equal tiles merge into two of the next tile. Get to the 2216.838 (1.5<sup>19</sup>) tile to win!"],
            ["p", "Spawning tiles: 1 (72%), 1.5 (16%), 2.25 (8%), 3.375 (4%)"]);
        }
    }
    else if (gamemode == 38) { // 180
        if (mode_vars[0] == 0) {
            document.getElementById("180_length_text").innerHTML = "Merges occur between 2, 3, or 5 of the same tile.";
            document.getElementById("180_length_text").style.setProperty("color", "#0055d5");
            displayRules("rules_text", ["h2", "5-Smooth Supermerging"], ["h1", "180"], ["p", "Merges occur between exactly two, three, or five tiles of the same number - note that a line of four, six, etc. of the same tile will not merge! Get to the 180 tile to win, or see how many different tiles you can discover!"],
            ["p", "Spawning tiles: 1 (100%)"]);
            displayRules("gm_rules_text", ["h2", "5-Smooth Supermerging"], ["h1", "180"], ["p", "Merges occur between exactly two, three, or five tiles of the same number - note that a line of four, six, etc. of the same tile will not merge! Get to the 180 tile to win, or see how many different tiles you can discover!"],
            ["p", "Spawning tiles: 1 (100%)"]);
        }
        else if (mode_vars[0] == 1) {
            document.getElementById("180_length_text").innerHTML = "Merges occur between a prime number amount of the same tile.";
            document.getElementById("180_length_text").style.setProperty("color", "#0c2e00");
            displayRules("rules_text", ["h2", "Prime Supermerging"], ["h1", "180"], ["p", "Merges occur between a prime number amount (2, 3, 5, 7, etc.) tiles of the same number - note that a line of four, six, etc. of the same tile will not merge! Get to the 180 tile to win, or see how many different tiles you can discover!"],
            ["p", "Spawning tiles: 1 (100%)"]);
            displayRules("gm_rules_text", ["h2", "Prime Supermerging"], ["h1", "180"], ["p", "Merges occur between a prime number amount (2, 3, 5, 7, etc.) tiles of the same number - note that a line of four, six, etc. of the same tile will not merge! Get to the 180 tile to win, or see how many different tiles you can discover!"],
            ["p", "Spawning tiles: 1 (100%)"]);
        }
        else if (mode_vars[0] == 2) {
            document.getElementById("180_length_text").innerHTML = "Merges occur between any amount of the same tile.";
            document.getElementById("180_length_text").style.setProperty("color", "#ff6e46");
            displayRules("rules_text", ["h2", "Supermerging"], ["h1", "180"], ["p", "Merges occur between any amount of the same tile. Get to the 180 tile to win, or see how many different tiles you can discover!"],
            ["p", "Spawning tiles: 1 (100%)"]);
            displayRules("gm_rules_text", ["h2", "Supermerging"], ["h1", "180"], ["p", "Merges occur between any amount of the same tile. Get to the 180 tile to win, or see how many different tiles you can discover!"],
            ["p", "Spawning tiles: 1 (100%)"]);
        }
        if (mode_vars[1] == 0) {
            document.getElementById("180_randomGoals_text").innerHTML = "Random goals are disabled.";
            document.getElementById("180_randomGoals_text").style.setProperty("color", "#22002d");
        }
        else if (mode_vars[1] == 1) {
            document.getElementById("180_randomGoals_text").innerHTML = "Random goals build upon the previous goals.";
            document.getElementById("180_randomGoals_text").style.setProperty("color", "#732a8b");
        }
        else if (mode_vars[1] == 2) {
            document.getElementById("180_randomGoals_text").innerHTML = "Random goals are entirely random.";
            document.getElementById("180_randomGoals_text").style.setProperty("color", "#ba77d0");
        }
        document.getElementById("180_firstGoalMinimum").style.setProperty("display", (mode_vars[1] == 0) ? "none" : "block");
        document.getElementById("180_firstGoalMinimum_change").value = mode_vars[2];
    }
    else if (gamemode == 39) { // 2592
        if (mode_vars[0] == 0) {
            document.getElementById("2592_switch_text").innerHTML = "The merge rules switch after each move.";
            document.getElementById("2592_switch_text").style.setProperty("color", "#7cffb5");
            displayRules("rules_text", ["h2", "3-Smooth Numbers"], ["h1", "2592"], ["p", "The merge rules switch after each move. On even-numbered moves, merges occur between two equal tiles. On odd-numbered moves, merges occur between three equal tiles. Get to the 2592 tile to win!"],
            ["p", "Spawning tiles: 1 (90%), 2 (5%), 3 (5%)"]);
            displayRules("gm_rules_text", ["h2", "3-Smooth Numbers"], ["h1", "2592"], ["p", "The merge rules switch after each move. On even-numbered moves, merges occur between two equal tiles. On odd-numbered moves, merges occur between three equal tiles. Get to the 2592 tile to win!"],
            ["p", "Spawning tiles: 1 (90%), 2 (5%), 3 (5%)"]);
        }
        else if (mode_vars[0] == 1) {
            document.getElementById("2592_switch_text").innerHTML = "The merge rules switch after each move where a merge occurs.";
            document.getElementById("2592_switch_text").style.setProperty("color", "#ffd500");
            displayRules("rules_text", ["h2", "3-Smooth Numbers"], ["h1", "2592"], ["p", "The merge rules switch after each move where a merge occurs. At first, merges occur between two equal tiles. After the first move where a merge occurs, merges occur between three equal tiles. The merge rules alternate between these two states. Get to the 2592 tile to win!"],
            ["p", "Spawning tiles: 1 (90%), 2 (5%), 3 (5%)"]);
            displayRules("gm_rules_text", ["h2", "3-Smooth Numbers"], ["h1", "2592"], ["p", "The merge rules switch after each move where a merge occurs. At first, merges occur between two equal tiles. After the first move where a merge occurs, merges occur between three equal tiles. The merge rules alternate between these two states. Get to the 2592 tile to win!"],
            ["p", "Spawning tiles: 1 (90%), 2 (5%), 3 (5%)"]);
        }
        else if (mode_vars[0] == 2) {
            document.getElementById("2592_switch_text").innerHTML = "The merge rules switch based on the amount of merges that have happened so far, not counting the current turn.";
            document.getElementById("2592_switch_text").style.setProperty("color", "#9d00ff");
            displayRules("rules_text", ["h2", "3-Smooth Numbers"], ["h1", "2592"], ["p", "The merge rules switch based on the amount of merges that have happened in the game thus far. If the amount of merges is even, merges occur between two equal tiles. If the amount of merges is odd, merges occur between three equal tiles. The merge count only updates after each move, so the merge rules won't change in the middle of a move. Get to the 2592 tile to win!"],
            ["p", "Spawning tiles: 1 (90%), 2 (5%), 3 (5%)"]);
            displayRules("gm_rules_text", ["h2", "3-Smooth Numbers"], ["h1", "2592"], ["p", "The merge rules switch based on the amount of merges that have happened in the game thus far. If the amount of merges is even, merges occur between two equal tiles. If the amount of merges is odd, merges occur between three equal tiles. The merge count only updates after each move, so the merge rules won't change in the middle of a move. Get to the 2592 tile to win!"],
            ["p", "Spawning tiles: 1 (90%), 2 (5%), 3 (5%)"]);
        }
        if (mode_vars[1] == 0) {
            document.getElementById("2592_randomGoals_text").innerHTML = "Random goals are disabled.";
            document.getElementById("2592_randomGoals_text").style.setProperty("color", "#22002d");
        }
        else if (mode_vars[1] == 1) {
            document.getElementById("2592_randomGoals_text").innerHTML = "Random goals build upon the previous goals.";
            document.getElementById("2592_randomGoals_text").style.setProperty("color", "#732a8b");
        }
        else if (mode_vars[1] == 2) {
            document.getElementById("2592_randomGoals_text").innerHTML = "Random goals are entirely random.";
            document.getElementById("2592_randomGoals_text").style.setProperty("color", "#ba77d0");
        }
        document.getElementById("2592_firstGoalMinimum").style.setProperty("display", (mode_vars[1] == 0) ? "none" : "block");
        document.getElementById("2592_firstGoalMinimum_change").value = mode_vars[2];
    }
    else if (gamemode == 40) { // Wildcard 2048
        if (mode_vars[0] == 1) {
            document.getElementById("Wildcard2048_add_text").innerHTML = "When two tiles merge, all of their possibilities combine.";
            document.getElementById("Wildcard2048_add_text").style.setProperty("color", "#b83f1a");
        }
        else if (mode_vars[0] == 2) {
            document.getElementById("Wildcard2048_add_text").innerHTML = "Some tiles contain multiple tiles at once instead of acting as one of multiple tiles.";
            document.getElementById("Wildcard2048_add_text").style.setProperty("color", "#bb9e4d");
        }
        else {
            document.getElementById("Wildcard2048_add_text").innerHTML = "When two tiles merge, only the possibilities they both share remain.";
            document.getElementById("Wildcard2048_add_text").style.setProperty("color", "#524439");
        }
        if (mode_vars[1]) {
            document.getElementById("Wildcard2048_chaosSpawns_text").innerHTML = "All tiles spawned are crazy combination tiles.";
            document.getElementById("Wildcard2048_chaosSpawns_text").style.setProperty("color", "#dd88ff");
        }
        else {
            document.getElementById("Wildcard2048_chaosSpawns_text").innerHTML = "Crazy combination tiles only spawn 4% of the time.";
            document.getElementById("Wildcard2048_chaosSpawns_text").style.setProperty("color", "#ffbfa4");
        }
        let spawnText;
        if (mode_vars[1]) spawnText = ["p", "Tiles spawned could be any combination of tiles up to (but not including) the highest power of 2 you've reached, but they're biased towards smaller values."];
        else spawnText = ["p", "Spawning tiles: 1 (35%), 2 (15%), 4 (10%), 1 2 (12%), 1 4 (8%), 2 4 (8%), 1 2 4 (8%). The remaining 4% chance spawns a tile that could be any combination of tiles up to (but not including) the highest power of 2 you've reached, but is biased towards smaller values."];
        if (mode_vars[0] == 1) {
            displayRules("rules_text", ["h1", "Wildcard 2048 (Melting Pot Mode)"], ["p", "2048, but some tiles can act as multiple tiles, such as a \"2 4\" tile, which could merge with a 2 or with a 4. Two of these \"wildcard\" tiles can merge as long as they share at least one possibility. When two tiles merge, they combine in a \"melting pot\" fashion: for example, a 4 tile and a 2 4 tile merge into an 8 2 tile, while a 1 2 tile and a 1 4 tile merge into an 8 tile. To win, you must make a regular 2048 tile - a tile with 2048 as one of its multiple possibilities doesn't count!"],
            spawnText);
            displayRules("gm_rules_text", ["h1", "Wildcard 2048 (Melting Pot Mode)"], ["p", "2048, but some tiles can act as multiple tiles, such as a \"2 4\" tile, which could merge with a 2 or with a 4. Two of these \"wildcard\" tiles can merge as long as they share at least one possibility. When two tiles merge, they combine in a \"melting pot\" fashion: for example, a 4 tile and a 2 4 tile merge into an 8 2 tile, while a 1 2 tile and a 1 4 tile merge into an 8 tile. To win, you must make a regular 2048 tile - a tile with 2048 as one of its multiple possibilities doesn't count!"],
            spawnText);
        }
        else if (mode_vars[0] == 2) {
            displayRules("rules_text", ["h1", "Multitile 2048"], ["p", "2048, but some tiles contain multiple tiles, such as a \"2 4\" tile, which contains both a 2 and a 4. Two tiles can only merge if every tile the one that contains less tiles contains is also part of the one that contains more tiles, and only the tiles they share are merged. For example, a 2 4 tile and a 2 4 16 tile share the 2 and 4 possibilities, so they merge into a 4 8 16 tile - the 2s and the 4s merged, but the 8 did not. If the resulting tile would contain multiple copies of the same tile, only one of those copies remains. To win, you must make a regular 2048 tile - a multitile with 2048 as one of the tiles it contains doesn't count!"],
            spawnText);
            displayRules("gm_rules_text", ["h1", "Multitile 2048"], ["p", "2048, but some tiles contain multiple tiles, such as a \"2 4\" tile, which contains both a 2 and a 4. Two tiles can only merge if every tile the one that contains less tiles contains is also part of the one that contains more tiles, and only the tiles they share are merged. For example, a 2 4 tile and a 2 4 16 tile share the 2 and 4 possibilities, so they merge into a 4 8 16 tile - the 2s and the 4s merged, but the 8 did not. If the resulting tile would contain multiple copies of the same tile, only one of those copies remains. To win, you must make a regular 2048 tile - a multitile with 2048 as one of the tiles it contains doesn't count!"],
            spawnText);
        }
        else {
            displayRules("rules_text", ["h1", "Wildcard 2048"], ["p", "2048, but some tiles can act as multiple tiles, such as a \"2 4\" tile, which could merge with a 2 to make a 4, or it could merge with a 4 to make an 8. Two of these \"wildcard\" tiles can merge as long as they share at least one possibility, and the result of their merge is a tile that contains all of the possibilities they both had, but doubled since they just merged. For example, a 1 2 4 tile and a 2 4 8 tile share the 2 and 4 possibilities, so they merge into a 4 8 tile. To win, you must make a regular 2048 tile - a tile with 2048 as one of its multiple possibilities doesn't count!"],
            spawnText);
            displayRules("gm_rules_text", ["h1", "Wildcard 2048"], ["p", "2048, but some tiles can act as multiple tiles, such as a \"2 4\" tile, which could merge with a 2 to make a 4, or it could merge with a 4 to make an 8. Two of these \"wildcard\" tiles can merge as long as they share at least one possibility, and the result of their merge is a tile that contains all of the possibilities they both had, but doubled since they just merged. For example, a 1 2 4 tile and a 2 4 8 tile share the 2 and 4 possibilities, so they merge into a 4 8 tile. To win, you must make a regular 2048 tile - a tile with 2048 as one of its multiple possibilities doesn't count!"],
            spawnText);
        }
    }
    else if (gamemode == 41) { // X^Y
        if (mode_vars[0] == 2n**1024n) document.getElementById("XpowY_pow_counter").innerHTML = "&infin;";
        else document.getElementById("XpowY_pow_counter").innerHTML = mode_vars[0];
        document.getElementById("XpowY_merge_counter").innerHTML = mode_vars[1];
        if (mode_vars[1] < 5) document.getElementById("XpowY_merge_minus").style.setProperty("display", "none");
        else document.getElementById("XpowY_merge_minus").style.setProperty("display", "inline-block");
        document.getElementById("XpowY_merge_plus").style.setProperty("display", "inline-block");
    }
    else if (gamemode == 43) { // 1321
        if (mode_vars[0]) {
            document.getElementById("1321_evensOnly_text").innerHTML = "+1s can only merge with even numbers.";
            document.getElementById("1321_evensOnly_text").style.setProperty("color", "#ff5656");
            displayRules("rules_text", ["h1", "1321"], ["p", "Merges occur between two equal tiles, but there are also +1 tiles that can merge with any even number. Get to the 1321 tile to win (your first task is figuring out how to get there...). If you're looking for a different kind of challenge, see how many different multiples of 32 you can make!"],
            ["p", "Spawning tiles: 1 (70%), +1 (30%)"]);
            displayRules("gm_rules_text", ["h1", "1321"], ["p", "Merges occur between two equal tiles, but there are also +1 tiles that can merge with any even number. Get to the 1321 tile to win (your first task is figuring out how to get there...). If you're looking for a different kind of challenge, see how many different multiples of 32 you can make!"],
            ["p", "Spawning tiles: 1 (70%), +1 (30%)"]);
        }
        else {
            document.getElementById("1321_evensOnly_text").innerHTML = "+1s can merge with any tile.";
            document.getElementById("1321_evensOnly_text").style.setProperty("color", "#dada47");
            displayRules("rules_text", ["h1", "1321"], ["p", "Merges occur between two equal tiles, but there are also +1 tiles that can merge with anything. Get to the 1321 tile to win (your first task is figuring out how to get there...). If you're looking for a different kind of challenge, see how many different multiples of 32 you can make!"],
            ["p", "Spawning tiles: 1 (70%), +1 (30%)"]);
            displayRules("gm_rules_text", ["h1", "1321"], ["p", "Merges occur between two equal tiles, but there are also +1 tiles that can merge with anything. Get to the 1321 tile to win (your first task is figuring out how to get there...). If you're looking for a different kind of challenge, see how many different multiples of 32 you can make!"],
            ["p", "Spawning tiles: 1 (70%), +1 (30%)"]);
        }
        if (mode_vars[1] == 0) {
            document.getElementById("1321_randomGoals_text").innerHTML = "Random goals are disabled.";
            document.getElementById("1321_randomGoals_text").style.setProperty("color", "#22002d");
        }
        else if (mode_vars[1] == 1) {
            document.getElementById("1321_randomGoals_text").innerHTML = "Random goals build upon the previous goals.";
            document.getElementById("1321_randomGoals_text").style.setProperty("color", "#732a8b");
        }
        else if (mode_vars[1] == 2) {
            document.getElementById("1321_randomGoals_text").innerHTML = "Random goals are entirely random.";
            document.getElementById("1321_randomGoals_text").style.setProperty("color", "#ba77d0");
        }
        if (mode_vars[1] == 0) {
            document.getElementById("1321_firstGoalMinimum").style.setProperty("display", "none");
        }
        else {
            document.getElementById("1321_firstGoalMinimum").style.setProperty("display", "block");
            document.getElementById("1321_firstGoalMinimum_counter").innerHTML = mode_vars[2];
            if (mode_vars[2] < 3) document.getElementById("1321_firstGoalMinimum_minus").style.setProperty("display", "none");
            else document.getElementById("1321_firstGoalMinimum_minus").style.setProperty("display", "inline-block");
        }
    }
    else if (gamemode == 45) { // Directional Merges
        // Not only does this mode have different difficulties, it also behaves differently when the movement directions are altered by the grid modifiers
        if (((modifiers[5] == "Square" || modifiers[5] == "Diamond") && modifiers[10] == "Orthogonal") || (modifiers[5] == "Checkerboard") && modifiers[10] == "Diagonal") { // Orthogonal only
            if (mode_vars[0] == 1) { // Easy
                document.getElementById("2100_difficulty_text").innerHTML = "Easy: rightwards and downwards are X + X, leftwards and upwards are X + 2X.";
                document.getElementById("2100_difficulty_text").style.setProperty("color", "#a0d4ff");
                document.getElementById("2100_difficulty_decrease").style.setProperty("display", "none");
                document.getElementById("2100_difficulty_increase").style.setProperty("display", "block");
                displayRules("rules_text", ["h2", "Directional Merges (Easy)"], ["h1", "1944"], ["p","The merge rules are different depending on which direction you're moving. On a rightwards or downwards move, merges occur between two equal tiles. On a leftwards or upwards move, merges occur between an X tile and a 2X tile, for any X. Get to the 1944 tile to win!"],
                ["p", "Spawning tiles: 1 (100%)"]);
                displayRules("gm_rules_text", ["h2", "Directional Merges (Easy)"], ["h1", "1944"], ["p","The merge rules are different depending on which direction you're moving. On a rightwards or downwards move, merges occur between two equal tiles. On a leftwards or upwards move, merges occur between an X tile and a 2X tile, for any X. Get to the 1944 tile to win!"],
                ["p", "Spawning tiles: 1 (100%)"]);
                MergeRules = [
                    [2, [["@HDir", ">", 0], "||", ["@VDir", ">", 0], "&&", ["@This 0", "=", "@Next 1 0"], "&&", ["@This 1", "=", "@Next 1 1"], "&&", ["@This 2", "=", "@Next 1 2"], "&&", ["@This 3", "=", "@Next 1 3"], "&&", ["@This 4", "=", "@Next 1 4"], "&&", ["@This 5", "=", "@Next 1 5"]], false, [[["@This 0", "+", 1], "@This 1", "@This 2", "@This 3", "@This 4", "@This 5"]], [[2, "^", "@This 0"], "*", [3, "^", "@This 1"], "*", [5, "^", "@This 2"], "*", [7, "^", "@This 3"], "*", [11, "^", "@This 4"], "*", [13, "^", "@This 5"], "*", 2], [false, true]],
                    [2, [["@HDir", "<", 0], "||", ["@VDir", "<", 0], "&&", ["@This 0", "+", 1, "=", "@Next 1 0"], "&&", ["@This 1", "=", "@Next 1 1"], "&&", ["@This 2", "=", "@Next 1 2"], "&&", ["@This 3", "=", "@Next 1 3"], "&&", ["@This 4", "=", "@Next 1 4"], "&&", ["@This 5", "=", "@Next 1 5"]], false, [["@This 0", ["@This 1", "+", 1], "@This 2", "@This 3", "@This 4", "@This 5"]], [[2, "^", "@This 0"], "*", [3, "^", "@This 1"], "*", [5, "^", "@This 2"], "*", [7, "^", "@This 3"], "*", [11, "^", "@This 4"], "*", [13, "^", "@This 5"], "*", 3], [false, true]]
                ];
                winConditions = [[3, 5, 0, 0, 0, 0]];
                document.documentElement.style.setProperty("background-image", "linear-gradient(#90cdff, #00447c)");
                document.documentElement.style.setProperty("--background-color", "linear-gradient(#73c0ff, #005eac)");
                document.documentElement.style.setProperty("--grid-color", "#125c99");
                document.documentElement.style.setProperty("--tile-color", "#3f89c6");
                document.documentElement.style.setProperty("--text-color", "#003159");
            }
            else if (mode_vars[0] == 2) { // Medium
                document.getElementById("2100_difficulty_text").innerHTML = "Medium: rightwards is X + X, downwards is X + 2X, leftwards is X + 3X, upwards is 2X + 3X.";
                document.getElementById("2100_difficulty_text").style.setProperty("color", "#7573ff");
                document.getElementById("2100_difficulty_decrease").style.setProperty("display", "block");
                document.getElementById("2100_difficulty_increase").style.setProperty("display", "block");
                displayRules("rules_text", ["h2", "Directional Merges (Medium)"], ["h1", "2160"], ["p","The merge rules are different depending on which direction you're moving. On a rightwards move, merges occur between two equal tiles. On a downwards move, merges occur between an X tile and a 2X tile, for any X. On a leftwards move, merges occur between an X tile and a 3X tile, for any X. On an upwards move, merges occur between a 2X tile and a 3X tile, for any X. Get to the 2160 tile to win!"],
                ["p", "Spawning tiles: 1 (100%)"]);
                displayRules("gm_rules_text", ["h2", "Directional Merges (Medium)"], ["h1", "2160"], ["p","The merge rules are different depending on which direction you're moving. On a rightwards move, merges occur between two equal tiles. On a downwards move, merges occur between an X tile and a 2X tile, for any X. On a leftwards move, merges occur between an X tile and a 3X tile, for any X. On an upwards move, merges occur between a 2X tile and a 3X tile, for any X. Get to the 2160 tile to win!"],
                ["p", "Spawning tiles: 1 (100%)"]);
                MergeRules = [
                    [2, [["@HDir", ">", 0], "&&", ["@This 0", "=", "@Next 1 0"], "&&", ["@This 1", "=", "@Next 1 1"], "&&", ["@This 2", "=", "@Next 1 2"], "&&", ["@This 3", "=", "@Next 1 3"], "&&", ["@This 4", "=", "@Next 1 4"], "&&", ["@This 5", "=", "@Next 1 5"]], false, [[["@This 0", "+", 1], "@This 1", "@This 2", "@This 3", "@This 4", "@This 5"]], [[2, "^", "@This 0"], "*", [3, "^", "@This 1"], "*", [5, "^", "@This 2"], "*", [7, "^", "@This 3"], "*", [11, "^", "@This 4"], "*", [13, "^", "@This 5"], "*", 2], [false, true]],
                    [2, [["@VDir", ">", 0], "&&", ["@This 0", "+", 1, "=", "@Next 1 0"], "&&", ["@This 1", "=", "@Next 1 1"], "&&", ["@This 2", "=", "@Next 1 2"], "&&", ["@This 3", "=", "@Next 1 3"], "&&", ["@This 4", "=", "@Next 1 4"], "&&", ["@This 5", "=", "@Next 1 5"]], false, [["@This 0", ["@This 1", "+", 1], "@This 2", "@This 3", "@This 4", "@This 5"]], [[2, "^", "@This 0"], "*", [3, "^", "@This 1"], "*", [5, "^", "@This 2"], "*", [7, "^", "@This 3"], "*", [11, "^", "@This 4"], "*", [13, "^", "@This 5"], "*", 3], [false, true]],
                    [2, [["@HDir", "<", 0], "&&", ["@This 0", "=", "@Next 1 0"], "&&", ["@This 1", "+", 1, "=", "@Next 1 1"], "&&", ["@This 2", "=", "@Next 1 2"], "&&", ["@This 3", "=", "@Next 1 3"], "&&", ["@This 4", "=", "@Next 1 4"], "&&", ["@This 5", "=", "@Next 1 5"]], false, [[["@This 0", "+", 2], "@This 1", "@This 2", "@This 3", "@This 4", "@This 5"]], [[2, "^", "@This 0"], "*", [3, "^", "@This 1"], "*", [5, "^", "@This 2"], "*", [7, "^", "@This 3"], "*", [11, "^", "@This 4"], "*", [13, "^", "@This 5"], "*", 4], [false, true]],
                    [2, [["@VDir", "<", 0], "&&", ["@This 0", "-", 1, "=", "@Next 1 0"], "&&", ["@This 1", "+", 1, "=", "@Next 1 1"], "&&", ["@This 2", "=", "@Next 1 2"], "&&", ["@This 3", "=", "@Next 1 3"], "&&", ["@This 4", "=", "@Next 1 4"], "&&", ["@This 5", "=", "@Next 1 5"]], false, [[["@This 0", "-", 1], "@This 1", ["@This 2", "+", 1], "@This 3", "@This 4", "@This 5"]], [[2, "^", "@This 0"], "*", [3, "^", "@This 1"], "*", [5, "^", "@This 2"], "*", [7, "^", "@This 3"], "*", [11, "^", "@This 4"], "*", [13, "^", "@This 5"], "*", 5, "/", 2], [false, true]]
                ];
                winConditions = [[4, 3, 1, 0, 0, 0]];
                document.documentElement.style.setProperty("background-image", "linear-gradient(#c2acff, #004f4f)");
                document.documentElement.style.setProperty("--background-color", "linear-gradient(#926aff, #008383)");
                document.documentElement.style.setProperty("--grid-color", "#218383");
                document.documentElement.style.setProperty("--tile-color", "#977ce1");
                document.documentElement.style.setProperty("--text-color", "#23144e");
            }
            else if (mode_vars[0] == 3) { // Hard
                document.getElementById("2100_difficulty_text").innerHTML = "Hard: rightwards is X + X, downwards is X + 2X, leftwards is X + 4X, upwards is 3X + 4X.";
                document.getElementById("2100_difficulty_text").style.setProperty("color", "#bc79ff");
                document.getElementById("2100_difficulty_decrease").style.setProperty("opacity", "block");
                document.getElementById("2100_difficulty_increase").style.setProperty("display", "none");
                displayRules("rules_text", ["h2", "Directional Merges (Hard)"], ["h1", "2100"], ["p","The merge rules are different depending on which direction you're moving. On a rightwards move, merges occur between two equal tiles. On a downwards move, merges occur between an X tile and a 2X tile, for any X. On a leftwards move, merges occur between an X tile and a 4X tile, for any X. On an upwards move, merges occur between a 3X tile and a 4X tile, for any X. Get to the 2100 tile to win!"],
                ["p", "Spawning tiles: 1 (100%)"]);
                displayRules("gm_rules_text", ["h2", "Directional Merges (Hard)"], ["h1", "2100"], ["p","The merge rules are different depending on which direction you're moving. On a rightwards move, merges occur between two equal tiles. On a downwards move, merges occur between an X tile and a 2X tile, for any X. On a leftwards move, merges occur between an X tile and a 4X tile, for any X. On an upwards move, merges occur between a 3X tile and a 4X tile, for any X. Get to the 2100 tile to win!"],
                ["p", "Spawning tiles: 1 (100%)"]);
                MergeRules = [
                    [2, [["@HDir", ">", 0], "&&", ["@This 0", "=", "@Next 1 0"], "&&", ["@This 1", "=", "@Next 1 1"], "&&", ["@This 2", "=", "@Next 1 2"], "&&", ["@This 3", "=", "@Next 1 3"], "&&", ["@This 4", "=", "@Next 1 4"], "&&", ["@This 5", "=", "@Next 1 5"]], false, [[["@This 0", "+", 1], "@This 1", "@This 2", "@This 3", "@This 4", "@This 5"]], [[2, "^", "@This 0"], "*", [3, "^", "@This 1"], "*", [5, "^", "@This 2"], "*", [7, "^", "@This 3"], "*", [11, "^", "@This 4"], "*", [13, "^", "@This 5"], "*", 2], [false, true]],
                    [2, [["@VDir", ">", 0], "&&", ["@This 0", "+", 1, "=", "@Next 1 0"], "&&", ["@This 1", "=", "@Next 1 1"], "&&", ["@This 2", "=", "@Next 1 2"], "&&", ["@This 3", "=", "@Next 1 3"], "&&", ["@This 4", "=", "@Next 1 4"], "&&", ["@This 5", "=", "@Next 1 5"]], false, [["@This 0", ["@This 1", "+", 1], "@This 2", "@This 3", "@This 4", "@This 5"]], [[2, "^", "@This 0"], "*", [3, "^", "@This 1"], "*", [5, "^", "@This 2"], "*", [7, "^", "@This 3"], "*", [11, "^", "@This 4"], "*", [13, "^", "@This 5"], "*", 3], [false, true]],
                    [2, [["@HDir", "<", 0], "&&", ["@This 0", "+", 2, "=", "@Next 1 0"], "&&", ["@This 1", "=", "@Next 1 1"], "&&", ["@This 2", "=", "@Next 1 2"], "&&", ["@This 3", "=", "@Next 1 3"], "&&", ["@This 4", "=", "@Next 1 4"], "&&", ["@This 5", "=", "@Next 1 5"]], false, [["@This 0", "@This 1", ["@This 2", "+", 1], "@This 3", "@This 4", "@This 5"]], [[2, "^", "@This 0"], "*", [3, "^", "@This 1"], "*", [5, "^", "@This 2"], "*", [7, "^", "@This 3"], "*", [11, "^", "@This 4"], "*", [13, "^", "@This 5"], "*", 5], [false, true]],
                    [2, [["@VDir", "<", 0], "&&", ["@This 0", "+", 2, "=", "@Next 1 0"], "&&", ["@This 1", "-", 1, "=", "@Next 1 1"], "&&", ["@This 2", "=", "@Next 1 2"], "&&", ["@This 3", "=", "@Next 1 3"], "&&", ["@This 4", "=", "@Next 1 4"], "&&", ["@This 5", "=", "@Next 1 5"]], false, [["@This 0", ["@This 1", "-", 1], "@This 2", ["@This 3", "+", 1], "@This 4", "@This 5"]], [[2, "^", "@This 0"], "*", [3, "^", "@This 1"], "*", [5, "^", "@This 2"], "*", [7, "^", "@This 3"], "*", [11, "^", "@This 4"], "*", [13, "^", "@This 5"], "*", 7, "/", 3], [false, true]]
                ];
                winConditions = [[2, 1, 2, 1, 0, 0]];
                document.documentElement.style.setProperty("background-image", "linear-gradient(#e6b5ff, #19004d)");
                document.documentElement.style.setProperty("--background-color", "linear-gradient(#db93ff, #200061)");
                document.documentElement.style.setProperty("--grid-color", "#330099");
                document.documentElement.style.setProperty("--tile-color", "#cb63ff");
                document.documentElement.style.setProperty("--text-color", "#2c0d4b");
            }
        }
        else if (((modifiers[5] == "Square" || modifiers[5] == "Diamond") && modifiers[10] == "Diagonal") || (modifiers[5] == "Checkerboard") && modifiers[10] == "Orthogonal") { // Diagonal only. The modes here are the same as orthogonal only, but with diagonal directions replacing orthogonal directions.
            if (mode_vars[0] == 1) { // Easy
                document.getElementById("2100_difficulty_text").innerHTML = "Easy: northeast and southeast are X + X, southwest and northwest are X + 2X.";
                document.getElementById("2100_difficulty_text").style.setProperty("color", "#a0d4ff");
                document.getElementById("2100_difficulty_decrease").style.setProperty("display", "none");
                document.getElementById("2100_difficulty_increase").style.setProperty("display", "block");
                displayRules("rules_text", ["h2", "Directional Merges (Easy)"], ["h1", "1944"], ["p","The merge rules are different depending on which direction you're moving. On a northeast or southeast move, merges occur between two equal tiles. On a southwest or northwest move, merges occur between an X tile and a 2X tile, for any X. Get to the 1944 tile to win!"],
                ["p", "Spawning tiles: 1 (100%)"]);
                displayRules("gm_rules_text", ["h2", "Directional Merges (Easy)"], ["h1", "1944"], ["p","The merge rules are different depending on which direction you're moving. On a northeast or southeast move, merges occur between two equal tiles. On a southwest or northwest move, merges occur between an X tile and a 2X tile, for any X. Get to the 1944 tile to win!"],
                ["p", "Spawning tiles: 1 (100%)"]);
                MergeRules = [
                    [2, [["@HDir", ">", 0], "&&", ["@This 0", "=", "@Next 1 0"], "&&", ["@This 1", "=", "@Next 1 1"], "&&", ["@This 2", "=", "@Next 1 2"], "&&", ["@This 3", "=", "@Next 1 3"], "&&", ["@This 4", "=", "@Next 1 4"], "&&", ["@This 5", "=", "@Next 1 5"]], false, [[["@This 0", "+", 1], "@This 1", "@This 2", "@This 3", "@This 4", "@This 5"]], [[2, "^", "@This 0"], "*", [3, "^", "@This 1"], "*", [5, "^", "@This 2"], "*", [7, "^", "@This 3"], "*", [11, "^", "@This 4"], "*", [13, "^", "@This 5"], "*", 2], [false, true]],
                    [2, [["@HDir", "<", 0], "&&", ["@This 0", "+", 1, "=", "@Next 1 0"], "&&", ["@This 1", "=", "@Next 1 1"], "&&", ["@This 2", "=", "@Next 1 2"], "&&", ["@This 3", "=", "@Next 1 3"], "&&", ["@This 4", "=", "@Next 1 4"], "&&", ["@This 5", "=", "@Next 1 5"]], false, [["@This 0", ["@This 1", "+", 1], "@This 2", "@This 3", "@This 4", "@This 5"]], [[2, "^", "@This 0"], "*", [3, "^", "@This 1"], "*", [5, "^", "@This 2"], "*", [7, "^", "@This 3"], "*", [11, "^", "@This 4"], "*", [13, "^", "@This 5"], "*", 3], [false, true]]
                ];
                winConditions = [[3, 5, 0, 0, 0, 0]];
                document.documentElement.style.setProperty("background-image", "linear-gradient(#90cdff, #00447c)");
                document.documentElement.style.setProperty("--background-color", "linear-gradient(#73c0ff, #005eac)");
                document.documentElement.style.setProperty("--grid-color", "#125c99");
                document.documentElement.style.setProperty("--tile-color", "#3f89c6");
                document.documentElement.style.setProperty("--text-color", "#003159");
            }
            else if (mode_vars[0] == 2) { // Medium
                document.getElementById("2100_difficulty_text").innerHTML = "Medium: northeast is X + X, southeast is X + 2X, southwest is X + 3X, northwest is 2X + 3X.";
                document.getElementById("2100_difficulty_text").style.setProperty("color", "#7573ff");
                document.getElementById("2100_difficulty_decrease").style.setProperty("display", "block");
                document.getElementById("2100_difficulty_increase").style.setProperty("display", "block");
                displayRules("rules_text", ["h2", "Directional Merges (Medium)"], ["h1", "2160"], ["p","The merge rules are different depending on which direction you're moving. On a northeast move, merges occur between two equal tiles. On a southeast move, merges occur between an X tile and a 2X tile, for any X. On a southwest move, merges occur between an X tile and a 3X tile, for any X. On a northwest move, merges occur between a 2X tile and a 3X tile, for any X. Get to the 2160 tile to win!"],
                ["p", "Spawning tiles: 1 (100%)"]);
                displayRules("gm_rules_text", ["h2", "Directional Merges (Medium)"], ["h1", "2160"], ["p","The merge rules are different depending on which direction you're moving. On a northeast move, merges occur between two equal tiles. On a southeast move, merges occur between an X tile and a 2X tile, for any X. On a southwest move, merges occur between an X tile and a 3X tile, for any X. On a northwest move, merges occur between a 2X tile and a 3X tile, for any X. Get to the 2160 tile to win!"],
                ["p", "Spawning tiles: 1 (100%)"]);
                MergeRules = [
                    [2, [[["@HDir", ">", 0], "&&", ["@VDir", "<", 0]], "&&", ["@This 0", "=", "@Next 1 0"], "&&", ["@This 1", "=", "@Next 1 1"], "&&", ["@This 2", "=", "@Next 1 2"], "&&", ["@This 3", "=", "@Next 1 3"], "&&", ["@This 4", "=", "@Next 1 4"], "&&", ["@This 5", "=", "@Next 1 5"]], false, [[["@This 0", "+", 1], "@This 1", "@This 2", "@This 3", "@This 4", "@This 5"]], [[2, "^", "@This 0"], "*", [3, "^", "@This 1"], "*", [5, "^", "@This 2"], "*", [7, "^", "@This 3"], "*", [11, "^", "@This 4"], "*", [13, "^", "@This 5"], "*", 2], [false, true]],
                    [2, [[["@HDir", ">", 0], "&&", ["@VDir", ">", 0]], "&&", ["@This 0", "+", 1, "=", "@Next 1 0"], "&&", ["@This 1", "=", "@Next 1 1"], "&&", ["@This 2", "=", "@Next 1 2"], "&&", ["@This 3", "=", "@Next 1 3"], "&&", ["@This 4", "=", "@Next 1 4"], "&&", ["@This 5", "=", "@Next 1 5"]], false, [["@This 0", ["@This 1", "+", 1], "@This 2", "@This 3", "@This 4", "@This 5"]], [[2, "^", "@This 0"], "*", [3, "^", "@This 1"], "*", [5, "^", "@This 2"], "*", [7, "^", "@This 3"], "*", [11, "^", "@This 4"], "*", [13, "^", "@This 5"], "*", 3], [false, true]],
                    [2, [[["@HDir", "<", 0], "&&", ["@VDir", ">", 0]], "&&", ["@This 0", "=", "@Next 1 0"], "&&", ["@This 1", "+", 1, "=", "@Next 1 1"], "&&", ["@This 2", "=", "@Next 1 2"], "&&", ["@This 3", "=", "@Next 1 3"], "&&", ["@This 4", "=", "@Next 1 4"], "&&", ["@This 5", "=", "@Next 1 5"]], false, [[["@This 0", "+", 2], "@This 1", "@This 2", "@This 3", "@This 4", "@This 5"]], [[2, "^", "@This 0"], "*", [3, "^", "@This 1"], "*", [5, "^", "@This 2"], "*", [7, "^", "@This 3"], "*", [11, "^", "@This 4"], "*", [13, "^", "@This 5"], "*", 4], [false, true]],
                    [2, [[["@HDir", "<", 0], "&&", ["@VDir", "<", 0]], "&&", ["@This 0", "-", 1, "=", "@Next 1 0"], "&&", ["@This 1", "+", 1, "=", "@Next 1 1"], "&&", ["@This 2", "=", "@Next 1 2"], "&&", ["@This 3", "=", "@Next 1 3"], "&&", ["@This 4", "=", "@Next 1 4"], "&&", ["@This 5", "=", "@Next 1 5"]], false, [[["@This 0", "-", 1], "@This 1", ["@This 2", "+", 1], "@This 3", "@This 4", "@This 5"]], [[2, "^", "@This 0"], "*", [3, "^", "@This 1"], "*", [5, "^", "@This 2"], "*", [7, "^", "@This 3"], "*", [11, "^", "@This 4"], "*", [13, "^", "@This 5"], "*", 5, "/", 2], [false, true]]
                ];
                winConditions = [[4, 3, 1, 0, 0, 0]];
                document.documentElement.style.setProperty("background-image", "linear-gradient(#c2acff, #004f4f)");
                document.documentElement.style.setProperty("--background-color", "linear-gradient(#926aff, #008383)");
                document.documentElement.style.setProperty("--grid-color", "#218383");
                document.documentElement.style.setProperty("--tile-color", "#977ce1");
                document.documentElement.style.setProperty("--text-color", "#23144e");
            }
            else if (mode_vars[0] == 3) { // Hard
                document.getElementById("2100_difficulty_text").innerHTML = "Hard: northeast is X + X, southeast is X + 2X, southwest is X + 4X, northwest is 3X + 4X.";
                document.getElementById("2100_difficulty_text").style.setProperty("color", "#bc79ff");
                document.getElementById("2100_difficulty_decrease").style.setProperty("opacity", "block");
                document.getElementById("2100_difficulty_increase").style.setProperty("display", "none");
                displayRules("rules_text", ["h2", "Directional Merges (Hard)"], ["h1", "2100"], ["p","The merge rules are different depending on which direction you're moving. On a northeast move, merges occur between two equal tiles. On a northwest move, merges occur between an X tile and a 2X tile, for any X. On a southwest move, merges occur between an X tile and a 4X tile, for any X. On a northwest move, merges occur between a 3X tile and a 4X tile, for any X. Get to the 2100 tile to win!"],
                ["p", "Spawning tiles: 1 (100%)"]);
                displayRules("gm_rules_text", ["h2", "Directional Merges (Hard)"], ["h1", "2100"], ["p","The merge rules are different depending on which direction you're moving. On a northeast move, merges occur between two equal tiles. On a northwest move, merges occur between an X tile and a 2X tile, for any X. On a southwest move, merges occur between an X tile and a 4X tile, for any X. On a northwest move, merges occur between a 3X tile and a 4X tile, for any X. Get to the 2100 tile to win!"],
                ["p", "Spawning tiles: 1 (100%)"]);
                MergeRules = [
                    [2, [[["@HDir", ">", 0], "&&", ["@VDir", "<", 0]], "&&", ["@This 0", "=", "@Next 1 0"], "&&", ["@This 1", "=", "@Next 1 1"], "&&", ["@This 2", "=", "@Next 1 2"], "&&", ["@This 3", "=", "@Next 1 3"], "&&", ["@This 4", "=", "@Next 1 4"], "&&", ["@This 5", "=", "@Next 1 5"]], false, [[["@This 0", "+", 1], "@This 1", "@This 2", "@This 3", "@This 4", "@This 5"]], [[2, "^", "@This 0"], "*", [3, "^", "@This 1"], "*", [5, "^", "@This 2"], "*", [7, "^", "@This 3"], "*", [11, "^", "@This 4"], "*", [13, "^", "@This 5"], "*", 2], [false, true]],
                    [2, [[["@HDir", ">", 0], "&&", ["@VDir", ">", 0]], "&&", ["@This 0", "+", 1, "=", "@Next 1 0"], "&&", ["@This 1", "=", "@Next 1 1"], "&&", ["@This 2", "=", "@Next 1 2"], "&&", ["@This 3", "=", "@Next 1 3"], "&&", ["@This 4", "=", "@Next 1 4"], "&&", ["@This 5", "=", "@Next 1 5"]], false, [["@This 0", ["@This 1", "+", 1], "@This 2", "@This 3", "@This 4", "@This 5"]], [[2, "^", "@This 0"], "*", [3, "^", "@This 1"], "*", [5, "^", "@This 2"], "*", [7, "^", "@This 3"], "*", [11, "^", "@This 4"], "*", [13, "^", "@This 5"], "*", 3], [false, true]],
                    [2, [[["@HDir", "<", 0], "&&", ["@VDir", ">", 0]], "&&", ["@This 0", "+", 2, "=", "@Next 1 0"], "&&", ["@This 1", "=", "@Next 1 1"], "&&", ["@This 2", "=", "@Next 1 2"], "&&", ["@This 3", "=", "@Next 1 3"], "&&", ["@This 4", "=", "@Next 1 4"], "&&", ["@This 5", "=", "@Next 1 5"]], false, [["@This 0", "@This 1", ["@This 2", "+", 1], "@This 3", "@This 4", "@This 5"]], [[2, "^", "@This 0"], "*", [3, "^", "@This 1"], "*", [5, "^", "@This 2"], "*", [7, "^", "@This 3"], "*", [11, "^", "@This 4"], "*", [13, "^", "@This 5"], "*", 5], [false, true]],
                    [2, [[["@HDir", "<", 0], "&&", ["@VDir", "<", 0]], "&&", ["@This 0", "+", 2, "=", "@Next 1 0"], "&&", ["@This 1", "-", 1, "=", "@Next 1 1"], "&&", ["@This 2", "=", "@Next 1 2"], "&&", ["@This 3", "=", "@Next 1 3"], "&&", ["@This 4", "=", "@Next 1 4"], "&&", ["@This 5", "=", "@Next 1 5"]], false, [["@This 0", ["@This 1", "-", 1], "@This 2", ["@This 3", "+", 1], "@This 4", "@This 5"]], [[2, "^", "@This 0"], "*", [3, "^", "@This 1"], "*", [5, "^", "@This 2"], "*", [7, "^", "@This 3"], "*", [11, "^", "@This 4"], "*", [13, "^", "@This 5"], "*", 7, "/", 3], [false, true]]
                ];
                winConditions = [[2, 1, 2, 1, 0, 0]];
                document.documentElement.style.setProperty("background-image", "linear-gradient(#e6b5ff, #19004d)");
                document.documentElement.style.setProperty("--background-color", "linear-gradient(#db93ff, #200061)");
                document.documentElement.style.setProperty("--grid-color", "#330099");
                document.documentElement.style.setProperty("--tile-color", "#cb63ff");
                document.documentElement.style.setProperty("--text-color", "#2c0d4b");
            }
        }
        else if (((modifiers[5] == "Square" || modifiers[5] == "Diamond" || modifiers[5] == "Checkerboard") && modifiers[10] == "Both") || (modifiers[5] == "Custom" && !hexagonal)) { // Eight-directional. Used for custom grid too, because you could use any set of directions you want there.
            if (mode_vars[0] == 0) { // Eight-Directional Easy
                document.getElementById("2100_difficulty_text").innerHTML = "Eight-Directional Easy: orthogonal directions are X + X, diagonal directions are X + 2X.";
                document.getElementById("2100_difficulty_text").style.setProperty("color", "#a0d4ff");
                document.getElementById("2100_difficulty_decrease").style.setProperty("display", "none");
                document.getElementById("2100_difficulty_increase").style.setProperty("display", "block");
                displayRules("rules_text", ["h2", "Directional Merges (Eight-Directional Easy)"], ["h1", "1944"], ["p","The merge rules are different depending on which direction you're moving. On a move in an orthogonal direction, merges occur between two equal tiles. On a move in a diagonal direction, merges occur between an X tile and a 2X tile, for any X. Get to the 1944 tile to win!"],
                ["p", "Spawning tiles: 1 (100%)"]);
                displayRules("gm_rules_text", ["h2", "Directional Merges (Eight-Directional Easy)"], ["h1", "1944"], ["p","The merge rules are different depending on which direction you're moving. On a move in an orthogonal direction, merges occur between two equal tiles. On a move in a diagonal direction, merges occur between an X tile and a 2X tile, for any X. Get to the 1944 tile to win!"],
                ["p", "Spawning tiles: 1 (100%)"]);
                MergeRules = [
                    [2, [["@HDir", "=", 0], "||", ["@VDir", "=", 0], "&&", ["@This 0", "=", "@Next 1 0"], "&&", ["@This 1", "=", "@Next 1 1"], "&&", ["@This 2", "=", "@Next 1 2"], "&&", ["@This 3", "=", "@Next 1 3"], "&&", ["@This 4", "=", "@Next 1 4"], "&&", ["@This 5", "=", "@Next 1 5"]], false, [[["@This 0", "+", 1], "@This 1", "@This 2", "@This 3", "@This 4", "@This 5"]], [[2, "^", "@This 0"], "*", [3, "^", "@This 1"], "*", [5, "^", "@This 2"], "*", [7, "^", "@This 3"], "*", [11, "^", "@This 4"], "*", [13, "^", "@This 5"], "*", 2], [false, true]],
                    [2, [["@HDir", "!=", 0], "&&", ["@VDir", "!=", 0], "&&", ["@This 0", "+", 1, "=", "@Next 1 0"], "&&", ["@This 1", "=", "@Next 1 1"], "&&", ["@This 2", "=", "@Next 1 2"], "&&", ["@This 3", "=", "@Next 1 3"], "&&", ["@This 4", "=", "@Next 1 4"], "&&", ["@This 5", "=", "@Next 1 5"]], false, [["@This 0", ["@This 1", "+", 1], "@This 2", "@This 3", "@This 4", "@This 5"]], [[2, "^", "@This 0"], "*", [3, "^", "@This 1"], "*", [5, "^", "@This 2"], "*", [7, "^", "@This 3"], "*", [11, "^", "@This 4"], "*", [13, "^", "@This 5"], "*", 3], [false, true]]
                ];
                winConditions = [[3, 5, 0, 0, 0, 0]];
                document.documentElement.style.setProperty("background-image", "linear-gradient(#90cdff, #00447c)");
                document.documentElement.style.setProperty("--background-color", "linear-gradient(#73c0ff, #005eac)");
                document.documentElement.style.setProperty("--grid-color", "#125c99");
                document.documentElement.style.setProperty("--tile-color", "#3f89c6");
                document.documentElement.style.setProperty("--text-color", "#003159");
            }
            else if (mode_vars[0] == 1) { // Easy
                document.getElementById("2100_difficulty_text").innerHTML = "Easy: rightwards and downwards are X + X, leftwards and upwards are X + 2X. Diagonals allow both merges from their constituent directions.";
                document.getElementById("2100_difficulty_text").style.setProperty("color", "#a0d4ff");
                document.getElementById("2100_difficulty_decrease").style.setProperty("display", "block");
                document.getElementById("2100_difficulty_increase").style.setProperty("display", "block");
                displayRules("rules_text", ["h2", "Directional Merges (Easy)"], ["h1", "1944"], ["p","The merge rules are different depending on which direction you're moving. On a rightwards or downwards move, merges occur between two equal tiles. On a leftwards or upwards move, merges occur between an X tile and a 2X tile, for any X. Get to the 1944 tile to win!"],
                ["p", "Spawning tiles: 1 (100%)"]);
                displayRules("gm_rules_text", ["h2", "Directional Merges (Easy)"], ["h1", "1944"], ["p","The merge rules are different depending on which direction you're moving. On a rightwards or downwards move, merges occur between two equal tiles. On a leftwards or upwards move, merges occur between an X tile and a 2X tile, for any X. Get to the 1944 tile to win!"],
                ["p", "Spawning tiles: 1 (100%)"]);
                MergeRules = [
                    [2, [["@HDir", ">", 0], "||", ["@VDir", ">", 0], "&&", ["@This 0", "=", "@Next 1 0"], "&&", ["@This 1", "=", "@Next 1 1"], "&&", ["@This 2", "=", "@Next 1 2"], "&&", ["@This 3", "=", "@Next 1 3"], "&&", ["@This 4", "=", "@Next 1 4"], "&&", ["@This 5", "=", "@Next 1 5"]], false, [[["@This 0", "+", 1], "@This 1", "@This 2", "@This 3", "@This 4", "@This 5"]], [[2, "^", "@This 0"], "*", [3, "^", "@This 1"], "*", [5, "^", "@This 2"], "*", [7, "^", "@This 3"], "*", [11, "^", "@This 4"], "*", [13, "^", "@This 5"], "*", 2], [false, true]],
                    [2, [["@HDir", "<", 0], "||", ["@VDir", "<", 0], "&&", ["@This 0", "+", 1, "=", "@Next 1 0"], "&&", ["@This 1", "=", "@Next 1 1"], "&&", ["@This 2", "=", "@Next 1 2"], "&&", ["@This 3", "=", "@Next 1 3"], "&&", ["@This 4", "=", "@Next 1 4"], "&&", ["@This 5", "=", "@Next 1 5"]], false, [["@This 0", ["@This 1", "+", 1], "@This 2", "@This 3", "@This 4", "@This 5"]], [[2, "^", "@This 0"], "*", [3, "^", "@This 1"], "*", [5, "^", "@This 2"], "*", [7, "^", "@This 3"], "*", [11, "^", "@This 4"], "*", [13, "^", "@This 5"], "*", 3], [false, true]]
                ];
                winConditions = [[3, 5, 0, 0, 0, 0]];
                document.documentElement.style.setProperty("background-image", "linear-gradient(#90cdff, #00447c)");
                document.documentElement.style.setProperty("--background-color", "linear-gradient(#73c0ff, #005eac)");
                document.documentElement.style.setProperty("--grid-color", "#125c99");
                document.documentElement.style.setProperty("--tile-color", "#3f89c6");
                document.documentElement.style.setProperty("--text-color", "#003159");
            }
            else if (mode_vars[0] == 2) { // Medium
                document.getElementById("2100_difficulty_text").innerHTML = "Medium: rightwards is X + X, downwards is X + 2X, leftwards is X + 3X, upwards is 2X + 3X. Diagonals allow both merges from their constituent directions.";
                document.getElementById("2100_difficulty_text").style.setProperty("color", "#7573ff");
                document.getElementById("2100_difficulty_decrease").style.setProperty("display", "block");
                document.getElementById("2100_difficulty_increase").style.setProperty("display", "block");
                displayRules("rules_text", ["h2", "Directional Merges (Medium)"], ["h1", "2160"], ["p","The merge rules are different depending on which direction you're moving. On a rightwards move, merges occur between two equal tiles. On a downwards move, merges occur between an X tile and a 2X tile, for any X. On a leftwards move, merges occur between an X tile and a 3X tile, for any X. On an upwards move, merges occur between a 2X tile and a 3X tile, for any X. Get to the 2160 tile to win!"],
                ["p", "Spawning tiles: 1 (100%)"]);
                displayRules("gm_rules_text", ["h2", "Directional Merges (Medium)"], ["h1", "2160"], ["p","The merge rules are different depending on which direction you're moving. On a rightwards move, merges occur between two equal tiles. On a downwards move, merges occur between an X tile and a 2X tile, for any X. On a leftwards move, merges occur between an X tile and a 3X tile, for any X. On an upwards move, merges occur between a 2X tile and a 3X tile, for any X. Get to the 2160 tile to win!"],
                ["p", "Spawning tiles: 1 (100%)"]);
                MergeRules = [
                    [2, [["@HDir", ">", 0], "&&", ["@This 0", "=", "@Next 1 0"], "&&", ["@This 1", "=", "@Next 1 1"], "&&", ["@This 2", "=", "@Next 1 2"], "&&", ["@This 3", "=", "@Next 1 3"], "&&", ["@This 4", "=", "@Next 1 4"], "&&", ["@This 5", "=", "@Next 1 5"]], false, [[["@This 0", "+", 1], "@This 1", "@This 2", "@This 3", "@This 4", "@This 5"]], [[2, "^", "@This 0"], "*", [3, "^", "@This 1"], "*", [5, "^", "@This 2"], "*", [7, "^", "@This 3"], "*", [11, "^", "@This 4"], "*", [13, "^", "@This 5"], "*", 2], [false, true]],
                    [2, [["@VDir", ">", 0], "&&", ["@This 0", "+", 1, "=", "@Next 1 0"], "&&", ["@This 1", "=", "@Next 1 1"], "&&", ["@This 2", "=", "@Next 1 2"], "&&", ["@This 3", "=", "@Next 1 3"], "&&", ["@This 4", "=", "@Next 1 4"], "&&", ["@This 5", "=", "@Next 1 5"]], false, [["@This 0", ["@This 1", "+", 1], "@This 2", "@This 3", "@This 4", "@This 5"]], [[2, "^", "@This 0"], "*", [3, "^", "@This 1"], "*", [5, "^", "@This 2"], "*", [7, "^", "@This 3"], "*", [11, "^", "@This 4"], "*", [13, "^", "@This 5"], "*", 3], [false, true]],
                    [2, [["@HDir", "<", 0], "&&", ["@This 0", "=", "@Next 1 0"], "&&", ["@This 1", "+", 1, "=", "@Next 1 1"], "&&", ["@This 2", "=", "@Next 1 2"], "&&", ["@This 3", "=", "@Next 1 3"], "&&", ["@This 4", "=", "@Next 1 4"], "&&", ["@This 5", "=", "@Next 1 5"]], false, [[["@This 0", "+", 2], "@This 1", "@This 2", "@This 3", "@This 4", "@This 5"]], [[2, "^", "@This 0"], "*", [3, "^", "@This 1"], "*", [5, "^", "@This 2"], "*", [7, "^", "@This 3"], "*", [11, "^", "@This 4"], "*", [13, "^", "@This 5"], "*", 4], [false, true]],
                    [2, [["@VDir", "<", 0], "&&", ["@This 0", "-", 1, "=", "@Next 1 0"], "&&", ["@This 1", "+", 1, "=", "@Next 1 1"], "&&", ["@This 2", "=", "@Next 1 2"], "&&", ["@This 3", "=", "@Next 1 3"], "&&", ["@This 4", "=", "@Next 1 4"], "&&", ["@This 5", "=", "@Next 1 5"]], false, [[["@This 0", "-", 1], "@This 1", ["@This 2", "+", 1], "@This 3", "@This 4", "@This 5"]], [[2, "^", "@This 0"], "*", [3, "^", "@This 1"], "*", [5, "^", "@This 2"], "*", [7, "^", "@This 3"], "*", [11, "^", "@This 4"], "*", [13, "^", "@This 5"], "*", 5, "/", 2], [false, true]]
                ];
                winConditions = [[4, 3, 1, 0, 0, 0]];
                document.documentElement.style.setProperty("background-image", "linear-gradient(#c2acff, #004f4f)");
                document.documentElement.style.setProperty("--background-color", "linear-gradient(#926aff, #008383)");
                document.documentElement.style.setProperty("--grid-color", "#218383");
                document.documentElement.style.setProperty("--tile-color", "#977ce1");
                document.documentElement.style.setProperty("--text-color", "#23144e");
            }
            else if (mode_vars[0] == 3) { // Hard
                document.getElementById("2100_difficulty_text").innerHTML = "Hard: rightwards is X + X, downwards is X + 2X, leftwards is X + 4X, upwards is 3X + 4X. Diagonals allow both merges from their constituent directions.";
                document.getElementById("2100_difficulty_text").style.setProperty("color", "#bc79ff");
                document.getElementById("2100_difficulty_decrease").style.setProperty("opacity", "block");
                document.getElementById("2100_difficulty_increase").style.setProperty("display", "block");
                displayRules("rules_text", ["h2", "Directional Merges (Hard)"], ["h1", "2100"], ["p","The merge rules are different depending on which direction you're moving. On a rightwards move, merges occur between two equal tiles. On a downwards move, merges occur between an X tile and a 2X tile, for any X. On a leftwards move, merges occur between an X tile and a 4X tile, for any X. On an upwards move, merges occur between a 3X tile and a 4X tile, for any X. Get to the 2100 tile to win!"],
                ["p", "Spawning tiles: 1 (100%)"]);
                displayRules("gm_rules_text", ["h2", "Directional Merges (Hard)"], ["h1", "2100"], ["p","The merge rules are different depending on which direction you're moving. On a rightwards move, merges occur between two equal tiles. On a downwards move, merges occur between an X tile and a 2X tile, for any X. On a leftwards move, merges occur between an X tile and a 4X tile, for any X. On an upwards move, merges occur between a 3X tile and a 4X tile, for any X. Get to the 2100 tile to win!"],
                ["p", "Spawning tiles: 1 (100%)"]);
                MergeRules = [
                    [2, [["@HDir", ">", 0], "&&", ["@This 0", "=", "@Next 1 0"], "&&", ["@This 1", "=", "@Next 1 1"], "&&", ["@This 2", "=", "@Next 1 2"], "&&", ["@This 3", "=", "@Next 1 3"], "&&", ["@This 4", "=", "@Next 1 4"], "&&", ["@This 5", "=", "@Next 1 5"]], false, [[["@This 0", "+", 1], "@This 1", "@This 2", "@This 3", "@This 4", "@This 5"]], [[2, "^", "@This 0"], "*", [3, "^", "@This 1"], "*", [5, "^", "@This 2"], "*", [7, "^", "@This 3"], "*", [11, "^", "@This 4"], "*", [13, "^", "@This 5"], "*", 2], [false, true]],
                    [2, [["@VDir", ">", 0], "&&", ["@This 0", "+", 1, "=", "@Next 1 0"], "&&", ["@This 1", "=", "@Next 1 1"], "&&", ["@This 2", "=", "@Next 1 2"], "&&", ["@This 3", "=", "@Next 1 3"], "&&", ["@This 4", "=", "@Next 1 4"], "&&", ["@This 5", "=", "@Next 1 5"]], false, [["@This 0", ["@This 1", "+", 1], "@This 2", "@This 3", "@This 4", "@This 5"]], [[2, "^", "@This 0"], "*", [3, "^", "@This 1"], "*", [5, "^", "@This 2"], "*", [7, "^", "@This 3"], "*", [11, "^", "@This 4"], "*", [13, "^", "@This 5"], "*", 3], [false, true]],
                    [2, [["@HDir", "<", 0], "&&", ["@This 0", "+", 2, "=", "@Next 1 0"], "&&", ["@This 1", "=", "@Next 1 1"], "&&", ["@This 2", "=", "@Next 1 2"], "&&", ["@This 3", "=", "@Next 1 3"], "&&", ["@This 4", "=", "@Next 1 4"], "&&", ["@This 5", "=", "@Next 1 5"]], false, [["@This 0", "@This 1", ["@This 2", "+", 1], "@This 3", "@This 4", "@This 5"]], [[2, "^", "@This 0"], "*", [3, "^", "@This 1"], "*", [5, "^", "@This 2"], "*", [7, "^", "@This 3"], "*", [11, "^", "@This 4"], "*", [13, "^", "@This 5"], "*", 5], [false, true]],
                    [2, [["@VDir", "<", 0], "&&", ["@This 0", "+", 2, "=", "@Next 1 0"], "&&", ["@This 1", "-", 1, "=", "@Next 1 1"], "&&", ["@This 2", "=", "@Next 1 2"], "&&", ["@This 3", "=", "@Next 1 3"], "&&", ["@This 4", "=", "@Next 1 4"], "&&", ["@This 5", "=", "@Next 1 5"]], false, [["@This 0", ["@This 1", "-", 1], "@This 2", ["@This 3", "+", 1], "@This 4", "@This 5"]], [[2, "^", "@This 0"], "*", [3, "^", "@This 1"], "*", [5, "^", "@This 2"], "*", [7, "^", "@This 3"], "*", [11, "^", "@This 4"], "*", [13, "^", "@This 5"], "*", 7, "/", 3], [false, true]]
                ];
                winConditions = [[2, 1, 2, 1, 0, 0]];
                document.documentElement.style.setProperty("background-image", "linear-gradient(#e6b5ff, #19004d)");
                document.documentElement.style.setProperty("--background-color", "linear-gradient(#db93ff, #200061)");
                document.documentElement.style.setProperty("--grid-color", "#330099");
                document.documentElement.style.setProperty("--tile-color", "#cb63ff");
                document.documentElement.style.setProperty("--text-color", "#2c0d4b");
            }
            else if (mode_vars[0] == 4) { // Eight-Directional Hard
                document.getElementById("2100_difficulty_text").innerHTML = "Eight-Directional Hard: rightwards is X + X, downwards is X + 2X, leftwards is X + 3X, upwards is 2X + 3X, northeast is X + 5X, southeast is 2X + 5X, southwest is X + 7X, northwest is 2X + 7X.";
                document.getElementById("2100_difficulty_text").style.setProperty("color", "#bc79ff");
                document.getElementById("2100_difficulty_decrease").style.setProperty("opacity", "block");
                document.getElementById("2100_difficulty_increase").style.setProperty("display", "block");
                displayRules("rules_text", ["h2", "Directional Merges (Eight-Directional Hard)"], ["h1", "2100"], ["p","The merge rules are different depending on which direction you're moving. On a rightwards move, merges occur between two equal tiles. On a downwards move, merges occur between an X tile and a 2X tile. On a leftwards move, merges occur between an X tile and a 3X tile. On an upwards move, merges occur between a 2X tile and a 3X tile. On a northeast move, merges occur between an X tile and a 5X tile. On a southeast move, merges occur between a 2X tile and a 5X tile. On a southwest move, merges occur between an X tile and a 7X tile. On a northwest move, merges occur between a 2X tile and a 7X tile. Get to the 2100 tile to win!"],
                ["p", "Spawning tiles: 1 (100%)"]);
                displayRules("gm_rules_text", ["h2", "Directional Merges (Eight-Directional Hard)"], ["h1", "2100"], ["p","The merge rules are different depending on which direction you're moving. On a rightwards move, merges occur between two equal tiles. On a downwards move, merges occur between an X tile and a 2X tile. On a leftwards move, merges occur between an X tile and a 3X tile. On an upwards move, merges occur between a 2X tile and a 3X tile. On a northeast move, merges occur between an X tile and a 5X tile. On a southeast move, merges occur between a 2X tile and a 5X tile. On a southwest move, merges occur between an X tile and a 7X tile. On a northwest move, merges occur between a 2X tile and a 7X tile. Get to the 2100 tile to win!"],
                ["p", "Spawning tiles: 1 (100%)"]);
                MergeRules = [
                    [2, [[["@HDir", ">", 0], "&&", ["@VDir", "=", 0]], "&&", ["@This 0", "=", "@Next 1 0"], "&&", ["@This 1", "=", "@Next 1 1"], "&&", ["@This 2", "=", "@Next 1 2"], "&&", ["@This 3", "=", "@Next 1 3"], "&&", ["@This 4", "=", "@Next 1 4"], "&&", ["@This 5", "=", "@Next 1 5"]], false, [[["@This 0", "+", 1], "@This 1", "@This 2", "@This 3", "@This 4", "@This 5"]], [[2, "^", "@This 0"], "*", [3, "^", "@This 1"], "*", [5, "^", "@This 2"], "*", [7, "^", "@This 3"], "*", [11, "^", "@This 4"], "*", [13, "^", "@This 5"], "*", 2], [false, true]],
                    [2, [[["@HDir", "=", 0], "&&", ["@VDir", ">", 0]], "&&", ["@This 0", "+", 1, "=", "@Next 1 0"], "&&", ["@This 1", "=", "@Next 1 1"], "&&", ["@This 2", "=", "@Next 1 2"], "&&", ["@This 3", "=", "@Next 1 3"], "&&", ["@This 4", "=", "@Next 1 4"], "&&", ["@This 5", "=", "@Next 1 5"]], false, [["@This 0", ["@This 1", "+", 1], "@This 2", "@This 3", "@This 4", "@This 5"]], [[2, "^", "@This 0"], "*", [3, "^", "@This 1"], "*", [5, "^", "@This 2"], "*", [7, "^", "@This 3"], "*", [11, "^", "@This 4"], "*", [13, "^", "@This 5"], "*", 3], [false, true]],
                    [2, [[["@HDir", "<", 0], "&&", ["@VDir", "=", 0]], "&&", ["@This 0", "=", "@Next 1 0"], "&&", ["@This 1", "+", 1, "=", "@Next 1 1"], "&&", ["@This 2", "=", "@Next 1 2"], "&&", ["@This 3", "=", "@Next 1 3"], "&&", ["@This 4", "=", "@Next 1 4"], "&&", ["@This 5", "=", "@Next 1 5"]], false, [[["@This 0", "+", 2], "@This 1", "@This 2", "@This 3", "@This 4", "@This 5"]], [[2, "^", "@This 0"], "*", [3, "^", "@This 1"], "*", [5, "^", "@This 2"], "*", [7, "^", "@This 3"], "*", [11, "^", "@This 4"], "*", [13, "^", "@This 5"], "*", 4], [false, true]],
                    [2, [[["@HDir", "=", 0], "&&", ["@VDir", "<", 0]], "&&", ["@This 0", "-", 1, "=", "@Next 1 0"], "&&", ["@This 1", "+", 1, "=", "@Next 1 1"], "&&", ["@This 2", "=", "@Next 1 2"], "&&", ["@This 3", "=", "@Next 1 3"], "&&", ["@This 4", "=", "@Next 1 4"], "&&", ["@This 5", "=", "@Next 1 5"]], false, [[["@This 0", "-", 1], "@This 1", ["@This 2", "+", 1], "@This 3", "@This 4", "@This 5"]], [[2, "^", "@This 0"], "*", [3, "^", "@This 1"], "*", [5, "^", "@This 2"], "*", [7, "^", "@This 3"], "*", [11, "^", "@This 4"], "*", [13, "^", "@This 5"], "*", 5, "/", 2], [false, true]],
                    [2, [[["@HDir", ">", 0], "&&", ["@VDir", "<", 0]], "&&", ["@This 0", "=", "@Next 1 0"], "&&", ["@This 1", "=", "@Next 1 1"], "&&", ["@This 2", "+", 1, "=", "@Next 1 2"], "&&", ["@This 3", "=", "@Next 1 3"], "&&", ["@This 4", "=", "@Next 1 4"], "&&", ["@This 5", "=", "@Next 1 5"]], false, [[["@This 0", "+", 1], ["@This 1", "+", 1], "@This 2", "@This 3", "@This 4", "@This 5"]], [[2, "^", "@This 0"], "*", [3, "^", "@This 1"], "*", [5, "^", "@This 2"], "*", [7, "^", "@This 3"], "*", [11, "^", "@This 4"], "*", [13, "^", "@This 5"], "*", 6], [false, true]],
                    [2, [[["@HDir", ">", 0], "&&", ["@VDir", ">", 0]], "&&", ["@This 0", "-", 1, "=", "@Next 1 0"], "&&", ["@This 1", "=", "@Next 1 1"], "&&", ["@This 2", "+", 1, "=", "@Next 1 2"], "&&", ["@This 3", "=", "@Next 1 3"], "&&", ["@This 4", "=", "@Next 1 4"], "&&", ["@This 5", "=", "@Next 1 5"]], false, [[["@This 0", "-", 1], "@This 1", "@This 2", ["@This 3", "+", 1], "@This 4", "@This 5"]], [[2, "^", "@This 0"], "*", [3, "^", "@This 1"], "*", [5, "^", "@This 2"], "*", [7, "^", "@This 3"], "*", [11, "^", "@This 4"], "*", [13, "^", "@This 5"], "*", 7, "/", 2], [false, true]],
                    [2, [[["@HDir", "<", 0], "&&", ["@VDir", ">", 0]], "&&", ["@This 0", "=", "@Next 1 0"], "&&", ["@This 1", "=", "@Next 1 1"], "&&", ["@This 2", "=", "@Next 1 2"], "&&", ["@This 3", "+", 1, "=", "@Next 1 3"], "&&", ["@This 4", "=", "@Next 1 4"], "&&", ["@This 5", "=", "@Next 1 5"]], false, [[["@This 0", "+", 3], "@This 1", "@This 2", "@This 3", "@This 4", "@This 5"]], [[2, "^", "@This 0"], "*", [3, "^", "@This 1"], "*", [5, "^", "@This 2"], "*", [7, "^", "@This 3"], "*", [11, "^", "@This 4"], "*", [13, "^", "@This 5"], "*", 8], [false, true]],
                    [2, [[["@HDir", "<", 0], "&&", ["@VDir", "<", 0]], "&&", ["@This 0", "-", 1, "=", "@Next 1 0"], "&&", ["@This 1", "=", "@Next 1 1"], "&&", ["@This 2", "=", "@Next 1 2"], "&&", ["@This 3", "+", 1, "=", "@Next 1 3"], "&&", ["@This 4", "=", "@Next 1 4"], "&&", ["@This 5", "=", "@Next 1 5"]], false, [[["@This 0", "-", 1], ["@This 1", "+", 2], "@This 2", "@This 3", "@This 4", "@This 5"]], [[2, "^", "@This 0"], "*", [3, "^", "@This 1"], "*", [5, "^", "@This 2"], "*", [7, "^", "@This 3"], "*", [11, "^", "@This 4"], "*", [13, "^", "@This 5"], "*", 9, "/", 2], [false, true]],
                ];
                winConditions = [[2, 1, 2, 1, 0, 0]];
                document.documentElement.style.setProperty("background-image", "linear-gradient(#e6b5ff, #19004d)");
                document.documentElement.style.setProperty("--background-color", "linear-gradient(#db93ff, #200061)");
                document.documentElement.style.setProperty("--grid-color", "#330099");
                document.documentElement.style.setProperty("--tile-color", "#cb63ff");
                document.documentElement.style.setProperty("--text-color", "#2c0d4b");
            }
            else if (mode_vars[0] == 5) { // Eight-Directional Extreme
                document.getElementById("2100_difficulty_text").innerHTML = "Eight-Directional Extreme: rightwards is X + X, downwards is X + 2X, leftwards is X + 4X, upwards is 3X + 4X, northeast is X + 8X, southeast is 3X + 8X, southwest is 5X + 8X, northwest is 7X + 8X.";
                document.getElementById("2100_difficulty_text").style.setProperty("color", "#ffad9c");
                document.getElementById("2100_difficulty_decrease").style.setProperty("opacity", "block");
                document.getElementById("2100_difficulty_increase").style.setProperty("display", "none");
                displayRules("rules_text", ["h2", "Directional Merges (Eight-Directional Extreme)"], ["h1", "2002"], ["p","The merge rules are different depending on which direction you're moving. On a rightwards move, merges occur between two equal tiles. On a downwards move, merges occur between an X tile and a 2X tile. On a leftwards move, merges occur between an X tile and a 4X tile. On an upwards move, merges occur between a 3X tile and a 4X tile. On a northeast move, merges occur between an X tile and an 8X tile. On a southeast move, merges occur between a 3X tile and an 8X tile. On a southwest move, merges occur between a 5X tile and an 8X tile. On a northwest move, merges occur between a 7X tile and an 8X tile. Get to the 2002 tile to win!"],
                ["p", "Spawning tiles: 1 (100%)"]);
                displayRules("gm_rules_text", ["h2", "Directional Merges (Eight-Directional Extreme)"], ["h1", "2002"], ["p","The merge rules are different depending on which direction you're moving. On a rightwards move, merges occur between two equal tiles. On a downwards move, merges occur between an X tile and a 2X tile. On a leftwards move, merges occur between an X tile and a 4X tile. On an upwards move, merges occur between a 3X tile and a 4X tile. On a northeast move, merges occur between an X tile and an 8X tile. On a southeast move, merges occur between a 3X tile and an 8X tile. On a southwest move, merges occur between a 5X tile and an 8X tile. On a northwest move, merges occur between a 7X tile and an 8X tile. Get to the 2002 tile to win!"],
                ["p", "Spawning tiles: 1 (100%)"]);
                MergeRules = [
                    [2, [[["@HDir", ">", 0], "&&", ["@VDir", "=", 0]], "&&", ["@This 0", "=", "@Next 1 0"], "&&", ["@This 1", "=", "@Next 1 1"], "&&", ["@This 2", "=", "@Next 1 2"], "&&", ["@This 3", "=", "@Next 1 3"], "&&", ["@This 4", "=", "@Next 1 4"], "&&", ["@This 5", "=", "@Next 1 5"]], false, [[["@This 0", "+", 1], "@This 1", "@This 2", "@This 3", "@This 4", "@This 5"]], [[2, "^", "@This 0"], "*", [3, "^", "@This 1"], "*", [5, "^", "@This 2"], "*", [7, "^", "@This 3"], "*", [11, "^", "@This 4"], "*", [13, "^", "@This 5"], "*", 2], [false, true]],
                    [2, [[["@HDir", "=", 0], "&&", ["@VDir", ">", 0]], "&&", ["@This 0", "+", 1, "=", "@Next 1 0"], "&&", ["@This 1", "=", "@Next 1 1"], "&&", ["@This 2", "=", "@Next 1 2"], "&&", ["@This 3", "=", "@Next 1 3"], "&&", ["@This 4", "=", "@Next 1 4"], "&&", ["@This 5", "=", "@Next 1 5"]], false, [["@This 0", ["@This 1", "+", 1], "@This 2", "@This 3", "@This 4", "@This 5"]], [[2, "^", "@This 0"], "*", [3, "^", "@This 1"], "*", [5, "^", "@This 2"], "*", [7, "^", "@This 3"], "*", [11, "^", "@This 4"], "*", [13, "^", "@This 5"], "*", 3], [false, true]],
                    [2, [[["@HDir", "<", 0], "&&", ["@VDir", "=", 0]], "&&", ["@This 0", "+", 2, "=", "@Next 1 0"], "&&", ["@This 1", "=", "@Next 1 1"], "&&", ["@This 2", "=", "@Next 1 2"], "&&", ["@This 3", "=", "@Next 1 3"], "&&", ["@This 4", "=", "@Next 1 4"], "&&", ["@This 5", "=", "@Next 1 5"]], false, [["@This 0", "@This 1", ["@This 2", "+", 1], "@This 3", "@This 4", "@This 5"]], [[2, "^", "@This 0"], "*", [3, "^", "@This 1"], "*", [5, "^", "@This 2"], "*", [7, "^", "@This 3"], "*", [11, "^", "@This 4"], "*", [13, "^", "@This 5"], "*", 5], [false, true]],
                    [2, [[["@HDir", "=", 0], "&&", ["@VDir", "<", 0]], "&&", ["@This 0", "+", 2, "=", "@Next 1 0"], "&&", ["@This 1", "-", 1, "=", "@Next 1 1"], "&&", ["@This 2", "=", "@Next 1 2"], "&&", ["@This 3", "=", "@Next 1 3"], "&&", ["@This 4", "=", "@Next 1 4"], "&&", ["@This 5", "=", "@Next 1 5"]], false, [["@This 0", ["@This 1", "-", 1], "@This 2", ["@This 3", "+", 1], "@This 4", "@This 5"]], [[2, "^", "@This 0"], "*", [3, "^", "@This 1"], "*", [5, "^", "@This 2"], "*", [7, "^", "@This 3"], "*", [11, "^", "@This 4"], "*", [13, "^", "@This 5"], "*", 7, "/", 3], [false, true]],
                    [2, [[["@HDir", ">", 0], "&&", ["@VDir", "<", 0]], "&&", ["@This 0", "+", 3, "=", "@Next 1 0"], "&&", ["@This 1", "=", "@Next 1 1"], "&&", ["@This 2", "=", "@Next 1 2"], "&&", ["@This 3", "=", "@Next 1 3"], "&&", ["@This 4", "=", "@Next 1 4"], "&&", ["@This 5", "=", "@Next 1 5"]], false, [["@This 0", ["@This 1", "+", 2], "@This 2", "@This 3", "@This 4", "@This 5"]], [[2, "^", "@This 0"], "*", [3, "^", "@This 1"], "*", [5, "^", "@This 2"], "*", [7, "^", "@This 3"], "*", [11, "^", "@This 4"], "*", [13, "^", "@This 5"], "*", 9], [false, true]],
                    [2, [[["@HDir", ">", 0], "&&", ["@VDir", ">", 0]], "&&", ["@This 0", "+", 3, "=", "@Next 1 0"], "&&", ["@This 1", "-", 1, "=", "@Next 1 1"], "&&", ["@This 2", "=", "@Next 1 2"], "&&", ["@This 3", "=", "@Next 1 3"], "&&", ["@This 4", "=", "@Next 1 4"], "&&", ["@This 5", "=", "@Next 1 5"]], false, [["@This 0", ["@This 1", "-", 1], "@This 2", "@This 3", ["@This 4", "+", 1], "@This 5"]], [[2, "^", "@This 0"], "*", [3, "^", "@This 1"], "*", [5, "^", "@This 2"], "*", [7, "^", "@This 3"], "*", [11, "^", "@This 4"], "*", [13, "^", "@This 5"], "*", 11, "/", 3], [false, true]],
                    [2, [[["@HDir", "<", 0], "&&", ["@VDir", ">", 0]], "&&", ["@This 0", "+", 3, "=", "@Next 1 0"], "&&", ["@This 1", "=", "@Next 1 1"], "&&", ["@This 2", "-", 1, "=", "@Next 1 2"], "&&", ["@This 3", "=", "@Next 1 3"], "&&", ["@This 4", "=", "@Next 1 4"], "&&", ["@This 5", "=", "@Next 1 5"]], false, [["@This 0", "@This 1", ["@This 2", "-", 1], "@This 3", "@This 4", ["@This 5", "+", 1]]], [[2, "^", "@This 0"], "*", [3, "^", "@This 1"], "*", [5, "^", "@This 2"], "*", [7, "^", "@This 3"], "*", [11, "^", "@This 4"], "*", [13, "^", "@This 5"], "*", 13, "/", 5], [false, true]],
                    [2, [[["@HDir", "<", 0], "&&", ["@VDir", "<", 0]], "&&", ["@This 0", "+", 3, "=", "@Next 1 0"], "&&", ["@This 1", "=", "@Next 1 1"], "&&", ["@This 2", "=", "@Next 1 2"], "&&", ["@This 3", "-", 1, "=", "@Next 1 3"], "&&", ["@This 4", "=", "@Next 1 4"], "&&", ["@This 5", "=", "@Next 1 5"]], false, [["@This 0", ["@This 1", "+", 1], ["@This 2", "+", 1], ["@This 3", "-", 1], "@This 4", "@This 5"]], [[2, "^", "@This 0"], "*", [3, "^", "@This 1"], "*", [5, "^", "@This 2"], "*", [7, "^", "@This 3"], "*", [11, "^", "@This 4"], "*", [13, "^", "@This 5"], "*", 15, "/", 7], [false, true]],
                ];
                winConditions = [[1, 0, 0, 1, 1, 1]];
                document.documentElement.style.setProperty("background-image", "linear-gradient(#ffa0a0, #bbbb00, #9c673b)");
                document.documentElement.style.setProperty("--background-color", "linear-gradient(#ff6c6c, #999900, #b87a47)");
                document.documentElement.style.setProperty("--grid-color", "#be7b43");
                document.documentElement.style.setProperty("--tile-color", "#e06b6b");
                document.documentElement.style.setProperty("--text-color", "#484800");
            }
        }
        else if (modifiers[5] == "4D") { // 4D grid. The modes here are the same as eight-directional, but with the 3D/4D directions replacing the diagonal directions.
            if (mode_vars[0] == 0) { // 4D Easy
                document.getElementById("2100_difficulty_text").innerHTML = "4D Easy: 2D directions are X + X, between-grid directions are X + 2X.";
                document.getElementById("2100_difficulty_text").style.setProperty("color", "#a0d4ff");
                document.getElementById("2100_difficulty_decrease").style.setProperty("display", "none");
                document.getElementById("2100_difficulty_increase").style.setProperty("display", "block");
                displayRules("rules_text", ["h2", "Directional Merges (4D Easy)"], ["h1", "1944"], ["p","The merge rules are different depending on which direction you're moving. On a move within a 2D grid, merges occur between two equal tiles. On a move between grids, merges occur between an X tile and a 2X tile, for any X. Get to the 1944 tile to win!"],
                ["p", "Spawning tiles: 1 (100%)"]);
                displayRules("gm_rules_text", ["h2", "Directional Merges (4D Easy)"], ["h1", "1944"], ["p","The merge rules are different depending on which direction you're moving. On a move within a 2D grid, merges occur between two equal tiles. On a move between grids, merges occur between an X tile and a 2X tile, for any X. Get to the 1944 tile to win!"],
                ["p", "Spawning tiles: 1 (100%)"]);
                MergeRules = [
                    [2, [["@HDir", "abs", "=", 1], "||", ["@VDir", "abs", "=", 1], "&&", ["@This 0", "=", "@Next 1 0"], "&&", ["@This 1", "=", "@Next 1 1"], "&&", ["@This 2", "=", "@Next 1 2"], "&&", ["@This 3", "=", "@Next 1 3"], "&&", ["@This 4", "=", "@Next 1 4"], "&&", ["@This 5", "=", "@Next 1 5"]], false, [[["@This 0", "+", 1], "@This 1", "@This 2", "@This 3", "@This 4", "@This 5"]], [[2, "^", "@This 0"], "*", [3, "^", "@This 1"], "*", [5, "^", "@This 2"], "*", [7, "^", "@This 3"], "*", [11, "^", "@This 4"], "*", [13, "^", "@This 5"], "*", 2], [false, true]],
                    [2, [["@HDir", "abs", ">", 1], "||", ["@VDir", "abs", ">", 1], "&&", ["@This 0", "+", 1, "=", "@Next 1 0"], "&&", ["@This 1", "=", "@Next 1 1"], "&&", ["@This 2", "=", "@Next 1 2"], "&&", ["@This 3", "=", "@Next 1 3"], "&&", ["@This 4", "=", "@Next 1 4"], "&&", ["@This 5", "=", "@Next 1 5"]], false, [["@This 0", ["@This 1", "+", 1], "@This 2", "@This 3", "@This 4", "@This 5"]], [[2, "^", "@This 0"], "*", [3, "^", "@This 1"], "*", [5, "^", "@This 2"], "*", [7, "^", "@This 3"], "*", [11, "^", "@This 4"], "*", [13, "^", "@This 5"], "*", 3], [false, true]]
                ];
                winConditions = [[3, 5, 0, 0, 0, 0]];
                document.documentElement.style.setProperty("background-image", "linear-gradient(#90cdff, #00447c)");
                document.documentElement.style.setProperty("--background-color", "linear-gradient(#73c0ff, #005eac)");
                document.documentElement.style.setProperty("--grid-color", "#125c99");
                document.documentElement.style.setProperty("--tile-color", "#3f89c6");
                document.documentElement.style.setProperty("--text-color", "#003159");
            }
            else if (mode_vars[0] == 1) { // Easy
                document.getElementById("2100_difficulty_text").innerHTML = "Easy: rightwards and downwards are X + X, leftwards and upwards are X + 2X. Moves between grids have the same merge rules as their corresponding moves within a grid.";
                document.getElementById("2100_difficulty_text").style.setProperty("color", "#a0d4ff");
                document.getElementById("2100_difficulty_decrease").style.setProperty("display", "block");
                document.getElementById("2100_difficulty_increase").style.setProperty("display", "block");
                displayRules("rules_text", ["h2", "Directional Merges (Easy)"], ["h1", "1944"], ["p","The merge rules are different depending on which direction you're moving. On a rightwards or downwards move, merges occur between two equal tiles. On a leftwards or upwards move, merges occur between an X tile and a 2X tile, for any X. Moves between grids have the same merge rules as their corresponding moves within a grid. Get to the 1944 tile to win!"],
                ["p", "Spawning tiles: 1 (100%)"]);
                displayRules("gm_rules_text", ["h2", "Directional Merges (Easy)"], ["h1", "1944"], ["p","The merge rules are different depending on which direction you're moving. On a rightwards or downwards move, merges occur between two equal tiles. On a leftwards or upwards move, merges occur between an X tile and a 2X tile, for any X. Moves between grids have the same merge rules as their corresponding moves within a grid. Get to the 1944 tile to win!"],
                ["p", "Spawning tiles: 1 (100%)"]);
                MergeRules = [
                    [2, [["@HDir", ">", 0], "||", ["@VDir", ">", 0], "&&", ["@This 0", "=", "@Next 1 0"], "&&", ["@This 1", "=", "@Next 1 1"], "&&", ["@This 2", "=", "@Next 1 2"], "&&", ["@This 3", "=", "@Next 1 3"], "&&", ["@This 4", "=", "@Next 1 4"], "&&", ["@This 5", "=", "@Next 1 5"]], false, [[["@This 0", "+", 1], "@This 1", "@This 2", "@This 3", "@This 4", "@This 5"]], [[2, "^", "@This 0"], "*", [3, "^", "@This 1"], "*", [5, "^", "@This 2"], "*", [7, "^", "@This 3"], "*", [11, "^", "@This 4"], "*", [13, "^", "@This 5"], "*", 2], [false, true]],
                    [2, [["@HDir", "<", 0], "||", ["@VDir", "<", 0], "&&", ["@This 0", "+", 1, "=", "@Next 1 0"], "&&", ["@This 1", "=", "@Next 1 1"], "&&", ["@This 2", "=", "@Next 1 2"], "&&", ["@This 3", "=", "@Next 1 3"], "&&", ["@This 4", "=", "@Next 1 4"], "&&", ["@This 5", "=", "@Next 1 5"]], false, [["@This 0", ["@This 1", "+", 1], "@This 2", "@This 3", "@This 4", "@This 5"]], [[2, "^", "@This 0"], "*", [3, "^", "@This 1"], "*", [5, "^", "@This 2"], "*", [7, "^", "@This 3"], "*", [11, "^", "@This 4"], "*", [13, "^", "@This 5"], "*", 3], [false, true]]
                ];
                winConditions = [[3, 5, 0, 0, 0, 0]];
                document.documentElement.style.setProperty("background-image", "linear-gradient(#90cdff, #00447c)");
                document.documentElement.style.setProperty("--background-color", "linear-gradient(#73c0ff, #005eac)");
                document.documentElement.style.setProperty("--grid-color", "#125c99");
                document.documentElement.style.setProperty("--tile-color", "#3f89c6");
                document.documentElement.style.setProperty("--text-color", "#003159");
            }
            else if (mode_vars[0] == 2) { // Medium
                document.getElementById("2100_difficulty_text").innerHTML = "Medium: rightwards is X + X, downwards is X + 2X, leftwards is X + 3X, upwards is 2X + 3X. Moves between grids have the same merge rules as their corresponding moves within a grid.";
                document.getElementById("2100_difficulty_text").style.setProperty("color", "#7573ff");
                document.getElementById("2100_difficulty_decrease").style.setProperty("display", "block");
                document.getElementById("2100_difficulty_increase").style.setProperty("display", "block");
                displayRules("rules_text", ["h2", "Directional Merges (Medium)"], ["h1", "2160"], ["p","The merge rules are different depending on which direction you're moving. On a rightwards move, merges occur between two equal tiles. On a downwards move, merges occur between an X tile and a 2X tile, for any X. On a leftwards move, merges occur between an X tile and a 3X tile, for any X. On an upwards move, merges occur between a 2X tile and a 3X tile, for any X. Moves between grids have the same merge rules as their corresponding moves within a grid. Get to the 2160 tile to win!"],
                ["p", "Spawning tiles: 1 (100%)"]);
                displayRules("gm_rules_text", ["h2", "Directional Merges (Medium)"], ["h1", "2160"], ["p","The merge rules are different depending on which direction you're moving. On a rightwards move, merges occur between two equal tiles. On a downwards move, merges occur between an X tile and a 2X tile, for any X. On a leftwards move, merges occur between an X tile and a 3X tile, for any X. On an upwards move, merges occur between a 2X tile and a 3X tile, for any X. Moves between grids have the same merge rules as their corresponding moves within a grid. Get to the 2160 tile to win!"],
                ["p", "Spawning tiles: 1 (100%)"]);
                MergeRules = [
                    [2, [["@HDir", ">", 0], "&&", ["@This 0", "=", "@Next 1 0"], "&&", ["@This 1", "=", "@Next 1 1"], "&&", ["@This 2", "=", "@Next 1 2"], "&&", ["@This 3", "=", "@Next 1 3"], "&&", ["@This 4", "=", "@Next 1 4"], "&&", ["@This 5", "=", "@Next 1 5"]], false, [[["@This 0", "+", 1], "@This 1", "@This 2", "@This 3", "@This 4", "@This 5"]], [[2, "^", "@This 0"], "*", [3, "^", "@This 1"], "*", [5, "^", "@This 2"], "*", [7, "^", "@This 3"], "*", [11, "^", "@This 4"], "*", [13, "^", "@This 5"], "*", 2], [false, true]],
                    [2, [["@VDir", ">", 0], "&&", ["@This 0", "+", 1, "=", "@Next 1 0"], "&&", ["@This 1", "=", "@Next 1 1"], "&&", ["@This 2", "=", "@Next 1 2"], "&&", ["@This 3", "=", "@Next 1 3"], "&&", ["@This 4", "=", "@Next 1 4"], "&&", ["@This 5", "=", "@Next 1 5"]], false, [["@This 0", ["@This 1", "+", 1], "@This 2", "@This 3", "@This 4", "@This 5"]], [[2, "^", "@This 0"], "*", [3, "^", "@This 1"], "*", [5, "^", "@This 2"], "*", [7, "^", "@This 3"], "*", [11, "^", "@This 4"], "*", [13, "^", "@This 5"], "*", 3], [false, true]],
                    [2, [["@HDir", "<", 0], "&&", ["@This 0", "=", "@Next 1 0"], "&&", ["@This 1", "+", 1, "=", "@Next 1 1"], "&&", ["@This 2", "=", "@Next 1 2"], "&&", ["@This 3", "=", "@Next 1 3"], "&&", ["@This 4", "=", "@Next 1 4"], "&&", ["@This 5", "=", "@Next 1 5"]], false, [[["@This 0", "+", 2], "@This 1", "@This 2", "@This 3", "@This 4", "@This 5"]], [[2, "^", "@This 0"], "*", [3, "^", "@This 1"], "*", [5, "^", "@This 2"], "*", [7, "^", "@This 3"], "*", [11, "^", "@This 4"], "*", [13, "^", "@This 5"], "*", 4], [false, true]],
                    [2, [["@VDir", "<", 0], "&&", ["@This 0", "-", 1, "=", "@Next 1 0"], "&&", ["@This 1", "+", 1, "=", "@Next 1 1"], "&&", ["@This 2", "=", "@Next 1 2"], "&&", ["@This 3", "=", "@Next 1 3"], "&&", ["@This 4", "=", "@Next 1 4"], "&&", ["@This 5", "=", "@Next 1 5"]], false, [[["@This 0", "-", 1], "@This 1", ["@This 2", "+", 1], "@This 3", "@This 4", "@This 5"]], [[2, "^", "@This 0"], "*", [3, "^", "@This 1"], "*", [5, "^", "@This 2"], "*", [7, "^", "@This 3"], "*", [11, "^", "@This 4"], "*", [13, "^", "@This 5"], "*", 5, "/", 2], [false, true]]
                ];
                winConditions = [[4, 3, 1, 0, 0, 0]];
                document.documentElement.style.setProperty("background-image", "linear-gradient(#c2acff, #004f4f)");
                document.documentElement.style.setProperty("--background-color", "linear-gradient(#926aff, #008383)");
                document.documentElement.style.setProperty("--grid-color", "#218383");
                document.documentElement.style.setProperty("--tile-color", "#977ce1");
                document.documentElement.style.setProperty("--text-color", "#23144e");
            }
            else if (mode_vars[0] == 3) { // Hard
                document.getElementById("2100_difficulty_text").innerHTML = "Hard: rightwards is X + X, downwards is X + 2X, leftwards is X + 4X, upwards is 3X + 4X. Moves between grids have the same merge rules as their corresponding moves within a grid.";
                document.getElementById("2100_difficulty_text").style.setProperty("color", "#bc79ff");
                document.getElementById("2100_difficulty_decrease").style.setProperty("opacity", "block");
                document.getElementById("2100_difficulty_increase").style.setProperty("display", "block");
                displayRules("rules_text", ["h2", "Directional Merges (Hard)"], ["h1", "2100"], ["p","The merge rules are different depending on which direction you're moving. On a rightwards move, merges occur between two equal tiles. On a downwards move, merges occur between an X tile and a 2X tile, for any X. On a leftwards move, merges occur between an X tile and a 4X tile, for any X. On an upwards move, merges occur between a 3X tile and a 4X tile, for any X. Moves between grids have the same merge rules as their corresponding moves within a grid. Get to the 2100 tile to win!"],
                ["p", "Spawning tiles: 1 (100%)"]);
                displayRules("gm_rules_text", ["h2", "Directional Merges (Hard)"], ["h1", "2100"], ["p","The merge rules are different depending on which direction you're moving. On a rightwards move, merges occur between two equal tiles. On a downwards move, merges occur between an X tile and a 2X tile, for any X. On a leftwards move, merges occur between an X tile and a 4X tile, for any X. On an upwards move, merges occur between a 3X tile and a 4X tile, for any X. Moves between grids have the same merge rules as their corresponding moves within a grid. Get to the 2100 tile to win!"],
                ["p", "Spawning tiles: 1 (100%)"]);
                MergeRules = [
                    [2, [["@HDir", ">", 0], "&&", ["@This 0", "=", "@Next 1 0"], "&&", ["@This 1", "=", "@Next 1 1"], "&&", ["@This 2", "=", "@Next 1 2"], "&&", ["@This 3", "=", "@Next 1 3"], "&&", ["@This 4", "=", "@Next 1 4"], "&&", ["@This 5", "=", "@Next 1 5"]], false, [[["@This 0", "+", 1], "@This 1", "@This 2", "@This 3", "@This 4", "@This 5"]], [[2, "^", "@This 0"], "*", [3, "^", "@This 1"], "*", [5, "^", "@This 2"], "*", [7, "^", "@This 3"], "*", [11, "^", "@This 4"], "*", [13, "^", "@This 5"], "*", 2], [false, true]],
                    [2, [["@VDir", ">", 0], "&&", ["@This 0", "+", 1, "=", "@Next 1 0"], "&&", ["@This 1", "=", "@Next 1 1"], "&&", ["@This 2", "=", "@Next 1 2"], "&&", ["@This 3", "=", "@Next 1 3"], "&&", ["@This 4", "=", "@Next 1 4"], "&&", ["@This 5", "=", "@Next 1 5"]], false, [["@This 0", ["@This 1", "+", 1], "@This 2", "@This 3", "@This 4", "@This 5"]], [[2, "^", "@This 0"], "*", [3, "^", "@This 1"], "*", [5, "^", "@This 2"], "*", [7, "^", "@This 3"], "*", [11, "^", "@This 4"], "*", [13, "^", "@This 5"], "*", 3], [false, true]],
                    [2, [["@HDir", "<", 0], "&&", ["@This 0", "+", 2, "=", "@Next 1 0"], "&&", ["@This 1", "=", "@Next 1 1"], "&&", ["@This 2", "=", "@Next 1 2"], "&&", ["@This 3", "=", "@Next 1 3"], "&&", ["@This 4", "=", "@Next 1 4"], "&&", ["@This 5", "=", "@Next 1 5"]], false, [["@This 0", "@This 1", ["@This 2", "+", 1], "@This 3", "@This 4", "@This 5"]], [[2, "^", "@This 0"], "*", [3, "^", "@This 1"], "*", [5, "^", "@This 2"], "*", [7, "^", "@This 3"], "*", [11, "^", "@This 4"], "*", [13, "^", "@This 5"], "*", 5], [false, true]],
                    [2, [["@VDir", "<", 0], "&&", ["@This 0", "+", 2, "=", "@Next 1 0"], "&&", ["@This 1", "-", 1, "=", "@Next 1 1"], "&&", ["@This 2", "=", "@Next 1 2"], "&&", ["@This 3", "=", "@Next 1 3"], "&&", ["@This 4", "=", "@Next 1 4"], "&&", ["@This 5", "=", "@Next 1 5"]], false, [["@This 0", ["@This 1", "-", 1], "@This 2", ["@This 3", "+", 1], "@This 4", "@This 5"]], [[2, "^", "@This 0"], "*", [3, "^", "@This 1"], "*", [5, "^", "@This 2"], "*", [7, "^", "@This 3"], "*", [11, "^", "@This 4"], "*", [13, "^", "@This 5"], "*", 7, "/", 3], [false, true]]
                ];
                winConditions = [[2, 1, 2, 1, 0, 0]];
                document.documentElement.style.setProperty("background-image", "linear-gradient(#e6b5ff, #19004d)");
                document.documentElement.style.setProperty("--background-color", "linear-gradient(#db93ff, #200061)");
                document.documentElement.style.setProperty("--grid-color", "#330099");
                document.documentElement.style.setProperty("--tile-color", "#cb63ff");
                document.documentElement.style.setProperty("--text-color", "#2c0d4b");
            }
            else if (mode_vars[0] == 4) { // 4D Hard
                document.getElementById("2100_difficulty_text").innerHTML = "4D Hard: rightwards is X + X, downwards is X + 2X, leftwards is X + 3X, upwards is 2X + 3X, 4D-right is X + 5X, 4D-down is 2X + 5X, 4D-left is X + 7X, 4D-up is 2X + 7X.";
                document.getElementById("2100_difficulty_text").style.setProperty("color", "#bc79ff");
                document.getElementById("2100_difficulty_decrease").style.setProperty("opacity", "block");
                document.getElementById("2100_difficulty_increase").style.setProperty("display", "block");
                displayRules("rules_text", ["h2", "Directional Merges (4D Hard)"], ["h1", "2100"], ["p","The merge rules are different depending on which direction you're moving. On a rightwards move, merges occur between two equal tiles. On a downwards move, merges occur between an X tile and a 2X tile. On a leftwards move, merges occur between an X tile and a 3X tile. On an upwards move, merges occur between a 2X tile and a 3X tile. On a 4D-right move, merges occur between an X tile and a 5X tile. On a 4D-down move, merges occur between a 2X tile and a 5X tile. On a 4D-left move, merges occur between an X tile and a 7X tile. On a 4D-up move, merges occur between a 2X tile and a 7X tile. Get to the 2100 tile to win!"],
                ["p", "Spawning tiles: 1 (100%)"]);
                displayRules("gm_rules_text", ["h2", "Directional Merges (4D Hard)"], ["h1", "2100"], ["p","The merge rules are different depending on which direction you're moving. On a rightwards move, merges occur between two equal tiles. On a downwards move, merges occur between an X tile and a 2X tile. On a leftwards move, merges occur between an X tile and a 3X tile. On an upwards move, merges occur between a 2X tile and a 3X tile. On a 4D-right move, merges occur between an X tile and a 5X tile. On a 4D-down move, merges occur between a 2X tile and a 5X tile. On a 4D-left move, merges occur between an X tile and a 7X tile. On a 4D-up move, merges occur between a 2X tile and a 7X tile. Get to the 2100 tile to win!"],
                ["p", "Spawning tiles: 1 (100%)"]);
                MergeRules = [
                    [2, [["@HDir", "=", 1], "&&", ["@This 0", "=", "@Next 1 0"], "&&", ["@This 1", "=", "@Next 1 1"], "&&", ["@This 2", "=", "@Next 1 2"], "&&", ["@This 3", "=", "@Next 1 3"], "&&", ["@This 4", "=", "@Next 1 4"], "&&", ["@This 5", "=", "@Next 1 5"]], false, [[["@This 0", "+", 1], "@This 1", "@This 2", "@This 3", "@This 4", "@This 5"]], [[2, "^", "@This 0"], "*", [3, "^", "@This 1"], "*", [5, "^", "@This 2"], "*", [7, "^", "@This 3"], "*", [11, "^", "@This 4"], "*", [13, "^", "@This 5"], "*", 2], [false, true]],
                    [2, [["@VDir", "=", 1], "&&", ["@This 0", "+", 1, "=", "@Next 1 0"], "&&", ["@This 1", "=", "@Next 1 1"], "&&", ["@This 2", "=", "@Next 1 2"], "&&", ["@This 3", "=", "@Next 1 3"], "&&", ["@This 4", "=", "@Next 1 4"], "&&", ["@This 5", "=", "@Next 1 5"]], false, [["@This 0", ["@This 1", "+", 1], "@This 2", "@This 3", "@This 4", "@This 5"]], [[2, "^", "@This 0"], "*", [3, "^", "@This 1"], "*", [5, "^", "@This 2"], "*", [7, "^", "@This 3"], "*", [11, "^", "@This 4"], "*", [13, "^", "@This 5"], "*", 3], [false, true]],
                    [2, [["@HDir", "=", -1], "&&", ["@This 0", "=", "@Next 1 0"], "&&", ["@This 1", "+", 1, "=", "@Next 1 1"], "&&", ["@This 2", "=", "@Next 1 2"], "&&", ["@This 3", "=", "@Next 1 3"], "&&", ["@This 4", "=", "@Next 1 4"], "&&", ["@This 5", "=", "@Next 1 5"]], false, [[["@This 0", "+", 2], "@This 1", "@This 2", "@This 3", "@This 4", "@This 5"]], [[2, "^", "@This 0"], "*", [3, "^", "@This 1"], "*", [5, "^", "@This 2"], "*", [7, "^", "@This 3"], "*", [11, "^", "@This 4"], "*", [13, "^", "@This 5"], "*", 4], [false, true]],
                    [2, [["@VDir", "=", -1], "&&", ["@This 0", "-", 1, "=", "@Next 1 0"], "&&", ["@This 1", "+", 1, "=", "@Next 1 1"], "&&", ["@This 2", "=", "@Next 1 2"], "&&", ["@This 3", "=", "@Next 1 3"], "&&", ["@This 4", "=", "@Next 1 4"], "&&", ["@This 5", "=", "@Next 1 5"]], false, [[["@This 0", "-", 1], "@This 1", ["@This 2", "+", 1], "@This 3", "@This 4", "@This 5"]], [[2, "^", "@This 0"], "*", [3, "^", "@This 1"], "*", [5, "^", "@This 2"], "*", [7, "^", "@This 3"], "*", [11, "^", "@This 4"], "*", [13, "^", "@This 5"], "*", 5, "/", 2], [false, true]],
                    [2, [["@HDir", ">", 1], "&&", ["@This 0", "=", "@Next 1 0"], "&&", ["@This 1", "=", "@Next 1 1"], "&&", ["@This 2", "+", 1, "=", "@Next 1 2"], "&&", ["@This 3", "=", "@Next 1 3"], "&&", ["@This 4", "=", "@Next 1 4"], "&&", ["@This 5", "=", "@Next 1 5"]], false, [[["@This 0", "+", 1], ["@This 1", "+", 1], "@This 2", "@This 3", "@This 4", "@This 5"]], [[2, "^", "@This 0"], "*", [3, "^", "@This 1"], "*", [5, "^", "@This 2"], "*", [7, "^", "@This 3"], "*", [11, "^", "@This 4"], "*", [13, "^", "@This 5"], "*", 6], [false, true]],
                    [2, [["@VDir", ">", 1], "&&", ["@This 0", "-", 1, "=", "@Next 1 0"], "&&", ["@This 1", "=", "@Next 1 1"], "&&", ["@This 2", "+", 1, "=", "@Next 1 2"], "&&", ["@This 3", "=", "@Next 1 3"], "&&", ["@This 4", "=", "@Next 1 4"], "&&", ["@This 5", "=", "@Next 1 5"]], false, [[["@This 0", "-", 1], "@This 1", "@This 2", ["@This 3", "+", 1], "@This 4", "@This 5"]], [[2, "^", "@This 0"], "*", [3, "^", "@This 1"], "*", [5, "^", "@This 2"], "*", [7, "^", "@This 3"], "*", [11, "^", "@This 4"], "*", [13, "^", "@This 5"], "*", 7, "/", 2], [false, true]],
                    [2, [["@HDir", "<", -1], "&&", ["@This 0", "=", "@Next 1 0"], "&&", ["@This 1", "=", "@Next 1 1"], "&&", ["@This 2", "=", "@Next 1 2"], "&&", ["@This 3", "+", 1, "=", "@Next 1 3"], "&&", ["@This 4", "=", "@Next 1 4"], "&&", ["@This 5", "=", "@Next 1 5"]], false, [[["@This 0", "+", 3], "@This 1", "@This 2", "@This 3", "@This 4", "@This 5"]], [[2, "^", "@This 0"], "*", [3, "^", "@This 1"], "*", [5, "^", "@This 2"], "*", [7, "^", "@This 3"], "*", [11, "^", "@This 4"], "*", [13, "^", "@This 5"], "*", 8], [false, true]],
                    [2, [["@VDir", "<", -1], "&&", ["@This 0", "-", 1, "=", "@Next 1 0"], "&&", ["@This 1", "=", "@Next 1 1"], "&&", ["@This 2", "=", "@Next 1 2"], "&&", ["@This 3", "+", 1, "=", "@Next 1 3"], "&&", ["@This 4", "=", "@Next 1 4"], "&&", ["@This 5", "=", "@Next 1 5"]], false, [[["@This 0", "-", 1], ["@This 1", "+", 2], "@This 2", "@This 3", "@This 4", "@This 5"]], [[2, "^", "@This 0"], "*", [3, "^", "@This 1"], "*", [5, "^", "@This 2"], "*", [7, "^", "@This 3"], "*", [11, "^", "@This 4"], "*", [13, "^", "@This 5"], "*", 9, "/", 2], [false, true]],
                ];
                winConditions = [[2, 1, 2, 1, 0, 0]];
                document.documentElement.style.setProperty("background-image", "linear-gradient(#e6b5ff, #19004d)");
                document.documentElement.style.setProperty("--background-color", "linear-gradient(#db93ff, #200061)");
                document.documentElement.style.setProperty("--grid-color", "#330099");
                document.documentElement.style.setProperty("--tile-color", "#cb63ff");
                document.documentElement.style.setProperty("--text-color", "#2c0d4b");
            }
            else if (mode_vars[0] == 5) { // 4D Extreme
                document.getElementById("2100_difficulty_text").innerHTML = "4D Extreme: rightwards is X + X, downwards is X + 2X, leftwards is X + 4X, upwards is 3X + 4X, 4D-right is X + 8X, 4D-down is 3X + 8X, 4D-left is 5X + 8X, 4D-up is 7X + 8X.";
                document.getElementById("2100_difficulty_text").style.setProperty("color", "#ffad9c");
                document.getElementById("2100_difficulty_decrease").style.setProperty("opacity", "block");
                document.getElementById("2100_difficulty_increase").style.setProperty("display", "none");
                displayRules("rules_text", ["h2", "Directional Merges (4D Extreme)"], ["h1", "2002"], ["p","The merge rules are different depending on which direction you're moving. On a rightwards move, merges occur between two equal tiles. On a downwards move, merges occur between an X tile and a 2X tile. On a leftwards move, merges occur between an X tile and a 4X tile. On an upwards move, merges occur between a 3X tile and a 4X tile. On a 4D-right move, merges occur between an X tile and an 8X tile. On a 4D-down move, merges occur between a 3X tile and an 8X tile. On a 4D-left move, merges occur between a 5X tile and an 8X tile. On a 4D-up move, merges occur between a 7X tile and an 8X tile. Get to the 2002 tile to win!"],
                ["p", "Spawning tiles: 1 (100%)"]);
                displayRules("gm_rules_text", ["h2", "Directional Merges (4D Extreme)"], ["h1", "2002"], ["p","The merge rules are different depending on which direction you're moving. On a rightwards move, merges occur between two equal tiles. On a downwards move, merges occur between an X tile and a 2X tile. On a leftwards move, merges occur between an X tile and a 4X tile. On an upwards move, merges occur between a 3X tile and a 4X tile. On a 4D-right move, merges occur between an X tile and an 8X tile. On a 4D-down move, merges occur between a 3X tile and an 8X tile. On a 4D-left move, merges occur between a 5X tile and an 8X tile. On a 4D-up move, merges occur between a 7X tile and an 8X tile. Get to the 2002 tile to win!"],
                ["p", "Spawning tiles: 1 (100%)"]);
                MergeRules = [
                    [2, [["@HDir", "=", 1], "&&", ["@This 0", "=", "@Next 1 0"], "&&", ["@This 1", "=", "@Next 1 1"], "&&", ["@This 2", "=", "@Next 1 2"], "&&", ["@This 3", "=", "@Next 1 3"], "&&", ["@This 4", "=", "@Next 1 4"], "&&", ["@This 5", "=", "@Next 1 5"]], false, [[["@This 0", "+", 1], "@This 1", "@This 2", "@This 3", "@This 4", "@This 5"]], [[2, "^", "@This 0"], "*", [3, "^", "@This 1"], "*", [5, "^", "@This 2"], "*", [7, "^", "@This 3"], "*", [11, "^", "@This 4"], "*", [13, "^", "@This 5"], "*", 2], [false, true]],
                    [2, [["@VDir", "=", 1], "&&", ["@This 0", "+", 1, "=", "@Next 1 0"], "&&", ["@This 1", "=", "@Next 1 1"], "&&", ["@This 2", "=", "@Next 1 2"], "&&", ["@This 3", "=", "@Next 1 3"], "&&", ["@This 4", "=", "@Next 1 4"], "&&", ["@This 5", "=", "@Next 1 5"]], false, [["@This 0", ["@This 1", "+", 1], "@This 2", "@This 3", "@This 4", "@This 5"]], [[2, "^", "@This 0"], "*", [3, "^", "@This 1"], "*", [5, "^", "@This 2"], "*", [7, "^", "@This 3"], "*", [11, "^", "@This 4"], "*", [13, "^", "@This 5"], "*", 3], [false, true]],
                    [2, [["@HDir", "=", -1], "&&", ["@This 0", "+", 2, "=", "@Next 1 0"], "&&", ["@This 1", "=", "@Next 1 1"], "&&", ["@This 2", "=", "@Next 1 2"], "&&", ["@This 3", "=", "@Next 1 3"], "&&", ["@This 4", "=", "@Next 1 4"], "&&", ["@This 5", "=", "@Next 1 5"]], false, [["@This 0", "@This 1", ["@This 2", "+", 1], "@This 3", "@This 4", "@This 5"]], [[2, "^", "@This 0"], "*", [3, "^", "@This 1"], "*", [5, "^", "@This 2"], "*", [7, "^", "@This 3"], "*", [11, "^", "@This 4"], "*", [13, "^", "@This 5"], "*", 5], [false, true]],
                    [2, [["@VDir", "=", -1], "&&", ["@This 0", "+", 2, "=", "@Next 1 0"], "&&", ["@This 1", "-", 1, "=", "@Next 1 1"], "&&", ["@This 2", "=", "@Next 1 2"], "&&", ["@This 3", "=", "@Next 1 3"], "&&", ["@This 4", "=", "@Next 1 4"], "&&", ["@This 5", "=", "@Next 1 5"]], false, [["@This 0", ["@This 1", "-", 1], "@This 2", ["@This 3", "+", 1], "@This 4", "@This 5"]], [[2, "^", "@This 0"], "*", [3, "^", "@This 1"], "*", [5, "^", "@This 2"], "*", [7, "^", "@This 3"], "*", [11, "^", "@This 4"], "*", [13, "^", "@This 5"], "*", 7, "/", 3], [false, true]],
                    [2, [["@HDir", ">", 1], "&&", ["@This 0", "+", 3, "=", "@Next 1 0"], "&&", ["@This 1", "=", "@Next 1 1"], "&&", ["@This 2", "=", "@Next 1 2"], "&&", ["@This 3", "=", "@Next 1 3"], "&&", ["@This 4", "=", "@Next 1 4"], "&&", ["@This 5", "=", "@Next 1 5"]], false, [["@This 0", ["@This 1", "+", 2], "@This 2", "@This 3", "@This 4", "@This 5"]], [[2, "^", "@This 0"], "*", [3, "^", "@This 1"], "*", [5, "^", "@This 2"], "*", [7, "^", "@This 3"], "*", [11, "^", "@This 4"], "*", [13, "^", "@This 5"], "*", 9], [false, true]],
                    [2, [["@VDir", ">", 1], "&&", ["@This 0", "+", 3, "=", "@Next 1 0"], "&&", ["@This 1", "-", 1, "=", "@Next 1 1"], "&&", ["@This 2", "=", "@Next 1 2"], "&&", ["@This 3", "=", "@Next 1 3"], "&&", ["@This 4", "=", "@Next 1 4"], "&&", ["@This 5", "=", "@Next 1 5"]], false, [["@This 0", ["@This 1", "-", 1], "@This 2", "@This 3", ["@This 4", "+", 1], "@This 5"]], [[2, "^", "@This 0"], "*", [3, "^", "@This 1"], "*", [5, "^", "@This 2"], "*", [7, "^", "@This 3"], "*", [11, "^", "@This 4"], "*", [13, "^", "@This 5"], "*", 11, "/", 3], [false, true]],
                    [2, [["@HDir", "<", -1], "&&", ["@This 0", "+", 3, "=", "@Next 1 0"], "&&", ["@This 1", "=", "@Next 1 1"], "&&", ["@This 2", "-", 1, "=", "@Next 1 2"], "&&", ["@This 3", "=", "@Next 1 3"], "&&", ["@This 4", "=", "@Next 1 4"], "&&", ["@This 5", "=", "@Next 1 5"]], false, [["@This 0", "@This 1", ["@This 2", "-", 1], "@This 3", "@This 4", ["@This 5", "+", 1]]], [[2, "^", "@This 0"], "*", [3, "^", "@This 1"], "*", [5, "^", "@This 2"], "*", [7, "^", "@This 3"], "*", [11, "^", "@This 4"], "*", [13, "^", "@This 5"], "*", 13, "/", 5], [false, true]],
                    [2, [["@VDir", "<", -1], "&&", ["@This 0", "+", 3, "=", "@Next 1 0"], "&&", ["@This 1", "=", "@Next 1 1"], "&&", ["@This 2", "=", "@Next 1 2"], "&&", ["@This 3", "-", 1, "=", "@Next 1 3"], "&&", ["@This 4", "=", "@Next 1 4"], "&&", ["@This 5", "=", "@Next 1 5"]], false, [["@This 0", ["@This 1", "+", 1], ["@This 2", "+", 1], ["@This 3", "-", 1], "@This 4", "@This 5"]], [[2, "^", "@This 0"], "*", [3, "^", "@This 1"], "*", [5, "^", "@This 2"], "*", [7, "^", "@This 3"], "*", [11, "^", "@This 4"], "*", [13, "^", "@This 5"], "*", 15, "/", 7], [false, true]],
                ];
                winConditions = [[1, 0, 0, 1, 1, 1]];
                document.documentElement.style.setProperty("background-image", "linear-gradient(#ffa0a0, #bbbb00, #9c673b)");
                document.documentElement.style.setProperty("--background-color", "linear-gradient(#ff6c6c, #999900, #b87a47)");
                document.documentElement.style.setProperty("--grid-color", "#be7b43");
                document.documentElement.style.setProperty("--tile-color", "#e06b6b");
                document.documentElement.style.setProperty("--text-color", "#484800");
            }
        }
        else if (modifiers[5] == "Hexagon" || (modifiers[5] == "Custom" && hexagonal)) { // Hexagonal grid, which has to do its own thing from the rest since its directions are different. Hexa-diagonal directions always allow both of the merges allowed by their constituents, because I'm not going to implement a mode of this with twelve independent directions and primes up to 23
            if (mode_vars[0] == 1) { // Hexagonal Easy
                document.getElementById("2100_difficulty_text").innerHTML = "Hexagonal Easy: Any rightwards direction is X + X, any leftwards direction is X + 2X.";
                document.getElementById("2100_difficulty_text").style.setProperty("color", "#a0d4ff");
                document.getElementById("2100_difficulty_decrease").style.setProperty("display", "none");
                document.getElementById("2100_difficulty_increase").style.setProperty("display", "block");
                displayRules("rules_text", ["h2", "Directional Merges (Hexagonal Easy)"], ["h1", "1944"], ["p","The merge rules are different depending on which direction you're moving. On any rightwards move, merges occur between two equal tiles. On any leftwards move, merges occur between an X tile and a 2X tile, for any X. Get to the 1944 tile to win!"],
                ["p", "Spawning tiles: 1 (100%)"]);
                displayRules("gm_rules_text", ["h2", "Directional Merges (Hexagonal Easy)"], ["h1", "1944"], ["p","The merge rules are different depending on which direction you're moving. On any rightwards move, merges occur between two equal tiles. On any leftwards move, merges occur between an X tile and a 2X tile, for any X. Get to the 1944 tile to win!"],
                ["p", "Spawning tiles: 1 (100%)"]);
                MergeRules = [
                    [2, [["@HDir", ">=", 0], "&&", ["@This 0", "=", "@Next 1 0"], "&&", ["@This 1", "=", "@Next 1 1"], "&&", ["@This 2", "=", "@Next 1 2"], "&&", ["@This 3", "=", "@Next 1 3"], "&&", ["@This 4", "=", "@Next 1 4"], "&&", ["@This 5", "=", "@Next 1 5"]], false, [[["@This 0", "+", 1], "@This 1", "@This 2", "@This 3", "@This 4", "@This 5"]], [[2, "^", "@This 0"], "*", [3, "^", "@This 1"], "*", [5, "^", "@This 2"], "*", [7, "^", "@This 3"], "*", [11, "^", "@This 4"], "*", [13, "^", "@This 5"], "*", 2], [false, true]],
                    [2, [["@HDir", "<=", 0], "&&", ["@This 0", "+", 1, "=", "@Next 1 0"], "&&", ["@This 1", "=", "@Next 1 1"], "&&", ["@This 2", "=", "@Next 1 2"], "&&", ["@This 3", "=", "@Next 1 3"], "&&", ["@This 4", "=", "@Next 1 4"], "&&", ["@This 5", "=", "@Next 1 5"]], false, [["@This 0", ["@This 1", "+", 1], "@This 2", "@This 3", "@This 4", "@This 5"]], [[2, "^", "@This 0"], "*", [3, "^", "@This 1"], "*", [5, "^", "@This 2"], "*", [7, "^", "@This 3"], "*", [11, "^", "@This 4"], "*", [13, "^", "@This 5"], "*", 3], [false, true]]
                ];
                winConditions = [[3, 5, 0, 0, 0, 0]];
                document.documentElement.style.setProperty("background-image", "linear-gradient(#90cdff, #00447c)");
                document.documentElement.style.setProperty("--background-color", "linear-gradient(#73c0ff, #005eac)");
                document.documentElement.style.setProperty("--grid-color", "#125c99");
                document.documentElement.style.setProperty("--tile-color", "#3f89c6");
                document.documentElement.style.setProperty("--text-color", "#003159");
            }
            else if (mode_vars[0] == 2) { // Hexagonal Medium
                document.getElementById("2100_difficulty_text").innerHTML = "Hexagonal Medium: rightwards and southeast are X + X, southwest and leftwards are X + 2X, northwest and northeast are 2X + 3X.";
                document.getElementById("2100_difficulty_text").style.setProperty("color", "#7573ff");
                document.getElementById("2100_difficulty_decrease").style.setProperty("display", "block");
                document.getElementById("2100_difficulty_increase").style.setProperty("display", "block");
                displayRules("rules_text", ["h2", "Directional Merges (Hexagonal Medium)"], ["h1", "2160"], ["p","The merge rules are different depending on which direction you're moving. On a rightwards or southeast move, merges occur between two equal tiles. On a southwest or leftwards move, merges occur between an X tile and a 2X tile, for any X. On a northwest or northeast move, merges occur between an 2X tile and a 3X tile, for any X. Get to the 2160 tile to win!"],
                ["p", "Spawning tiles: 1 (100%)"]);
                displayRules("gm_rules_text", ["h2", "Directional Merges (Hexagonal Medium)"], ["h1", "2160"], ["p","The merge rules are different depending on which direction you're moving. On a rightwards or southeast move, merges occur between two equal tiles. On a southwest or leftwards move, merges occur between an X tile and a 2X tile, for any X. On a northwest or northeast move, merges occur between an 2X tile and a 3X tile, for any X. Get to the 2160 tile to win!"],
                ["p", "Spawning tiles: 1 (100%)"]);
                MergeRules = [
                    [2, [["@HDir", ">=", 2], "||", [["@HDir", ">=", 0], "&&", ["@VDir", ">", 0]], "&&", ["@This 0", "=", "@Next 1 0"], "&&", ["@This 1", "=", "@Next 1 1"], "&&", ["@This 2", "=", "@Next 1 2"], "&&", ["@This 3", "=", "@Next 1 3"], "&&", ["@This 4", "=", "@Next 1 4"], "&&", ["@This 5", "=", "@Next 1 5"]], false, [[["@This 0", "+", 1], "@This 1", "@This 2", "@This 3", "@This 4", "@This 5"]], [[2, "^", "@This 0"], "*", [3, "^", "@This 1"], "*", [5, "^", "@This 2"], "*", [7, "^", "@This 3"], "*", [11, "^", "@This 4"], "*", [13, "^", "@This 5"], "*", 2], [false, true]],
                    [2, [["@HDir", "<=", -2], "||", [["@HDir", "<=", 0], "&&", ["@VDir", ">", 0]], "&&", ["@This 0", "+", 1, "=", "@Next 1 0"], "&&", ["@This 1", "=", "@Next 1 1"], "&&", ["@This 2", "=", "@Next 1 2"], "&&", ["@This 3", "=", "@Next 1 3"], "&&", ["@This 4", "=", "@Next 1 4"], "&&", ["@This 5", "=", "@Next 1 5"]], false, [["@This 0", ["@This 1", "+", 1], "@This 2", "@This 3", "@This 4", "@This 5"]], [[2, "^", "@This 0"], "*", [3, "^", "@This 1"], "*", [5, "^", "@This 2"], "*", [7, "^", "@This 3"], "*", [11, "^", "@This 4"], "*", [13, "^", "@This 5"], "*", 3], [false, true]],
                    [2, [["@VDir", "<", 0], "&&", ["@This 0", "-", 1, "=", "@Next 1 0"], "&&", ["@This 1", "+", 1, "=", "@Next 1 1"], "&&", ["@This 2", "=", "@Next 1 2"], "&&", ["@This 3", "=", "@Next 1 3"], "&&", ["@This 4", "=", "@Next 1 4"], "&&", ["@This 5", "=", "@Next 1 5"]], false, [[["@This 0", "-", 1], "@This 1", ["@This 2", "+", 1], "@This 3", "@This 4", "@This 5"]], [[2, "^", "@This 0"], "*", [3, "^", "@This 1"], "*", [5, "^", "@This 2"], "*", [7, "^", "@This 3"], "*", [11, "^", "@This 4"], "*", [13, "^", "@This 5"], "*", 5, "/", 2], [false, true]]
                ];
                winConditions = [[4, 3, 1, 0, 0, 0]];
                document.documentElement.style.setProperty("background-image", "linear-gradient(#c2acff, #004f4f)");
                document.documentElement.style.setProperty("--background-color", "linear-gradient(#926aff, #008383)");
                document.documentElement.style.setProperty("--grid-color", "#218383");
                document.documentElement.style.setProperty("--tile-color", "#977ce1");
                document.documentElement.style.setProperty("--text-color", "#23144e");
            }
            else if (mode_vars[0] == 3) { // Hexagonal Hard
                document.getElementById("2100_difficulty_text").innerHTML = "Hexagonal Hard: rightwards is X + X, southeast is X + 2X, southwest is X + 3X, leftwards is 2X + 3X, northwest is X + 5X, northeast is 2X + 5X.";
                document.getElementById("2100_difficulty_text").style.setProperty("color", "#bc79ff");
                document.getElementById("2100_difficulty_decrease").style.setProperty("opacity", "block");
                document.getElementById("2100_difficulty_increase").style.setProperty("display", "block");
                displayRules("rules_text", ["h2", "Directional Merges (Hexagonal Hard)"], ["h1", "2100"], ["p","The merge rules are different depending on which direction you're moving. On a rightwards move, merges occur between two equal tiles. On a southeast move, merges occur between an X tile and a 2X tile. On a southwest move, merges occur between an X tile and a 3X tile. On a leftwards move, merges occur between a 2X tile and a 3X tile. On a northwest move, merges occur between an X tile and a 5X tile. On a northeast move, merges occur between a 2X tile and a 5X tile. Get to the 2100 tile to win!"],
                ["p", "Spawning tiles: 1 (100%)"]);
                displayRules("gm_rules_text", ["h2", "Directional Merges (Hexagonal Hard)"], ["h1", "2100"], ["p","The merge rules are different depending on which direction you're moving. On a rightwards move, merges occur between two equal tiles. On a southeast move, merges occur between an X tile and a 2X tile. On a southwest move, merges occur between an X tile and a 3X tile. On a leftwards move, merges occur between a 2X tile and a 3X tile. On a northwest move, merges occur between an X tile and a 5X tile. On a northeast move, merges occur between a 2X tile and a 5X tile. Get to the 2100 tile to win!"],
                ["p", "Spawning tiles: 1 (100%)"]);
                MergeRules = [
                    [2, [["@HDir", ">=", 2], "&&", ["@This 0", "=", "@Next 1 0"], "&&", ["@This 1", "=", "@Next 1 1"], "&&", ["@This 2", "=", "@Next 1 2"], "&&", ["@This 3", "=", "@Next 1 3"], "&&", ["@This 4", "=", "@Next 1 4"], "&&", ["@This 5", "=", "@Next 1 5"]], false, [[["@This 0", "+", 1], "@This 1", "@This 2", "@This 3", "@This 4", "@This 5"]], [[2, "^", "@This 0"], "*", [3, "^", "@This 1"], "*", [5, "^", "@This 2"], "*", [7, "^", "@This 3"], "*", [11, "^", "@This 4"], "*", [13, "^", "@This 5"], "*", 2], [false, true]],
                    [2, [[["@HDir", ">=", 0], "&&", ["@VDir", ">", 0]], "&&", ["@This 0", "+", 1, "=", "@Next 1 0"], "&&", ["@This 1", "=", "@Next 1 1"], "&&", ["@This 2", "=", "@Next 1 2"], "&&", ["@This 3", "=", "@Next 1 3"], "&&", ["@This 4", "=", "@Next 1 4"], "&&", ["@This 5", "=", "@Next 1 5"]], false, [["@This 0", ["@This 1", "+", 1], "@This 2", "@This 3", "@This 4", "@This 5"]], [[2, "^", "@This 0"], "*", [3, "^", "@This 1"], "*", [5, "^", "@This 2"], "*", [7, "^", "@This 3"], "*", [11, "^", "@This 4"], "*", [13, "^", "@This 5"], "*", 3], [false, true]],
                    [2, [[["@HDir", "<=", 0], "&&", ["@VDir", ">", 0]], "&&", ["@This 0", "=", "@Next 1 0"], "&&", ["@This 1", "+", 1, "=", "@Next 1 1"], "&&", ["@This 2", "=", "@Next 1 2"], "&&", ["@This 3", "=", "@Next 1 3"], "&&", ["@This 4", "=", "@Next 1 4"], "&&", ["@This 5", "=", "@Next 1 5"]], false, [[["@This 0", "+", 2], "@This 1", "@This 2", "@This 3", "@This 4", "@This 5"]], [[2, "^", "@This 0"], "*", [3, "^", "@This 1"], "*", [5, "^", "@This 2"], "*", [7, "^", "@This 3"], "*", [11, "^", "@This 4"], "*", [13, "^", "@This 5"], "*", 4], [false, true]],
                    [2, [["@HDir", "<=", -2], "&&", ["@This 0", "-", 1, "=", "@Next 1 0"], "&&", ["@This 1", "+", 1, "=", "@Next 1 1"], "&&", ["@This 2", "=", "@Next 1 2"], "&&", ["@This 3", "=", "@Next 1 3"], "&&", ["@This 4", "=", "@Next 1 4"], "&&", ["@This 5", "=", "@Next 1 5"]], false, [[["@This 0", "-", 1], "@This 1", ["@This 2", "+", 1], "@This 3", "@This 4", "@This 5"]], [[2, "^", "@This 0"], "*", [3, "^", "@This 1"], "*", [5, "^", "@This 2"], "*", [7, "^", "@This 3"], "*", [11, "^", "@This 4"], "*", [13, "^", "@This 5"], "*", 5, "/", 2], [false, true]],
                    [2, [[["@HDir", "<=", 0], "&&", ["@VDir", "<", 0]], "&&", ["@This 0", "=", "@Next 1 0"], "&&", ["@This 1", "=", "@Next 1 1"], "&&", ["@This 2", "+", 1, "=", "@Next 1 2"], "&&", ["@This 3", "=", "@Next 1 3"], "&&", ["@This 4", "=", "@Next 1 4"], "&&", ["@This 5", "=", "@Next 1 5"]], false, [[["@This 0", "+", 1], ["@This 1", "+", 1], "@This 2", "@This 3", "@This 4", "@This 5"]], [[2, "^", "@This 0"], "*", [3, "^", "@This 1"], "*", [5, "^", "@This 2"], "*", [7, "^", "@This 3"], "*", [11, "^", "@This 4"], "*", [13, "^", "@This 5"], "*", 6], [false, true]],
                    [2, [[["@HDir", ">=", 0], "&&", ["@VDir", "<", 0]], "&&", ["@This 0", "-", 1, "=", "@Next 1 0"], "&&", ["@This 1", "=", "@Next 1 1"], "&&", ["@This 2", "+", 1, "=", "@Next 1 2"], "&&", ["@This 3", "=", "@Next 1 3"], "&&", ["@This 4", "=", "@Next 1 4"], "&&", ["@This 5", "=", "@Next 1 5"]], false, [[["@This 0", "-", 1], "@This 1", "@This 2", ["@This 3", "+", 1], "@This 4", "@This 5"]], [[2, "^", "@This 0"], "*", [3, "^", "@This 1"], "*", [5, "^", "@This 2"], "*", [7, "^", "@This 3"], "*", [11, "^", "@This 4"], "*", [13, "^", "@This 5"], "*", 7, "/", 2], [false, true]],
                ];
                winConditions = [[2, 1, 2, 1, 0, 0]];
                document.documentElement.style.setProperty("background-image", "linear-gradient(#e6b5ff, #19004d)");
                document.documentElement.style.setProperty("--background-color", "linear-gradient(#db93ff, #200061)");
                document.documentElement.style.setProperty("--grid-color", "#330099");
                document.documentElement.style.setProperty("--tile-color", "#cb63ff");
                document.documentElement.style.setProperty("--text-color", "#2c0d4b");
            }
            else if (mode_vars[0] == 4) { // Hexagonal Very Hard
                document.getElementById("2100_difficulty_text").innerHTML = "Hexagonal Very Hard: rightwards is X + X, southeast is X + 2X, southwest is X + 3X, leftwards is 2X + 3X, northwest is X + 6X, northeast is 5X + 6X.";
                document.getElementById("2100_difficulty_text").style.setProperty("color", "#ff7be9");
                document.getElementById("2100_difficulty_decrease").style.setProperty("opacity", "block");
                document.getElementById("2100_difficulty_increase").style.setProperty("display", "none");
                displayRules("rules_text", ["h2", "Directional Merges (Hexagonal Very Hard)"], ["h1", "2310"], ["p","The merge rules are different depending on which direction you're moving. On a rightwards move, merges occur between two equal tiles. On a southeast move, merges occur between an X tile and a 2X tile. On a southwest move, merges occur between an X tile and a 3X tile. On a leftwards move, merges occur between a 2X tile and a 3X tile. On a northwest move, merges occur between an X tile and a 6X tile. On a northeast move, merges occur between a 5X tile and a 6X tile. Get to the 2310 tile to win!"],
                ["p", "Spawning tiles: 1 (100%)"]);
                displayRules("gm_rules_text", ["h2", "Directional Merges (Hexagonal Very Hard)"], ["h1", "2310"], ["p","The merge rules are different depending on which direction you're moving. On a rightwards move, merges occur between two equal tiles. On a southeast move, merges occur between an X tile and a 2X tile. On a southwest move, merges occur between an X tile and a 3X tile. On a leftwards move, merges occur between a 2X tile and a 3X tile. On a northwest move, merges occur between an X tile and a 6X tile. On a northeast move, merges occur between a 5X tile and a 6X tile. Get to the 2310 tile to win!"],
                ["p", "Spawning tiles: 1 (100%)"]);
                MergeRules = [
                    [2, [["@HDir", ">=", 2], "&&", ["@This 0", "=", "@Next 1 0"], "&&", ["@This 1", "=", "@Next 1 1"], "&&", ["@This 2", "=", "@Next 1 2"], "&&", ["@This 3", "=", "@Next 1 3"], "&&", ["@This 4", "=", "@Next 1 4"], "&&", ["@This 5", "=", "@Next 1 5"]], false, [[["@This 0", "+", 1], "@This 1", "@This 2", "@This 3", "@This 4", "@This 5"]], [[2, "^", "@This 0"], "*", [3, "^", "@This 1"], "*", [5, "^", "@This 2"], "*", [7, "^", "@This 3"], "*", [11, "^", "@This 4"], "*", [13, "^", "@This 5"], "*", 2], [false, true]],
                    [2, [[["@HDir", ">=", 0], "&&", ["@VDir", ">", 0]], "&&", ["@This 0", "+", 1, "=", "@Next 1 0"], "&&", ["@This 1", "=", "@Next 1 1"], "&&", ["@This 2", "=", "@Next 1 2"], "&&", ["@This 3", "=", "@Next 1 3"], "&&", ["@This 4", "=", "@Next 1 4"], "&&", ["@This 5", "=", "@Next 1 5"]], false, [["@This 0", ["@This 1", "+", 1], "@This 2", "@This 3", "@This 4", "@This 5"]], [[2, "^", "@This 0"], "*", [3, "^", "@This 1"], "*", [5, "^", "@This 2"], "*", [7, "^", "@This 3"], "*", [11, "^", "@This 4"], "*", [13, "^", "@This 5"], "*", 3], [false, true]],
                    [2, [[["@HDir", "<=", 0], "&&", ["@VDir", ">", 0]], "&&", ["@This 0", "=", "@Next 1 0"], "&&", ["@This 1", "+", 1, "=", "@Next 1 1"], "&&", ["@This 2", "=", "@Next 1 2"], "&&", ["@This 3", "=", "@Next 1 3"], "&&", ["@This 4", "=", "@Next 1 4"], "&&", ["@This 5", "=", "@Next 1 5"]], false, [[["@This 0", "+", 2], "@This 1", "@This 2", "@This 3", "@This 4", "@This 5"]], [[2, "^", "@This 0"], "*", [3, "^", "@This 1"], "*", [5, "^", "@This 2"], "*", [7, "^", "@This 3"], "*", [11, "^", "@This 4"], "*", [13, "^", "@This 5"], "*", 4], [false, true]],
                    [2, [["@HDir", "<=", -2], "&&", ["@This 0", "-", 1, "=", "@Next 1 0"], "&&", ["@This 1", "+", 1, "=", "@Next 1 1"], "&&", ["@This 2", "=", "@Next 1 2"], "&&", ["@This 3", "=", "@Next 1 3"], "&&", ["@This 4", "=", "@Next 1 4"], "&&", ["@This 5", "=", "@Next 1 5"]], false, [[["@This 0", "-", 1], "@This 1", ["@This 2", "+", 1], "@This 3", "@This 4", "@This 5"]], [[2, "^", "@This 0"], "*", [3, "^", "@This 1"], "*", [5, "^", "@This 2"], "*", [7, "^", "@This 3"], "*", [11, "^", "@This 4"], "*", [13, "^", "@This 5"], "*", 5, "/", 2], [false, true]],
                    [2, [[["@HDir", "<=", 0], "&&", ["@VDir", "<", 0]], "&&", ["@This 0", "+", 1, "=", "@Next 1 0"], "&&", ["@This 1", "+", 1, "=", "@Next 1 1"], "&&", ["@This 2", "=", "@Next 1 2"], "&&", ["@This 3", "=", "@Next 1 3"], "&&", ["@This 4", "=", "@Next 1 4"], "&&", ["@This 5", "=", "@Next 1 5"]], false, [["@This 0", "@This 1", "@This 2", ["@This 3", "+", 1], "@This 4", "@This 5"]], [[2, "^", "@This 0"], "*", [3, "^", "@This 1"], "*", [5, "^", "@This 2"], "*", [7, "^", "@This 3"], "*", [11, "^", "@This 4"], "*", [13, "^", "@This 5"], "*", 6], [false, true]],
                    [2, [[["@HDir", ">=", 0], "&&", ["@VDir", "<", 0]], "&&", ["@This 0", "+", 1, "=", "@Next 1 0"], "&&", ["@This 1", "+", 1, "=", "@Next 1 1"], "&&", ["@This 2", "-", 1, "=", "@Next 1 2"], "&&", ["@This 3", "=", "@Next 1 3"], "&&", ["@This 4", "=", "@Next 1 4"], "&&", ["@This 5", "=", "@Next 1 5"]], false, [["@This 0", "@This 1", ["@This 2", "-", 1], "@This 3", ["@This 4", "+", 1], "@This 5"]], [[2, "^", "@This 0"], "*", [3, "^", "@This 1"], "*", [5, "^", "@This 2"], "*", [7, "^", "@This 3"], "*", [11, "^", "@This 4"], "*", [13, "^", "@This 5"], "*", 11, "/", 5], [false, true]],
                ];
                winConditions = [[1, 1, 1, 1, 1, 0]];
                document.documentElement.style.setProperty("background-image", "linear-gradient(#a2a2ff, #a400a4, #64947c)");
                document.documentElement.style.setProperty("--background-color", "linear-gradient(#ac70ff, #ef00ef, #5bae84)");
                document.documentElement.style.setProperty("--grid-color", "#b927b9");
                document.documentElement.style.setProperty("--tile-color", "#8585ff");
                document.documentElement.style.setProperty("--text-color", "#005028");
            }
        }
    }
    else if (gamemode == 49) { // 378
        if (mode_vars[0]) {
            document.getElementById("378_goal_text").innerHTML = "You have to make the triangular numbers in order.";
            document.getElementById("378_goal_text").style.setProperty("color", "#166c00");
            displayRules("rules_text", ["h2", "Triangular Numbers"], ["h1", "378"], ["p", "Any two or three tiles can merge as long as they add to a triangular number. There is a \"goal tile\" that starts at 6. Whenever you make the goal tile, that tile disappears and the goal tile increases to the next triangular number. If you ever make a tile greater than the current goal tile, you immediately lose. Get to and make the 378 tile to win!"],
            ["p", "Spawning tiles: 1 (90%), 3 (10%)"]);
            displayRules("gm_rules_text", ["h2", "Triangular Numbers"], ["h1", "378"], ["p", "Any two or three tiles can merge as long as they add to a triangular number. There is a \"goal tile\" that starts at 6. Whenever you make the goal tile, that tile disappears and the goal tile increases to the next triangular number. If you ever make a tile greater than the current goal tile, you immediately lose. Get to and make the 378 tile to win!"],
            ["p", "Spawning tiles: 1 (90%), 3 (10%)"]);
        }
        else {
            document.getElementById("378_goal_text").innerHTML = "You may make tiles freely.";
            document.getElementById("378_goal_text").style.setProperty("color", "#a54bff");
            displayRules("rules_text", ["h2", "Triangular Numbers"], ["h1", "378"], ["p", "Any two or three tiles can merge as long as they add to a triangular number. There's no win condition here - just play around and see how many tiles you can discover!"],
            ["p", "Spawning tiles: 1 (90%), 3 (10%)"]);
            displayRules("gm_rules_text", ["h2", "Triangular Numbers"], ["h1", "378"], ["p", "Any two or three tiles can merge as long as they add to a triangular number. There's no win condition here - just play around and see how many tiles you can discover!"],
            ["p", "Spawning tiles: 1 (90%), 3 (10%)"]);
        }
        document.getElementById("378_merge_counter").innerHTML = mode_vars[1];
        if (mode_vars[1] < 4) document.getElementById("378_merge_minus").style.setProperty("display", "none");
        else document.getElementById("378_merge_minus").style.setProperty("display", "inline-block");
        document.getElementById("378_merge_plus").style.setProperty("display", "inline-block");
    }
    else if (gamemode == 50) { // DIVE
        if (mode_vars[0] > 0) {
            document.getElementById("DIVE_seeds").style.setProperty("display", "none");
            document.getElementById("DIVE_primeSpawns").style.setProperty("display", "block");
            document.getElementById("DIVE_primeSpawns_change").value = mode_vars[0];
        }
        else {
            document.getElementById("DIVE_seeds").style.setProperty("display", "block");
            document.getElementById("DIVE_primeSpawns").style.setProperty("display", "none");
            if (mode_vars[0] == 0) {
                document.getElementById("DIVE_seeds_text").innerHTML = "Spawning tiles, a.k.a. seeds, can be unlocked and eliminated.";
                document.getElementById("DIVE_seeds_text").style.setProperty("color", "#060");
            }
            else if (mode_vars[0] == -1) {
                document.getElementById("DIVE_seeds_text").innerHTML = "Spawning tiles, a.k.a. seeds, are unlocked permanently.";
                document.getElementById("DIVE_seeds_text").style.setProperty("color", "#400");
            }
        }
        if (mode_vars[1]) {
            document.getElementById("DIVE_1s_text").innerHTML = "1s are as likely to spawn as any other spawning tile.";
            document.getElementById("DIVE_1s_text").style.setProperty("color", "#000");
        }
        else {
            document.getElementById("DIVE_1s_text").innerHTML = "1s cannot spawn.";
            document.getElementById("DIVE_1s_text").style.setProperty("color", "#fff");
        }
        let seedCheckDescription = "";
        if (mode_vars[2] == 0) {
            document.getElementById("DIVE_unlockRules_text").innerHTML = "When deciding what new seed to unlock, seeds are checked largest to smallest.";
            document.getElementById("DIVE_unlockRules_text").style.setProperty("color", "#b7ff3c");
            seedCheckDescription = " (Seeds are checked largest to smallest.) "
        }
        else if (mode_vars[2] == 1) {
            document.getElementById("DIVE_unlockRules_text").innerHTML = "When deciding what new seed to unlock, the minimum possibility is always chosen, as in the original DIVE. (This may be laggy.)";
            document.getElementById("DIVE_unlockRules_text").style.setProperty("color", "#e3ae79");
            seedCheckDescription = " (Seeds are checked in a way that gives the minimum possible outcome.) "
        }
        else if (mode_vars[2] == 2) {
            document.getElementById("DIVE_unlockRules_text").innerHTML = "When deciding what new seed to unlock, seeds are checked smallest to largest.";
            document.getElementById("DIVE_unlockRules_text").style.setProperty("color", "#fa6756");
            seedCheckDescription = " (Seeds are checked smallest to largest.) "
        }
        else {
            document.getElementById("DIVE_unlockRules_text").innerHTML = "When deciding what new seed to unlock, seeds are checked in the order they were unlocked.";
            document.getElementById("DIVE_unlockRules_text").style.setProperty("color", "#58c2dc");
            seedCheckDescription = " (Seeds are checked in the order they were unlocked.) "
        }
        let seedSpawnDescription = "";
        if (mode_vars[0] == 0) {
            if (mode_vars[1]) {
                seedSpawnDescription = "At first, only 1s spawn. When a new tile is made, if the value leftover after dividing that tile by all current spawning tiles as many times as you can is greater than 1, that leftover value is added as a new spawning tile." + seedCheckDescription + "If there are no remaining multiples of a spawning tile on the board, that tile is removed from the spawn pool, and you gain points equal to its value.";
            }
            else {
                seedSpawnDescription = "At first, only 2s spawn. When a new tile is made, if the value leftover after dividing that tile by all current spawning tiles as many times as you can is greater than 1, that leftover value is added as a new spawning tile." + seedCheckDescription + "If there are no remaining multiples of a spawning tile on the board, that tile is removed from the spawn pool, and you gain points equal to its value."
            }
        }
        else if (mode_vars[0] == -1) {
            if (mode_vars[1]) {
                seedSpawnDescription = "At first, only 1s spawn. When a new tile is made, if the value leftover after dividing that tile by all current spawning tiles as many times as you can is greater than 1, that leftover value is permanently added as a new spawning tile." + seedCheckDescription
            }
            else {
                seedSpawnDescription = "At first, only 2s spawn. When a new tile is made, if the value leftover after dividing that tile by all current spawning tiles as many times as you can is greater than 1, that leftover value is permanently added as a new spawning tile." + seedCheckDescription;
            }
        }
        else {
            if (mode_vars[1]) {
                seedSpawnDescription = "The spawning tiles are 1 and the first " + mode_vars[0] + " primes, with an equal chance for each to spawn."
            }
            else {
                seedSpawnDescription = "The spawning tiles are the first " + mode_vars[0] + " primes, with an equal chance for each to spawn."
            }
        }
        displayRules("rules_text", ["h1", "DIVE"], ["p", "Tiles merge with their divisors. When two tiles merge, the score gained from the merge is only the smaller value out of the two tiles (rather than the value of the new tile). This mode has no win condition, so just try to get as high of a score as you can!"],
        ["p", seedSpawnDescription]);
        displayRules("gm_rules_text", ["h1", "DIVE"], ["p", "Tiles merge with their divisors. When two tiles merge, the score gained from the merge is only the smaller value out of the two tiles (rather than the value of the new tile). This mode has no win condition, so just try to get as high of a score as you can!"],
        ["p", seedSpawnDescription]);
        if (mode_vars[3] == 0) {
            document.getElementById("DIVE_randomGoals_text").innerHTML = "Random goals are disabled.";
            document.getElementById("DIVE_randomGoals_text").style.setProperty("color", "#22002d");
        }
        else if (mode_vars[3] == 1) {
            document.getElementById("DIVE_randomGoals_text").innerHTML = "Random goals build upon the previous goals.";
            document.getElementById("DIVE_randomGoals_text").style.setProperty("color", "#732a8b");
        }
        else if (mode_vars[3] == 2) {
            document.getElementById("DIVE_randomGoals_text").innerHTML = "Random goals are entirely random.";
            document.getElementById("DIVE_randomGoals_text").style.setProperty("color", "#ba77d0");
        }
        document.getElementById("DIVE_firstGoalMinimum").style.setProperty("display", (mode_vars[3] == 0) ? "none" : "block");
        document.getElementById("DIVE_firstGoalMinimum_change").value = mode_vars[4];
    }
    else if (gamemode == 54) { // 3888
        if (mode_vars[0] == 0) {
            document.getElementById("3888_randomGoals_text").innerHTML = "Random goals are disabled.";
            document.getElementById("3888_randomGoals_text").style.setProperty("color", "#22002d");
        }
        else if (mode_vars[0] == 1) {
            document.getElementById("3888_randomGoals_text").innerHTML = "Random goals build upon the previous goals.";
            document.getElementById("3888_randomGoals_text").style.setProperty("color", "#732a8b");
        }
        else if (mode_vars[0] == 2) {
            document.getElementById("3888_randomGoals_text").innerHTML = "Random goals are entirely random.";
            document.getElementById("3888_randomGoals_text").style.setProperty("color", "#ba77d0");
        }
        document.getElementById("3888_firstGoalMinimum").style.setProperty("display", (mode_vars[0] == 0) ? "none" : "block");
        document.getElementById("3888_firstGoalMinimum_change").value = mode_vars[1];
    }
    else if (gamemode == 55) { // 2000
        if (mode_vars[0] == 0) {
            document.getElementById("2000_randomGoals_text").innerHTML = "Random goals are disabled.";
            document.getElementById("2000_randomGoals_text").style.setProperty("color", "#22002d");
        }
        else if (mode_vars[0] == 1) {
            document.getElementById("2000_randomGoals_text").innerHTML = "Random goals build upon the previous goals.";
            document.getElementById("2000_randomGoals_text").style.setProperty("color", "#732a8b");
        }
        else if (mode_vars[0] == 2) {
            document.getElementById("2000_randomGoals_text").innerHTML = "Random goals are entirely random.";
            document.getElementById("2000_randomGoals_text").style.setProperty("color", "#ba77d0");
        }
        document.getElementById("2000_firstGoalMinimum").style.setProperty("display", (mode_vars[0] == 0) ? "none" : "block");
        document.getElementById("2000_firstGoalMinimum_change").value = mode_vars[1];
    }
    else if (gamemode == 56) { // 3645
        if (mode_vars[0] == 0) {
            document.getElementById("3645_randomGoals_text").innerHTML = "Random goals are disabled.";
            document.getElementById("3645_randomGoals_text").style.setProperty("color", "#22002d");
        }
        else if (mode_vars[0] == 1) {
            document.getElementById("3645_randomGoals_text").innerHTML = "Random goals build upon the previous goals.";
            document.getElementById("3645_randomGoals_text").style.setProperty("color", "#732a8b");
        }
        else if (mode_vars[0] == 2) {
            document.getElementById("3645_randomGoals_text").innerHTML = "Random goals are entirely random.";
            document.getElementById("3645_randomGoals_text").style.setProperty("color", "#ba77d0");
        }
        document.getElementById("3645_firstGoalMinimum").style.setProperty("display", (mode_vars[0] == 0) ? "none" : "block");
        document.getElementById("3645_firstGoalMinimum_change").value = mode_vars[1];
    }
    // else if (gamemode == 54) { // 3888
    //     if (mode_vars[0] == 0) {
    //         document.getElementById("180_randomGoals_text").innerHTML = "Random goals are disabled.";
    //         document.getElementById("180_randomGoals_text").style.setProperty("color", "#22002d");
    //     }
    //     else if (mode_vars[0] == 1) {
    //         document.getElementById("180_randomGoals_text").innerHTML = "Random goals build upon the previous goals.";
    //         document.getElementById("180_randomGoals_text").style.setProperty("color", "#732a8b");
    //     }
    //     else if (mode_vars[0] == 2) {
    //         document.getElementById("180_randomGoals_text").innerHTML = "Random goals are entirely random.";
    //         document.getElementById("180_randomGoals_text").style.setProperty("color", "#ba77d0");
    //     }
    // }
    else if (gamemode == 57) { // 2700
        if (mode_vars[0] == 1) { // Level 1
            document.getElementById("2700_level_text").innerHTML = "Level 1: The merges are n + 2n, n + 3n, 2n + 3n, and 3n + 5n.";
            document.getElementById("2700_level_text").style.setProperty("color", "#004700");
            document.getElementById("2700_level_decrease").style.setProperty("display", "none");
            document.getElementById("2700_level_increase").style.setProperty("display", "block");
            document.getElementById("2700_level3Merges").style.setProperty("display", "none");
            displayRules("rules_text", ["h2", "Powers of 2 Times Powers of 3 Times Powers of 5"], ["h1", "2700 (Level 1)"], ["p", "Two 1s can merge into a 2. Merges occur between any tile and a tile that's double or triple it, between a 2n tile and a 3n tile (for the same n), or between a 3n tile and a 5n tile (for the same n). Get to the 2700 tile to win!"],
            ["p", "Spawning tiles: 1 (100%)"]);
            displayRules("gm_rules_text", ["h2", "Powers of 2 Times Powers of 3 Times Powers of 5"], ["h1", "2700 (Level 1)"], ["p", "Two 1s can merge into a 2. Merges occur between any tile and a tile that's double or triple it, between a 2n tile and a 3n tile (for the same n), or between a 3n tile and a 5n tile (for the same n). Get to the 2700 tile to win!"],
            ["p", "Spawning tiles: 1 (100%)"]);
            MergeRules = [
                [2, [["@This 0", "=", 0], "&&", ["@This 1", "=", 0], "&&", ["@This 2", "=", 0], "&&", ["@Next 1 0", "=", 0], "&&", ["@Next 1 1", "=", 0], "&&", ["@Next 1 2", "=", 0]], true, [[1, 0, 0]], 2, [false, true]],
                [2, [["@This 0", "+", 1, "=", "@Next 1 0"], "&&", ["@This 1", "=", "@Next 1 1"], "&&", ["@This 2", "=", "@Next 1 2"]], false, [["@This 0", ["@This 1", "+", 1], "@This 2"]], [[2, "^", "@This 0"], "*", [3, "^", "@This 1"], "*", [5, "^", "@This 2"], "*", 3], [false, true]],
                [2, [["@This 0", "=", "@Next 1 0"], "&&", ["@This 1", "+", 1, "=", "@Next 1 1"], "&&", ["@This 2", "=", "@Next 1 2"]], false, [[["@This 0", "+", 2], "@This 1", "@This 2"]], [[2, "^", "@This 0"], "*", [3, "^", "@This 1"], "*", [5, "^", "@This 2"], "*", 4], [false, true]],
                [2, [["@This 0", "+", 1, "=", "@Next 1 0"], "&&", ["@This 1", "-", 1, "=", "@Next 1 1"], "&&", ["@This 2", "=", "@Next 1 2"]], false, [["@This 0", ["@This 1", "-", 1], ["@This 2", "+", 1]]], [[2, "^", "@This 0"], "*", [3, "^", ["@This 1", "-", 1]], "*", [5, "^", "@This 2"], "*", 5], [false, true]],
                [2, [["@This 0", "=", "@Next 1 0"], "&&", ["@This 1", "-", 1, "=", "@Next 1 1"], "&&", ["@This 2", "+", 1, "=", "@Next 1 2"]], false, [[["@This 0", "+", 3], ["@This 1", "-", 1], "@This 2"]], [[2, "^", "@This 0"], "*", [3, "^", ["@This 1", "-", 1]], "*", [5, "^", "@This 2"], "*", 8], [false, true]]
            ];
            winConditions = [[2, 3, 2]];
            knownMergeMaxLength = 2;
            knownMergeLookbackDistance = 0;
            document.documentElement.style.setProperty("background-image", "linear-gradient(#fff, #bbf, #9f9, #f77, #b0ff70 10%, #319761, #b0ff70 90%, #f77, #9f9, #bbf, #fff)");
            document.documentElement.style.setProperty("--background-color", "linear-gradient(90deg, #fff, #ddf, #bfb, #faa, #d3ffaf 10%, #80c8a1, #d3ffaf 90%, #faa, #bfb, #ddf, #fff)");
        }
        else if (mode_vars[0] == 2) { // Level 2
            document.getElementById("2700_level_text").innerHTML = "Level 2: The merges are n + 2n, n + 4n, and 3n + 5n.";
            document.getElementById("2700_level_text").style.setProperty("color", "#470000");
            document.getElementById("2700_level_decrease").style.setProperty("display", "block");
            document.getElementById("2700_level_increase").style.setProperty("display", "block");
            document.getElementById("2700_level3Merges").style.setProperty("display", "none");
            displayRules("rules_text", ["h2", "Powers of 2 Times Powers of 3 Times Powers of 5"], ["h1", "2700 (Level 2)"], ["p", "Two 1s can merge into a 2, and two 2s can merge into a 4. Merges occur between any tile and a tile that's double or quadruple it, or between a 3n tile and a 5n tile (for the same n). Get to the 2700 tile to win!"],
            ["p", "Spawning tiles: 1 (100%)"]);
            displayRules("gm_rules_text", ["h2", "Powers of 2 Times Powers of 3 Times Powers of 5"], ["h1", "2700 (Level 2)"], ["p", "Two 1s can merge into a 2, and two 2s can merge into a 4. Merges occur between any tile and a tile that's double or quadruple it, or between a 3n tile and a 5n tile (for the same n). Get to the 2700 tile to win!"],
            ["p", "Spawning tiles: 1 (100%)"]);
            MergeRules = [
                [2, [["@This 0", "=", 0], "&&", ["@This 1", "=", 0], "&&", ["@This 2", "=", 0], "&&", ["@Next 1 0", "=", 0], "&&", ["@Next 1 1", "=", 0], "&&", ["@Next 1 2", "=", 0]], true, [[1, 0, 0]], 2, [false, true]],
                [2, [["@This 0", "=", 1], "&&", ["@This 1", "=", 0], "&&", ["@This 2", "=", 0], "&&", ["@Next 1 0", "=", 1], "&&", ["@Next 1 1", "=", 0], "&&", ["@Next 1 2", "=", 0]], true, [[2, 0, 0]], 4, [false, true]],
                [2, [["@This 0", "+", 1, "=", "@Next 1 0"], "&&", ["@This 1", "=", "@Next 1 1"], "&&", ["@This 2", "=", "@Next 1 2"]], false, [["@This 0", ["@This 1", "+", 1], "@This 2"]], [[2, "^", "@This 0"], "*", [3, "^", "@This 1"], "*", [5, "^", "@This 2"], "*", 3], [false, true]],
                [2, [["@This 0", "+", 2, "=", "@Next 1 0"], "&&", ["@This 1", "=", "@Next 1 1"], "&&", ["@This 2", "=", "@Next 1 2"]], false, [["@This 0", "@This 1", ["@This 2", "+", 1]]], [[2, "^", "@This 0"], "*", [3, "^", "@This 1"], "*", [5, "^", "@This 2"], "*", 5], [false, true]],
                [2, [["@This 0", "=", "@Next 1 0"], "&&", ["@This 1", "-", 1, "=", "@Next 1 1"], "&&", ["@This 2", "+", 1, "=", "@Next 1 2"]], false, [[["@This 0", "+", 3], ["@This 1", "-", 1], "@This 2"]], [[2, "^", "@This 0"], "*", [3, "^", ["@This 1", "-", 1]], "*", [5, "^", "@This 2"], "*", 8], [false, true]]
            ];
            winConditions = [[2, 3, 2]];
            knownMergeMaxLength = 2;
            knownMergeLookbackDistance = 0;
            document.documentElement.style.setProperty("background-image", "linear-gradient(#fff, #bbf, #9f9, #f77, #ff607a 10%, #a0271a, #ff607a 90%, #f77, #9f9, #bbf, #fff)");
            document.documentElement.style.setProperty("--background-color", "linear-gradient(90deg, #fff, #ddf, #bfb, #faa, #ffafbf 10%, #d3907c, #ffafbf 90%, #faa, #bfb, #ddf, #fff)");
        }
        else if (mode_vars[0] == 3 && mode_vars[1] == 1) { // Level 3a
            document.getElementById("2700_level_text").innerHTML = "Level 3: The merges are 4n + n + n, 2n + 3n, 3n + 5n, and 2n + 5n + 20n.";
            document.getElementById("2700_level_text").style.setProperty("color", "#000047");
            document.getElementById("2700_level_decrease").style.setProperty("display", "block");
            document.getElementById("2700_level_increase").style.setProperty("display", "none");
            document.getElementById("2700_level3Merges").style.setProperty("display", "block");
            document.getElementById("2700_level3Merges_text").innerHTML = "The 2 + 1 = 3 merge is enabled, but the 2 + 2 = 4 and 6 + 2 + 1 = 9 merges are not.";
            document.getElementById("2700_level3Merges_text").style.setProperty("color", "#20ff20");
            displayRules("rules_text", ["h2", "Powers of 2 Times Powers of 3 Times Powers of 5"], ["h1", "2700 (Level 3a)"], ["p", "Two 1s can merge into a 2, and a 2 and a 1 can merge into a 3. Merges occur between a 4n tile and two n tiles (for the same n), between a 2n tile and a 3n tile (for the same n), between a 3n tile and a 5n tile (for the same n), or between a 2n tile, a 5n tile, and a 20n tile (for the same n). Get to the 2700 tile to win!"],
            ["p", "Spawning tiles: 1 (100%)"]);
            displayRules("gm_rules_text", ["h2", "Powers of 2 Times Powers of 3 Times Powers of 5"], ["h1", "2700 (Level 3a)"], ["p", "Two 1s can merge into a 2, and a 2 and a 1 can merge into a 3. Merges occur between a 4n tile and two n tiles (for the same n), between a 2n tile and a 3n tile (for the same n), between a 3n tile and a 5n tile (for the same n), or between a 2n tile, a 5n tile, and a 20n tile (for the same n). Get to the 2700 tile to win!"],
            ["p", "Spawning tiles: 1 (100%)"]);
            MergeRules = [
                [3, [["@This 0", "=", "@Next 1 0"], "&&", ["@This 1", "=", "@Next 1 1"], "&&", ["@This 2", "=", "@Next 1 2"], "&&", ["@This 0", "+", 2, "=", "@Next 2 0"], "&&", ["@This 1", "=", "@Next 2 1"], "&&", ["@This 2", "=", "@Next 2 2"]], false, [[["@This 0", "+", 1], ["@This 1", "+", 1], "@This 2"]], [[2, "^", "@This 0"], "*", [3, "^", "@This 1"], "*", [5, "^", "@This 2"], "*", 6], [false, true, true]],
                [3, [["@This 0", "-", 1, "=", "@Next 1 0"], "&&", ["@This 1", "=", "@Next 1 1"], "&&", ["@This 2", "+", 1, "=", "@Next 1 2"], "&&", ["@This 0", "+", 1, "=", "@Next 2 0"], "&&", ["@This 1", "=", "@Next 2 1"], "&&", ["@This 2", "+", 1, "=", "@Next 2 2"]], false, [[["@This 0", "-", 1], ["@This 1", "+", 3], "@This 2"]], [[2, "^", ["@This 0", "-", 1]], "*", [3, "^", "@This 1"], "*", [5, "^", "@This 2"], "*", 27], [false, true, true]],
                [2, [["@This 0", "=", 0], "&&", ["@This 1", "=", 0], "&&", ["@This 2", "=", 0], "&&", ["@Next 1 0", "=", 0], "&&", ["@Next 1 1", "=", 0], "&&", ["@Next 1 2", "=", 0], "&&", [["@NextNE -1 0", "!=", 2], "||", ["@NextNE -1 1", "!=", 0], "||", ["@NextNE -1 2", "!=", 0]]], true, [[1, 0, 0]], 2, [false, true]],
                [2, [["@This 0", "=", 1], "&&", ["@This 1", "=", 0], "&&", ["@This 2", "=", 0], "&&", ["@Next 1 0", "=", 0], "&&", ["@Next 1 1", "=", 0], "&&", ["@Next 1 2", "=", 0]], false, [[0, 1, 0]], 3, [false, true]],
                [2, [["@This 0", "+", 1, "=", "@Next 1 0"], "&&", ["@This 1", "-", 1, "=", "@Next 1 1"], "&&", ["@This 2", "=", "@Next 1 2"]], false, [["@This 0", ["@This 1", "-", 1], ["@This 2", "+", 1]]], [[2, "^", "@This 0"], "*", [3, "^", ["@This 1", "-", 1]], "*", [5, "^", "@This 2"], "*", 5], [false, true]],
                [2, [["@This 0", "=", "@Next 1 0"], "&&", ["@This 1", "-", 1, "=", "@Next 1 1"], "&&", ["@This 2", "+", 1, "=", "@Next 1 2"]], false, [[["@This 0", "+", 3], ["@This 1", "-", 1], "@This 2"]], [[2, "^", "@This 0"], "*", [3, "^", ["@This 1", "-", 1]], "*", [5, "^", "@This 2"], "*", 8], [false, true]],
            ];
            winConditions = [[2, 3, 2]];
            knownMergeMaxLength = 3;
            knownMergeLookbackDistance = 1;
            document.documentElement.style.setProperty("background-image", "linear-gradient(#fff, #bbf, #9f9, #f77, #68c3ff 10%, #58269e, #68c3ff 90%, #f77, #9f9, #bbf, #fff)");
            document.documentElement.style.setProperty("--background-color", "linear-gradient(90deg, #0c0, #fff 4%, #ddf, #bfb, #faa, #afdfff 12%, #906dea, #afdfff 88%, #faa, #bfb, #ddf, #fff 96%, #0c0)");
        }
        else if (mode_vars[0] == 3 && mode_vars[1] == 2) { // Level 3b
            document.getElementById("2700_level_text").innerHTML = "Level 3: The merges are 4n + n + n, 2n + 3n, 3n + 5n, and 2n + 5n + 20n.";
            document.getElementById("2700_level_text").style.setProperty("color", "#000047");
            document.getElementById("2700_level_decrease").style.setProperty("display", "block");
            document.getElementById("2700_level_increase").style.setProperty("display", "none");
            document.getElementById("2700_level3Merges").style.setProperty("display", "block");
            document.getElementById("2700_level3Merges_text").innerHTML = "The 2 + 2 = 4 and 6 + 2 + 1 = 9 merges are enabled, but the 2 + 1 = 3 merge is not.";
            document.getElementById("2700_level3Merges_text").style.setProperty("color", "#ff2020");
            displayRules("rules_text", ["h2", "Powers of 2 Times Powers of 3 Times Powers of 5"], ["h1", "2700 (Level 3b)"], ["p", "Two 1s can merge into a 2, two 2s can merge into a 4, and a 6, a 2, and a 1 can merge into a 9. Merges occur between a 4n tile and two n tiles (for the same n), between a 2n tile and a 3n tile (for the same n), between a 3n tile and a 5n tile (for the same n), or between a 2n tile, a 5n tile, and a 20n tile (for the same n). The 2700 tile isn't reachable under the current settings, so the goal is the 3600 tile instead."],
            ["p", "Spawning tiles: 1 (100%)"]);
            displayRules("gm_rules_text", ["h2", "Powers of 2 Times Powers of 3 Times Powers of 5"], ["h1", "2700 (Level 3b)"], ["p", "Two 1s can merge into a 2, two 2s can merge into a 4, and a 6, a 2, and a 1 can merge into a 9. Merges occur between a 4n tile and two n tiles (for the same n), between a 2n tile and a 3n tile (for the same n), between a 3n tile and a 5n tile (for the same n), or between a 2n tile, a 5n tile, and a 20n tile (for the same n). The 2700 tile isn't reachable under the current settings, so the goal is the 3600 tile instead."],
            ["p", "Spawning tiles: 1 (100%)"]);
            MergeRules = [
                [3, [["@This 0", "=", "@Next 1 0"], "&&", ["@This 1", "=", "@Next 1 1"], "&&", ["@This 2", "=", "@Next 1 2"], "&&", ["@This 0", "+", 2, "=", "@Next 2 0"], "&&", ["@This 1", "=", "@Next 2 1"], "&&", ["@This 2", "=", "@Next 2 2"]], false, [[["@This 0", "+", 1], ["@This 1", "+", 1], "@This 2"]], [[2, "^", "@This 0"], "*", [3, "^", "@This 1"], "*", [5, "^", "@This 2"], "*", 6], [false, true, true]],
                [3, [["@This 0", "=", 1], "&&", ["@This 1", "=", 1], "&&", ["@This 2", "=", 0], "&&", ["@Next 1 0", "=", 1], "&&", ["@Next 1 1", "=", 0], "&&", ["@Next 1 2", "=", 0], "&&", ["@Next 2 0", "=", 0], "&&", ["@Next 2 1", "=", 0], "&&", ["@Next 2 2", "=", 0]], false, [[0, 2, 0]], 9, [false, true]],
                [3, [["@This 0", "-", 1, "=", "@Next 1 0"], "&&", ["@This 1", "=", "@Next 1 1"], "&&", ["@This 2", "+", 1, "=", "@Next 1 2"], "&&", ["@This 0", "+", 1, "=", "@Next 2 0"], "&&", ["@This 1", "=", "@Next 2 1"], "&&", ["@This 2", "+", 1, "=", "@Next 2 2"]], false, [[["@This 0", "-", 1], ["@This 1", "+", 3], "@This 2"]], [[2, "^", ["@This 0", "-", 1]], "*", [3, "^", "@This 1"], "*", [5, "^", "@This 2"], "*", 27], [false, true, true]],
                [2, [["@This 0", "=", 0], "&&", ["@This 1", "=", 0], "&&", ["@This 2", "=", 0], "&&", ["@Next 1 0", "=", 0], "&&", ["@Next 1 1", "=", 0], "&&", ["@Next 1 2", "=", 0], "&&", [["@NextNE -1 0", "!=", 2], "||", ["@NextNE -1 1", "!=", 0], "||", ["@NextNE -1 2", "!=", 0]]], true, [[1, 0, 0]], 2, [false, true]],
                [2, [["@This 0", "=", 1], "&&", ["@This 1", "=", 0], "&&", ["@This 2", "=", 0], "&&", ["@Next 1 0", "=", 1], "&&", ["@Next 1 1", "=", 0], "&&", ["@Next 1 2", "=", 0], "&&", [["@NextNE -1 0", "!=", 3], "||", ["@NextNE -1 1", "!=", 0], "||", ["@NextNE -1 2", "!=", 0]]], false, [[2, 0, 0]], 4, [false, true]],
                [2, [["@This 0", "+", 1, "=", "@Next 1 0"], "&&", ["@This 1", "-", 1, "=", "@Next 1 1"], "&&", ["@This 2", "=", "@Next 1 2"]], false, [["@This 0", ["@This 1", "-", 1], ["@This 2", "+", 1]]], [[2, "^", "@This 0"], "*", [3, "^", ["@This 1", "-", 1]], "*", [5, "^", "@This 2"], "*", 5], [false, true]],
                [2, [["@This 0", "=", "@Next 1 0"], "&&", ["@This 1", "-", 1, "=", "@Next 1 1"], "&&", ["@This 2", "+", 1, "=", "@Next 1 2"]], false, [[["@This 0", "+", 3], ["@This 1", "-", 1], "@This 2"]], [[2, "^", "@This 0"], "*", [3, "^", ["@This 1", "-", 1]], "*", [5, "^", "@This 2"], "*", 8], [false, true]],
            ];
            winConditions = [[4, 2, 2]];
            knownMergeMaxLength = 3;
            knownMergeLookbackDistance = 1;
            document.documentElement.style.setProperty("background-image", "linear-gradient(#fff, #bbf, #9f9, #f77, #68c3ff 10%, #58269e, #68c3ff 90%, #f77, #9f9, #bbf, #fff)");
            document.documentElement.style.setProperty("--background-color", "linear-gradient(90deg, #c00, #fff 4%, #ddf, #bfb, #faa, #afdfff 12%, #906dea, #afdfff 88%, #faa, #bfb, #ddf, #fff 96%, #c00)");
        }
        else if (mode_vars[0] == 3 && mode_vars[1] == 3) { // Level 3c
            document.getElementById("2700_level_text").innerHTML = "Level 3: The merges are 4n + n + n, 2n + 3n, 3n + 5n, and 2n + 5n + 20n.";
            document.getElementById("2700_level_text").style.setProperty("color", "#000047");
            document.getElementById("2700_level_decrease").style.setProperty("display", "block");
            document.getElementById("2700_level_increase").style.setProperty("display", "none");
            document.getElementById("2700_level3Merges").style.setProperty("display", "block");
            document.getElementById("2700_level3Merges_text").innerHTML = "The 2 + 1 = 3, 2 + 2 = 4 and 6 + 2 + 1 = 9 merges are all enabled.";
            document.getElementById("2700_level3Merges_text").style.setProperty("color", "#2020ff");
            displayRules("rules_text", ["h2", "Powers of 2 Times Powers of 3 Times Powers of 5"], ["h1", "2700 (Level 3c)"], ["p", "Two 1s can merge into a 2, a 2 and a 1 can merge into a 3, two 2s can merge into a 4, and a 6, a 2, and a 1 can merge into a 9. Merges occur between a 4n tile and two n tiles (for the same n), between a 2n tile and a 3n tile (for the same n), between a 3n tile and a 5n tile (for the same n), or between a 2n tile, a 5n tile, and a 20n tile (for the same n). Get to the 2700 tile to win!"],
            ["p", "Spawning tiles: 1 (100%)"]);
            displayRules("gm_rules_text", ["h2", "Powers of 2 Times Powers of 3 Times Powers of 5"], ["h1", "2700 (Level 3c)"], ["p", "Two 1s can merge into a 2, a 2 and a 1 can merge into a 3, two 2s can merge into a 4, and a 6, a 2, and a 1 can merge into a 9. Merges occur between a 4n tile and two n tiles (for the same n), between a 2n tile and a 3n tile (for the same n), between a 3n tile and a 5n tile (for the same n), or between a 2n tile, a 5n tile, and a 20n tile (for the same n). Get to the 2700 tile to win!"],
            ["p", "Spawning tiles: 1 (100%)"]);
            MergeRules = [
                [3, [["@This 0", "=", "@Next 1 0"], "&&", ["@This 1", "=", "@Next 1 1"], "&&", ["@This 2", "=", "@Next 1 2"], "&&", ["@This 0", "+", 2, "=", "@Next 2 0"], "&&", ["@This 1", "=", "@Next 2 1"], "&&", ["@This 2", "=", "@Next 2 2"]], false, [[["@This 0", "+", 1], ["@This 1", "+", 1], "@This 2"]], [[2, "^", "@This 0"], "*", [3, "^", "@This 1"], "*", [5, "^", "@This 2"], "*", 6], [false, true, true]],
                [3, [["@This 0", "=", 1], "&&", ["@This 1", "=", 1], "&&", ["@This 2", "=", 0], "&&", ["@Next 1 0", "=", 1], "&&", ["@Next 1 1", "=", 0], "&&", ["@Next 1 2", "=", 0], "&&", ["@Next 2 0", "=", 0], "&&", ["@Next 2 1", "=", 0], "&&", ["@Next 2 2", "=", 0]], false, [[0, 2, 0]], 9, [false, true]],
                [3, [["@This 0", "-", 1, "=", "@Next 1 0"], "&&", ["@This 1", "=", "@Next 1 1"], "&&", ["@This 2", "+", 1, "=", "@Next 1 2"], "&&", ["@This 0", "+", 1, "=", "@Next 2 0"], "&&", ["@This 1", "=", "@Next 2 1"], "&&", ["@This 2", "+", 1, "=", "@Next 2 2"]], false, [[["@This 0", "-", 1], ["@This 1", "+", 3], "@This 2"]], [[2, "^", ["@This 0", "-", 1]], "*", [3, "^", "@This 1"], "*", [5, "^", "@This 2"], "*", 27], [false, true, true]],
                [2, [["@This 0", "=", 0], "&&", ["@This 1", "=", 0], "&&", ["@This 2", "=", 0], "&&", ["@Next 1 0", "=", 0], "&&", ["@Next 1 1", "=", 0], "&&", ["@Next 1 2", "=", 0], "&&", [["@NextNE -1 0", "!=", 2], "||", ["@NextNE -1 1", "!=", 0], "||", ["@NextNE -1 2", "!=", 0]]], true, [[1, 0, 0]], 2, [false, true]],
                [2, [["@This 0", "=", 1], "&&", ["@This 1", "=", 0], "&&", ["@This 2", "=", 0], "&&", ["@Next 1 0", "=", 0], "&&", ["@Next 1 1", "=", 0], "&&", ["@Next 1 2", "=", 0], "&&", [["@NextNE -1 0", "!=", 1], "||", ["@NextNE -1 1", "!=", 1], "||", ["@NextNE -1 2", "!=", 0]]], false, [[0, 1, 0]], 3, [false, true]],
                [2, [["@This 0", "=", 1], "&&", ["@This 1", "=", 0], "&&", ["@This 2", "=", 0], "&&", ["@Next 1 0", "=", 1], "&&", ["@Next 1 1", "=", 0], "&&", ["@Next 1 2", "=", 0], "&&", [["@NextNE -1 0", "!=", 3], "||", ["@NextNE -1 1", "!=", 0], "||", ["@NextNE -1 2", "!=", 0]]], false, [[2, 0, 0]], 4, [false, true]],
                [2, [["@This 0", "+", 1, "=", "@Next 1 0"], "&&", ["@This 1", "-", 1, "=", "@Next 1 1"], "&&", ["@This 2", "=", "@Next 1 2"]], false, [["@This 0", ["@This 1", "-", 1], ["@This 2", "+", 1]]], [[2, "^", "@This 0"], "*", [3, "^", ["@This 1", "-", 1]], "*", [5, "^", "@This 2"], "*", 5], [false, true]],
                [2, [["@This 0", "=", "@Next 1 0"], "&&", ["@This 1", "-", 1, "=", "@Next 1 1"], "&&", ["@This 2", "+", 1, "=", "@Next 1 2"]], false, [[["@This 0", "+", 3], ["@This 1", "-", 1], "@This 2"]], [[2, "^", "@This 0"], "*", [3, "^", ["@This 1", "-", 1]], "*", [5, "^", "@This 2"], "*", 8], [false, true]],
            ];
            winConditions = [[2, 3, 2]];
            knownMergeMaxLength = 3;
            knownMergeLookbackDistance = 1;
            document.documentElement.style.setProperty("background-image", "linear-gradient(#fff, #bbf, #9f9, #f77, #68c3ff 10%, #58269e, #68c3ff 90%, #f77, #9f9, #bbf, #fff)");
            document.documentElement.style.setProperty("--background-color", "linear-gradient(90deg, #00c, #fff 4%, #ddf, #bfb, #faa, #afdfff 12%, #906dea, #afdfff 88%, #faa, #bfb, #ddf, #fff 96%, #00c)");
        }
    }
    else if (gamemode == 59) { // 1825
        if (mode_vars[0] == 0) {
            document.getElementById("1825_randomGoals_text").innerHTML = "Random goals are disabled.";
            document.getElementById("1825_randomGoals_text").style.setProperty("color", "#22002d");
        }
        else if (mode_vars[0] == 1) {
            document.getElementById("1825_randomGoals_text").innerHTML = "Random goals build upon the previous goals.";
            document.getElementById("1825_randomGoals_text").style.setProperty("color", "#732a8b");
        }
        else if (mode_vars[0] == 2) {
            document.getElementById("1825_randomGoals_text").innerHTML = "Random goals are entirely random.";
            document.getElementById("1825_randomGoals_text").style.setProperty("color", "#ba77d0");
        }
        if (mode_vars[0] == 0) {
            document.getElementById("1825_firstGoalMinimum").style.setProperty("display", "none");
        }
        else {
            document.getElementById("1825_firstGoalMinimum").style.setProperty("display", "block");
            document.getElementById("1825_firstGoalMinimum_counter").innerHTML = mode_vars[1];
            if (mode_vars[1] < 3) document.getElementById("1825_firstGoalMinimum_minus").style.setProperty("display", "none");
            else document.getElementById("1825_firstGoalMinimum_minus").style.setProperty("display", "inline-block");
        }
    }
    else if (gamemode == 61) { // 3069
        if (!mode_vars[2]) {
            document.documentElement.style.setProperty("background-image", "linear-gradient(90deg, #00d800, #008f8f, #47008f)");
            document.documentElement.style.setProperty("--background-color", "linear-gradient(#6dd36d, #6dd36d, #58c5c5, #58c5c5, #7b52a4, #7b52a4)");
            document.documentElement.style.setProperty("--grid-color", "#005b5b");
            document.documentElement.style.setProperty("--tile-color", "#793bb6");
            document.documentElement.style.setProperty("--text-color", "#4eff4e");
            displayRules("rules_text", ["h1", "3069"], ["p", "Merges occur between two equal tiles, or between a larger tile and a smaller tile such that the merge causes one of the prime factors of the larger tile to increase to the next prime. For example, 90 (2335) could merge with 45 to make 135 (3335), 90 could merge with 60 to make 150 (2355), 90 could merge with 36 to make 126 (2337), or 90 could merge with 90 to make 180. Get to the 3069 tile to win, or see how many different tiles you can discover!"],
            ["p", "Spawning tiles: 1 (100%)"]);
            displayRules("gm_rules_text", ["h1", "3069"], ["p", "Merges occur between two equal tiles, or between a larger tile and a smaller tile such that the merge causes one of the prime factors of the larger tile to increase to the next prime. For example, 90 (2335) could merge with 45 to make 135 (3335), 90 could merge with 60 to make 150 (2355), 90 could merge with 36 to make 126 (2337), or 90 could merge with 90 to make 180. Get to the 3069 tile to win, or see how many different tiles you can discover!"],
            ["p", "Spawning tiles: 1 (100%)"]);
            document.getElementById("3069_oddsOnly_text").innerHTML = "Merges occur between two tiles.";
            document.getElementById("3069_oddsOnly_text").style.setProperty("color", "#4eff4e");
        }
        else {
            document.documentElement.style.setProperty("background-image", "linear-gradient(90deg, #ffff27, #ff7070, #ffb870)");
            document.documentElement.style.setProperty("--background-color", "linear-gradient(#dede34, #dede34,#c75353, #c75353,#e2a363, #e2a363)");
            document.documentElement.style.setProperty("--grid-color", "#efd64a");
            document.documentElement.style.setProperty("--tile-color", "#f75951");
            document.documentElement.style.setProperty("--text-color", "#9a2100");
            displayRules("rules_text", ["h1", "Odds-Only 3069"], ["p", "Merges occur between three equal tiles, or between a larger tile and two smaller tiles such that the merge causes one of the prime factors of the larger tile to increase to the next prime. For example, 105 (357) could merge with two tiles that add to 70 to make 175 (557), 105 could merge with two tiles that add to 42 to make 147 (377), 105 could merge with two tiles that add to 60 to make 165 (3511), or three 105s could merge to make 135. Get to the 3069 tile to win, or see how many different tiles you can discover!"],
            ["p", "Spawning tiles: 1 (100%)"]);
            displayRules("gm_rules_text", ["h1", "Odds-Only 3069"], ["p", "Merges occur between three equal tiles, or between a larger tile and two smaller tiles such that the merge causes one of the prime factors of the larger tile to increase to the next prime. For example, 105 (357) could merge with two tiles that add to 70 to make 175 (557), 105 could merge with two tiles that add to 42 to make 147 (377), 105 could merge with two tiles that add to 60 to make 165 (3511), or three 105s could merge to make 135. Get to the 3069 tile to win, or see how many different tiles you can discover!"],
            ["p", "Spawning tiles: 1 (100%)"]);
            document.getElementById("3069_oddsOnly_text").innerHTML = "Merges occur between three tiles.";
            document.getElementById("3069_oddsOnly_text").style.setProperty("color", "#9a2100");
        }
        if (mode_vars[0] == 0) {
            document.getElementById("3069_randomGoals_text").innerHTML = "Random goals are disabled.";
            document.getElementById("3069_randomGoals_text").style.setProperty("color", "#22002d");
        }
        else if (mode_vars[0] == 1) {
            document.getElementById("3069_randomGoals_text").innerHTML = "Random goals build upon the previous goals.";
            document.getElementById("3069_randomGoals_text").style.setProperty("color", "#732a8b");
        }
        else if (mode_vars[0] == 2) {
            document.getElementById("3069_randomGoals_text").innerHTML = "Random goals are entirely random.";
            document.getElementById("3069_randomGoals_text").style.setProperty("color", "#ba77d0");
        }
        document.getElementById("3069_firstGoalMinimum").style.setProperty("display", (mode_vars[0] == 0) ? "none" : "block");
        document.getElementById("3069_firstGoalMinimum_change").value = mode_vars[1];
    }
    else if (gamemode == 67) { // 1762
        if (mode_vars[0] == 0) {
            document.getElementById("1762_randomGoals_text").innerHTML = "Random goals are disabled.";
            document.getElementById("1762_randomGoals_text").style.setProperty("color", "#22002d");
        }
        else if (mode_vars[0] == 1) {
            document.getElementById("1762_randomGoals_text").innerHTML = "Random goals build upon the previous goals.";
            document.getElementById("1762_randomGoals_text").style.setProperty("color", "#732a8b");
        }
        else if (mode_vars[0] == 2) {
            document.getElementById("1762_randomGoals_text").innerHTML = "Random goals are entirely random.";
            document.getElementById("1762_randomGoals_text").style.setProperty("color", "#ba77d0");
        }
        if (mode_vars[0] == 0) {
            document.getElementById("1762_firstGoalMinimum").style.setProperty("display", "none");
        }
        else {
            document.getElementById("1762_firstGoalMinimum").style.setProperty("display", "block");
            document.getElementById("1762_firstGoalMinimum_counter").innerHTML = mode_vars[1];
            if (mode_vars[1] < 3) document.getElementById("1762_firstGoalMinimum_minus").style.setProperty("display", "none");
            else document.getElementById("1762_firstGoalMinimum_minus").style.setProperty("display", "inline-block");
        }
    }
    else if (gamemode == 68) { // 2205
        if (mode_vars[0] == 1) {
            document.getElementById("2205_level_text").innerHTML = "Level 1: The merges are n + n + 3n, n + n + 5n, and n + n + 7n.";
            document.getElementById("2205_level_text").style.setProperty("color", "#474700");
            document.getElementById("2205_level_decrease").style.setProperty("display", "none");
            document.getElementById("2205_level_increase").style.setProperty("display", "block");
            MergeRules = [
                [3, [["@This 0", "=", 0], "&&", ["@This 1", "=", 0], "&&", ["@This 2", "=", 0], "&&", ["@Next 1 0", "=", 0], "&&", ["@Next 1 1", "=", 0], "&&", ["@Next 1 2", "=", 0], "&&", ["@Next 2 0", "=", 0], "&&", ["@Next 2 1", "=", 0], "&&", ["@Next 2 2", "=", 0]], true, [[1, 0, 0]], 3, [false, true, true]],
                [3, [["@This 0", "+", 1, "=", "@Next 1 0"], "&&", ["@This 1", "=", "@Next 1 1"], "&&", ["@This 2", "=", "@Next 1 2"], "&&", ["@This 0", "=", "@Next 2 0"], "&&", ["@This 1", "=", "@Next 2 1"], "&&", ["@This 2", "=", "@Next 2 2"]], false, [["@This 0", ["@This 1", "+", 1], "@This 2"]], [[3, "^", "@This 0"], "*", [5, "^", "@This 1"], "*", [7, "^", "@This 2"], "*", 5], [false, true, true]],
                [3, [["@This 0", "=", "@Next 1 0"], "&&", ["@This 1", "+", 1, "=", "@Next 1 1"], "&&", ["@This 2", "=", "@Next 1 2"], "&&", ["@This 0", "=", "@Next 2 0"], "&&", ["@This 1", "=", "@Next 2 1"], "&&", ["@This 2", "=", "@Next 2 2"]], false, [["@This 0", "@This 1", ["@This 2", "+", 1]]], [[3, "^", "@This 0"], "*", [5, "^", "@This 1"], "*", [7, "^", "@This 2"], "*", 7], [false, true, true]],
                [3, [["@This 0", "=", "@Next 1 0"], "&&", ["@This 1", "=", "@Next 1 1"], "&&", ["@This 2", "+", 1, "=", "@Next 1 2"], "&&", ["@This 0", "=", "@Next 2 0"], "&&", ["@This 1", "=", "@Next 2 1"], "&&", ["@This 2", "=", "@Next 2 2"]], false, [[["@This 0", "+", 2], "@This 1", "@This 2"]], [[3, "^", "@This 0"], "*", [5, "^", "@This 1"], "*", [7, "^", "@This 2"], "*", 9], [false, true, true]]
            ];
            document.documentElement.style.setProperty("background-image", "linear-gradient(#fff, #fbf, #9ff, #ff7, #ffdc5c 10%, #baba35, #ffdc5c 90%, #ff7, #9ff, #fbf, #fff)");
            document.documentElement.style.setProperty("--background-color", "linear-gradient(#fff, #fdf, #bff, #ffa, #ffe78f 10%, #dddd57, #ffe78f 90%, #ffa, #bff, #fdf, #fff)");
            displayRules("rules_text", ["h2", "Powers of 3 Times Powers of 5 Times Powers of 7"], ["h1", "2205 (Level 1)"], ["p", "Merges occur between three 1s, or between any tile and two equal tiles that are each a third, a fifth, or a seventh of the larger tile. Get to the 2205 tile to win!"],
            ["p", "Spawning tiles: 1 (100%)"]);
            displayRules("gm_rules_text", ["h2", "Powers of 3 Times Powers of 5 Times Powers of 7"], ["h1", "2205 (Level 1)"], ["p", "Merges occur between three 1s, or between any tile and two equal tiles that are each a third, a fifth, or a seventh of the larger tile. Get to the 2205 tile to win!"],
            ["p", "Spawning tiles: 1 (100%)"]);
        }
        else if (mode_vars[0] == 2) {
            document.getElementById("2205_level_text").innerHTML = "Level 2: The merges are n + n + n, n + n + 3n, n + n + 5n and n + 7n + 7n.";
            document.getElementById("2205_level_text").style.setProperty("color", "#004747");
            document.getElementById("2205_level_decrease").style.setProperty("display", "block");
            document.getElementById("2205_level_increase").style.setProperty("display", "block");
            MergeRules = [
                [3, [["@This 0", "=", "@Next 1 0"], "&&", ["@This 1", "=", "@Next 1 1"], "&&", ["@This 2", "=", "@Next 1 2"], "&&", ["@This 0", "=", "@Next 2 0"], "&&", ["@This 1", "=", "@Next 2 1"], "&&", ["@This 2", "=", "@Next 2 2"]], true, [[["@This 0", "+", 1], "@This 1", "@This 2"]], [[3, "^", "@This 0"], "*", [5, "^", "@This 1"], "*", [7, "^", "@This 2"], "*", 3], [false, true, true]],
                [3, [["@This 0", "+", 1, "=", "@Next 1 0"], "&&", ["@This 1", "=", "@Next 1 1"], "&&", ["@This 2", "=", "@Next 1 2"], "&&", ["@This 0", "=", "@Next 2 0"], "&&", ["@This 1", "=", "@Next 2 1"], "&&", ["@This 2", "=", "@Next 2 2"]], false, [["@This 0", ["@This 1", "+", 1], "@This 2"]], [[3, "^", "@This 0"], "*", [5, "^", "@This 1"], "*", [7, "^", "@This 2"], "*", 5], [false, true, true]],
                [3, [["@This 0", "=", "@Next 1 0"], "&&", ["@This 1", "+", 1, "=", "@Next 1 1"], "&&", ["@This 2", "=", "@Next 1 2"], "&&", ["@This 0", "=", "@Next 2 0"], "&&", ["@This 1", "=", "@Next 2 1"], "&&", ["@This 2", "=", "@Next 2 2"]], false, [["@This 0", "@This 1", ["@This 2", "+", 1]]], [[3, "^", "@This 0"], "*", [5, "^", "@This 1"], "*", [7, "^", "@This 2"], "*", 7], [false, true, true]],
                [3, [["@This 0", "=", "@Next 1 0"], "&&", ["@This 1", "=", "@Next 1 1"], "&&", ["@This 2", "+", 1, "=", "@Next 1 2"], "&&", ["@This 0", "=", "@Next 2 0"], "&&", ["@This 1", "=", "@Next 2 1"], "&&", ["@This 2", "+", 1, "=", "@Next 2 2"]], false, [[["@This 0", "+", 1], ["@This 1", "+", 1], "@This 2"]], [[3, "^", "@This 0"], "*", [5, "^", "@This 1"], "*", [7, "^", "@This 2"], "*", 15], [false, true, true]]
            ];
            document.documentElement.style.setProperty("background-image", "linear-gradient(#fff, #fbf, #9ff, #ff7, #5cffe1 10%, #438db0, #5cffe1 90%, #ff7, #9ff, #fbf, #fff)");
            document.documentElement.style.setProperty("--background-color", "linear-gradient(90deg, #fff, #fdf, #bff, #ffa, #8fffea 10%, #60a8ca, #8fffea 90%, #ffa, #bff, #fdf, #fff)");
            displayRules("rules_text", ["h2", "Powers of 3 Times Powers of 5 Times Powers of 7"], ["h1", "2205 (Level 2)"], ["p", "Merges occur between three equal tiles, or between any tile and two equal tiles that are each a third or a fifth of the larger tile, or between two equal tiles and a tile that's a seventh of the other two tiles. Get to the 2205 tile to win!"],
            ["p", "Spawning tiles: 1 (100%)"]);
            displayRules("gm_rules_text", ["h2", "Powers of 3 Times Powers of 5 Times Powers of 7"], ["h1", "2205 (Level 2)"], ["p", "Merges occur between three equal tiles, or between any tile and two equal tiles that are each a third or a fifth of the larger tile, or between two equal tiles and a tile that's a seventh of the other two tiles. Get to the 2205 tile to win!"],
            ["p", "Spawning tiles: 1 (100%)"]);
        }
        else if (mode_vars[0] == 3) {
            document.getElementById("2205_level_text").innerHTML = "Level 3: The merges are n + n + n, n + n + 3n, n + 3n + 3n, n + n + 7n, and n + 7n + 7n.";
            document.getElementById("2205_level_text").style.setProperty("color", "#470047");
            document.getElementById("2205_level_decrease").style.setProperty("display", "block");
            document.getElementById("2205_level_increase").style.setProperty("display", "none");
            MergeRules = [
                [3, [["@This 0", "=", "@Next 1 0"], "&&", ["@This 1", "=", "@Next 1 1"], "&&", ["@This 2", "=", "@Next 1 2"], "&&", ["@This 0", "=", "@Next 2 0"], "&&", ["@This 1", "=", "@Next 2 1"], "&&", ["@This 2", "=", "@Next 2 2"]], true, [[["@This 0", "+", 1], "@This 1", "@This 2"]], [[3, "^", "@This 0"], "*", [5, "^", "@This 1"], "*", [7, "^", "@This 2"], "*", 3], [false, true, true]],
                [3, [["@This 0", "+", 1, "=", "@Next 1 0"], "&&", ["@This 1", "=", "@Next 1 1"], "&&", ["@This 2", "=", "@Next 1 2"], "&&", ["@This 0", "=", "@Next 2 0"], "&&", ["@This 1", "=", "@Next 2 1"], "&&", ["@This 2", "=", "@Next 2 2"]], false, [["@This 0", ["@This 1", "+", 1], "@This 2"]], [[3, "^", "@This 0"], "*", [5, "^", "@This 1"], "*", [7, "^", "@This 2"], "*", 5], [false, true, true]],
                [3, [["@This 0", "+", 1, "=", "@Next 1 0"], "&&", ["@This 1", "=", "@Next 1 1"], "&&", ["@This 2", "=", "@Next 1 2"], "&&", ["@This 0", "+", 1, "=", "@Next 2 0"], "&&", ["@This 1", "=", "@Next 2 1"], "&&", ["@This 2", "=", "@Next 2 2"]], false, [["@This 0", "@This 1", ["@This 2", "+", 1]]], [[3, "^", "@This 0"], "*", [5, "^", "@This 1"], "*", [7, "^", "@This 2"], "*", 7], [false, true, true]],
                [3, [["@This 0", "=", "@Next 1 0"], "&&", ["@This 1", "=", "@Next 1 1"], "&&", ["@This 2", "+", 1, "=", "@Next 1 2"], "&&", ["@This 0", "=", "@Next 2 0"], "&&", ["@This 1", "=", "@Next 2 1"], "&&", ["@This 2", "=", "@Next 2 2"]], false, [[["@This 0", "+", 2], "@This 1", "@This 2"]], [[3, "^", "@This 0"], "*", [5, "^", "@This 1"], "*", [7, "^", "@This 2"], "*", 9], [false, true, true]],
                [3, [["@This 0", "=", "@Next 1 0"], "&&", ["@This 1", "=", "@Next 1 1"], "&&", ["@This 2", "+", 1, "=", "@Next 1 2"], "&&", ["@This 0", "=", "@Next 2 0"], "&&", ["@This 1", "=", "@Next 2 1"], "&&", ["@This 2", "+", 1, "=", "@Next 2 2"]], false, [[["@This 0", "+", 1], ["@This 1", "+", 1], "@This 2"]], [[3, "^", "@This 0"], "*", [5, "^", "@This 1"], "*", [7, "^", "@This 2"], "*", 15], [false, true, true]]
            ];
            document.documentElement.style.setProperty("background-image", "linear-gradient(#fff, #fbf, #9ff, #ff7, #f15cff 10%, #ba359d, #f15cff 90%, #ff7, #9ff, #fbf, #fff)");
            document.documentElement.style.setProperty("--background-color", "linear-gradient(#fff, #fdf, #bff, #ffa, #f695ff 10%, #c758af, #f695ff 90%, #ffa, #bff, #fdf, #fff)");
            displayRules("rules_text", ["h2", "Powers of 3 Times Powers of 5 Times Powers of 7"], ["h1", "2205 (Level 3)"], ["p", "Merges occur between three equal tiles, or between three tiles such that there are two types of tile in the merge and the larger type is three times or seven times the smaller type. Get to the 2205 tile to win!"],
            ["p", "Spawning tiles: 1 (100%)"]);
            displayRules("gm_rules_text", ["h2", "Powers of 3 Times Powers of 5 Times Powers of 7"], ["h1", "2205 (Level 3)"], ["p", "Merges occur between three equal tiles, or between three tiles such that there are two types of tile in the merge and the larger type is three times or seven times the smaller type. Get to the 2205 tile to win!"],
            ["p", "Spawning tiles: 1 (100%)"]);
        }
    }
    if (gamemode == 71) { // 3,188,646
        if (mode_vars[0]) {
            document.getElementById("3188646_multiplyMiddle_text").innerHTML = "Multiplication tiles must be in the middle of the two tiles they are merging.";
            document.getElementById("3188646_multiplyMiddle_text").style.setProperty("color", "#a6ff6a");
            displayRules("rules_text", ["h1", "3,188,646"], ["p","There are multiplication tiles. If you merge two tiles that are each double a power of three (they do not need to be double the <i>same</i> power of three) with a multiplication tile in the middle, those two tiles will be multiplied. A tile that's quadruple a power of three can merge with a tile that's half of itself (i.e. double that power of three); this is the only kind of merge that gives any score. Also, if two multiplication tiles collide, they merge (and this does not prevent that multiplication tile from merging again that turn) to save on space. Get to the 3,188,646 (2 &#215; 3<sup>13</sup>) tile to win!"],
            ["p", "Spawning tiles: 2 (50%), &#215; (50%)"]);
            displayRules("gm_rules_text", ["h1", "3,188,646"], ["p","There are multiplication tiles. If you merge two tiles that are each double a power of three (they do not need to be double the <i>same</i> power of three) with a multiplication tile in the middle, those two tiles will be multiplied. A tile that's quadruple a power of three can merge with a tile that's half of itself (i.e. double that power of three); this is the only kind of merge that gives any score. Also, if two multiplication tiles collide, they merge (and this does not prevent that multiplication tile from merging again that turn) to save on space. Get to the 3,188,646 (2 &#215; 3<sup>13</sup>) tile to win!"],
            ["p", "Spawning tiles: 2 (50%), &#215; (50%)"]);
        }
        else {
            document.getElementById("3188646_multiplyMiddle_text").innerHTML = "Multiplication tiles don't have to be in the middle of the two tiles they are merging.";
            document.getElementById("3188646_multiplyMiddle_text").style.setProperty("color", "#5ad3ff");
            displayRules("rules_text", ["h1", "3,188,646"], ["p","There are multiplication tiles. If you merge two tiles that are each double a power of three (they do not need to be double the <i>same</i> power of three) with a multiplication tile, those two tiles will be multiplied. A tile that's quadruple a power of three can merge with a tile that's half of itself (i.e. double that power of three); this is the only kind of merge that gives any score. Also, if two multiplication tiles collide, they merge (and this does not prevent that multiplication tile from merging again that turn) to save on space. Get to the 3,188,646 (2 &#215; 3<sup>13</sup>) tile to win!"],
            ["p", "Spawning tiles: 2 (50%), &#215; (50%)"]);
            displayRules("gm_rules_text", ["h1", "3,188,646"], ["p","There are multiplication tiles. If you merge two tiles that are each double a power of three (they do not need to be double the <i>same</i> power of three) with a multiplication tile, those two tiles will be multiplied. A tile that's quadruple a power of three can merge with a tile that's half of itself (i.e. double that power of three); this is the only kind of merge that gives any score. Also, if two multiplication tiles collide, they merge (and this does not prevent that multiplication tile from merging again that turn) to save on space. Get to the 3,188,646 (2 &#215; 3<sup>13</sup>) tile to win!"],
            ["p", "Spawning tiles: 2 (50%), &#215; (50%)"]);
        }
    }
    if (gamemode == 72) { // 3026
        if (mode_vars[0]) {
            document.getElementById("3026_allMerges_text").innerHTML = "Any two tiles that add to a product of two Fibonacci numbers can merge.";
            document.getElementById("3026_allMerges_text").style.setProperty("color", "#fff6b3");
            displayRules("rules_text", ["h1", "3026"], ["p", "Tiles are products of two Fibonacci numbers, and any two tiles can merge if their sum can be expressed as such a product (thanks to relations between Fibonacci numbers, this allows for more merges than you may expect!). Get to the 3026 (34 &#215; 89) tile to win!"],
            ["p", "Spawning tiles: 1 (90%), 2 (10%)"]);
            displayRules("gm_rules_text", ["h1", "3026"], ["p", "Tiles are products of two Fibonacci numbers, and any two tiles can merge if their sum can be expressed as such a product (thanks to relations between Fibonacci numbers, this allows for more merges than you may expect!). Get to the 3026 (34 &#215; 89) tile to win!"],
            ["p", "Spawning tiles: 1 (90%), 2 (10%)"]);
        }
        else {
            document.getElementById("3026_allMerges_text").innerHTML = "Only Fibonacci-style merges are allowed.";
            document.getElementById("3026_allMerges_text").style.setProperty("color", "#1d0056");
            displayRules("rules_text", ["h1", "3026"], ["p", "Tiles are products of two Fibonacci numbers. Two tiles can merge if they share one Fibonacci number in common, and either the other Fibonacci number is 1 for both of them or one tile's other Fibonacci number is the Fibonacci number right before the other tile's other Fibonacci number. For example, 5 &#215; 8 and 5 &#215; 13 can merge to make 5 &#215; 21. Get to the 3026 (34 &#215; 89) tile to win!"],
            ["p", "Spawning tiles: 1 (90%), 2 (10%)"]);
            displayRules("gm_rules_text", ["h1", "3026"], ["p", "Tiles are products of two Fibonacci numbers. Two tiles can merge if they share one Fibonacci number in common, and either the other Fibonacci number is 1 for both of them or one tile's other Fibonacci number is the Fibonacci number right before the other tile's other Fibonacci number. For example, 5 &#215; 8 and 5 &#215; 13 can merge to make 5 &#215; 21. Get to the 3026 (34 &#215; 89) tile to win!"],
            ["p", "Spawning tiles: 1 (90%), 2 (10%)"]);
        }
        if (mode_vars[1] == 0) {
            document.getElementById("3026_randomGoals_text").innerHTML = "Random goals are disabled.";
            document.getElementById("3026_randomGoals_text").style.setProperty("color", "#22002d");
        }
        else if (mode_vars[1] == 1) {
            document.getElementById("3026_randomGoals_text").innerHTML = "Random goals build upon the previous goals.";
            document.getElementById("3026_randomGoals_text").style.setProperty("color", "#732a8b");
        }
        else if (mode_vars[1] == 2) {
            document.getElementById("3026_randomGoals_text").innerHTML = "Random goals are entirely random.";
            document.getElementById("3026_randomGoals_text").style.setProperty("color", "#ba77d0");
        }
        if (mode_vars[1] == 0) {
            document.getElementById("3026_firstGoalMinimum").style.setProperty("display", "none");
        }
        else {
            document.getElementById("3026_firstGoalMinimum").style.setProperty("display", "block");
            document.getElementById("3026_firstGoalMinimum_counter").innerHTML = mode_vars[2];
            if (mode_vars[2] < 3) document.getElementById("3026_firstGoalMinimum_minus").style.setProperty("display", "none");
            else document.getElementById("3026_firstGoalMinimum_minus").style.setProperty("display", "inline-block");
        }
    }
    else if (gamemode == 73) { // SQUART
        if (mode_vars[0] == 0) {
            document.getElementById("SQUART_randomGoals_text").innerHTML = "Random goals are disabled.";
            document.getElementById("SQUART_randomGoals_text").style.setProperty("color", "#22002d");
        }
        else if (mode_vars[0] == 1) {
            document.getElementById("SQUART_randomGoals_text").innerHTML = "Random goals build upon the previous goals.";
            document.getElementById("SQUART_randomGoals_text").style.setProperty("color", "#732a8b");
        }
        else if (mode_vars[0] == 2) {
            document.getElementById("SQUART_randomGoals_text").innerHTML = "Each random goal builds upon the previous goal, but not necessarily the ones before.";
            document.getElementById("SQUART_randomGoals_text").style.setProperty("color", "#a01acd");
        }
        else if (mode_vars[0] == 3) {
            document.getElementById("SQUART_randomGoals_text").innerHTML = "Random goals are entirely random.";
            document.getElementById("SQUART_randomGoals_text").style.setProperty("color", "#ba77d0");
        }
        document.getElementById("SQUART_firstGoalMinimum").style.setProperty("display", (mode_vars[0] == 0) ? "none" : "block");
        document.getElementById("SQUART_firstGoalMinimum_change").value = mode_vars[1];
    }
    else if (gamemode == 74) { // Turatin
        document.getElementById("Turatin_interval_counter").innerHTML = mode_vars[0];
        if (mode_vars[0] < 2) document.getElementById("Turatin_interval_minus").style.setProperty("display", "none");
        else document.getElementById("Turatin_interval_minus").style.setProperty("display", "inline-block");
        document.getElementById("Turatin_interval_plus").style.setProperty("display", "inline-block");
        let mergeNumberText, ratioText, title;
        if (mode_vars[2] == 0) {
            document.getElementById("Turatin_switch_text").innerHTML = "The merge number increases based on the amount of turns.";
            document.getElementById("Turatin_switch_text").style.setProperty("color", "#7cffb5");
            if (mode_vars[0] == 1) {
                mergeNumberText = 'The "merge number" starts at 1 and increases by 1 every turn.'
            }
            else {
                mergeNumberText = 'The "merge number" starts at 1 and increases by 1 every ' + mode_vars[0] + ' turns.'
            }
        }
        else if (mode_vars[2] == 1) {
            document.getElementById("Turatin_switch_text").innerHTML = "The merge number increases based on the amount of turns where a merge occured.";
            document.getElementById("Turatin_switch_text").style.setProperty("color", "#ffd500");
            if (mode_vars[0] == 1) {
                mergeNumberText = 'The "merge number" starts at 1 and increases by 1 every turn where a merge occured.'
            }
            else {
                mergeNumberText = 'The "merge number" starts at 1 and increases by 1 every ' + mode_vars[0] + ' turns where a merge occured.'
            }
        }
        else if (mode_vars[2] == 2) {
            document.getElementById("Turatin_switch_text").innerHTML = "The merge number increases based on the amount of merges that have happened so far, not counting the current turn.";
            document.getElementById("Turatin_switch_text").style.setProperty("color", "#9d00ff");
            if (mode_vars[0] == 1) {
                mergeNumberText = 'The "merge number" starts at 1 and increases by 1 every merge (this only updates after each move, so the merge rules won\'t change in the middle of a move).'
            }
            else {
                mergeNumberText = 'The "merge number" starts at 1 and increases by 1 every ' + mode_vars[0] + ' merges (this only updates after each move, so the merge rules won\'t change in the middle of a move).'
            }
        }
        if (mode_vars[1]) {
            ratioText = ' Two tiles can merge if the current merge number is a multiple of the ratio between the larger tile and the smaller tile (even if that ratio is not an integer!). '
            document.getElementById("Turatin_nonIntegerRatio_text").innerHTML = "The ratio between merging tiles doesn't have to be an integer.";
            document.getElementById("Turatin_nonIntegerRatio_text").style.setProperty("color", "#25a39d");
            title = "Turatin (Extra Fluid)"
        }
        else {
            ratioText = ' Two tiles can merge if the ratio between the larger tile and the smaller tile is a factor of the current merge number. '
            document.getElementById("Turatin_nonIntegerRatio_text").innerHTML = "The ratio between merging tiles must be an integer.";
            document.getElementById("Turatin_nonIntegerRatio_text").style.setProperty("color", "#005551");
            title = "Turatin";
        }
        displayRules("rules_text", ["h1", title], ["p", mergeNumberText + ratioText + 'This mode has no win condition - your goal is just to survive as long as you can! (When two tiles merge, the score gained is the larger tile divided by the smaller tile, so if you want to go for high score, you\'ll need to make trickier merges!)'],
        ["p", "Spawning tiles: 1 (100%)"]);
        displayRules("gm_rules_text", ["h1", title], ["p", mergeNumberText + ratioText + 'This mode has no win condition - your goal is just to survive as long as you can! (When two tiles merge, the score gained is the larger tile divided by the smaller tile, so if you want to go for high score, you\'ll need to make trickier merges!)'],
        ["p", "Spawning tiles: 1 (100%)"]);
    }
    else if (gamemode == 75) { // 3307
        if (mode_vars[0] == 0) { // 3307 (two equal tiles)
            if (modifiers[13] == "None") {
                MergeRules = [
                    [2, ["@This 0", "=", "@Next 1 0"], true, [[["@This 0", "*B", 2]]], ["@This 0", "*", 2], [false, true]],
                    [3, [["@This 0", "^B", 2], "=", ["@Next 1 0", "*B", "@Next 2 0"], "&&", ["@This 0", "!=", "@Next 1 0"]], false, [[["@This 0", "+B", "@Next 1 0", "+B", "@Next 2 0"]]], ["@This 0", "+", "@Next 1 0", "+", "@Next 2 0"], [false, true, true]]
                ];
            }
            else if (modifiers[13] == "Non-Interacting") {
                MergeRules = [
                    [2, ["@This 0", "=", "@Next 1 0"], true, [[["@This 0", "*B", 2]]], ["@This 0", "*", 2, "abs"], [false, true]],
                    [3, [["@This 0", "^B", 2], "=", ["@Next 1 0", "*B", "@Next 2 0"], "&&", [["@This 0", "absB"], "!=", ["@Next 1 0", "absB"]], "&&", [["@This 0", "signB"], "=", ["@Next 1 0", "signB"]]], false, [[["@This 0", "+B", "@Next 1 0", "+B", "@Next 2 0"]]], ["@This 0", "+", "@Next 1 0", "+", "@Next 2 0", "abs"], [false, true, true]]
                ];
            }
            else {
                MergeRules = [
                    [2, ["@This 0", "*B", -1, "=", "@Next 1 0"], true, [], 0, [true, true]],
                    [2, ["@This 0", "=", "@Next 1 0"], true, [[["@This 0", "*B", 2]]], ["@This 0", "*", 2, "abs"], [false, true]],
                    [3, [["@This 0", "^B", 2], "=", ["@Next 1 0", "*B", "@Next 2 0"], "&&", [["@This 0", "absB"], "!=", ["@Next 1 0", "absB"]]], false, [[["@This 0", "+B", "@Next 1 0", "+B", "@Next 2 0"]]], ["@This 0", "+", "@Next 1 0", "+", "@Next 2 0", "abs"], [false, true, true]]
                ]; 
            }
            winConditions = [[3307n]];
            knownMergeMaxLength = 3;
            knownMergeLookbackDistance = 0;
            document.documentElement.style.setProperty("background-image", "repeating-linear-gradient(#990080 0% 6%, #660033 6% 9%, #990080 9% 15%, #330066 15% 18%)");
            document.documentElement.style.setProperty("--background-color", "repeating-linear-gradient(#dc6fca 0% 6%, #ba3979 6% 9%, #dc6fca 9% 15%, #7b41b6 15% 18%)");
            document.documentElement.style.setProperty("--grid-color", "#620051");
            document.documentElement.style.setProperty("--tile-color", "#a12e68");
            document.documentElement.style.setProperty("--text-color", "#190032");
            displayRules("rules_text", ["h1", "3307"], ["p", 'Merges occur between two equal tiles, or between three different tiles such that the ratio between the middle-sized tile and the smallest tile is the same as the ratio between the largest tile and the middle-sized tile. Get to the 3307 tile to win, or see what other tiles you can make!'],
            ["p", "Spawning tiles: 1 (100%)"]);
            displayRules("gm_rules_text", ["h1", "3307"], ["p", 'Merges occur between two equal tiles, or between three different tiles such that the ratio between the middle-sized tile and the smallest tile is the same as the ratio between the largest tile and the middle-sized tile. Get to the 3307 tile to win, or see what other tiles you can make!'],
            ["p", "Spawning tiles: 1 (100%)"]);
            document.getElementById("3307_equalVariant_text").innerHTML = "Two equal tiles can merge.";
            document.getElementById("3307_equalVariant_text").style.setProperty("color", "#e77000");
        }
        else if (mode_vars[0] == 1) { // 2379 (three equal tiles)
            if (modifiers[13] == "None") {
                MergeRules = [
                    [3, [["@This 0", "^B", 2], "=", ["@Next 1 0", "*B", "@Next 2 0"]], false, [[["@This 0", "+B", "@Next 1 0", "+B", "@Next 2 0"]]], ["@This 0", "+", "@Next 1 0", "+", "@Next 2 0"], [false, true, true]]
                ];
            }
            else if (modifiers[13] == "Non-Interacting") {
                MergeRules = [
                    [3, [["@This 0", "^B", 2], "=", ["@Next 1 0", "*B", "@Next 2 0"], "&&", [["@This 0", "signB"], "=", ["@Next 1 0", "signB"]]], false, [[["@This 0", "+B", "@Next 1 0", "+B", "@Next 2 0"]]], ["@This 0", "+", "@Next 1 0", "+", "@Next 2 0", "abs"], [false, true, true]]
                ];
            }
            else {
                MergeRules = [
                    [2, ["@This 0", "*B", -1, "=", "@Next 1 0"], true, [], 0, [true, true]],
                    [3, [["@This 0", "^B", 2], "=", ["@Next 1 0", "*B", "@Next 2 0"]], false, [[["@This 0", "+B", "@Next 1 0", "+B", "@Next 2 0"]]], ["@This 0", "+", "@Next 1 0", "+", "@Next 2 0", "abs"], [false, true, true]]
                ]; 
            }
            winConditions = [[2379n]];
            knownMergeMaxLength = 3;
            knownMergeLookbackDistance = 0;
            document.documentElement.style.setProperty("background-image", "repeating-linear-gradient(#006a37 0% 6%, #d98026 6% 9%, #006a37 9% 15%, #ffff85 15% 18%)");
            document.documentElement.style.setProperty("--background-color", "repeating-linear-gradient(#13aa61 0% 6%, #f0b478 6% 9%, #13aa61 9% 15%, #ffffb4 15% 18%)");
            document.documentElement.style.setProperty("--grid-color", "#2b895c");
            document.documentElement.style.setProperty("--tile-color", "#bbbb6b");
            document.documentElement.style.setProperty("--text-color", "#36200a");
            displayRules("rules_text", ["h1", "2379"], ["p", 'Merges occur between three tiles such that the ratio between the middle-sized tile and the smallest tile is the same as the ratio between the largest tile and the middle-sized tile. Get to the 2379 tile to win, or see what other tiles you can make!'],
            ["p", "Spawning tiles: 1 (100%)"]);
            displayRules("gm_rules_text", ["h1", "2379"], ["p", 'Merges occur between three tiles such that the ratio between the middle-sized tile and the smallest tile is the same as the ratio between the largest tile and the middle-sized tile. Get to the 2379 tile to win, or see what other tiles you can make!'],
            ["p", "Spawning tiles: 1 (100%)"]);
            document.getElementById("3307_equalVariant_text").innerHTML = "Three equal tiles can merge.";
            document.getElementById("3307_equalVariant_text").style.setProperty("color", "#00e768");
        }
        else if (mode_vars[0] == 2) { // 2667 (both)
            // [2, ["@This 0", "=", "@Next 1 0", "&&", ["@NextNE -1 0", "!=", "@This 0"]], true, [[["@This 0", "*B", 2]]], ["@This 0", "*", 2], [false, true]]
            if (modifiers[13] == "None") {
                MergeRules = [
                    [3, [["@This 0", "^B", 2], "=", ["@Next 1 0", "*B", "@Next 2 0"]], false, [[["@This 0", "+B", "@Next 1 0", "+B", "@Next 2 0"]]], ["@This 0", "+", "@Next 1 0", "+", "@Next 2 0"], [false, true, true]],
                    [2, ["@This 0", "=", "@Next 1 0", "&&", ["@NextNE -1 0", "!=", "@This 0"]], true, [[["@This 0", "*B", 2]]], ["@This 0", "*", 2], [false, true]]
                ];
            }
            else if (modifiers[13] == "Non-Interacting") {
                MergeRules = [
                    [3, [["@This 0", "^B", 2], "=", ["@Next 1 0", "*B", "@Next 2 0"], "&&", [["@This 0", "signB"], "=", ["@Next 1 0", "signB"]]], false, [[["@This 0", "+B", "@Next 1 0", "+B", "@Next 2 0"]]], ["@This 0", "+", "@Next 1 0", "+", "@Next 2 0", "abs"], [false, true, true]],
                    [2, ["@This 0", "=", "@Next 1 0", "&&", ["@NextNE -1 0", "!=", "@This 0"]], true, [[["@This 0", "*B", 2]]], ["@This 0", "*", 2, "abs"], [false, true]]
                ];
            }
            else {
                MergeRules = [
                    [2, ["@This 0", "*B", -1, "=", "@Next 1 0"], true, [], 0, [true, true]],
                    [3, [["@This 0", "^B", 2], "=", ["@Next 1 0", "*B", "@Next 2 0"]], false, [[["@This 0", "+B", "@Next 1 0", "+B", "@Next 2 0"]]], ["@This 0", "+", "@Next 1 0", "+", "@Next 2 0", "abs"], [false, true, true]],
                    [2, ["@This 0", "=", "@Next 1 0", "&&", ["@NextNE -1 0", "!=", "@This 0"]], true, [[["@This 0", "*B", 2]]], ["@This 0", "*", 2, "abs"], [false, true]]
                ]; 
            }
            winConditions = [[2667n]];
            knownMergeMaxLength = 3;
            knownMergeLookbackDistance = 1;
            document.documentElement.style.setProperty("background-image", "repeating-linear-gradient(#004f9d 0% 6%, #4d4d4d 6% 9%, #004f9d 9% 15%, #330066 15% 18%)");
            document.documentElement.style.setProperty("--background-color", "repeating-linear-gradient(#4087ce 0% 6%, #b7b7b7 6% 9%, #4087ce 9% 15%, #8948ca 15% 18%)");
            document.documentElement.style.setProperty("--grid-color", "#2062a3");
            document.documentElement.style.setProperty("--tile-color", "#543475");
            document.documentElement.style.setProperty("--text-color", "#373737");
            displayRules("rules_text", ["h1", "2667"], ["p", 'Merges occur between two equal tiles, or between three tiles such that the ratio between the middle-sized tile and the smallest tile is the same as the ratio between the largest tile and the middle-sized tile. Get to the 2667 tile to win, or see what other tiles you can make!'],
            ["p", "Spawning tiles: 1 (100%)"]);
            displayRules("gm_rules_text", ["h1", "2667"], ["p", 'Merges occur between two equal tiles, or between three tiles such that the ratio between the middle-sized tile and the smallest tile is the same as the ratio between the largest tile and the middle-sized tile. Get to the 2667 tile to win, or see what other tiles you can make!'],
            ["p", "Spawning tiles: 1 (100%)"]);
            document.getElementById("3307_equalVariant_text").innerHTML = "Two or three equal tiles can merge.";
            document.getElementById("3307_equalVariant_text").style.setProperty("color", "#8000ea");
        }
    }
    else if (gamemode == 77) { // 1668
        if (mode_vars[0] == 0) {
            document.getElementById("1668_randomGoals_text").innerHTML = "Random goals are disabled.";
            document.getElementById("1668_randomGoals_text").style.setProperty("color", "#22002d");
        }
        else if (mode_vars[0] == 1) {
            document.getElementById("1668_randomGoals_text").innerHTML = "Random goals build upon the previous goals.";
            document.getElementById("1668_randomGoals_text").style.setProperty("color", "#732a8b");
        }
        else if (mode_vars[0] == 2) {
            document.getElementById("1668_randomGoals_text").innerHTML = "Random goals are entirely random.";
            document.getElementById("1668_randomGoals_text").style.setProperty("color", "#ba77d0");
        }
        if (mode_vars[0] == 0) {
            document.getElementById("1668_firstGoalMinimum").style.setProperty("display", "none");
        }
        else {
            document.getElementById("1668_firstGoalMinimum").style.setProperty("display", "block");
            document.getElementById("1668_firstGoalMinimum_counter").innerHTML = mode_vars[1];
            if (mode_vars[1] < 2) document.getElementById("1668_firstGoalMinimum_minus").style.setProperty("display", "none");
            else document.getElementById("1668_firstGoalMinimum_minus").style.setProperty("display", "inline-block");
        }
    }
    else if (gamemode == 78) { // 1847
        if (mode_vars[0] == 0) {
            document.getElementById("1847_randomGoals_text").innerHTML = "Random goals are disabled.";
            document.getElementById("1847_randomGoals_text").style.setProperty("color", "#22002d");
        }
        else if (mode_vars[0] == 1) {
            document.getElementById("1847_randomGoals_text").innerHTML = "Random goals build upon the previous goals.";
            document.getElementById("1847_randomGoals_text").style.setProperty("color", "#732a8b");
        }
        else if (mode_vars[0] == 2) {
            document.getElementById("1847_randomGoals_text").innerHTML = "Random goals are entirely random.";
            document.getElementById("1847_randomGoals_text").style.setProperty("color", "#ba77d0");
        }
        if (mode_vars[0] == 0) {
            document.getElementById("1847_firstGoalMinimum").style.setProperty("display", "none");
        }
        else {
            document.getElementById("1847_firstGoalMinimum").style.setProperty("display", "block");
            document.getElementById("1847_firstGoalMinimum_counter").innerHTML = mode_vars[1];
            if (mode_vars[1] < 5) document.getElementById("1847_firstGoalMinimum_minus").style.setProperty("display", "none");
            else document.getElementById("1847_firstGoalMinimum_minus").style.setProperty("display", "inline-block");
        }
    }
    else if (gamemode == 80) { // 1429
        if (mode_vars[0] == 0) {
            document.getElementById("1429_randomGoals_text").innerHTML = "Random goals are disabled.";
            document.getElementById("1429_randomGoals_text").style.setProperty("color", "#22002d");
        }
        else if (mode_vars[0] == 1) {
            document.getElementById("1429_randomGoals_text").innerHTML = "Random goals build upon the previous goals.";
            document.getElementById("1429_randomGoals_text").style.setProperty("color", "#5f1179")
        }
        else if (mode_vars[0] == 2) {
            document.getElementById("1429_randomGoals_text").innerHTML = "Random goals are entirely random.";
            document.getElementById("1429_randomGoals_text").style.setProperty("color", "#ba77d0");
        }
        if (mode_vars[0] == 0) {
            document.getElementById("1429_firstGoalMinimum").style.setProperty("display", "none");
        }
        else {
            document.getElementById("1429_firstGoalMinimum").style.setProperty("display", "block");
            document.getElementById("1429_firstGoalMinimum_counter").innerHTML = mode_vars[1];
            if (mode_vars[1] < 4) document.getElementById("1429_firstGoalMinimum_minus").style.setProperty("display", "none");
            else document.getElementById("1429_firstGoalMinimum_minus").style.setProperty("display", "inline-block");
        }
    }
    else if (gamemode == 81) { // 2058
        if (mode_vars[0] == 1) {
            document.getElementById("2058_powRequired_counter").innerHTML = "N/A";
            document.getElementById("2058_startMaxNum").style.setProperty("display", "none");
            displayRules("rules_text", ["h2", "Powers of n Times Powers of n+1"], ["h1", "2058"], ["p", "Two equal tiles can merge if they are a power of 2. A tile of the form n<sup>a</sup> &#215; (n + 1)<sup>b</sup> can merge with an n<sup>a - 1</sup> &#215; (n + 1)<sup>b</sup> tile to make an n<sup>a - 1</sup> &#215; (n + 1)<sup>b + 1</sup> tile. If this would result in the first exponent being 0, the bases are increased by 1 to shift the exponents over: for example, 2<sup>0</sup> &#215; 3<sup>2</sup> becomes 3<sup>2</sup> &#215; 4<sup>0</sup>. A merge only gives score if the sum of the exponents of the result tile is at least 2. Get to the 2058 (6<sup>1</sup> &#215; 7<sup>3</sup>) tile to win!"],
            ["p", "Spawning tiles: 1 (70%), 2 (30%)"]);
            displayRules("gm_rules_text", ["h2", "Powers of n Times Powers of n+1"], ["h1", "2058"], ["p", "Two equal tiles can merge if they are a power of 2. A tile of the form n<sup>a</sup> &#215; (n + 1)<sup>b</sup> can merge with an n<sup>a - 1</sup> &#215; (n + 1)<sup>b</sup> tile to make an n<sup>a - 1</sup> &#215; (n + 1)<sup>b + 1</sup> tile. If this would result in the first exponent being 0, the bases are increased by 1 to shift the exponents over: for example, 2<sup>0</sup> &#215; 3<sup>2</sup> becomes 3<sup>2</sup> &#215; 4<sup>0</sup>. A merge only gives score if the sum of the exponents of the result tile is at least 2. Get to the 2058 (6<sup>1</sup> &#215; 7<sup>3</sup>) tile to win!"],
            ["p", "Spawning tiles: 1 (70%), 2 (30%)"]);
        }
        else {
            document.getElementById("2058_powRequired_counter").innerHTML = mode_vars[0];
            document.getElementById("2058_startMaxNum").style.setProperty("display", "block");
            document.getElementById("2058_startMaxNum_counter").innerHTML = mode_vars[1];
            displayRules("rules_text", ["h2", "Powers of n Times Powers of n+1"], ["h1", "2058"], ["p", "Two equal tiles can merge if they are a power of 2. A tile of the form n<sup>a</sup> &#215; (n + 1)<sup>b</sup> can merge with an n<sup>a - 1</sup> &#215; (n + 1)<sup>b</sup> tile to make an n<sup>a - 1</sup> &#215; (n + 1)<sup>b + 1</sup> tile. If this would result in the first exponent being 0, the bases are increased by 1 to shift the exponents over: for example, 2<sup>0</sup> &#215; 3<sup>2</sup> becomes 3<sup>2</sup> &#215; 4<sup>0</sup>. However, if the tile contains any number above a certain threshold with a power above 0, then that tile disappears. This maximum number starts at " + mode_vars[1] + ", but increases by 1 whenever you make a tile that includes the current maximum number with a power of at least " + mode_vars[0] + ". Get to the 2058 (6<sup>1</sup> &#215; 7<sup>3</sup>) tile to win!"],
            ["p", "Spawning tiles: 1 (70%), 2 (30%)"]);
            displayRules("gm_rules_text", ["h2", "Powers of n Times Powers of n+1"], ["h1", "2058"], ["p", "Two equal tiles can merge if they are a power of 2. A tile of the form n<sup>a</sup> &#215; (n + 1)<sup>b</sup> can merge with an n<sup>a - 1</sup> &#215; (n + 1)<sup>b</sup> tile to make an n<sup>a - 1</sup> &#215; (n + 1)<sup>b + 1</sup> tile. If this would result in the first exponent being 0, the bases are increased by 1 to shift the exponents over: for example, 2<sup>0</sup> &#215; 3<sup>2</sup> becomes 3<sup>2</sup> &#215; 4<sup>0</sup>. However, if the tile contains any number above a certain threshold with a power above 0, then that tile disappears. This maximum number starts at " + mode_vars[1] + ", but increases by 1 whenever you make a tile that includes the current maximum number with a power of at least " + mode_vars[0] + ". Get to the 2058 (6<sup>1</sup> &#215; 7<sup>3</sup>) tile to win!"],
            ["p", "Spawning tiles: 1 (70%), 2 (30%)"]);
        }
        if (mode_vars[0] < 2) document.getElementById("2058_powRequired_minus").style.setProperty("display", "none");
        else document.getElementById("2058_powRequired_minus").style.setProperty("display", "inline-block");
        document.getElementById("2058_powRequired_plus").style.setProperty("display", "inline-block");
        if (mode_vars[1] < 3) document.getElementById("2058_startMaxNum_minus").style.setProperty("display", "none");
        else document.getElementById("2058_startMaxNum_minus").style.setProperty("display", "inline-block");
        document.getElementById("2058_startMaxNum_plus").style.setProperty("display", "inline-block");
    }
    else if (gamemode == 82) { // 1716
        if (mode_vars[0]) {
            document.getElementById("1716_equalDisappear_text").innerHTML = "Any two equal tiles can merge, disappearing if that's not a valid merge."
            document.getElementById("1716_equalDisappear_text").style.setProperty("color", "#932e0f");
            displayRules("rules_text", ["h2", "Pascal's Triangle"], ["h1", "1716"], ["p", "Tiles can be thought of as (unordered) pairs. An (a, b) tile can merge with an (a - 1, b + 1) tile to make a (a, b + 1) tile, or with an (a + 1, b - 1) tile to make an (a + 1, b) tile. Also, two equal (n, n + 1) tiles can merge into an (n + 1, n + 1 tile), and a 1 tile can serve as (1, n) for any n, meaning a (2, n) tile merges with a 1 to make a (2, n + 1) tile. If any two equal tiles other than the aforementioned cases collide, they'll disappear. Get to the 1716 (7, 8) tile to win!"],
            ["p", "Spawning tiles: 1 (85%), 2 (8%), 3 (8%)"]);
            displayRules("gm_rules_text", ["h2", "Pascal's Triangle"], ["h1", "1716"], ["p", "Tiles can be thought of as (unordered) pairs. An (a, b) tile can merge with an (a - 1, b + 1) tile to make a (a, b + 1) tile, or with an (a + 1, b - 1) tile to make an (a + 1, b) tile. Also, two equal (n, n + 1) tiles can merge into an (n + 1, n + 1 tile), and a 1 tile can serve as (1, n) for any n, meaning a (2, n) tile merges with a 1 to make a (2, n + 1) tile. If any two equal tiles other than the aforementioned cases collide, they'll disappear. Get to the 1716 (7, 8) tile to win!"],
            ["p", "Spawning tiles: 1 (85%), 2 (8%), 3 (8%)"]);
        }
        else {
            document.getElementById("1716_equalDisappear_text").innerHTML = "Only valid equal tile merges can occur."
            document.getElementById("1716_equalDisappear_text").style.setProperty("color", "#99861a");
            displayRules("rules_text", ["h2", "Pascal's Triangle"], ["h1", "1716"], ["p", "Tiles can be thought of as (unordered) pairs. An (a, b) tile can merge with an (a - 1, b + 1) tile to make a (a, b + 1) tile, or with an (a + 1, b - 1) tile to make an (a + 1, b) tile. Also, two equal (n, n + 1) tiles can merge into an (n + 1, n + 1 tile), and a 1 tile can serve as (1, n) for any n, meaning a (2, n) tile merges with a 1 to make a (2, n + 1) tile. A merge only gives score if both entries in the resulting tile's pair are at least 3. Get to the 1716 (7, 8) tile to win!"],
            ["p", "Spawning tiles: 1 (85%), 2 (8%), 3 (8%)"]);
            displayRules("gm_rules_text", ["h2", "Pascal's Triangle"], ["h1", "1716"], ["p", "Tiles can be thought of as (unordered) pairs. An (a, b) tile can merge with an (a - 1, b + 1) tile to make a (a, b + 1) tile, or with an (a + 1, b - 1) tile to make an (a + 1, b) tile. Also, two equal (n, n + 1) tiles can merge into an (n + 1, n + 1 tile), and a 1 tile can serve as (1, n) for any n, meaning a (2, n) tile merges with a 1 to make a (2, n + 1) tile. A merge only gives score if both entries in the resulting tile's pair are at least 3. Get to the 1716 (7, 8) tile to win!"],
            ["p", "Spawning tiles: 1 (85%), 2 (8%), 3 (8%)"]);
        }
    }
    else if (gamemode == 85) { // 2669
        if (mode_vars[0] == 0) {
            document.getElementById("2669_randomGoals_text").innerHTML = "Random goals are disabled.";
            document.getElementById("2669_randomGoals_text").style.setProperty("color", "#22002d");
        }
        else if (mode_vars[0] == 1) {
            document.getElementById("2669_randomGoals_text").innerHTML = "Random goals build upon the previous goals.";
            document.getElementById("2669_randomGoals_text").style.setProperty("color", "#732a8b");
        }
        else if (mode_vars[0] == 2) {
            document.getElementById("2669_randomGoals_text").innerHTML = "Random goals are entirely random.";
            document.getElementById("2669_randomGoals_text").style.setProperty("color", "#ba77d0");
        }
        document.getElementById("2669_firstGoalMinimum").style.setProperty("display", (mode_vars[0] == 0) ? "none" : "block");
        document.getElementById("2669_firstGoalMinimum_change").value = mode_vars[1];
    }
    else if (gamemode == 88) { // FACTUP
        if (mode_vars[0]) {
            document.getElementById("FACTUP_crazy_text").innerHTML = "The result of a merge may have the same amount of factors as its components.";
            document.getElementById("FACTUP_crazy_text").style.setProperty("color", "#3d62c7");
            displayRules("rules_text", ["h1", "FACTUP (Crazy Mode)"], ["p", "Two tiles can merge if their sum has as least as many factors as each of the two tiles themselves. This mode has a lot of possible tiles, so it doesn't have a win condition. If you want a goal to strive for, see how many tiles with different amounts of factors you can make."],
            ["p", "Spawning tiles: 1 (100%)"]);
            displayRules("gm_rules_text", ["h1", "FACTUP (Crazy Mode)"], ["p", "Two tiles can merge if their sum has at least as many factors as each of the two tiles themselves. This mode has a lot of possible tiles, so it doesn't have a win condition. If you want a goal to strive for, see how many tiles with different amounts of factors you can make."],
            ["p", "Spawning tiles: 1 (100%)"]);
        }
        else {
            document.getElementById("FACTUP_crazy_text").innerHTML = "The result of a merge must have more factors than its components.";
            document.getElementById("FACTUP_crazy_text").style.setProperty("color", "#107f33");
            displayRules("rules_text", ["h1", "FACTUP"], ["p", "Two tiles can merge if their sum has more factors than either of the two tiles themselves. This mode has a lot of possible tiles, so it doesn't have a win condition. If you want a goal to strive for, see how many tiles with different amounts of factors you can make."],
            ["p", "Spawning tiles: 1 (100%)"]);
            displayRules("gm_rules_text", ["h1", "FACTUP"], ["p", "Two tiles can merge if their sum has more factors than either of the two tiles themselves. This mode has a lot of possible tiles, so it doesn't have a win condition. If you want a goal to strive for, see how many tiles with different amounts of factors you can make."],
            ["p", "Spawning tiles: 1 (100%)"]);
        }
        if (mode_vars[1] == 0) {
            document.getElementById("FACTUP_randomGoals_text").innerHTML = "Random goals are disabled.";
            document.getElementById("FACTUP_randomGoals_text").style.setProperty("color", "#22002d");
        }
        else if (mode_vars[1] == 1) {
            document.getElementById("FACTUP_randomGoals_text").innerHTML = "Random goals build upon the previous goals.";
            document.getElementById("FACTUP_randomGoals_text").style.setProperty("color", "#732a8b");
        }
        else if (mode_vars[1] == 2) {
            document.getElementById("FACTUP_randomGoals_text").innerHTML = "Each random goal builds upon the previous goal, but not necessarily the ones before.";
            document.getElementById("FACTUP_randomGoals_text").style.setProperty("color", "#a01acd");
        }
        else if (mode_vars[1] == 3) {
            document.getElementById("FACTUP_randomGoals_text").innerHTML = "Random goals are entirely random.";
            document.getElementById("FACTUP_randomGoals_text").style.setProperty("color", "#ba77d0");
        }
        document.getElementById("FACTUP_firstGoalMinimum").style.setProperty("display", (mode_vars[1] == 0) ? "none" : "block");
        document.getElementById("FACTUP_firstGoalMinimum_change").value = mode_vars[2];
    }
    else if (gamemode == 89) { // 2496
        if (mode_vars[0] == 0) {
            document.getElementById("2496_randomGoals_text").innerHTML = "Random goals are disabled.";
            document.getElementById("2496_randomGoals_text").style.setProperty("color", "#22002d");
        }
        else if (mode_vars[0] == 1) {
            document.getElementById("2496_randomGoals_text").innerHTML = "Random goals build upon the previous goals.";
            document.getElementById("2496_randomGoals_text").style.setProperty("color", "#732a8b");
        }
        else if (mode_vars[0] == 2) {
            document.getElementById("2496_randomGoals_text").innerHTML = "Random goals are entirely random.";
            document.getElementById("2496_randomGoals_text").style.setProperty("color", "#ba77d0");
        }
        if (mode_vars[0] == 0) {
            document.getElementById("2496_firstGoalMinimum").style.setProperty("display", "none");
        }
        else {
            document.getElementById("2496_firstGoalMinimum").style.setProperty("display", "block");
            document.getElementById("2496_firstGoalMinimum_counter").innerHTML = mode_vars[1];
            if (mode_vars[1] < 4) document.getElementById("2496_firstGoalMinimum_minus").style.setProperty("display", "none");
            else document.getElementById("2496_firstGoalMinimum_minus").style.setProperty("display", "inline-block");
        }
    }
    else if (gamemode == 91) { // 1845
        if (mode_vars[0] == 0) {
            document.getElementById("1845_randomGoals_text").innerHTML = "Random goals are disabled.";
            document.getElementById("1845_randomGoals_text").style.setProperty("color", "#22002d");
        }
        else if (mode_vars[0] == 1) {
            document.getElementById("1845_randomGoals_text").innerHTML = "Random goals build upon the previous goals.";
            document.getElementById("1845_randomGoals_text").style.setProperty("color", "#732a8b");
        }
        else if (mode_vars[0] == 2) {
            document.getElementById("1845_randomGoals_text").innerHTML = "Random goals are entirely random.";
            document.getElementById("1845_randomGoals_text").style.setProperty("color", "#ba77d0");
        }
        document.getElementById("1845_firstGoalMinimum").style.setProperty("display", (mode_vars[0] == 0) ? "none" : "block");
        document.getElementById("1845_firstGoalMinimum_change").value = mode_vars[1];
    }
    else if (gamemode == 92) { // SCAPRIM
        if (mode_vars[0] == 0) {
            document.getElementById("SCAPRIM_randomGoals_text").innerHTML = "Random goals are disabled.";
            document.getElementById("SCAPRIM_randomGoals_text").style.setProperty("color", "#22002d");
        }
        else if (mode_vars[0] == 1) {
            document.getElementById("SCAPRIM_randomGoals_text").innerHTML = "Random goals are entirely random.";
            document.getElementById("SCAPRIM_randomGoals_text").style.setProperty("color", "#ba77d0");
        }
        document.getElementById("SCAPRIM_firstGoalMinimum").style.setProperty("display", (mode_vars[0] == 0) ? "none" : "block");
        document.getElementById("SCAPRIM_firstGoalMinimum_change").value = mode_vars[1];
    }
    else if (gamemode == 93) { // TRIGAT
        if (mode_vars[0] == 0) {
            document.getElementById("TRIGAT_randomGoals_text").innerHTML = "Random goals are disabled.";
            document.getElementById("TRIGAT_randomGoals_text").style.setProperty("color", "#22002d");
        }
        else if (mode_vars[0] == 1) {
            document.getElementById("TRIGAT_randomGoals_text").innerHTML = "Random goals build upon the previous goals.";
            document.getElementById("TRIGAT_randomGoals_text").style.setProperty("color", "#732a8b");
        }
        else if (mode_vars[0] == 2) {
            document.getElementById("TRIGAT_randomGoals_text").innerHTML = "Each random goal builds upon the previous goal, but not necessarily the ones before.";
            document.getElementById("TRIGAT_randomGoals_text").style.setProperty("color", "#a01acd");
        }
        else if (mode_vars[0] == 3) {
            document.getElementById("TRIGAT_randomGoals_text").innerHTML = "Random goals are entirely random.";
            document.getElementById("TRIGAT_randomGoals_text").style.setProperty("color", "#ba77d0");
        }
        document.getElementById("TRIGAT_firstGoalMinimum").style.setProperty("display", (mode_vars[0] == 0) ? "none" : "block");
        document.getElementById("TRIGAT_firstGoalMinimum_change").value = mode_vars[1];
    }
    else if (gamemode == 96) { // LOCEF
        if (!mode_vars[0]) { // LOCEF
            if (modifiers[13] == "None") {
                MergeRules = [
                    [3, [["@This 0", "=", "@Next 1 0"], "&&", ["@This 0", "modB", "@Next 2 0", "=", 0n]], false, [[["@This 0", "+B", "@Next 1 0", "+B", "@Next 2 0"]]], ["@This 0", "+", "@Next 1 0", "+", "@Next 2 0"], [false, true, true]]
                ];
            }
            else if (modifiers[13] == "Non-Interacting") {
                MergeRules = [
                    [3, [["@This 0", "=", "@Next 1 0"], "&&", [["@This 0", "signB"], "=", ["@Next 2 0", "signB"]], "&&", ["@This 0", "modB", "@Next 2 0", "=", 0n]], false, [[["@This 0", "+B", "@Next 1 0", "+B", "@Next 2 0"]]], ["@This 0", "+", "@Next 1 0", "+", "@Next 2 0", "abs"], [false, true, true]]
                ];
            }
            else if (modifiers[13] == "Interacting") {
                MergeRules = [
                    [2, ["@This 0", "*B", -1n, "=", "@Next 1 0"], true, [], 0, [true, true]],
                    [3, [["@This 0", "=", "@Next 1 0"], "&&", ["@This 0", "modB", "@Next 2 0", "=", 0n]], false, [[["@This 0", "+B", "@Next 1 0", "+B", "@Next 2 0"]]], ["@This 0", "+", "@Next 1 0", "+", "@Next 2 0", "abs"], [false, true, true]]
                ];
            }
            document.documentElement.style.setProperty("background-image", "repeating-linear-gradient( #87ffff, #0000, #0000, #87ffff 35%), linear-gradient(90deg ,#099eab,#4d98cd,#9687c3,#bc7797,#ea603a)");
            document.documentElement.style.setProperty("--background-color", "repeating-linear-gradient(#b4ffff, #0000, #0000, #b4ffff 50%), linear-gradient(90deg , #12bac8, #62a9da, #aa9fca, #c192a8, #ef7959)");
            document.documentElement.style.setProperty("--grid-color", "#7de7e7");
            displayRules("rules_text", ["h1", "LOCEF"], ["p", "Three tiles can merge if two of them are equal and the third tile is a factor of the other two. This mode has a lot of possible tiles, so it doesn't have a win condition. If you want some goals to strive for, then here are some handpicked ones, from (hopefully) easiest to hardest: 2047, 2259, 2847, 2127, 2229, 1699, 2635. Alternatively, turn on random goals and aim for whatever goal it gives you!"],
            ["p", "Spawning tiles: 1 (100%)"]);
            displayRules("gm_rules_text", ["h1", "LOCEF"], ["p", "Three tiles can merge if two of them are equal and the third tile is a factor of the other two. This mode has a lot of possible tiles, so it doesn't have a win condition. If you want some goals to strive for, then here are some handpicked ones, from (hopefully) easiest to hardest: 2047, 2259, 2847, 2127, 2229, 1699, 2635. Alternatively, turn on random goals and aim for whatever goal it gives you!"],
            ["p", "Spawning tiles: 1 (100%)"]);
            document.getElementById("LOCEF_Extended_text").innerHTML = "The larger two tiles must be equal.";
            document.getElementById("LOCEF_Extended_text").style.setProperty("color", "#00bcbc");
        }
        else if (mode_vars[0]) { // Extended LOCEF
            if (modifiers[13] == "None") {
                MergeRules = [
                    [3, ["@This 0", "lcmB", "@Next 1 0", "=", "@Next 2 0"], false, [[["@This 0", "+B", "@Next 1 0", "+B", "@Next 2 0"]]], ["@This 0", "+", "@Next 1 0", "+", "@Next 2 0"], [false, true, true]]
                ];
            }
            else if (modifiers[13] == "Non-Interacting") {
                MergeRules = [
                    [3, [[["@This 0", "signB"], "=", ["@Next 1 0", "signB"]], "&&", [["@This 0", "signB"], "=", ["@Next 2 0", "signB"]], "&&", [["@This 0", "lcmB", "@Next 1 0", "absB"], "=", ["@Next 2 0", "absB"]]], false, [[["@This 0", "+B", "@Next 1 0", "+B", "@Next 2 0"]]], ["@This 0", "+", "@Next 1 0", "+", "@Next 2 0", "abs"], [false, true, true]]
                ];
            }
            else if (modifiers[13] == "Interacting") {
                MergeRules = [
                    [2, ["@This 0", "*B", -1n, "=", "@Next 1 0"], true, [], 0, [true, true]],
                    [3, [["@This 0", "lcmB", "@Next 1 0", "absB"], "=", ["@Next 2 0", "absB"]], false, [[["@This 0", "+B", "@Next 1 0", "+B", "@Next 2 0"]]], ["@This 0", "+", "@Next 1 0", "+", "@Next 2 0", "abs"], [false, true, true]]
                ];
            }
            document.documentElement.style.setProperty("background-image", "repeating-linear-gradient( #ff87ff, #0000, #0000, #ff87ff 35%), linear-gradient(90deg ,#099eab,#4d98cd,#9687c3,#bc7797,#ea603a)");
            document.documentElement.style.setProperty("--background-color", "repeating-linear-gradient( #ffb4ff, #0000, #0000, #ffb4ff 50%), linear-gradient(90deg , #12bac8, #62a9da, #aa9fca, #c192a8, #ef7959)");
            document.documentElement.style.setProperty("--grid-color", "#e77de7");
            displayRules("rules_text", ["h1", "Extended LOCEF"], ["p", "Three tiles can merge if one of the tiles is the least common multiple of the other two tiles. This mode has a lot of possible tiles, so it doesn't have a win condition. If you want some goals to strive for, then here are some handpicked ones, from (hopefully) easiest to hardest: 2047, 2259, 2847, 2127, 2229, 1699, 2635. Alternatively, turn on random goals and aim for whatever goal it gives you!"],
            ["p", "Spawning tiles: 1 (100%)"]);
            displayRules("gm_rules_text", ["h1", "Extended LOCEF"], ["p", "Three tiles can merge if one of the tiles is the least common multiple of the other two tiles. This mode has a lot of possible tiles, so it doesn't have a win condition. If you want some goals to strive for, then here are some handpicked ones, from (hopefully) easiest to hardest: 2047, 2259, 2847, 2127, 2229, 1699, 2635. Alternatively, turn on random goals and aim for whatever goal it gives you!"],
            ["p", "Spawning tiles: 1 (100%)"]);
            document.getElementById("LOCEF_Extended_text").innerHTML = "The larger two tiles may be different.";
            document.getElementById("LOCEF_Extended_text").style.setProperty("color", "#bc00bc");
        }
        if (mode_vars[1] == 0) {
            document.getElementById("LOCEF_randomGoals_text").innerHTML = "Random goals are disabled.";
            document.getElementById("LOCEF_randomGoals_text").style.setProperty("color", "#22002d");
        }
        else if (mode_vars[1] == 1) {
            document.getElementById("LOCEF_randomGoals_text").innerHTML = "Random goals build upon the previous goals.";
            document.getElementById("LOCEF_randomGoals_text").style.setProperty("color", "#732a8b");
        }
        else if (mode_vars[1] == 2) {
            document.getElementById("LOCEF_randomGoals_text").innerHTML = "Each random goal builds upon the previous goal, but not necessarily the ones before.";
            document.getElementById("LOCEF_randomGoals_text").style.setProperty("color", "#a01acd");
        }
        else if (mode_vars[1] == 3) {
            document.getElementById("LOCEF_randomGoals_text").innerHTML = "Random goals are entirely random.";
            document.getElementById("LOCEF_randomGoals_text").style.setProperty("color", "#ba77d0");
        }
        document.getElementById("LOCEF_firstGoalMinimum").style.setProperty("display", (mode_vars[1] == 0) ? "none" : "block");
        document.getElementById("LOCEF_firstGoalMinimum_change").value = mode_vars[2];
    }
    else if (gamemode == 99) { // Four-Sides 625
        // Rules and Goals
        winRequirement = 1;
        let directionAmount = 4;
        if (modifiers[5] == "Square" || modifiers[5] == "Checkerboard" || modifiers[5] == "Diamond") {
            if (modifiers[10] == "Both") directionAmount = 8;
            else directionAmount = 4;
        }
        else if (modifiers[5] == "Hexagon" || modifiers[5] == "HexaTriangle") {
            if (modifiers[10] == "Both") directionAmount = 12;
            else directionAmount = 6;
        }
        else if (modifiers[5] == "4D") {
            directionAmount = 4;
            if (modifiers[8] > 1) directionAmount += 2;
            if (modifiers[9] > 1) directionAmount += 2;
        }
        else if (modifiers[5] == "Custom") {
            directionAmount = 0;
            for (let d of directions) {
                if (d[0][0] != 0 || d[0][1] != 0) directionAmount++;
            }
        }
        directionAmount += 1;
        let numberNames = ["Zero", "One", "Two", "Three", "Four", "Five", "Six", "Seven", "Eight", "Nine", "Ten", "Eleven", "Twelve", "Thirteen", "Fourteen", "Fifteen", "Sixteen", "Seventeen", "Eighteen", "Nineteen", "Twenty"];
        let goalPow = 0;
        if (directionAmount >= 1000) goalPow = 1;
        else if (directionAmount > 1) while (directionAmount**(goalPow + 1) < 1000) goalPow++;
        winConditions = [[["@This 0", "=", goalPow]]];
        mergeResultKnownLevel = 0; // Directional merges doesn't work with known merge results
        let rulesTitle = ((directionAmount <= 20) ? numberNames[directionAmount - 1] : (directionAmount - 1)) + "-Sides " + (directionAmount**goalPow);
        let baseString = (directionAmount <= 20) ? numberNames[directionAmount].toLowerCase() : String(directionAmount)
        let rulesDescription = "A larger tile merges with a smaller or equal tile that's equal to the largest power of " + baseString + " that's not larger than the larger tile. However, said larger tile must be merged into in a different direction each time to get from one power of " + baseString + " to the next, once for each movement direction. Get to the " + (directionAmount**goalPow) + " tile to win!" 
        displayRules("rules_text", ["h1", rulesTitle], ["p", rulesDescription], ["p", "Spawning tiles: 1 (100%)"]);
        displayRules("gm_rules_text", ["h1", rulesTitle], ["p", rulesDescription], ["p", "Spawning tiles: 1 (100%)"]);
    }
    else if (gamemode == 100) { // Alternate 5040
        winRequirement = 1;
        let goalPow = 0n;
        start_game_vars = [];
        if (mode_vars[1] === true) {
            document.getElementById("Alternate5040_baseFactorials").style.setProperty("display", "block");
            document.getElementById("Alternate5040_base").style.setProperty("display", "none");
            document.getElementById("Alternate5040_baseRational").style.setProperty("display", "none");
            startTileSpawns = [[[1n, 1n], 1]];
            TileTypes = [
                [[1n, 1n], 1, "#ffffff", "#393900"],
                [true, ["@This 0", "factorial", "*", "@This 1"], ["@radial-gradient", ["@HSLA", ["@This 0", "*", 49, "+", 77], 100, [0.86, "^", ["@This 0", "-", 1], "*", 90, "+", 10], 1], 0, 60, ["@HSLA", ["@This 1", "log", ["@This 0", "+", 1], "*", 360], 100, [40, "@if", ["@This 0", ">", 6], "2nd", 60, "@end-if"], 1], 100], ["#393900", "@if", ["@This 0", ">", 6], "2nd", "#ffffd3", "@end-if"]]
            ]
            winConditions = [[7n, 1n]];
        }
        else if (mode_vars[1] instanceof BigRational) {
            document.getElementById("Alternate5040_baseFactorials").style.setProperty("display", "none");
            document.getElementById("Alternate5040_base").style.setProperty("display", "none");
            document.getElementById("Alternate5040_baseRational").style.setProperty("display", "block");
            document.getElementById("Alternate5040_baseRational_numerator_change").value = mode_vars[1].numerator;
            document.getElementById("Alternate5040_baseRational_denominator_change").value = mode_vars[1].denominator;
            startTileSpawns = [[[0n, new BigRational(1n)], 1]];
            TileTypes = [
                [["@This 0", ">=", 0n], [mode_vars[1], "^BR", "@This 0", "*BR", "@This 1"], ["@radial-gradient", ["@HSLA", ["@This 0", "*", 49, "+", (Number(mode_vars[1]) - 2) * 222.49223595], 100, [0.925, "^", ["@This 0", "*", Math.log2(Number(mode_vars[1]))], "*", 90, "+", 10], 1], 0, 60, ["@HSLA", ["@This 1", "log", mode_vars[1], "*", 360], 100, [40, "@if", [mode_vars[1], "^BR", "@This 0", ">=", 512n], "2nd", 60, "@end-if"], 1], 100], ["#393900", "@if", [mode_vars[1], "^BR", "@This 0", ">=", 512n], "2nd", "#ffffd3", "@end-if"]],
                [["@This 0", "<", 0n], [mode_vars[1], "^BR", "@This 0", "*BR", "@This 1"], ["@radial-gradient", ["@HSLA", ["@This 0", "*", 49, "+", (Number(mode_vars[1]) - 2) * 222.49223595], 50, [0.925, "^", ["@This 0", "*", Math.log2(Number(mode_vars[1])), "abs"], "*", 75, "+", 10], 1], 0, 60, ["@HSLA", ["@This 1", "log", mode_vars[1], "*", 360], 100, [40, "@if", [mode_vars[1], "^BR", "@This 0", "<=", 1/512], "2nd", 60, "@end-if"], 1], 100], ["#393900", "@if", [mode_vars[1], "^BR", "@This 0", "<=", 1/512], "2nd", "#ffffd3", "@end-if"]]
            ];
            if (mode_vars[1] < 4n) goalPow = BigInt(Math.round(11 / Math.log2(Number(mode_vars[1]))));
            else if (mode_vars[1] < 6n) goalPow = 5n;
            else if (mode_vars[1] < 10n) goalPow = 4n;
            else if (mode_vars[1] < 22n) goalPow = 3n;
            else if (mode_vars[1] < 256n) goalPow = 2n;
            else goalPow = 1n;
            winConditions = [[goalPow, new BigRational(1n)]];
        }
        else {
            document.getElementById("Alternate5040_baseFactorials").style.setProperty("display", "none");
            document.getElementById("Alternate5040_base").style.setProperty("display", "block");
            document.getElementById("Alternate5040_baseRational").style.setProperty("display", "none");
            document.getElementById("Alternate5040_base_change").value = mode_vars[1];
            startTileSpawns = [[[0n, 1n], 1]];
            TileTypes = [
                [true, [mode_vars[1], "^", "@This 0", "*", "@This 1"], ["@radial-gradient", ["@HSLA", ["@This 0", "*", 49, "+", (Number(mode_vars[1]) - 2) * 222.49223595], 100, [0.925, "^", ["@This 0", "*", Math.log2(Number(mode_vars[1]))], "*", 90, "+", 10], 1], 0, 60, ["@HSLA", ["@This 1", "log", mode_vars[1], "*", 360], 100, [40, "@if", [mode_vars[1], "^B", "@This 0", "*B", "@This 1", ">=", 512n], "2nd", 60, "@end-if"], 1], 100], ["#393900", "@if", [mode_vars[1], "^B", "@This 0", ">=", 512n], "2nd", "#ffffd3", "@end-if"]]
            ]
            if (mode_vars[1] < 3n) goalPow = 11n;
            else if (mode_vars[1] < 4n) goalPow = 7n;
            else if (mode_vars[1] < 6n) goalPow = 5n;
            else if (mode_vars[1] < 10n) goalPow = 4n;
            else if (mode_vars[1] < 22n) goalPow = 3n;
            else if (mode_vars[1] < 256n) goalPow = 2n;
            else goalPow = 1n;
            winConditions = [[goalPow, 1n]];
        }
        if (mode_vars[0] == 0) { // 1762 variant
            document.getElementById("Alternate5040_variant_text").innerHTML = "The merge rules are based on paths to tiles in 1762.";
            document.getElementById("Alternate5040_variant_text").style.setProperty("color", "#77a00d");
            document.documentElement.style.setProperty("background-image", "repeating-conic-gradient(from -45deg, #0000, #0000, #afe726, #0000, #0000 90deg), repeating-conic-gradient(#c5c500 0deg, #ffffa1 45deg, #c5c500 90deg)");
            document.documentElement.style.setProperty("--background-color", "repeating-conic-gradient(from -45deg, #0000, #0000, #afe726, #0000, #0000 90deg), repeating-conic-gradient(#c5c500 0deg,#eeee65 45deg,#8f8f00 90deg)");
            if (mode_vars[1] === true) {
                MergeRules = [
                    [2, [["@This 0", "=", "@Next 1 0"], "&&", ["@This 1", "-B", "@Next 1 1", "absB", "<", 2n], "&&", ["@This 1", "+B", "@Next 1 1", "=", ["@This 0", "+B", 1n]]], true, [[["@This 0", "+B", 1n], 1n]], ["@This 0", "+", 1, "factorial"], [false, true]],
                    [2, [["@This 0", "=", "@Next 1 0"], "&&", ["@This 1", "-B", "@Next 1 1", "absB", "<", 2n], "&&", ["@This 1", "+B", "@Next 1 1", "<", ["@This 0", "+B", 1n]], "&&", [[2n, "^B", ["@This 0", "+B", 1n, "/", ["@This 1", "+", "@Next 1 1"], "log", 2, "round", 1, "max", 0]], "@end_vars", "@This 0", "+B", 1n, "-B", ["@var_retain", "@This 1", "+B", "@Next 1 1", "*B", "@Var 0"], "absB", "<", "@Var 0"]], true, [["@This 0", ["@This 1", "+B", "@Next 1 1"]]], ["@This 0", "factorial", "*", ["@This 1", "+", "@Next 1 1"]], [false, true]]
                ];
                displayRules("rules_text", ["h1", "Alternate 5040 (1762 Variant)"], ["p", "Two tiles can merge if they are equal or they are consecutive multiples of n! that are smaller than (n + 1)!, and their sum is less than n! away from (n + 1)! divided by some nonnegative integer power of two. (In other words, to get from n! to (n + 1)!, pretend n! is 1 and follow the path to get from 1 to (n + 1) in 1762.) Get to the 5040 tile to win!"],
                ["p", "Spawning tiles: 1 (100%)"]);
                displayRules("gm_rules_text", ["h1", "Alternate 5040 (1762 Variant)"], ["p", "Two tiles can merge if they are equal or they are consecutive multiples of n! that are smaller than (n + 1)!, and their sum is less than n! away from (n + 1)! divided by some nonnegative integer power of two. (In other words, to get from n! to (n + 1)!, pretend n! is 1 and follow the path to get from 1 to (n + 1) in 1762.) Get to the 5040 tile to win!"],
                ["p", "Spawning tiles: 1 (100%)"]);
            }
            else {
                MergeRules = [
                    [2, [["@This 0", "=", "@Next 1 0"], "&&", ["@This 1", "-B", "@Next 1 1", "absB", "<", 2n], "&&", ["@This 1", "+B", "@Next 1 1", "=", mode_vars[1]]], true, [[["@This 0", "+B", 1n], 1n]], [mode_vars[1], "^", ["@This 0", "+", 1]], [false, true]],
                    [2, [["@This 0", "=", "@Next 1 0"], "&&", ["@This 1", "-B", "@Next 1 1", "absB", "<", 2n], "&&", ["@This 1", "+B", "@Next 1 1", "<", mode_vars[1]], "&&", [[2n, "^B", [mode_vars[1], "/", ["@This 1", "+", "@Next 1 1"], "log", 2, "round", 1, "max", 0]], "@end_vars", mode_vars[1], "-B", ["@var_retain", "@This 1", "+B", "@Next 1 1", "*B", "@Var 0"], "absB", "<", "@Var 0"]], true, [["@This 0", ["@This 1", "+B", "@Next 1 1"]]], [mode_vars[1], "^", "@This 0", "*", ["@This 1", "+", "@Next 1 1"]], [false, true]]
                ];
                let rulesTitle = mode_vars[1]**goalPow + " (Alternate 5040, 1762 Variant)";
                let rulesDescription = "Two tiles can merge if they are equal or they are consecutive multiples of " + mode_vars[1] + "<sup>n</sup> that are smaller than " + mode_vars[1] + "<sup>n + 1</sup>, and their sum is less than " + mode_vars[1] + "<sup>n</sup> away from " + mode_vars[1] + "<sup>n + 1</sup> divided by some nonnegative integer power of two. (In other words, to get from one power of " + mode_vars[1] + " to the next, pretend " + mode_vars[1] + "<sup>n</sup> is 1 and follow the path to get from 1 to " + mode_vars[1] + " in 1762.) Get to the " + mode_vars[1]**goalPow + " tile to win!"
                displayRules("rules_text", ["h1", rulesTitle], ["p", rulesDescription], ["p", "Spawning tiles: 1 (100%)"]);
                displayRules("gm_rules_text", ["h1", rulesTitle], ["p", rulesDescription], ["p", "Spawning tiles: 1 (100%)"]);
            }
            knownMergeMaxLength = 2;
            knownMergeLookbackDistance = 0;
        }
        else if (mode_vars[0] == 1) { // 2047 variant
            document.getElementById("Alternate5040_variant_text").innerHTML = "The merge rules are based on binary digits and 2047.";
            document.getElementById("Alternate5040_variant_text").style.setProperty("color", "#912ad5");
            document.documentElement.style.setProperty("background-image", "repeating-conic-gradient(from -45deg, #0000, #0000, #9900ff, #0000, #0000 90deg), repeating-conic-gradient(#c5c500 0deg, #ffffa1 45deg, #c5c500 90deg)");
            document.documentElement.style.setProperty("--background-color", "repeating-conic-gradient(from -45deg, #0000, #0000, #9900ff, #0000, #0000 90deg), repeating-conic-gradient(#c5c500 0deg,#eeee65 45deg,#8f8f00 90deg)");
            if (mode_vars[1] === true) {
                MergeRules = [
                    [3, [["@This 0", "=", "@Next 1 0"], "&&", ["@This 1", "=", "@Next 1 1"], "&&", ["@This 0", "=", "@Next 2 0"], "&&", ["@Next 2 1", "=", 1n], "&&", ["@This 1", "*B", 2n, "+B", 1n, "=", ["@This 0", "+B", 1n]]], false, [[["@This 0", "+B", 1n], 1n]], ["@This 0", "+", 1, "factorial"], [false, true, true]],
                    [2, [["@This 0", "=", "@Next 1 0"], "&&", ["@This 1", "=", "@Next 1 1"], "&&", ["@This 1", "*B", 2n, "=", ["@This 0", "+B", 1n]]], false, [[["@This 0", "+B", 1n], 1n]], ["@This 0", "+", 1, "factorial"], [false, true]],
                    [3, [["@This 0", "=", "@Next 1 0"], "&&", ["@This 1", "=", "@Next 1 1"], "&&", ["@This 0", "=", "@Next 2 0"], "&&", ["@Next 2 1", "=", 1n], "&&", ["@This 1", "*B", 2n, "+B", 1n, "*B", [2n, "^B", [["@This 0", "+B", 1n, "logB", 2n], "-B", ["@This 1", "logB", 2n], "-B", 1n]], "<=", ["@This 0", "+B", 1n]]], false, [["@This 0", ["@This 1", "+B", "@Next 1 1", "+B", 1n]]], ["@This 0", "factorial", "*", ["@This 1", "+", "@Next 1 1", "+", 1]], [false, true, true]],
                    [2, [["@This 0", "=", "@Next 1 0"], "&&", ["@This 1", "=", "@Next 1 1"], "&&", ["@This 1", "*B", 2n, "+B", 1n, "*B", [2n, "^B", [["@This 0", "+B", 1n, "logB", 2n], "-B", ["@This 1", "logB", 2n], "-B", 1n]], ">", ["@This 0", "+B", 1n]]], false, [["@This 0", ["@This 1", "+B", "@Next 1 1"]]], ["@This 0", "factorial", "*", ["@This 1", "+", "@Next 1 1"]], [false, true]]
                ];
                displayRules("rules_text", ["h1", "Alternate 5040 (2047 Variant)"], ["p", "Merges occur between two equal tiles that are multiples of n! but smaller than (n + 1)!, potentially including an n! as a third tile. Whether or not that third tile must be included depends on the binary digits of (n + 1). Get to the 5040 tile to win!"],
                ["p", "Spawning tiles: 1 (100%)"]);
                displayRules("gm_rules_text", ["h1", "Alternate 5040 (2047 Variant)"], ["p", "Merges occur between two equal tiles that are multiples of n! but smaller than (n + 1)!, potentially including an n! as a third tile. Whether or not that third tile must be included depends on the binary digits of (n + 1). Get to the 5040 tile to win!"],
                ["p", "Spawning tiles: 1 (100%)"]);
            }
            else {
                MergeRules = [
                    [3, [["@This 0", "=", "@Next 1 0"], "&&", ["@This 1", "=", "@Next 1 1"], "&&", ["@This 0", "=", "@Next 2 0"], "&&", ["@Next 2 1", "=", 1n], "&&", ["@This 1", "*B", 2n, "+B", 1n, "=", mode_vars[1]]], false, [[["@This 0", "+B", 1n], 1n]], [mode_vars[1], "^", ["@This 0", "+", 1]], [false, true, true]],
                    [2, [["@This 0", "=", "@Next 1 0"], "&&", ["@This 1", "=", "@Next 1 1"], "&&", ["@This 1", "*B", 2n, "=", mode_vars[1]]], false, [[["@This 0", "+B", 1n], 1n]], [mode_vars[1], "^", ["@This 0", "+", 1]], [false, true]],
                    [3, [["@This 0", "=", "@Next 1 0"], "&&", ["@This 1", "=", "@Next 1 1"], "&&", ["@This 0", "=", "@Next 2 0"], "&&", ["@Next 2 1", "=", 1n], "&&", ["@This 1", "*B", 2n, "+B", 1n, "*B", [2n, "^B", [[mode_vars[1], "logB", 2n], "-B", ["@This 1", "logB", 2n], "-B", 1n]], "<=", mode_vars[1]]], false, [["@This 0", ["@This 1", "+B", "@Next 1 1", "+B", 1n]]], [mode_vars[1], "^", "@This 0", "*", ["@This 1", "+", "@Next 1 1", "+", 1]], [false, true, true]],
                    [2, [["@This 0", "=", "@Next 1 0"], "&&", ["@This 1", "=", "@Next 1 1"], "&&", ["@This 1", "*B", 2n, "+B", 1n, "*B", [2n, "^B", [[mode_vars[1], "logB", 2n], "-B", ["@This 1", "logB", 2n], "-B", 1n]], ">", mode_vars[1]]], false, [["@This 0", ["@This 1", "+B", "@Next 1 1"]]], [mode_vars[1], "^", "@This 0", "*", ["@This 1", "+", "@Next 1 1"]], [false, true]]
                ];
                let rulesTitle = mode_vars[1]**goalPow + " (Alternate 5040, 2047 Variant)";
                let rulesDescription = "Merges occur between two equal tiles that are multiples of " + mode_vars[1] + "<sup>n</sup> but smaller than " + mode_vars[1] + "<sup>n + 1</sup>, potentially including a " + mode_vars[1] + "<sup>n</sup> as a third tile. Whether or not that third tile must be included depends on the binary digits of " + mode_vars[1] + ". Get to the " + mode_vars[1]**goalPow + " tile to win!"
                displayRules("rules_text", ["h1", rulesTitle], ["p", rulesDescription], ["p", "Spawning tiles: 1 (100%)"]);
                displayRules("gm_rules_text", ["h1", rulesTitle], ["p", rulesDescription], ["p", "Spawning tiles: 1 (100%)"]);
            }
            knownMergeMaxLength = 3;
            knownMergeLookbackDistance = 0;
        }
        else if (mode_vars[0] == 2) { // 1668 variant
            document.getElementById("Alternate5040_variant_text").innerHTML = "The merge rules are based on paths to tiles in 1668.";
            document.getElementById("Alternate5040_variant_text").style.setProperty("color", "#c65344");
            document.documentElement.style.setProperty("background-image", "repeating-conic-gradient(from -45deg, #0000, #0000, #f36fae, #0000, #0000 90deg), repeating-conic-gradient(#c5c500 0deg, #ffffa1 45deg, #c5c500 90deg)");
            document.documentElement.style.setProperty("--background-color", "repeating-conic-gradient(from -45deg, #0000, #0000, #f36fae, #0000, #0000 90deg), repeating-conic-gradient(#c5c500 0deg,#eeee65 45deg,#8f8f00 90deg)");
            if (mode_vars[1] === true) {
                MergeRules = [
                    [3, [["@This 0", "=", "@Next 1 0"], "&&", ["@This 0", "=", "@Next 2 0"], "&&", ["@This 1", "=", "@Next 1 1"], "&&", ["@This 1", "-B", "@Next 2 1", "absB", "<", 2n], "&&", ["@This 1", "+B", "@Next 1 1", "+B", "@Next 2 1", "=", ["@This 0", "+B", 1n]]], false, [[["@This 0", "+B", 1n], 1n]], ["@This 0", "+", 1, "factorial"], [false, true, true]],
                    [3, [["@This 0", "=", "@Next 1 0"], "&&", ["@This 0", "=", "@Next 2 0"], "&&", ["@This 1", "=", "@Next 1 1"], "&&", ["@This 1", "-B", "@Next 2 1", "absB", "<", 2n], "&&", ["@This 1", "+B", "@Next 1 1", "+B", "@Next 2 1", "<", ["@This 0", "+B", 1n]], "&&", [[3n, "^B", ["@This 0", "+B", 1n, "/", ["@This 1", "+", "@Next 1 1", "+", "@Next 2 1"], "log", 3, "round", 1, "max", 0]], "@end_vars", "@This 0", "+B", 1n, "-B", ["@var_retain", "@This 1", "+B", "@Next 1 1", "+B", "@Next 2 1", "*B", "@Var 0"], "absB", "<", "@Var 0"]], false, [["@This 0", ["@This 1", "+B", "@Next 1 1", "+B", "@Next 2 1"]]], ["@This 0", "factorial", "*", ["@This 1", "+", "@Next 1 1", "+", "@Next 2 1"]], [false, true, true]],
                    [2, [["@This 0", "=", 1n], "&&", ["@This 1", "=", 1n], "&&", ["@Next 1 0", "=", 1n], "&&", ["@Next 1 1", "=", 1n]], true, [[2n, 1n]], 2, [false, true]],
                    [2, [["@This 0", "=", "@Next 1 0"], "&&", ["@This 1", "=", 1n], "&&", ["@Next 1 1", "=", 1n], "&&", ["@This 0", "+B", 1n, "/B", [3n, "^B", ["@This 0", "+B", 1n, "expomodB", 3n]], "!=", 1n], "&&", [["@NextNE -1 0", "!=", "@This 0"], "||", ["@NextNE -1 1", "!=", 1n], "||", [[3n, "^B", ["@This 0", "+B", 1n, "*B", 2n, "logB", 3n, "-B", 1n, "max", 0n]], "@end_vars", "@This 0", "+B", 1n, "-B", ["@var_retain", "@Var 0", "*B", 3n], "absB", ">=", "@Var 0"]], "&&", [["@NextNE -1 0", "!=", "@This 0"], "||", ["@NextNE -1 1", "!=", 2n], "||", [[3n, "^B", ["@This 0", "+B", 1n, "logB", 3n, "-B", 1n, "max", 0n]], "@end_vars", "@This 0", "+B", 1n, "-B", ["@var_retain", "@Var 0", "*B", 4n], "absB", ">=", "@Var 0"]]], true, [["@This 0", ["@This 1", "+B", "@Next 1 1"]]], ["@This 0", "factorial", "*", ["@This 1", "+", "@Next 1 1"]], [false, true]]
                ];
                displayRules("rules_text", ["h1", "Alternate 5040 (1668 Variant)"], ["p", "Two equal tiles that are an n! can merge unless (n + 1) is a power of three, and three tiles that are multiples of n! and less than (n + 1)! can merge if two of them are equal and the third one is equal to the other two or exactly n! away from the other two, and their sum is less than n! away from (n + 1)! divided by some nonnegative integer power of three. (In other words, to get from n! to (n + 1)!, pretend n! is 1 and follow the path to get from 1 to (n + 1) in 1668.) Get to the 5040 tile to win!"],
                ["p", "Spawning tiles: 1 (100%)"]);
                displayRules("gm_rules_text", ["h1", "Alternate 5040 (1668 Variant)"], ["p", "Two equal tiles that are an n! can merge unless (n + 1) is a power of three, and three tiles that are multiples of n! and less than (n + 1)! can merge if two of them are equal and the third one is equal to the other two or exactly n! away from the other two, and their sum is less than n! away from (n + 1)! divided by some nonnegative integer power of three. (In other words, to get from n! to (n + 1)!, pretend n! is 1 and follow the path to get from 1 to (n + 1) in 1668.) Get to the 5040 tile to win!"],
                ["p", "Spawning tiles: 1 (100%)"]);
            }
            else {
                if (mode_vars[1] == 2n) { // 1+1=2 is a special case so I have to give this one a special exception this time
                    MergeRules = [
                        [2, [["@This 0", "=", "@This 1"], "&&", ["@Next 1 0", "=", 1n], "&&", ["@Next 1 1", "=", 1n]], true, [[["@This 0", "+B", 1n], 1n]], [2n, "^", ["@This 0", "+", 1]], [false, true]]
                    ];
                }
                else {
                    MergeRules = [
                        [3, [["@This 0", "=", "@Next 1 0"], "&&", ["@This 0", "=", "@Next 2 0"], "&&", ["@This 1", "=", "@Next 1 1"], "&&", ["@This 1", "-B", "@Next 2 1", "absB", "<", 2n], "&&", ["@This 1", "+B", "@Next 1 1", "+B", "@Next 2 1", "=", mode_vars[1]]], false, [[["@This 0", "+B", 1n], 1n]], [mode_vars[1], "^", ["@This 0", "+", 1]], [false, true, true]],
                        [3, [["@This 0", "=", "@Next 1 0"], "&&", ["@This 0", "=", "@Next 2 0"], "&&", ["@This 1", "=", "@Next 1 1"], "&&", ["@This 1", "-B", "@Next 2 1", "absB", "<", 2n], "&&", ["@This 1", "+B", "@Next 1 1", "+B", "@Next 2 1", "<", mode_vars[1]], "&&", [[3n, "^B", [mode_vars[1], "/", ["@This 1", "+", "@Next 1 1", "+", "@Next 2 1"], "log", 3, "round", 1, "max", 0]], "@end_vars", mode_vars[1], "-B", ["@var_retain", "@This 1", "+B", "@Next 1 1", "+B", "@Next 2 1", "*B", "@Var 0"], "absB", "<", "@Var 0"]], false, [["@This 0", ["@This 1", "+B", "@Next 1 1", "+B", "@Next 2 1"]]], [mode_vars[1], "^", "@This 0", "*", ["@This 1", "+", "@Next 1 1", "+", "@Next 2 1"]], [false, true, true]],
                        [2, [["@This 0", "=", "@Next 1 0"], "&&", ["@This 1", "=", 1n], "&&", ["@Next 1 1", "=", 1n], "&&", [mode_vars[1], "/B", [3n, "^B", [mode_vars[1], "expomodB", 3n]], "!=", 1n], "&&", [["@NextNE -1 0", "!=", "@This 0"], "||", ["@NextNE -1 1", "!=", 1n], "||", [[3n, "^B", [mode_vars[1], "*B", 2n, "logB", 3n, "-B", 1n, "max", 0n]], "@end_vars", mode_vars[1], "-B", ["@var_retain", "@Var 0", "*B", 3n], "absB", ">=", "@Var 0"]], "&&", [["@NextNE -1 0", "!=", "@This 0"], "||", ["@NextNE -1 1", "!=", 2n], "||", [[3n, "^B", [mode_vars[1], "logB", 3n, "-B", 1n, "max", 0n]], "@end_vars", mode_vars[1], "-B", ["@var_retain", "@Var 0", "*B", 4n], "absB", ">=", "@Var 0"]]], true, [["@This 0", ["@This 1", "+B", "@Next 1 1"]]], [mode_vars[1], "^", "@This 0", "*", ["@This 1", "+", "@Next 1 1", "+"]], [false, true]]
                    ];
                }
                let rulesTitle = mode_vars[1]**goalPow + " (Alternate 5040, 1668 Variant)";
                let rulesDescription = "Two equal tiles that are a power of " + mode_vars[1] + " can merge if " + mode_vars[1] + " is not a power of 3, and three tiles that are multiples of " + mode_vars[1] + "<sup>n</sup> and less than " + mode_vars[1] + "<sup>n + 1</sup> can merge if two of them are equal and the third one is equal to the other two or exactly " + mode_vars[1] + "<sup>n</sup> away from the other two, and their sum is less than " + mode_vars[1] + "<sup>n</sup> away from " + mode_vars[1] + "<sup>n + 1</sup> divided by some nonnegative integer power of three. (In other words, to get from one power of " + mode_vars[1] + " to the next, pretend " + mode_vars[1] + "<sup>n</sup> is 1 and follow the path to get from 1 to " + mode_vars[1] + " in 1668.) Get to the " + mode_vars[1]**goalPow + " tile to win!"
                displayRules("rules_text", ["h1", rulesTitle], ["p", rulesDescription], ["p", "Spawning tiles: 1 (100%)"]);
                displayRules("gm_rules_text", ["h1", rulesTitle], ["p", rulesDescription], ["p", "Spawning tiles: 1 (100%)"]);
            }
            knownMergeMaxLength = 3;
            knownMergeLookbackDistance = 1;
        }
        else if (mode_vars[0] == 3) { // 3069 variant
            start_game_vars = [[[1n], [1n, 2n], [1n, 2n, 3n], [1n, 2n, 4n], [1n, 2n, 3n, 5n], [1n, 2n, 3n, 4n, 6n], [1n, 2n, 3n, 5n, 7n]], 7n]; // List of valid tiles per factorial level
            document.getElementById("Alternate5040_variant_text").innerHTML = "The merge rules are based on paths to tiles in 3069.";
            document.getElementById("Alternate5040_variant_text").style.setProperty("color", "#043c5d");
            document.documentElement.style.setProperty("background-image", "repeating-conic-gradient(from -45deg, #0000, #0000, #0b798f, #0000, #0000 90deg), repeating-conic-gradient(#c5c500 0deg, #ffffa1 45deg, #c5c500 90deg)");
            document.documentElement.style.setProperty("--background-color", "repeating-conic-gradient(from -45deg, #0000, #0000, #0b798f, #0000, #0000 90deg), repeating-conic-gradient(#c5c500 0deg,#eeee65 45deg,#8f8f00 90deg)");
            // Doing the merge rules by hand for this one proved to be laggy, so instead we'll make an array of the valid tiles to reference later
            if (mode_vars[1] === true) {
                MergeRules = [
                    [3, ["@global_var_retain_inner", ["@This 1", "typeof", "=", "bigint"], "&&", ["@Next 1 1", "typeof", "=", "bigint"], "&&", ["@Next 2 1", "typeof", "=", "bigint"], "&&", ["@This 0", "=", "@Next 1 0"], "&&", ["@This 0", "=", "@Next 2 0"], "@add_var", [["@This 1", "+B", "@Next 1 1", "+B", "@Next 2 1"], "/BR", "@This 1"], "&&", ["@Var 0", "numeratorBR", "primeFactorizeB", 2, "arr_length", "=", 1], "&&", [["@Var 0", "=", new BigRational(2n)], "||", [["@Var 0", "numeratorBR", ">", 2n], "@primesUpdate", ["@Var 0", "numeratorBR"], "&&", [["@Primes", "arr_indexOf", ["@Var 0", "numeratorBR"]], "-", ["@Primes", "arr_indexOf", ["@Var 0", "denominatorBR"]], "=", 1]]], "&&", ["@GVar 0", "arr_elem", "@This 0", "arr_indexOf", ["@This 1", "+B", "@Next 1 1", "+B", "@Next 2 1"], "!=", -1]], false, [[["@This 0", "@if", ["@This 1", "+B", "@Next 1 1", "+B", "@Next 2 1", "=", ["@This 0", "+B", 1n]], "+B", 1n, "@repeat", ["@Parent -2", ">=", "@GVar 1"], "@run_script", 0, "@end-repeat", "@end-if"], ["@This 1", "+B", "@Next 1 1", "+B", "@Next 2 1", "@if", ["@Parent -2", "=", ["@This 0", "+B", 1n]], "2nd", 1n]]], ["@This 0", "factorial", "*", ["@This 1", "+", "@Next 1 1", "+", "@Next 2 1"]], [false, true, true]],
                    [2, ["@global_var_retain_inner", ["@This 1", "typeof", "=", "bigint"], "&&", ["@Next 1 1", "typeof", "=", "bigint"], "&&", ["@This 0", "=", "@Next 1 0"], "@add_var", [["@This 1", "+B", "@Next 1 1"], "/BR", "@This 1"], "&&", ["@Var 0", "numeratorBR", "primeFactorizeB", 2, "arr_length", "=", 1], "&&", [["@Var 0", "=", new BigRational(2n)], "||", [["@Var 0", "numeratorBR", ">", 2n], "@primesUpdate", ["@Var 0", "numeratorBR"], "&&", [["@Primes", "arr_indexOf", ["@Var 0", "numeratorBR"]], "-", ["@Primes", "arr_indexOf", ["@Var 0", "denominatorBR"]], "=", 1]]], "&&", ["@GVar 0", "arr_elem", "@This 0", "arr_indexOf", ["@This 1", "+B", "@Next 1 1"], "!=", -1], "&&", [0, "mergeRuleApplies", -1, "!"]], false, [[["@This 0", "@if", ["@This 1", "+B", "@Next 1 1", "=", ["@This 0", "+B", 1n]], "+B", 1n, "@repeat", ["@Parent -2", ">=", "@GVar 1"], "@run_script", 0, "@end-repeat", "@end-if"], ["@This 1", "+B", "@Next 1 1", "@if", ["@Parent -2", "=", ["@This 0", "+B", 1n]], "2nd", 1n]]], ["@This 0", "factorial", "*", ["@This 1", "+", "@Next 1 1"]], [false, true]],
                ];
                displayRules("rules_text", ["h1", "Alternate 5040 (3069 Variant)"], ["p", "Two or three tiles can merge if they're multiples of n! that are less than (n + 1)! if this merge would cause one of the prime factors of (the largest tile divided by n!) to increase to the next prime, and the prime factorization remains elementwise less than or equal to the prime factorization of (n + 1). (In other words, to get from n! to (n + 1)!, pretend n! is 1 and follow a path to get from 1 to (n + 1) in 3069.) Get to the 5040 tile to win!"],
                ["p", "Spawning tiles: 1 (100%)"]);
                displayRules("gm_rules_text", ["h1", "Alternate 5040 (3069 Variant)"], ["p", "Two or three tiles can merge if they're multiples of n! that are less than (n + 1)! if this merge would cause one of the prime factors of (the largest tile divided by n!) to increase to the next prime, and the prime factorization remains elementwise less than or equal to the prime factorization of (n + 1). (In other words, to get from n! to (n + 1)!, pretend n! is 1 and follow a path to get from 1 to (n + 1) in 3069.) Get to the 5040 tile to win!"],
                ["p", "Spawning tiles: 1 (100%)"]);
                scripts = [
                    [["@global_var_retain_inner", ["@Literal"], ["@GVar 1", "+B", 1n, "primeFactorizeB", 2, "@primesUpdate", ["@Parent -2", "arr_elem", -1], "arr_map", ["@Primes", "arr_indexOf", "@Var -1", "+B", 1n]], [["@Literal"], "@repeat", ["@Var 1", "arr_length"], "arr_push", 0n, "@end-repeat"], ["@Var 1", "arr_length", "-", 1], ["@Var 1", "arr_length", "-", 1], "@end_vars", 0, "@edit_gvar", 1, ["@GVar 1", "+B", 1n], "@repeat", [["@Var 2", "arr_elem", 0], "<=", ["@Var 1", "arr_elem", 0]], "@edit_var", 0, ["@Var 0", "arr_push", ["@Var 2", "arr_reduce", 1n, ["*B", ["@Var -1", "primeB"]]]], "@edit_var", 2, ["@Var 2", "arr_edit_elem", "@Var 4", ["@Var 2", "arr_elem", "@Var 4", "+B", 1n]], "@repeat", [[["@Var 2", "arr_elem", "@Var 3"], ">", ["@Var 1", "arr_elem", "@Var 3"]], "&&", ["@Var 3", ">", 0]], "@edit_var", 3, ["@Var 3", "-", 1], "@edit_var", 2, ["@Var 2", "arr_edit_elem", "@Var 3", ["@Var 2", "arr_elem", "@Var 3", "+B", 1n]], "@end-repeat", "@edit_var", 3, ["@Var 3", "+", 1], "@repeat", ["@Var 3", "<=", "@Var 4"], "@edit_var", 2, ["@Var 2", "arr_edit_elem", "@Var 3", ["@Var 2", "arr_elem", ["@Var 3", "-", 1]]], "@edit_var", 3, ["@Var 3", "+", 1], "@end-repeat", "@edit_var", 3, "@Var 4", "@end-repeat", "@edit_gvar", 0, ["@GVar 0", "arr_push", "@Var 0"]], "None"]
                ]
            }
            else {
                start_game_vars = [[]]; // List of valid tiles
                let basePF = primeFactorize(mode_vars[1], Infinity, false, 2)[0];
                primesUpdate(basePF.at(-1));
                basePF = basePF.map(n => (primes.indexOf(n) + 1));
                let PFiteration = [];
                for (let i = 0; i < basePF.length; i++) PFiteration.push(0n);
                let scanned = PFiteration.length - 1;
                while (PFiteration[0] <= basePF[0]) {
                    start_game_vars[0].push(PFiteration.reduce((x, p) => (x * prime(p)), 1n));
                    PFiteration[PFiteration.length - 1]++;
                    scanned = PFiteration.length - 1;
                    while (PFiteration[scanned] > basePF[scanned] && scanned > 0) {
                        PFiteration[scanned - 1]++;
                        scanned--;
                    }
                    scanned++;
                    while (scanned < PFiteration.length) {
                        PFiteration[scanned] = PFiteration[scanned - 1];
                        scanned++;
                    }
                }
                MergeRules = [
                    [3, ["@global_var_retain_inner", ["@This 1", "typeof", "=", "bigint"], "&&", ["@Next 1 1", "typeof", "=", "bigint"], "&&", ["@Next 2 1", "typeof", "=", "bigint"], "&&", ["@This 0", "=", "@Next 1 0"], "&&", ["@This 0", "=", "@Next 2 0"], "@add_var", [["@This 1", "+B", "@Next 1 1", "+B", "@Next 2 1"], "/BR", "@This 1"], "&&", ["@Var 0", "numeratorBR", "primeFactorizeB", 2, "arr_length", "=", 1], "&&", [["@Var 0", "=", new BigRational(2n)], "||", [["@Var 0", "numeratorBR", ">", 2n], "@primesUpdate", ["@Var 0", "numeratorBR"], "&&", [["@Primes", "arr_indexOf", ["@Var 0", "numeratorBR"]], "-", ["@Primes", "arr_indexOf", ["@Var 0", "denominatorBR"]], "=", 1]]], "&&", ["@GVar 0", "arr_indexOf", ["@This 1", "+B", "@Next 1 1", "+B", "@Next 2 1"], "!=", -1]], false, [[["@This 0", "@if", ["@This 1", "+B", "@Next 1 1", "+B", "@Next 2 1", "=", mode_vars[1]], "+B", 1n, "@end-if"], ["@This 1", "+B", "@Next 1 1", "+B", "@Next 2 1", "@if", ["@Parent -2", "=", mode_vars[1]], "2nd", 1n]]], [mode_vars[1], "^", "@This 0", "*", ["@This 1", "+", "@Next 1 1", "+", "@Next 2 1"]], [false, true]],
                    [2, ["@global_var_retain_inner", ["@This 1", "typeof", "=", "bigint"], "&&", ["@Next 1 1", "typeof", "=", "bigint"], "&&", ["@This 0", "=", "@Next 1 0"], "@add_var", [["@This 1", "+B", "@Next 1 1"], "/BR", "@This 1"], "&&", ["@Var 0", "numeratorBR", "primeFactorizeB", 2, "arr_length", "=", 1], "&&", [["@Var 0", "=", new BigRational(2n)], "||", [["@Var 0", "numeratorBR", ">", 2n], "@primesUpdate", ["@Var 0", "numeratorBR"], "&&", [["@Primes", "arr_indexOf", ["@Var 0", "numeratorBR"]], "-", ["@Primes", "arr_indexOf", ["@Var 0", "denominatorBR"]], "=", 1]]], "&&", ["@GVar 0", "arr_indexOf", ["@This 1", "+B", "@Next 1 1"], "!=", -1], "&&", [0, "mergeRuleApplies", -1, "!"]], false, [[["@This 0", "@if", ["@This 1", "+B", "@Next 1 1", "=", mode_vars[1]], "+B", 1n, "@end-if"], ["@This 1", "+B", "@Next 1 1", "@if", ["@Parent -2", "=", mode_vars[1]], "2nd", 1n]]], [mode_vars[1], "^", "@This 0", "*", ["@This 1", "+", "@Next 1 1"]], [false, true]],
                ];
                let rulesTitle = mode_vars[1]**goalPow + " (Alternate 5040, 3069 Variant)";
                let rulesDescription = "Two or three tiles can merge if they're multiples of " + mode_vars[1] + "<sup>n</sup> that are less than " + mode_vars[1] + "<sup>n + 1</sup> if this merge would cause one of the prime factors of (the largest tile divided by " + mode_vars[1] + "<sup>n</sup>) to increase to the next prime, and the prime factorization remains elementwise less than or equal to the prime factorization of " + mode_vars[1] + ". (In other words, to get from " + mode_vars[1] + "<sup>n</sup> to " + mode_vars[1] + "<sup>n + 1</sup>, pretend " + mode_vars[1] + "<sup>n</sup> is 1 and follow a path to get from 1 to " + mode_vars[1] + " in 3069.) Get to the " + mode_vars[1]**goalPow + " tile to win!"
                displayRules("rules_text", ["h1", rulesTitle], ["p", rulesDescription], ["p", "Spawning tiles: 1 (100%)"]);
                displayRules("gm_rules_text", ["h1", rulesTitle], ["p", rulesDescription], ["p", "Spawning tiles: 1 (100%)"]);
            }
            knownMergeMaxLength = 3;
            knownMergeLookbackDistance = 1;
        }
        else if (mode_vars[0] == 4) { // Partial Absorb variant
            document.getElementById("Alternate5040_variant_text").innerHTML = "Two equal tiles merge, potentially in a Partial Absorb way.";
            document.getElementById("Alternate5040_variant_text").style.setProperty("color", "#333300");
            document.documentElement.style.setProperty("background-image", "repeating-conic-gradient(from -45deg, #0000, #0000, #525200, #0000, #0000 90deg), repeating-conic-gradient(#c5c500 0deg, #ffffa1 45deg, #c5c500 90deg)");
            document.documentElement.style.setProperty("--background-color", "repeating-conic-gradient(from -45deg, #0000, #0000, #525200, #0000, #0000 90deg), repeating-conic-gradient(#c5c500 0deg,#eeee65 45deg,#8f8f00 90deg)");
            if (mode_vars[1] === true) {
                MergeRules = [
                    [2, [["@This 0", "=", "@Next 1 0"], "&&", ["@This 1", "=", "@Next 1 1"], "&&", ["@This 1", "+B", "@Next 1 1", "<", ["@This 0", "+B", 1n]]], true, [["@This 0", ["@This 1", "+B", "@Next 1 1"]]], ["@This 0", "factorial", "*", ["@This 1", "+", "@Next 1 1"]], [false, true]],
                    [2, [["@This 0", "=", "@Next 1 0"], "&&", ["@This 1", "=", "@Next 1 1"], "&&", ["@This 1", "+B", "@Next 1 1", "=", ["@This 0", "+B", 1n]]], true, [[["@This 0", "+B", 1n], 1n]], ["@This 0", "factorial", "*", ["@This 1", "+", "@Next 1 1"]], [false, true]],
                    [2, [["@This 0", "=", "@Next 1 0"], "&&", ["@This 1", "=", "@Next 1 1"], "&&", ["@This 1", "+B", "@Next 1 1", ">", ["@This 0", "+B", 1n]]], true, [[["@This 0", "+B", 1n], 1n], ["@This 0", ["@This 1", "+B", "@Next 1 1", "-B", "@This 0", "-B", 1n]]], ["@This 0", "factorial", "*", ["@This 1", "+", "@Next 1 1"]], [false, false]]
                ];
                displayRules("rules_text", ["h1", "Alternate 5040 (Partial Absorb Variant)"], ["p", "Two equal tiles merge, but if those two tiles are multiples of n! that are less than (n + 1)! and their sum is greater than (n + 1)!, then the tile being collided into only absorbs enough of the other tile to increase itself to (n + 1)!. Get to the 5040 tile to win!"],
                ["p", "Spawning tiles: 1 (100%)"]);
                displayRules("gm_rules_text", ["h1", "Alternate 5040 (Partial Absorb Variant)"], ["p", "Two equal tiles merge, but if those two tiles are multiples of n! that are less than (n + 1)! and their sum is greater than (n + 1)!, then the tile being collided into only absorbs enough of the other tile to increase itself to (n + 1)!. Get to the 5040 tile to win!"],
                ["p", "Spawning tiles: 1 (100%)"]);
            }
            else if (mode_vars[1] instanceof BigRational) {
                MergeRules = [
                    [2, [["@This 0", "=", "@Next 1 0"], "&&", ["@This 1", "=", "@Next 1 1"], "&&", ["@This 1", "+BR", "@Next 1 1", "<", mode_vars[1]]], true, [["@This 0", ["@This 1", "+BR", "@Next 1 1"]]], [mode_vars[1], "^", "@This 0", "*", ["@This 1", "+", "@Next 1 1"]], [false, true]],
                    [2, [["@This 0", "=", "@Next 1 0"], "&&", ["@This 1", "=", "@Next 1 1"], "&&", ["@This 1", "+BR", "@Next 1 1", "=", mode_vars[1]]], true, [[["@This 0", "+B", 1n], new BigRational(1n)]], [mode_vars[1], "^", "@This 0", "*", ["@This 1", "+", "@Next 1 1"]], [false, true]],
                    [0n, "@end_vars", 2, ["@global_var_retain", ["@This 0", "=", "@Next 1 0"], "&&", ["@This 1", "=", "@Next 1 1"], "&&", ["@This 1", "+BR", "@Next 1 1", ">", mode_vars[1]], "@if", "@Parent -1", "@repeat", ["@This 1", "+BR", "@Next 1 1", "-BR", mode_vars[1], "*BR", [mode_vars[1], "^BR", "@Var 0"], "<", 1], "@edit_var", 0, ["@Var 0", "+B", 1n], "@end-repeat", "@end-if"], true, [[["@This 0", "+B", 1n], new BigRational(1n)], [["@var_retain", "@This 0", "-B", "@Var 0"], ["@var_retain", "@This 1", "+BR", "@Next 1 1", "-BR", mode_vars[1], "*BR", ["@var_retain", mode_vars[1], "^BR", "@Var 0"]]]], [mode_vars[1], "^", "@This 0", "*", ["@This 1", "+", "@Next 1 1"]], [false, false]]
                ];
                let rulesTitle = defaultAbbreviate(mode_vars[1].pow(goalPow)) + " (Alternate 5040, Partial Absorb Variant)";
                let rulesDescription = "Two equal tiles merge, but if those two tiles are multiples of (" + defaultAbbreviate(mode_vars[1]) + ")<sup>n</sup> that are less than (" + defaultAbbreviate(mode_vars[1]) + ")<sup>n + 1</sup> and their sum is greater than (" + defaultAbbreviate(mode_vars[1]) + ")<sup>n + 1</sup>, then the tile being collided into only absorbs enough of the other tile to increase itself to (" + defaultAbbreviate(mode_vars[1]) + ")<sup>n + 1</sup>. Get to the " + defaultAbbreviate(mode_vars[1].pow(goalPow)) + " tile, which is (" + defaultAbbreviate(mode_vars[1]) + ")<sup>" + goalPow + "</sup>, to win!"
                displayRules("rules_text", ["h1", rulesTitle], ["p", rulesDescription], ["p", "Spawning tiles: 1 (100%)"]);
                displayRules("gm_rules_text", ["p", "You found a hidden mode! The Partial Absorb variant of Alternate 5040 can have a rational number for its base. Enjoy the chaos..."], ["h1", rulesTitle], ["p", rulesDescription], ["p", "Spawning tiles: 1 (100%)"]);
            }
            else {
                MergeRules = [
                    [2, [["@This 0", "=", "@Next 1 0"], "&&", ["@This 1", "=", "@Next 1 1"], "&&", ["@This 1", "+B", "@Next 1 1", "<", mode_vars[1]]], true, [["@This 0", ["@This 1", "+B", "@Next 1 1"]]], [mode_vars[1], "^", "@This 0", "*", ["@This 1", "+", "@Next 1 1"]], [false, true]],
                    [2, [["@This 0", "=", "@Next 1 0"], "&&", ["@This 1", "=", "@Next 1 1"], "&&", ["@This 1", "+B", "@Next 1 1", "=", mode_vars[1]]], true, [[["@This 0", "+B", 1n], 1n]], [mode_vars[1], "^", "@This 0", "*", ["@This 1", "+", "@Next 1 1"]], [false, true]],
                    [2, [["@This 0", "=", "@Next 1 0"], "&&", ["@This 1", "=", "@Next 1 1"], "&&", ["@This 1", "+B", "@Next 1 1", ">", mode_vars[1]]], true, [[["@This 0", "+B", 1n], 1n], ["@This 0", ["@This 1", "+B", "@Next 1 1", "-B", mode_vars[1]]]], [mode_vars[1], "^", "@This 0", "*", ["@This 1", "+", "@Next 1 1"]], [false, false]]
                ];
                let rulesTitle = mode_vars[1]**goalPow + " (Alternate 5040, Partial Absorb Variant)";
                let rulesDescription = "Two equal tiles merge, but if those two tiles are multiples of " + mode_vars[1] + "<sup>n</sup> that are less than " + mode_vars[1] + "<sup>n + 1</sup> and their sum is greater than " + mode_vars[1] + "<sup>n + 1</sup>, then the tile being collided into only absorbs enough of the other tile to increase itself to " + mode_vars[1] + "<sup>n + 1</sup>. Get to the " + mode_vars[1]**goalPow + " tile to win!"
                displayRules("rules_text", ["h1", rulesTitle], ["p", rulesDescription], ["p", "Spawning tiles: 1 (100%)"]);
                displayRules("gm_rules_text", ["h1", rulesTitle], ["p", rulesDescription], ["p", "Spawning tiles: 1 (100%)"]);
            }
            knownMergeMaxLength = 2;
            knownMergeLookbackDistance = 0;
        }
    }
    else if (gamemode == 50.1) { // Gaussian DIVE
        let seedCheckDescription = "";
        let seedSpawnDescription = "";
        let startingSeedsDescription = "";
        let firstQuadrantRotateDescription = "";
        if (mode_vars[0] == 0) {
            document.getElementById("GaussianDIVE_startSeeds_text").innerHTML = "The starting seed is 1+i.";
            document.getElementById("GaussianDIVE_startSeeds_text").style.setProperty("color", "#ff9393");
            startingSeedsDescription = "1+i tiles";
        }
        else if (mode_vars[0] == 1) {
            document.getElementById("GaussianDIVE_startSeeds_text").innerHTML = "The starting seeds are 1+i and 1-i.";
            document.getElementById("GaussianDIVE_startSeeds_text").style.setProperty("color", "#c9ff94");
            startingSeedsDescription = "1+i and 1-i tiles";
        }
        else if (mode_vars[0] == 2) {
            document.getElementById("GaussianDIVE_startSeeds_text").innerHTML = "The starting seeds are 1+i, 1-i, -1-i, and -1+i.";
            document.getElementById("GaussianDIVE_startSeeds_text").style.setProperty("color", "#c994ff");
            startingSeedsDescription = "1+i, 1-i, -1-i, and -1+i tiles";
        }
        else if (mode_vars[0] == 3) {
            document.getElementById("GaussianDIVE_startSeeds_text").innerHTML = "The starting seeds are 1 and i.";
            document.getElementById("GaussianDIVE_startSeeds_text").style.setProperty("color", "#366b00");
            startingSeedsDescription = "1 and i tiles";
        }
        else if (mode_vars[0] == 4) {
            document.getElementById("GaussianDIVE_startSeeds_text").innerHTML = "The starting seeds are 1, i, -1, and -i.";
            document.getElementById("GaussianDIVE_startSeeds_text").style.setProperty("color", "#36006b");
            startingSeedsDescription = "1, i, -1, and -1 tiles";
        }
        else if (mode_vars[0] == 5) {
            document.getElementById("GaussianDIVE_startSeeds_text").innerHTML = "The starting seed is 1.";
            document.getElementById("GaussianDIVE_startSeeds_text").style.setProperty("color", "#6b0000");
            startingSeedsDescription = "1 tiles";
        }
        if (mode_vars[1]) {
            document.getElementById("GaussianDIVE_unlocks_text").innerHTML = "Spawning tiles, a.k.a. seeds, can be unlocked and eliminated.";
            document.getElementById("GaussianDIVE_unlocks_text").style.setProperty("color", "#060");
        }
        else {
            document.getElementById("GaussianDIVE_unlocks_text").innerHTML = "Spawning tiles, a.k.a. seeds, are unlocked permanently.";
            document.getElementById("GaussianDIVE_unlocks_text").style.setProperty("color", "#400");
        }
        if (mode_vars[2]) {
            document.getElementById("GaussianDIVE_seedsFirstQuadrant_text").innerHTML = "Newly-unlocked seeds are always rotated into the first quadrant.";
            document.getElementById("GaussianDIVE_seedsFirstQuadrant_text").style.setProperty("color", "#d25931");
            firstQuadrantRotateDescription = "(rotated into the first quadrant) "
        }
        else {
            document.getElementById("GaussianDIVE_seedsFirstQuadrant_text").innerHTML = "Newly-unlocked seeds are left as is, even if some components are negative.";
            document.getElementById("GaussianDIVE_seedsFirstQuadrant_text").style.setProperty("color", "#5e76c4");
            firstQuadrantRotateDescription = "";
        }
        if (mode_vars[4] == 0) {
            document.getElementById("GaussianDIVE_unlockRules_text").innerHTML = "When deciding what new seed to unlock, seeds are checked largest to smallest.";
            document.getElementById("GaussianDIVE_unlockRules_text").style.setProperty("color", "#b7ff3c");
            seedCheckDescription = " (Seeds are checked largest to smallest.) "
        }
        else if (mode_vars[4] == 1) {
            document.getElementById("GaussianDIVE_unlockRules_text").innerHTML = "When deciding what new seed to unlock, the minimum possibility is always chosen, as in the original DIVE. (This may be laggy.)";
            document.getElementById("GaussianDIVE_unlockRules_text").style.setProperty("color", "#e3ae79");
            seedCheckDescription = " (Seeds are checked in a way that gives the minimum possible outcome.) "
        }
        else if (mode_vars[4] == 2) {
            document.getElementById("GaussianDIVE_unlockRules_text").innerHTML = "When deciding what new seed to unlock, seeds are checked smallest to largest.";
            document.getElementById("GaussianDIVE_unlockRules_text").style.setProperty("color", "#fa6756");
            seedCheckDescription = " (Seeds are checked smallest to largest.) "
        }
        else {
            document.getElementById("GaussianDIVE_unlockRules_text").innerHTML = "When deciding what new seed to unlock, seeds are checked in the order they were unlocked.";
            document.getElementById("GaussianDIVE_unlockRules_text").style.setProperty("color", "#58c2dc");
            seedCheckDescription = " (Seeds are checked in the order they were unlocked.) "
        }
        document.getElementById("GaussianDIVE_quadrant0SpawnRatio_change").value = mode_vars[3][0];
        document.getElementById("GaussianDIVE_quadrant1SpawnRatio_change").value = mode_vars[3][1];
        document.getElementById("GaussianDIVE_quadrant2SpawnRatio_change").value = mode_vars[3][2];
        document.getElementById("GaussianDIVE_quadrant3SpawnRatio_change").value = mode_vars[3][3];
        seedSpawnDescription = "At first, only " + startingSeedsDescription + " spawn. When a new tile is made, if the value leftover after dividing that tile by all current spawning tiles as many times as you can has a greater magnitude than 1, that leftover value " + firstQuadrantRotateDescription + "is permanently added as a new spawning tile." + seedCheckDescription;
        if (mode_vars[1]) seedSpawnDescription += "If there are no remaining multiples of a spawning tile on the board, that tile is removed from the spawn pool, and you gain points equal to its value."
        displayRules("rules_text", ["h1", "Gaussian DIVE"], ["p", "DIVE, but the tiles are complex integers instead of just real integers."],
        ["p", seedSpawnDescription]);
        displayRules("gm_rules_text", ["p", "You found a hidden mode!"], ["h1", "Gaussian DIVE"], ["p", "DIVE, but the tiles are complex integers instead of just real integers."],
        ["p", seedSpawnDescription]);
    }
    else if (gamemode == 71.37) { // 145.965
        if (mode_vars[0]) {
            document.getElementById("3188646_multiplyMiddle_text").innerHTML = "Division tiles must be in the middle of the two tiles they are merging.";
            document.getElementById("3188646_multiplyMiddle_text").style.setProperty("color", "#a6ff6a");
            displayRules("rules_text", ["h1", "145.965"], ["p","There are division tiles. If you merge two tiles that are each double a power of 1.5 or half a power of 1.5 (they do not need to be double or half the <i>same</i> power of 1.5) with a divison tile in the middle, those two tiles will be divided. Also, a 1 tile can be divided in this way with any other tile, and any tile can merge normally with a tile that's double itself. Get to the 145.965 (0.5 &#215; 1.5<sup>14</sup>) tile to win!"],
            ["p", "Spawning tiles: 2 (50%), &#247; (50%)"]);
            displayRules("gm_rules_text", ["h1", "145.965"], ["p", "You found a hidden mode!"], ["p","There are division tiles. If you merge two tiles that are each double a power of 1.5 or half a power of 1.5 (they do not need to be double or half the <i>same</i> power of 1.5) with a divison tile in the middle, those two tiles will be divided. Also, a 1 tile can be divided in this way with any other tile, and any tile can merge normally with a tile that's double itself. Get to the 145.965 (0.5 &#215; 1.5<sup>14</sup>) tile to win!"],
            ["p", "Spawning tiles: 2 (50%), &#247; (50%)"]);
        }
        else {
            document.getElementById("3188646_multiplyMiddle_text").innerHTML = "Division tiles don't have to be in the middle of the two tiles they are merging.";
            document.getElementById("3188646_multiplyMiddle_text").style.setProperty("color", "#5ad3ff");
            displayRules("rules_text", ["h1", "145.965"], ["p","There are division tiles. If you merge two tiles that are each double a power of 1.5 or half a power of 1.5 (they do not need to be double or half the <i>same</i> power of 1.5) with a divison tile, those two tiles will be divided. Also, a 1 tile can be divided in this way with any other tile, and any tile can merge normally with a tile that's double itself. Get to the 145.965 (0.5 &#215; 1.5<sup>14</sup>) tile to win!"],
            ["p", "Spawning tiles: 2 (50%), &#247; (50%)"]);
            displayRules("gm_rules_text", ["h1", "145.965"], ["p", "You found a hidden mode!"], ["p","There are division tiles. If you merge two tiles that are each double a power of 1.5 or half a power of 1.5 (they do not need to be double or half the <i>same</i> power of 1.5) with a divison tile, those two tiles will be divided. Also, a 1 tile can be divided in this way with any other tile, and any tile can merge normally with a tile that's double itself. Get to the 145.965 (0.5 &#215; 1.5<sup>14</sup>) tile to win!"],
            ["p", "Spawning tiles: 2 (50%), &#247; (50%)"]);
        }
    }
}

function displayModifiers(page) {
    if (modifiers[5] == "Custom") { // If the Custom Grid is enabled, page 3 (the grid modifiers) is replaced with pages 3.1 (custom grid) and 3.2 (custom directions)
        if (page < 3) document.getElementById("modifiers_page_counter").innerHTML = "Page " + page + " / " + 7;
        else if (page === 3.1) document.getElementById("modifiers_page_counter").innerHTML = "Page 3 / 7";
        else if (page === 3.2) document.getElementById("modifiers_page_counter").innerHTML = "Page 4 / 7";
        else document.getElementById("modifiers_page_counter").innerHTML = "Page " + (page + 1) + " / " + 7;
    }
    else {
        document.getElementById("modifiers_page_counter").innerHTML = "Page " + page + " / " + 6;
    }
    let pages = [1, 2, 3, 3.1, 3.2, 4, 5, 6];
    for (let p = 0; p < pages.length; p++) {
        if (pages[p] == page) {
            document.getElementById("modifiers_page_" + pages[p]).style.setProperty("display", "block");
        }
        else document.getElementById("modifiers_page_" + pages[p]).style.setProperty("display", "none");
    }
    if (page == 1) {
        if (modifiers[5] == "Custom") document.getElementById("modifiers_slideAmount_title").innerHTML = "Default Maximum Spaces per Move:";
        else document.getElementById("modifiers_slideAmount_title").innerHTML = "Maximum Spaces Moved per Move:";
        if (modifiers[0] == Infinity) document.getElementById("modifiers_slideAmount_counter").innerHTML = "&infin;";
        else document.getElementById("modifiers_slideAmount_counter").innerHTML = modifiers[0];
        if (modifiers[0] == Infinity) document.getElementById("modifiers_slideAmount_minus").style.setProperty("display", "none");
        else document.getElementById("modifiers_slideAmount_minus").style.setProperty("display", "inline-block");
        if (modifiers[0] >= 9999 && modifiers[0] != Infinity) document.getElementById("modifiers_slideAmount_plus").style.setProperty("display", "none");
        else document.getElementById("modifiers_slideAmount_plus").style.setProperty("display", "inline-block");
        if (modifiers[1] == Infinity) document.getElementById("modifiers_randomTileAmount_counter").innerHTML = "&infin;";
        else document.getElementById("modifiers_randomTileAmount_counter").innerHTML = modifiers[1];
        if (modifiers[1] == Infinity) document.getElementById("modifiers_randomTileAmount_minus").style.setProperty("display", "none");
        else document.getElementById("modifiers_randomTileAmount_minus").style.setProperty("display", "inline-block");
        document.getElementById("modifiers_randomTileAmount_plus").style.setProperty("display", "inline-block");
        if (modifiers[2] == Infinity) document.getElementById("modifiers_startTileAmount_counter").innerHTML = "&infin;";
        else document.getElementById("modifiers_startTileAmount_counter").innerHTML = modifiers[2];
        if (modifiers[2] == Infinity) document.getElementById("modifiers_startTileAmount_minus").style.setProperty("display", "none");
        else document.getElementById("modifiers_startTileAmount_minus").style.setProperty("display", "inline-block");
        document.getElementById("modifiers_startTileAmount_plus").style.setProperty("display", "inline-block");
        document.getElementById("modifiers_nextTiles_counter").innerHTML = modifiers[14];
        if (modifiers[14] <= 0) document.getElementById("modifiers_nextTiles_minus").style.setProperty("display", "none");
        else document.getElementById("modifiers_nextTiles_minus").style.setProperty("display", "inline-block");
        if (modifiers[14] >= 9999) document.getElementById("modifiers_nextTiles_plus").style.setProperty("display", "none");
        else document.getElementById("modifiers_nextTiles_plus").style.setProperty("display", "inline-block");
        document.getElementById("modifiers_animationSpeed_change").value = modifiers[16];
        document.getElementById("modifiers_randomVoid_counter").innerHTML = modifiers[17];
        if (modifiers[17] <= 0) document.getElementById("modifiers_randomVoid_minus").style.setProperty("display", "none");
        else document.getElementById("modifiers_randomVoid_minus").style.setProperty("display", "inline-block");
        document.getElementById("modifiers_randomVoid_plus").style.setProperty("display", "inline-block");
        document.getElementById("modifiers_randomBlackBox_counter").innerHTML = modifiers[18];
        if (modifiers[18] <= 0) document.getElementById("modifiers_randomBlackBox_minus").style.setProperty("display", "none");
        else document.getElementById("modifiers_randomBlackBox_minus").style.setProperty("display", "inline-block");
        document.getElementById("modifiers_randomBlackBox_plus").style.setProperty("display", "inline-block");
        document.getElementById("modifiers_randomSlippery_counter").innerHTML = modifiers[28];
        if (modifiers[28] <= 0) document.getElementById("modifiers_randomSlippery_minus").style.setProperty("display", "none");
        else document.getElementById("modifiers_randomSlippery_minus").style.setProperty("display", "inline-block");
        document.getElementById("modifiers_randomSlippery_plus").style.setProperty("display", "inline-block");
        document.getElementById("modifiers_spawnInterval_counter").innerHTML = modifiers[19];
        if (modifiers[19] <= 1) document.getElementById("modifiers_spawnInterval_minus").style.setProperty("display", "none");
        else document.getElementById("modifiers_spawnInterval_minus").style.setProperty("display", "inline-block");
        document.getElementById("modifiers_spawnInterval_plus").style.setProperty("display", "inline-block");
    }
    else if (page == 2) {
        if (modifiers[3]) {
            document.getElementById("modifiers_multiMerge_text").innerHTML = "A tile that was just merged can itself be part of another merge on the same move.";
            document.getElementById("modifiers_multiMerge_text").style.setProperty("color", "#c48828");
        }
        else {
            document.getElementById("modifiers_multiMerge_text").innerHTML = "A tile that was just merged cannot itself be part of another merge on the same move.";
            document.getElementById("modifiers_multiMerge_text").style.setProperty("color", "#4e3000");
        }
        if (modifiers[4] == "Edge") {
            document.getElementById("modifiers_spawnLocation_text").innerHTML = "New tiles can only spawn on the edge that you just moved away from.";
            document.getElementById("modifiers_spawnLocation_text").style.setProperty("color", "#c64200");
        }
        else {
            if (modifiers[5] == "4D") document.getElementById("modifiers_spawnLocation_text").innerHTML = "New tiles can spawn in any empty spaces on the grid.<br><br>(Note: This modifier cannot be changed while playing on a 3D/4D grid)";
            else document.getElementById("modifiers_spawnLocation_text").innerHTML = "New tiles can spawn in any empty spaces on the grid.";
            document.getElementById("modifiers_spawnLocation_text").style.setProperty("color", "#c6af00");
        }
        if (modifiers[15] == "Simple") {
            document.getElementById("modifiers_simpleSpawns_text").innerHTML = "Only the first spawnable tile type in each mode can spawn. (In 3072 and 1093 1094, this gets rid of spawning 3s and bonus tiles, keeping only 1s and 2s in the box. Does not affect 2049, 1535 1536 1537, Wildcard 2048, versions of 2216.838 with &#247;2 tiles, 1321, DIVE, 10, 1825, (232, 240), 16+16i, 3,188,646, 1429, 2058, 1716, Pro-Add-Uct, any Custom Mode, or any mode that already only spawns one tile)";
            document.getElementById("modifiers_simpleSpawns_text").style.setProperty("color", "#d3c480");
        }
        else if (modifiers[15] == "Equal") {
            document.getElementById("modifiers_simpleSpawns_text").innerHTML = "All tiles that can spawn have equal spawning probability. (Does not affect 3072, 1535 1536 1537, 1093 1094, any Custom Mode, or any mode that already only spawns one tile)";
            document.getElementById("modifiers_simpleSpawns_text").style.setProperty("color", "#fab444");
        }
        else {
            document.getElementById("modifiers_simpleSpawns_text").innerHTML = "Gamemodes have their normal spawning rules.";
            document.getElementById("modifiers_simpleSpawns_text").style.setProperty("color", "#bba43d");
        }
        if (modifiers[20]) {
            document.getElementById("modifiers_twoMoveMerge_text").innerHTML = "To merge tiles, you must move in the same direction twice in a row.";
            document.getElementById("modifiers_twoMoveMerge_text").style.setProperty("color", "#7f0099");
        }
        else {
            document.getElementById("modifiers_twoMoveMerge_text").innerHTML = "Merges can occur on any move.";
            document.getElementById("modifiers_twoMoveMerge_text").style.setProperty("color", "#ff56ff");
        }
    }
    else if (page == 3) {
        document.getElementById("modifiers_directions_button").style.setProperty("display", "block");
        document.getElementById("modifiers_spawnLocation_button").style.setProperty("display", "block");
        if (modifiers[5] == "Diamond") {
            document.getElementById("modifiers_gridShape_text").innerHTML = "The grid is a diamond, consisting of all tiles that are no more than a certain orthogonal distance away from the center.";
            document.getElementById("modifiers_gridShape_text").style.setProperty("color", "#00a7b7");
        }
        else if (modifiers[5] == "Checkerboard") {
            document.getElementById("modifiers_gridShape_text").innerHTML = "The grid is a checkerboard, i.e. a rectangle with half of the tiles cut out. Diagonals replace orthogonals, and double-size orthogonals replace diagonals.";
            document.getElementById("modifiers_gridShape_text").style.setProperty("color", "#1dae00");
        }
        else if (modifiers[5] == "Hexagon") {
            document.getElementById("modifiers_gridShape_text").innerHTML = "The grid is a hexagon, and the tiles are hexagonal.";
            document.getElementById("modifiers_gridShape_text").style.setProperty("color", "#6f1b8e");
        }
        else if (modifiers[5] == "HexaTriangle") {
            document.getElementById("modifiers_gridShape_text").innerHTML = "The grid is a triangle made of hexagonal tiles.";
            document.getElementById("modifiers_gridShape_text").style.setProperty("color", "#aaaa1c");
        }
        else if (modifiers[5] == "4D") {
            document.getElementById("modifiers_gridShape_text").innerHTML = "The grid is a 3D or 4D rectangular prism (represented by separated 2D grids), with width, height, length, and depth adjustable separately.";
            document.getElementById("modifiers_gridShape_text").style.setProperty("color", "#5c0900");
            document.getElementById("modifiers_directions_button").style.setProperty("display", "none");
            document.getElementById("modifiers_spawnLocation_button").style.setProperty("display", "none");
        }
        else {
            document.getElementById("modifiers_gridShape_text").innerHTML = "The grid is rectangular, with width and height adjustable separately.";
            document.getElementById("modifiers_gridShape_text").style.setProperty("color", "#8e511b");
        }
        if (modifiers[10] == "Both") {
            if (modifiers[5] == "Checkerboard") document.getElementById("modifiers_directions_text").innerHTML = "You may move in diagonal and double-orthogonal directions. Keyboard controls can use QEZC for the diagonals, WASD or WAXD or the arrow keys for the double-orthogonals.";
            else if (modifiers[5] == "Hexagon" || modifiers[5] == "HexaTriangle") document.getElementById("modifiers_directions_text").innerHTML = "You may move in the six hexagonal directions and the six hexa-diagonal directions. Keyboard controls can use QWASZX for the main six, IOPJKL for the diagonals.";
            else document.getElementById("modifiers_directions_text").innerHTML = "You may move in orthogonal and diagonal directions. Keyboard controls can use WASD or WAXD or the arrow keys for the orthogonals, QEZC for the diagonals.";
            document.getElementById("modifiers_directions_text").style.setProperty("color", "#717100");
        }
        else if (modifiers[10] == "Diagonal") {
            if (modifiers[5] == "Checkerboard") document.getElementById("modifiers_directions_text").innerHTML = "You may only move in double-orthogonal directions. Keyboard controls can use WASD, WAXD, or the arrow keys.";
            else if (modifiers[5] == "Hexagon" || modifiers[5] == "HexaTriangle") document.getElementById("modifiers_directions_text").innerHTML = "You may only move in the six hexa-diagonal directions. Keyboard controls can use IOPJKL.";
            else document.getElementById("modifiers_directions_text").innerHTML = "You may only move in diagonal directions. Keyboard controls can use QEZC.";
            document.getElementById("modifiers_directions_text").style.setProperty("color", "#713c00");
        }
        else {
            if (modifiers[5] == "Checkerboard") document.getElementById("modifiers_directions_text").innerHTML = "You may only move in diagonal directions. Keyboard controls can use QEZC.";
            else if (modifiers[5] == "Hexagon" || modifiers[5] == "HexaTriangle") document.getElementById("modifiers_directions_text").innerHTML = "You may only move in the six hexagonal directions. Keyboard controls can use QWASZX.";
            else if (modifiers[5] == "4D") document.getElementById("modifiers_directions_text").innerHTML = "Depending on the amount of dimensions, you may move in the 2, 4, 6, or 8 orthogonal directions. Keyboard controls can use WASD or the arrow keys to move within the 2D grids, IJKL to move between the 2D grids.<br><br>(Note: You cannot enable diagonal directions with a 3D/4D grid, because I don't want to make 26 or 80 directions of movement yet)"
            else document.getElementById("modifiers_directions_text").innerHTML = "You may only move in orthogonal directions. Keyboard controls can use WASD, WAXD, or the arrow keys.";
            document.getElementById("modifiers_directions_text").style.setProperty("color", "#007104");
        }
        if (modifiers[11]) {
            document.getElementById("modifiers_stayStill_text").innerHTML = "You may choose to not move and just let new tile(s) spawn. (Keyboard controls can use Spacebar to do so)";
            document.getElementById("modifiers_stayStill_text").style.setProperty("color", "#1b8e49");
        }
        else {
            document.getElementById("modifiers_stayStill_text").innerHTML = "You have to move on every turn.";
            document.getElementById("modifiers_stayStill_text").style.setProperty("color", "#798e1b");
        }
    }
    else if (page == 3.1) {
        if (hexagonal) {
            document.getElementById("modifiers_customGridSizeLineNormal").style.setProperty("display", "none");
            document.getElementById("modifiers_customGridSizeLineSingle").style.setProperty("display", "flex");
            document.getElementById("modifiers_customGridSize_counter").innerHTML = (height - 1)/2;
            if (height <= 1) document.getElementById("modifiers_customGridSize_minus").style.setProperty("display", "none");
            else document.getElementById("modifiers_customGridSize_minus").style.setProperty("display", "inline-block");
            if (height >= 19997) document.getElementById("modifiers_customGridSize_plus").style.setProperty("display", "none");
            else document.getElementById("modifiers_customGridSize_plus").style.setProperty("display", "inline-block");
        }
        else {
            document.getElementById("modifiers_customGridSizeLineNormal").style.setProperty("display", "flex");
            document.getElementById("modifiers_customGridSizeLineSingle").style.setProperty("display", "none");
            document.getElementById("modifiers_customGridWidth_counter").innerHTML = width;
            if (width <= 1) document.getElementById("modifiers_customGridWidth_minus").style.setProperty("display", "none");
            else document.getElementById("modifiers_customGridWidth_minus").style.setProperty("display", "inline-block");
            if (width >= 9999) document.getElementById("modifiers_customGridWidth_plus").style.setProperty("display", "none");
            else document.getElementById("modifiers_customGridWidth_plus").style.setProperty("display", "inline-block");
            document.getElementById("modifiers_customGridHeight_counter").innerHTML = height;
            if (height <= 1) document.getElementById("modifiers_customGridHeight_minus").style.setProperty("display", "none");
            else document.getElementById("modifiers_customGridHeight_minus").style.setProperty("display", "inline-block");
            if (height >= 9999) document.getElementById("modifiers_customGridHeight_plus").style.setProperty("display", "none");
            else document.getElementById("modifiers_customGridHeight_plus").style.setProperty("display", "inline-block");
        }
    }
    else if (page == 3.2) {
        createCustomArrows();
        if (screenVars[0] == -1) {
            document.getElementById("modifiers_customArrowOptions").style.setProperty("display", "none");
            document.getElementById("modifiers_customArrow_removeDirection").style.setProperty("display", "none");
            document.getElementById("modifiers_customArrow_addDirection").style.setProperty("display", "block");
        }
        else {
            document.getElementById("modifiers_customArrowOptions").style.setProperty("display", "inline-block");
            if (hexagonal) {
                document.getElementById("modifiers_customArrow_vdir_title").innerHTML = "Southeast Movement Magnitude:";
                document.getElementById("modifiers_customArrow_hdir_title").innerHTML = "Northeast Movement Magnitude:";
                document.getElementById("modifiers_customArrow_vdir_counter").innerHTML = directions[screenVars[0]][0][1]/2 + directions[screenVars[0]][0][0]/2;
                document.getElementById("modifiers_customArrow_hdir_counter").innerHTML = directions[screenVars[0]][0][1]/2 - directions[screenVars[0]][0][0]/2;
            }
            else {
                document.getElementById("modifiers_customArrow_vdir_title").innerHTML = "Vertical Movement Magnitude:";
                document.getElementById("modifiers_customArrow_hdir_counter").innerHTML = "Horizontal Movement Magnitude:";
                document.getElementById("modifiers_customArrow_vdir_counter").innerHTML = directions[screenVars[0]][0][0];
                document.getElementById("modifiers_customArrow_hdir_counter").innerHTML = directions[screenVars[0]][0][1];
            }
            if (directions[screenVars[0]][0][2] == Infinity) document.getElementById("modifiers_customArrow_slideAmount_counter").innerHTML = "&infin;";
            else document.getElementById("modifiers_customArrow_slideAmount_counter").innerHTML = directions[screenVars[0]][0][2];
            if (directions[screenVars[0]][0][0] >= height - 1) document.getElementById("modifiers_customArrow_vdir_plus").style.setProperty("display", "none");
            else document.getElementById("modifiers_customArrow_vdir_plus").style.setProperty("display", "flex");
            if (directions[screenVars[0]][0][0] <= 1 - height) document.getElementById("modifiers_customArrow_vdir_minus").style.setProperty("display", "none");
            else document.getElementById("modifiers_customArrow_vdir_minus").style.setProperty("display", "flex");
            if (directions[screenVars[0]][0][1] >= width - 1) document.getElementById("modifiers_customArrow_hdir_plus").style.setProperty("display", "none");
            else document.getElementById("modifiers_customArrow_hdir_plus").style.setProperty("display", "flex");
            if (directions[screenVars[0]][0][1] <= 1 - width) document.getElementById("modifiers_customArrow_hdir_minus").style.setProperty("display", "none");
            else document.getElementById("modifiers_customArrow_hdir_minus").style.setProperty("display", "flex");
            if (directions[screenVars[0]][0][2] == Infinity) document.getElementById("modifiers_customArrow_slideAmount_minus").style.setProperty("display", "none");
            else document.getElementById("modifiers_customArrow_slideAmount_minus").style.setProperty("display", "flex");
            document.getElementById("modifiers_customArrow_text_change").value = he.decode(directions[screenVars[0]][1]);
            document.getElementById("modifiers_customArrow_width_change").value = directions[screenVars[0]][2] * 100;
            document.getElementById("modifiers_customArrow_height_change").value = directions[screenVars[0]][3] * 100;
            document.getElementById("modifiers_customArrow_fontsize_change").value = directions[screenVars[0]][4] * 100;
            document.getElementById("modifiers_customArrow_vpos_change").value = directions[screenVars[0]][5] * 100;
            document.getElementById("modifiers_customArrow_hpos_change").value = directions[screenVars[0]][6] * 100;
            document.getElementById("modifiers_customArrow_rotation_change").value = directions[screenVars[0]][8];
            if (directions[screenVars[0]][6].length == 0) document.getElementById("modifiers_customArrow_keyText").innerHTML = "Keyboard Keys: (None)";
            else document.getElementById("modifiers_customArrow_keyText").innerHTML = "Keyboard Keys: " + directions[screenVars[0]][7];
            if (inputAvailable) {
                document.getElementById("modifiers_customArrow_addKey").style.setProperty("background-color", "#bfafff");
                document.getElementById("modifiers_customArrow_addKey").innerHTML = "Listening...";
            }
            else {
                document.getElementById("modifiers_customArrow_addKey").style.setProperty("background-color", "#3f2c88");
                document.getElementById("modifiers_customArrow_addKey").innerHTML = "Add New Key";
            }
            document.getElementById("modifiers_customArrow_removeDirection").style.setProperty("display", "block");
            document.getElementById("modifiers_customArrow_addDirection").style.setProperty("display", "none");
        }
    }
    else if (page == 4) {
        if (modifiers[12]) {
            document.getElementById("modifiers_garbage0_text").innerHTML = "Garbage 0s: ON";
            document.getElementById("modifiers_garbage0_text").style.setProperty("color", "#000000");
            document.getElementById("modifiers_garbage0_info").style.setProperty("color", "#000000");
        }
        else {
            document.getElementById("modifiers_garbage0_text").innerHTML = "Garbage 0s: OFF";
            document.getElementById("modifiers_garbage0_text").style.setProperty("color", "#808080");
            document.getElementById("modifiers_garbage0_info").style.setProperty("color", "#808080");
        }
        if (modifiers[13] == "None") {
            document.getElementById("modifiers_negativetiles_text").innerHTML = "Negative Tiles: OFF";
            document.getElementById("modifiers_negativetiles_text").style.setProperty("color", "#a81100");
            document.getElementById("modifiers_negativetiles_info").style.setProperty("color", "#a81100");
            document.getElementById("modifiers_negativetiles_positiveSpawnRatio").style.setProperty("display", "none");
            document.getElementById("modifiers_negativetiles_negativeSpawnRatio").style.setProperty("display", "none");
        }
        else if (modifiers[13] == "Interacting") {
            document.getElementById("modifiers_negativetiles_text").innerHTML = "Negative Tiles: ON, Interacting";
            document.getElementById("modifiers_negativetiles_text").style.setProperty("color", "#8c00a8");
            document.getElementById("modifiers_negativetiles_info").style.setProperty("color", "#8c00a8");
        }
        else {
            document.getElementById("modifiers_negativetiles_text").innerHTML = "Negative Tiles: ON, Non-Interacting";
            document.getElementById("modifiers_negativetiles_text").style.setProperty("color", "#0000a8");
            document.getElementById("modifiers_negativetiles_info").style.setProperty("color", "#0000a8");
        }
        if (modifiers[21]) {
            document.getElementById("modifiers_hiddenTileText_text").innerHTML = "Tile numbers are hidden, so you have to rely on the color scheme to know what the tiles are.";
            document.getElementById("modifiers_hiddenTileText_text").style.setProperty("color", "#bcb6aa");
        }
        else {
            document.getElementById("modifiers_hiddenTileText_text").innerHTML = "Tile numbers are shown as normal.";
            document.getElementById("modifiers_hiddenTileText_text").style.setProperty("color", "#1d1910");
        }
        if (modifiers[13] != "None") {
            document.getElementById("modifiers_negativetiles_positiveSpawnRatio").style.setProperty("display", "block");
            document.getElementById("modifiers_negativetiles_negativeSpawnRatio").style.setProperty("display", "block");
            document.getElementById("modifiers_negativetiles_positiveSpawnRatio_change").value = modifiers[22];
            document.getElementById("modifiers_negativetiles_negativeSpawnRatio_change").value = modifiers[23];
        }
    }
    else if (page == 5) {
        document.getElementById("modifiers_tricolortiles_text").style.setProperty("color", "transparent");
        document.getElementById("modifiers_tricolortiles_info").style.setProperty("color", "transparent");
        document.getElementById("modifiers_tricolortiles_text").style.setProperty("background-clip", "text");
        document.getElementById("modifiers_tricolortiles_info").style.setProperty("background-clip", "text");
        document.getElementById("modifiers_tricolortiles_text").style.setProperty("-webkit-background-clip", "text");
        document.getElementById("modifiers_tricolortiles_info").style.setProperty("-webkit-background-clip", "text");
        if (modifiers[24]) {
            document.getElementById("modifiers_tricolortiles_text").innerHTML = "Tricolor Tiles: ON";
            document.getElementById("modifiers_tricolortiles_text").style.setProperty("background-image", "linear-gradient(#db5a5a, #5a5adb, #5adb5a)");
            document.getElementById("modifiers_tricolortiles_info").style.setProperty("background-image", "linear-gradient(#db5a5a, #5a5adb, #5adb5a)");
        }
        else {
            document.getElementById("modifiers_tricolortiles_text").innerHTML = "Tricolor Tiles: OFF";
            document.getElementById("modifiers_tricolortiles_text").style.setProperty("background-image", "linear-gradient(#ae2323, #2323ae, #23ae23)");
            document.getElementById("modifiers_tricolortiles_info").style.setProperty("background-image", "linear-gradient(#ae2323, #2323ae, #23ae23)");
        }
        document.getElementById("modifiers_temporaryHoles_amount_counter").innerHTML = modifiers[25];
        if (modifiers[25] <= 0) document.getElementById("modifiers_temporaryHoles_amount_minus").style.setProperty("display", "none");
        else document.getElementById("modifiers_temporaryHoles_amount_minus").style.setProperty("display", "inline-block");
        if (modifiers[25] >= 99980001) document.getElementById("modifiers_temporaryHoles_amount_plus").style.setProperty("display", "none");
        else document.getElementById("modifiers_temporaryHoles_amount_plus").style.setProperty("display", "inline-block");
        document.getElementById("modifiers_temporaryHoles_interval_counter").innerHTML = modifiers[26];
        if (modifiers[26] <= 1) document.getElementById("modifiers_temporaryHoles_interval_minus").style.setProperty("display", "none");
        else document.getElementById("modifiers_temporaryHoles_interval_minus").style.setProperty("display", "inline-block");
        document.getElementById("modifiers_temporaryHoles_lifespan_counter").innerHTML = modifiers[27];
        if (modifiers[27] <= 1) document.getElementById("modifiers_temporaryHoles_lifespan_minus").style.setProperty("display", "none");
        else document.getElementById("modifiers_temporaryHoles_lifespan_minus").style.setProperty("display", "inline-block");
    }
    else if (page == 6) {
        if (auto_directions.length == 0) {
            document.getElementById("modifiers_emptyAutoMoves_text").style.setProperty("display", "block");
            document.getElementById("modifiers_emptyAutoMoves_button").style.setProperty("display", "block");
            document.getElementById("modifiers_AutoMovesBox").style.setProperty("display", "none");
        }
        else {
            document.getElementById("modifiers_emptyAutoMoves_text").style.setProperty("display", "none");
            document.getElementById("modifiers_emptyAutoMoves_button").style.setProperty("display", "none");
            document.getElementById("modifiers_AutoMovesBox").style.setProperty("display", "flex");
            document.getElementById("modifiers_AutoMoves_counter").innerHTML = "Automatic Move " + (screenVars[0] + 1) + " / " + auto_directions.length;
            if (hexagonal) {
                document.getElementById("modifiers_AutoMoves_vdir_title").innerHTML = "Southeast Movement Magnitude:";
                document.getElementById("modifiers_AutoMoves_hdir_title").innerHTML = "Northeast Movement Magnitude:";
                document.getElementById("modifiers_AutoMoves_vdir_counter").innerHTML = auto_directions[screenVars[0]][0][1]/2 + auto_directions[screenVars[0]][0][0]/2;
                document.getElementById("modifiers_AutoMoves_hdir_counter").innerHTML = auto_directions[screenVars[0]][0][1]/2 - auto_directions[screenVars[0]][0][0]/2;
            }
            else {
                document.getElementById("modifiers_AutoMoves_vdir_title").innerHTML = "Vertical Movement Magnitude:";
                document.getElementById("modifiers_AutoMoves_hdir_title").innerHTML = "Horizontal Movement Magnitude:";
                document.getElementById("modifiers_AutoMoves_vdir_counter").innerHTML = auto_directions[screenVars[0]][0][0];
                document.getElementById("modifiers_AutoMoves_hdir_counter").innerHTML = auto_directions[screenVars[0]][0][1];
            }
            if (auto_directions[screenVars[0]][0][2] == Infinity) document.getElementById("modifiers_AutoMoves_slideAmount_counter").innerHTML = "&infin;";
            else document.getElementById("modifiers_AutoMoves_slideAmount_counter").innerHTML = auto_directions[screenVars[0]][0][2];
            if (auto_directions[screenVars[0]][2][0] == Infinity) document.getElementById("modifiers_AutoMoves_frequency_counter").innerHTML = "&infin;";
            else document.getElementById("modifiers_AutoMoves_frequency_counter").innerHTML = auto_directions[screenVars[0]][2][0];
            document.getElementById("modifiers_AutoMoves_firstTurn_counter").innerHTML = auto_directions[screenVars[0]][2][1];
            if (auto_directions.length > 1) {
                document.getElementById("modifiers_AutoMoves_previous").style.setProperty("display", "inline-block");
                document.getElementById("modifiers_AutoMoves_next").style.setProperty("display", "inline-block");
            }
            else {
                document.getElementById("modifiers_AutoMoves_previous").style.setProperty("display", "none");
                document.getElementById("modifiers_AutoMoves_next").style.setProperty("display", "none");
            }
            if (auto_directions[screenVars[0]][0][2] == Infinity) document.getElementById("modifiers_AutoMoves_slideAmount_minus").style.setProperty("display", "none");
            else document.getElementById("modifiers_AutoMoves_slideAmount_minus").style.setProperty("display", "flex");
            if (auto_directions[screenVars[0]][2][0] == Infinity) document.getElementById("modifiers_AutoMoves_frequency_minus").style.setProperty("display", "none");
            else document.getElementById("modifiers_AutoMoves_frequency_minus").style.setProperty("display", "flex");
            if (auto_directions[screenVars[0]][2][1] == 0) document.getElementById("modifiers_AutoMoves_firstTurn_minus").style.setProperty("display", "none");
            else document.getElementById("modifiers_AutoMoves_firstTurn_minus").style.setProperty("display", "flex");
            if (auto_directions[screenVars[0]][0][4][0] == 0) {
                document.getElementById("modifiers_AutoMoves_manualStrength_text").innerHTML = "This automatic move counts as its own separate move."
                document.getElementById("modifiers_AutoMoves_manualStrength_text").style.setProperty("color", "#fc0058");
            }
            else {
                document.getElementById("modifiers_AutoMoves_manualStrength_text").innerHTML = "This automatic move counts as part of the manual move that it triggers during."
                document.getElementById("modifiers_AutoMoves_manualStrength_text").style.setProperty("color", "#8600fc");
            }
            if (auto_directions[screenVars[0]][0][4][1]) {
                document.getElementById("modifiers_AutoMoves_merges_text").innerHTML = "Tiles can be merged during this move."
                document.getElementById("modifiers_AutoMoves_merges_text").style.setProperty("color", "#a8d82c");
            }
            else {
                document.getElementById("modifiers_AutoMoves_merges_text").innerHTML = "Tiles can not be merged during this move."
                document.getElementById("modifiers_AutoMoves_merges_text").style.setProperty("color", "#638019");
            }
            if (auto_directions[screenVars[0]][1] == "Between") {
                document.getElementById("modifiers_AutoMoves_timing_text").innerHTML = "This automatic move occurs after the manual move finishes, but before new tiles spawn."
                document.getElementById("modifiers_AutoMoves_timing_text").style.setProperty("color", "#00bd5f");
            }
            else if (auto_directions[screenVars[0]][1] == "Before") {
                document.getElementById("modifiers_AutoMoves_timing_text").innerHTML = "This automatic move occurs before the manual move begins."
                document.getElementById("modifiers_AutoMoves_timing_text").style.setProperty("color", "#3f9cff");
            }
            else if (auto_directions[screenVars[0]][1] == "After") {
                document.getElementById("modifiers_AutoMoves_timing_text").innerHTML = "This automatic move occurs after the manual move finishes and new tiles have spawned."
                document.getElementById("modifiers_AutoMoves_timing_text").style.setProperty("color", "#7d000a");
            }
            document.getElementById("modifiers_AutoMoves_probability_change").value = auto_directions[screenVars[0]][0][5];
        }
    }
}

//Beginning the game and showing the grid
function startGame() {
    inputAvailable = false;
    switchScreen("Gameplay", "Main");
    for (let d = 0; d < directionsAvailable.length; d++) directionsAvailable[d] = true;
    possibleOverChecked = false;
    score = 0;
    won = 0;
    moves_so_far = 0;
    merges_so_far = 0;
    moves_where_merged = 0;
    merges_before_now = 0;
    discoveredTiles = [];
    discoveredWinning = [];
    discoveredLosing = [];

    Grid = [];
    tsize = 0;
    GridTiles = [];
    visibleNextTiles = [];
    if (gamemode != 0) nextTiles = modifiers[14]; //This isn't part of loadModifiers because it needs to happen before createGrid
    knownTileDisplayArrays = [];
    knownTileDisplayNodes = [];
    knownMergeResultInputs = [];
    knownMergeResultOutputs = [];
    createGrid((gamemode != 0));
    Grid = compendiumStructuredClone(startingGrid);
    loadModifiers();
    loadResettingModifiers();
    createArrows();
    createStatBoxes();
    TileSpawns = compendiumStructuredClone(startTileSpawns);
    game_vars = compendiumStructuredClone(start_game_vars);
    modifier_vars = compendiumStructuredClone(start_modifier_vars);
    SpawnBoxes = [];
    for (let i = 0; i < TileSpawns.length; i++) {
        SpawnBoxes.push([]);
        if (TileSpawns[i][0] == "Box") refillSpawnBox(i);
    }
    spawnConveyor = [];
    for (let i = 0; i < Math.max(nextTiles, 1); i++) spawnConveyor.push("@Empty");
    refillSpawnConveyor();
    forcedSpawnTiles("BeforeSpawns", 0, 0);
    RandomTiles(startTileAmount, 0, 0);
    forcedSpawnTiles("AfterSpawns", 0, 0);
    displayButtons(true);
    inputAvailable = true;
}

function createGrid() {
    let makeStart = true; //Normally, createGrid creates the starting grid, but if this is false, the starting grid is preserved and createGrid just makes the HTML tiles
    if (arguments.length > 0) makeStart = arguments[0];
    while (document.getElementById("grid").lastElementChild) document.getElementById("grid").removeChild(document.getElementById("grid").lastElementChild);
    while (document.getElementById("next_tiles").lastElementChild) document.getElementById("next_tiles").removeChild(document.getElementById("next_tiles").lastElementChild);
    if (gamemode != 0) {
        if (modifiers[5] == "Diamond") {
            width = modifiers[6] * 2 + 1;
            height = modifiers[6] * 2 + 1;
        }
        else if (modifiers[5] == "Hexagon") {
            width = modifiers[6] * 4 + 1;
            height = modifiers[6] * 2 + 1;
        }
        else if (modifiers[5] == "HexaTriangle") {
            let size = 0;
            if (modifiers[6] % 4 == 3) size = (modifiers[6] + 1)/2;
            else if (modifiers[6] % 4 == 1) size = (modifiers[6] - 1)/2
            else size = modifiers[6]/2;
            width = size * 4 + 1;
            height = size * 2 + 1;
        }
        else if (modifiers[5] == "4D") {
            width = modifiers[6] * modifiers[8] + modifiers[8] - 1;
            height = modifiers[7] * modifiers[9] + modifiers[9] - 1;
        }
    }
    let BlackBox = ["BlackBox"]; // From the "Randomly-Placed Box Tiles" modifier
    for (let i = 1; i < TileNumAmount; i++) BlackBox.push(0);
    if (makeStart && modifiers[5] != "Custom") startingGrid = [];
    let varHeight = (hexagonal ? (height * 2 - 1) : height)
    document.documentElement.style.setProperty("--width", width);
    document.documentElement.style.setProperty("--height", varHeight);
    tsize = 100 * Math.min(1, width/varHeight)/(hexagonal ? (width + 1)/2 * (width > 1 ? Math.sqrt(3) / 2 : 1) : width);
    document.documentElement.style.setProperty("--tile_size", tsize * 0.9 + "%");
    document.documentElement.style.setProperty("--th_dist", tsize * (1 - 0.1 * 1/(width + 1)) * Math.max(1, varHeight/width) * (hexagonal ? Math.sqrt(3)/4 : 1));
    document.documentElement.style.setProperty("--tv_dist", tsize * (1 - 0.1 * 1/(height + 1)) * Math.max(1, width/varHeight) * (hexagonal ? 3/4 : 1));
    for (let row = 0; row < height; row++) {
        if (makeStart && modifiers[5] != "Custom") startingGrid.push([]);
        for (let column = 0; column < width; column++) {
            if (makeStart && modifiers[5] != "Custom") {
                if (hexagonal && ((row + column + (height - 1)/2) % 2 == 1)) startingGrid[row].push("@Void");
                else if (modifiers[5] == "Diamond" && ((Math.abs(row - modifiers[6]) + Math.abs(column - modifiers[6])) > modifiers[6])) startingGrid[row].push("@Void");
                else if (modifiers[5] == "Checkerboard" && (row + column) % 2 == 1) startingGrid[row].push("@Void");
                else if (modifiers[5] == "Hexagon" && (Math.abs(row - modifiers[6]) + Math.abs(column - modifiers[6] * 2)) > modifiers[6] * 2) startingGrid[row].push("@Void");
                else if (modifiers[5] == "HexaTriangle" && ((Math.abs(row - (height - 1 - (modifiers[6] % 4 == 0 ? 1 : 0))) + Math.abs(column - (width - 1)/2)) > modifiers[6] || row > (height - 1 - (modifiers[6] % 4 == 0 ? 1 : 0)))) startingGrid[row].push("@Void");
                else if (modifiers[5] == "4D" && ((row + 1) % (modifiers[7] + 1) == 0 || (column + 1) % (modifiers[6] + 1) == 0)) startingGrid[row].push("@Void");
                else startingGrid[row].push("@Empty");
            }
            if (modifiers[5] == "Custom" && startingGrid[row][column] == "@BlackBox" || (Array.isArray(startingGrid[row][column]) && startingGrid[row][column][0] == "BlackBox")) {
                startingGrid[row][column] = compendiumStructuredClone(BlackBox);
            }
            if ((row + column + (height - 1)/2) % 2 == 0 || !hexagonal) {
                let newEmpty = document.createElement("div");
                newEmpty.id = "Empty_" + row + "_" + column;
                newEmpty.classList.add("empty_tile");
                if (hexagonal) newEmpty.classList.add("hexagon_clip");
                document.getElementById("grid").appendChild(newEmpty);
            }
        }
    }
    GridTiles = document.getElementById("grid").children; //An HTML collection of the empty tiles
    let Positions = [];
    for (let row = 0; row < height; row++) {
        Positions.push([]);
        for (let column = 0; column < width; column++) {
            Positions[row].push([]);
        }
    }
    for (let t of GridTiles) {
        let char = 6;
        let hcoord = "";
        let vcoord = "";
        while (t.id[char] != "_") {vcoord += t.id[char]; char++;}
        char++;
        while (char < t.id.length) {hcoord += t.id[char]; char++;}
        hcoord = Number(hcoord);
        vcoord = Number(vcoord);
        let hsize = Number(getComputedStyle(document.documentElement).getPropertyValue("--th_dist"));
        let vsize = Number(getComputedStyle(document.documentElement).getPropertyValue("--tv_dist"));
        let offset = 0.075 * (hexagonal ? Math.sqrt(3)/4 : 1)
        t.style.setProperty("left", hsize * (offset + hcoord) + "%");
        t.style.setProperty("top", vsize * (offset + vcoord) + (hexagonal ? (2 - Math.sqrt(3))*25*(1 - 1/height) : 0) + "%");
        Positions[vcoord][hcoord] = [hsize * (offset + hcoord), vsize * (offset + vcoord) + (hexagonal ? (2 - Math.sqrt(3))*25*(1 - 1/height) : 0)];
        let newTile = document.createElement("div");
        newTile.id = "Tile_" + vcoord + "_" + hcoord;
        newTile.classList.add("tile");
        if (hexagonal) newTile.classList.add("hexagon_clip");
        t.appendChild(newTile);
        let newTilep = document.createElement("p");
        let newTilet = document.createTextNode("");
        newTilep.appendChild(newTilet);
        t.firstElementChild.appendChild(newTilep);
        newTilep.classList.add("tile_text");
    }
    if (nextTiles == 0) document.getElementById("next_tiles_container").style.setProperty("display", "none");
    else {
        document.getElementById("next_tiles_container").style.setProperty("display", "inline-block");
        for (let nx = 0; nx < nextTiles; nx++) {
            let newNext = document.createElement("div");
            newNext.id = "nextTile_" + nx;
            newNext.classList.add("next_tile");
            if (hexagonal) newNext.classList.add("hexagon_clip");
            document.getElementById("next_tiles").appendChild(newNext);
            let newTilep = document.createElement("p");
            let newTilet = document.createTextNode("");
            newTilep.appendChild(newTilet);
            newNext.appendChild(newTilep);
            newTilep.classList.add("tile_text");
        }
    }
    visibleNextTiles = document.getElementById("next_tiles").children;
}

function createArrows() {
    while (document.getElementById("arrow-container").children.length > 0) document.getElementById("arrow-container").removeChild(document.getElementById("arrow-container").lastElementChild);
    directionsAvailable = [];
    for (let d = 0; d < directions.length; d++) {
        directionsAvailable.push(true);
        let newArrow = document.createElement("div");
        newArrow.id = "Arrow_" + d;
        newArrow.classList.add("arrow");
        newArrow.classList.add("button");
        newArrow.classList.add("hover_grow");
        document.getElementById("arrow-container").appendChild(newArrow);
        let newArrowp = document.createElement("p");
        newArrow.appendChild(newArrowp);
        newArrowp.innerHTML = directions[d][1];
        newArrow.style.setProperty("width", directions[d][2] * 100 + "%");
        newArrow.style.setProperty("height", directions[d][3] * 100 + "%");
        newArrow.style.setProperty("border-width", "calc(0.04vw * var(--grid_vw) *" + Math.min(directions[d][2], directions[d][3]) + ")");
        newArrow.style.setProperty("font-size", "calc(1vw * var(--grid_vw) *" + directions[d][4] + ")");
        newArrow.style.setProperty("top", directions[d][5] * 100 + "%");
        newArrow.style.setProperty("left", directions[d][6] * 100 + "%");
        if (directions[d].length > 8) newArrowp.style.setProperty("rotate", directions[d][8] + "deg");
        newArrow.addEventListener("click",  function(){
            if (!inputAvailable || currentScreen != "Gameplay") return;
            if (directionsAvailable[d]) MoveHandler(d);
        }
        )
    }
}

function createStatBoxes() {
    while (document.getElementById("score_line").children.length > 0) document.getElementById("score_line").removeChild(document.getElementById("score_line").lastElementChild);
    while (document.getElementById("bottom_score_line").children.length > 0) document.getElementById("bottom_score_line").removeChild(document.getElementById("bottom_score_line").lastElementChild);
    for (let b = 0; b < statBoxes.length; b++) {
        let newBox = document.createElement("div");
        newBox.id = "stat_container_" + b;
        newBox.classList.add("stat_container");
        if (statBoxes[b].length > 2 && statBoxes[b][2]) {
            document.getElementById("bottom_score_line").appendChild(newBox);
        }
        else {
            document.getElementById("score_line").appendChild(newBox);
        }
        if (statBoxes[b].length > 3 && statBoxes[b][3]) {
            newBox.style.setProperty("margin-left", "50%");
            newBox.style.setProperty("margin-right", "50%");
        }
        let title = document.createElement("p");
        title.id = "stat_title_" + b;
        title.classList.add("stat_title");
        if (statBoxes[b][0].length < 8) title.style.setProperty("font-size", "100%");
        else title.style.setProperty("font-size", "calc(75% *" + Math.min(1, Math.sqrt(20/statBoxes[b][0].length)) + ")");
        title.innerHTML = CalcArray(statBoxes[b][0]);
        newBox.appendChild(title);
        if (statBoxes[b].length > 4 && (statBoxes[b][4] == "Tile" || statBoxes[b][4] == "TileArray")) {
            let container = document.createElement("div");
            container.id = "stat_counter_" + b;
            container.classList.add("stat_tiles");
            newBox.appendChild(container);
        }
        else {
            let counter = document.createElement("p");
            counter.id = "stat_counter_" + b;
            counter.classList.add("stat_counter");
            counter.innerHTML = "0";
            newBox.appendChild(counter);
        }
        if (statBoxes[b][7] !== undefined) {
            newBox.addEventListener("click", function(){
                if (inputAvailable && (currentScreen == "Gameplay" || statBoxes[b][13] === undefined || CalcArray(statBoxes[13]) === true)) {
                    inputAvailable = false;
                    CalcArray(statBoxes[b][7]);
                    displayGrid();
                    inputAvailable = true;
                }
            })
        }
    }
}

function defaultAbbreviate(n) { // Tiles whose text values are of type number, bigint, GaussianBigInt, or BigRational (which is currently all of them except Garbage 0s, Box Tiles, and a couple special tiles in modes like 2216.838) use this
    if (typeof n == "number") {
        if (Math.abs(n) < 10000 && Math.abs(n) >= 0.1) return abbreviateNumber(n, "Number", 3, false);
        else if (Math.abs(n) >= 10000 && Math.abs(n) < 1e12) return abbreviateNumber(n, "Number", 3, true);
        else return abbreviateNumber(n, "Scientific", 5, true);
    }
    else if (typeof n == "bigint") {
        if (abs(n) < 10000) return String(n);
        else return abbreviateNumber(n, "BigInt", 0, true);
    }
    else if (n instanceof GaussianBigInt) {
        if (n.imaginary == 0n)
            return defaultAbbreviate(n.real);
        else if (n.real == 0n)
            return defaultAbbreviate(n.imaginary) + "i";
        else if (n.imaginary < 0n)
            return defaultAbbreviate(n.real) + "-" +  defaultAbbreviate(n.imaginary * -1n) + "i";
        else
            return defaultAbbreviate(n.real) + "+" +  defaultAbbreviate(n.imaginary) + "i";
    }
    else if (n instanceof BigRational) {
        return abbreviateNumber(n, "BigRational", 0, true, 10000n);
    }
    else return n;
}

function displayGrid() {
    for (let t of GridTiles) { //Displaying the tiles on the grid
        let char = 6;
        let hcoord = "";
        let vcoord = "";
        while (t.id[char] != "_") {vcoord += t.id[char]; char++;}
        char++;
        while (char < t.id.length) {hcoord += t.id[char]; char++;}
        hcoord = Number(hcoord);
        vcoord = Number(vcoord);
        let tile = t.firstElementChild;
        if (Grid[vcoord][hcoord] == "@Void") tile.parentElement.style.setProperty("display", "none");
        else tile.parentElement.style.setProperty("display", "inline-block");
        if (Grid[vcoord][hcoord].includes("@TemporaryHole")) {
            tile.parentElement.style.setProperty("--this-tile-color", "transparent");
            tile.parentElement.style.setProperty("--this-tile-image", "none");
        }
        else {
            tile.parentElement.style.setProperty("--this-tile-color", "var(--tile-color)");
            tile.parentElement.style.setProperty("--this-tile-image", "var(--tile-image)");
            if (Grid[vcoord][hcoord] == "@Slippery") {
                let currentimage = getComputedStyle(document.documentElement).getPropertyValue("--tile-image");
                let slipperyimage = (hexagonal) ? 'url("SlipperyHexagonal.png")' : 'url("Slippery.png")';
                if (currentimage == "none") currentimage = slipperyimage;
                else currentimage += ", " + slipperyimage;
                tile.parentElement.style.setProperty("--this-tile-image", currentimage);
            }
        }
        displayTile("Grid", tile, vcoord, hcoord, Grid, Grid[vcoord][hcoord]);
    }
    for (let t of visibleNextTiles) {  //Displaying the next spawning tiles
        let char = 9;
        let nextnum = "";
        while (char < t.id.length) {nextnum += t.id[char]; char++;}
        nextnum = Number(nextnum);
        let tile = t;
        displayTile("NextTiles", tile, nextnum, "None", spawnConveyor, spawnConveyor[nextnum]);
        if (nextnum < randomTileAmount) tile.style.setProperty("border-style", "solid");
        else tile.style.setProperty("border-style", "none");
    }
    for (let b = 0; b < statBoxes.length; b++) {
        let box = document.getElementById("stat_container_" + b);
        let counter = document.getElementById("stat_counter_" + b);
        let title = document.getElementById("stat_title_" + b);
        if (statBoxes[b][6] !== undefined && CalcArray(statBoxes[b][6]) == false) {
            box.style.setProperty("display", "none");
        }
        else {
            box.style.setProperty("display", "flex");
            title.innerHTML = CalcArray(statBoxes[b][0]);
            if (statBoxes[b].length > 4 && (statBoxes[b][4] == "Tile" || statBoxes[b][4] == "TileArray")) {
                while (counter.lastElementChild) counter.removeChild(counter.lastElementChild);
                let tiles = compendiumStructuredClone(CalcArray(statBoxes[b][1]));
                if (statBoxes[b][4] == "Tile") tiles = [tiles];
                for (let t = 0; t < tiles.length; t++) {
                    let newTile = document.createElement("div");
                    newTile.id = "stat_tile_" + b + "_" + t;
                    if (statBoxes[b][4] == "Tile") newTile.classList.add("stat_tile")
                    else newTile.classList.add("stat_array_tile");
                    if (hexagonal) newTile.classList.add("hexagon_clip")
                    counter.appendChild(newTile);
                    let newTilep = document.createElement("p");
                    let newTilet = document.createTextNode("");
                    newTilep.appendChild(newTilet);
                    newTile.appendChild(newTilep);
                    newTilep.classList.add("tile_text");
                    if (!Array.isArray(tiles[t])) tiles[t] = [tiles[t]];
                    if (statBoxes[b][4] == "Tile") {
                        if (statBoxes[b][5] == "Self") displayTile("ScoreSelf", newTile, "None", "None", tiles[t], tiles[t]);
                        else displayTile("Score", newTile, "None", "None", tiles[t], [true, "@This 0", "@ColorScheme", statBoxes[b][5], ["@This 0"]]);
                    }
                    else {
                        if (statBoxes[b][5] == "Self") displayTile("ScoreArraySelf", newTile, "None", "None", tiles[t], tiles[t]);
                        else displayTile("ScoreArray", newTile, "None", "None", tiles[t], [true, "@This 0", "@ColorScheme", statBoxes[b][5], ["@This 0"]]);
                    }
                }
            }
            else counter.innerHTML = defaultAbbreviate(CalcArray(statBoxes[b][1]));
            if (statBoxes[b][8] !== undefined) {
                if (typeof statBoxes[b][8] == "string") box.style.setProperty("border", statBoxes[b][8]);
                else if (statBoxes[b][8] === false) box.style.setProperty("border", "none");
                else if (statBoxes[b][8] === true) {
                    let sizeExpression = 1;
                    let size = "calc(1vw * var(--grid_vw) * " + sizeExpression + " * " + 0.005 + ") ";
                    let color = getComputedStyle(document.documentElement).getPropertyValue("--text-color");
                    let border = size + "solid " + color;
                    box.style.setProperty("border", border);
                }
                else if (Array.isArray(statBoxes[b][8]) && statBoxes[b][8].length > 0) {
                    let sizeExpression = 1;
                    let size = "calc(1vw * var(--grid_vw) * " + sizeExpression + " * " + statBoxes[b][8][0] + ") ";
                    let color;
                    if (statBoxes[b][8][1] === undefined) color = getComputedStyle(document.documentElement).getPropertyValue("--text-color");
                    else color = evaluateColor(statBoxes[b][8][1]);
                    let border = size + "solid " + color;
                    box.style.setProperty("border", border);
                }
            }
            else box.style.setProperty("border", "none");
            if (statBoxes[b][9] === undefined) box.style.setProperty("background-color", getComputedStyle(document.documentElement).getPropertyValue("--grid-color"));
            else box.style.setProperty("background-color", evaluateColor(statBoxes[b][9]));
            if (statBoxes[b][10] === undefined) counter.style.setProperty("color", "#ffffff");
            else counter.style.setProperty("color", evaluateColor(statBoxes[b][10]));
            if (statBoxes[b][11] === undefined) title.style.setProperty("color", getComputedStyle(document.documentElement).getPropertyValue("--text-color"));
            else title.style.setProperty("color", evaluateColor(statBoxes[b][11]));
            if (statBoxes[b][12] !== undefined) {
                if (typeof statBoxes[b][12] == "string") box.style.setProperty("box-shadow", statBoxes[b][12]);
                else if (statBoxes[b][12] === false) box.style.setProperty("box-shadow", "none");
                else if (Array.isArray(statBoxes[b][12]) && statBoxes[b][12].length > 2) {
                    let sizeExpression = 1;
                    let offset1 = "calc(1vw * var(--grid_vw) * " + sizeExpression + " * " + statBoxes[b][12][0] + ") ";
                    let offset2 = "calc(1vw * var(--grid_vw) * " + sizeExpression + " * " + statBoxes[b][12][1] + ") ";
                    let blur = "calc(1vw * var(--grid_vw) * " + sizeExpression + " * " + statBoxes[b][12][2] +  ") ";
                    let color;
                    if (statBoxes[b][8][3] === undefined) color = getComputedStyle(document.documentElement).getPropertyValue("--text-color");
                    else color = evaluateColor(statBoxes[b][12][3]);
                    let shadow = offset1 + offset2 + blur + color;
                    box.style.setProperty("box-shadow", shadow);
                }
            }
            else box.style.setProperty("box-shadow", "none");
        }
    }
    if (screen.width/screen.height > 1.2) {
        document.getElementById("left_of_grid").style.setProperty("top", getComputedStyle(document.getElementById("score_line")).getPropertyValue("height"));
    }
    else {
        document.getElementById("left_of_grid").style.setProperty("top", "");
    }
}

function displayTile(dType, tile, vcoord, hcoord, container, location) {
    let sizeExpression = 0;
    let knownDisplayIndex = -2;
    tile.style.setProperty("background-image", "none");
    if (location == "@Empty" || location == "@Void" || location == "@Slippery") {tile.style.setProperty("display", "none");}
    else {
        if (dType != "Subtile") {
            tile.style.setProperty("display", "flex"); //Flex display is so the number of the tile can be centered on the tile
            tile.style.setProperty("left", "0%");
            tile.style.setProperty("top", "0%");
            while (tile.children.length > 1) tile.removeChild(tile.lastElementChild);
        }
        let displaynum = 0;
        let displayfound = false;
        let display = [];
        let vars = [];
        if (location.includes("@TemporaryHole")) {
            let text_color = getComputedStyle(document.documentElement).getPropertyValue("--text-color");
            let faint_color = convertColor(text_color, "@HSLA");
            faint_color[4] *= 0.3;
            display = ["@TemporaryHole", Number(location.slice(15)), ["@radial-gradient", "#0004", "#0000", 75], faint_color, "none", 3, -1.05]
        }
        else if (dType == "Subtile" || dType == "Score" || dType == "ScoreArray" || dType == "Viewer") {
                display = compendiumStructuredClone(location);
                if (display[0] === "@include_gvars") {
                    let newvars = compendiumStructuredClone(game_vars);
                    for (let v = 0; v < newvars.length; v++) {
                        newvars[v] = CalcArrayConvert(newvars[v], "=", "None", "None", 0, 0, [1, Infinity, 0], container, [], vars);
                        if (Array.isArray(newvars[v])) newvars[v].unshift("@Literal");
                        vars.push(newvars[v]);
                    }
                    display.shift();
                }
                if (display.indexOf("@end_vars") > -1) {
                    let newvars = display.slice(0, display.indexOf("@end_vars"));
                    for (let v = 0; v < newvars.length; v++) {
                        newvars[v] = CalcArrayConvert(newvars[v], "=", "None", "None", 0, 0, [1, Infinity, 0], container, [], vars);
                        if (Array.isArray(newvars[v])) newvars[v].unshift("@Literal");
                        vars.push(newvars[v]);
                    }
                    display.splice(0, display.indexOf("@end_vars") + 1);
                }
            }
        else {
            knownDisplayIndex = indexOfPrimArray([location, dType], knownTileDisplayArrays);
            if (knownDisplayIndex != -1) {
                let emptyParent = tile.parentElement;
                let thisID = tile.id;
                let displayCopy = knownTileDisplayNodes[knownDisplayIndex].cloneNode(true);
                displayCopy.id = thisID;
                emptyParent.replaceChild(displayCopy, tile);
                displayCopy.style.setProperty("display", "flex");
                displayCopy.style.setProperty("left", "0%");
                displayCopy.style.setProperty("top", "0%");
                return;
            }
            while (!displayfound && displaynum < TileTypes.length) {
                display = compendiumStructuredClone(TileTypes[displaynum]);
                if (display[0] === "@include_gvars") {
                    let newvars = compendiumStructuredClone(game_vars);
                    for (let v = 0; v < newvars.length; v++) {
                        newvars[v] = CalcArrayConvert(newvars[v], "=", vcoord, hcoord, 0, 0, [1, Infinity, 0], container, [], vars);
                        if (Array.isArray(newvars[v])) newvars[v].unshift("@Literal");
                        vars.push(newvars[v]);
                    }
                    display.shift();
                }
                if (display.indexOf("@end_vars") > -1) {
                    let newvars = display.slice(0, display.indexOf("@end_vars"));
                    for (let v = 0; v < newvars.length; v++) {
                        newvars[v] = CalcArrayConvert(newvars[v], "=", vcoord, hcoord, 0, 0, [1, Infinity, 0], container, [], vars);
                        if (Array.isArray(newvars[v])) newvars[v].unshift("@Literal");
                        vars.push(newvars[v]);
                    }
                    display.splice(0, display.indexOf("@end_vars") + 1);
                }
                if (eqPrimArrays(display[0], location) || (CalcArray(display[0], vcoord, hcoord, 0, 0, [1, Infinity, 0], container, [], vars) === true)) displayfound = true;
                else displaynum++;
            }
        }
        if (displaynum >= TileTypes.length) {displaynum = TileTypes.length - 1;}
        let extraentries = [];
        if (dType != "Subtile") {
            if (hiddenTileText) tile.firstElementChild.innerHTML = "";
            else {
                tile.firstElementChild.innerHTML = defaultAbbreviate(CalcArray(display[1], vcoord, hcoord, 0, 0, [1, Infinity, 0], container, [], vars));
                let fontmin = 2;
                let fontmax = tile.firstElementChild.textContent.length * 0.7;
                //Normally, the font size on a tile is dependent on the size of the text, but if the TileTypes entry has more than four entries, the 4th and 5th entries place restrictions on the font size
                if (display[5] !== undefined) {
                    if (Array.isArray(display[5])) fontmin = CalcArray(display[5], vcoord, hcoord, 0, 0, [1, Infinity, 0], container, [], vars);
                    else fontmin = display[5];
                    if (fontmin == 0) fontmin = 2;
                    if (fontmin < 0) fontmin = tile.firstElementChild.textContent.length * Math.abs(fontmin);
                }
                if (display[6] !== undefined) {
                    if (Array.isArray(display[6])) fontmax = CalcArray(display[6], vcoord, hcoord, 0, 0, [1, Infinity, 0], container, [], vars);
                    else fontmax = display[6];
                    if (fontmax == 0) fontmax = -0.7;
                    if (fontmax < 0) fontmax = tile.firstElementChild.textContent.length * Math.abs(fontmax);
                }
                if (dType == "Viewer") tile.style.setProperty("font-size", "calc(var(--secondary_size) * " + (40 / Math.max(fontmin, fontmax)) * (hexagonal ? Math.sqrt(3)/2 : 1) + ")");
                else {
                    if (dType == "Grid") sizeExpression = (tsize / 100 / Math.max(fontmin, fontmax));
                    else if (dType == "Score" || dType == "ScoreSelf") sizeExpression = (6/33 / Math.max(fontmin, fontmax));
                    else sizeExpression = (4/33 / Math.max(fontmin, fontmax));
                    sizeExpression *= ((hexagonal) ? Math.sqrt(3)/2 : 1)
                    tile.style.setProperty("font-size", "calc(1vw * var(--grid_vw) * " + sizeExpression + ")");
                }
            }
        }
        if (display[2] != "@ColorScheme") {
            let dispbackground = evaluateColor(display[2], vcoord, hcoord, container, vars);
            if (dispbackground.includes("gradient")) {
                tile.style.setProperty("background-image", (dispbackground));
                tile.style.setProperty("background-color", "transparent");
            }
            else {
                tile.style.setProperty("background-color", (dispbackground));
                tile.style.setProperty("background-image", "none");
            }
            tile.style.setProperty("color", (evaluateColor(display[3], vcoord, hcoord, container, vars)));
            tile.style.setProperty("text-shadow", "none");
            if (display[4] !== undefined) {
                if (typeof display[4] == "string") tile.style.setProperty("text-shadow", display[4]);
                else if (Array.isArray(display[4]) && display[4].length > 3) {
                    let offset1 = "calc(1vw * var(--grid_vw) * " + sizeExpression + " * " + display[4][0] + ") ";
                    let offset2 = "calc(1vw * var(--grid_vw) * " + sizeExpression + " * " + display[4][1] + ") ";
                    let blur = "calc(1vw * var(--grid_vw) * " + sizeExpression + " * " + display[4][2] +  ") ";
                    let color = evaluateColor(display[4][3], vcoord, hcoord, container, vars);
                    let shadow = offset1 + offset2 + blur + color;
                    tile.style.setProperty("text-shadow", shadow);
                }
            }
        }
        else {
            let value;
            let params = [];
            // defaults
            tile.style.setProperty("background-color", "#000000");
            tile.style.setProperty("background-image", "none");
            tile.style.setProperty("color", "#ffffff");
            tile.style.setProperty("text-shadow", "none");
            if (display[4].length > 0) {
                value = CalcArray(display[4][0], vcoord, hcoord, 0, 0, [1, Infinity, 0], container, [], vars);
                params = display[4].slice(1);
            }
            else {
                value = CalcArray(display[1], vcoord, hcoord, 0, 0, [1, Infinity, 0], container, [], vars)
            }
            if (display[3] == "Wildcard 2048") {
                value = Number(value);
                let negative = false;
                if (value < 0) {
                    negative = true;
                    value = abs(value);
                }
                let textColor = "#f9f6f2";
                let values = [1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096, 8192, 16384, 32768, 65536, 131072, 262144, 524288, [["@Var -1", ">=", 1048576], [2, "^", ["@var_retain", "@Var -1", "+", 0.5, "log", 2, "floor", 1]]]];
                let colors = ["#89817b", "#aa937f", "#c69d79", "#f2b179", "#f59563", "#f67c5f", "#f65e3b", "#edcf72", "#edcc61", "#edc850", "#edc53f", "#edc22e", "#f29eff", "#eb75fd", "#e53bff", "#bd00db", "#770089", "#534de8", "#2922e1", "#0a05b6", ["@HSLA", ["@var_retain", -15, "*", ["@var_retain", "@Var -1", "+", 0.5, "log", 2, "floor", 1], "+", 520], 100, ["@var_retain", 0.9, "^", ["@var_retain", "@Var -1", "+", 0.5, "log", 2, "floor", 1, "-", 20], "*", 36], 1]];
                let remaining = value;
                let gradientArray = [];
                let textArray = [];
                if (value == 0) {
                    textColor = "#808080";
                    gradientArray = ["#ffffff"];
                    textArray = ["0"];
                }
                else while (remaining > 0) {
                    let testedvalue = 0;
                    let nextvalue = 0;
                    let nextentry = -1;
                    NextValueFinder: {
                        for (let i = 0; i < values.length; i++) {
                            if (Array.isArray(values[i])) {
                                let allowanceArray = compendiumStructuredClone(values[i][0]);
                                let vpos = 0;
                                if (allowanceArray.indexOf("@end_vars") > -1) {
                                    vpos = allowanceArray.indexOf("@end_vars") - 1;
                                    allowanceArray.splice(vpos, 0, remaining);
                                }
                                else {
                                    if (allowanceArray[0] == "@var_retain" || allowanceArray[0] == "@var_copy") vpos = 1;
                                    allowanceArray.splice(vpos, 0, remaining, "@end_vars");
                                }
                                if (CalcArray(allowanceArray, vcoord, hcoord, 0, 0, [1, Infinity, 0], container, [], vars)) {
                                    let valueArray = compendiumStructuredClone(values[i][1]);
                                    let vpos = 0;
                                    if (valueArray.indexOf("@end_vars") > -1) {
                                        vpos = valueArray.indexOf("@end_vars") - 1;
                                        valueArray.splice(vpos, 0, remaining);
                                    }
                                    else {
                                        if (valueArray[0] == "@var_retain" || valueArray[0] == "@var_copy") vpos = 1;
                                        valueArray.splice(vpos, 0, remaining, "@end_vars");
                                    }
                                    testedvalue = CalcArray(valueArray, vcoord, hcoord, 0, 0, [1, Infinity, 0], container, [], vars);
                                }
                                else continue;
                            }
                            else testedvalue = values[i];
                            if (testedvalue <= remaining && testedvalue >= nextvalue) {
                                nextvalue = testedvalue;
                                nextentry = i;
                            }
                        }
                    }
                    let color = compendiumStructuredClone(colors[nextentry]);
                    if (negative) color = ["@rotate", 180, true, color];
                    if (Array.isArray(color)) {
                        let vpos = 0;
                        if (color.indexOf("@end_vars") > -1) {
                            vpos = color.indexOf("@end_vars") - 1;
                            color.splice(vpos, 0, remaining);
                        }
                        else {
                            if (color[0] == "@var_retain" || color[0] == "@var_copy") vpos = 1;
                            color.splice(vpos, 0, remaining, "@end_vars");
                        }
                    }
                    gradientArray.unshift(evaluateColor(color, vcoord, hcoord, container, vars));
                    if (negative) {
                        if (typeof value == "number") textArray.unshift(defaultAbbreviate(nextvalue * -1));
                        else if (typeof value == "bigint") textArray.unshift(defaultAbbreviate(nextvalue * -1n));
                        else textArray.unshift(defaultAbbreviate(nextvalue));
                    }
                    else textArray.unshift(defaultAbbreviate(nextvalue));
                    remaining -= nextvalue;
                }
                let background = [];
                for (let c = 0; c < gradientArray.length; c++) {
                    background.push(gradientArray[c], 100 * c / gradientArray.length, 100 * (c + 1) / gradientArray.length);
                }
                tile.style.setProperty("background-image", (evaluateColor(["@linear-gradient", 90].concat(background), vcoord, hcoord, container, vars)));
                if (negative) textColor = ["@rotate", 180, true, textColor];
                tile.style.setProperty("color", (evaluateColor(textColor, vcoord, hcoord, container, vars)));
                if (params.length > 0 && params[0]) {
                    tile.firstElementChild.innerHTML = textArray.join(" ");
                    let fontmin = 2;
                    let fontmax = tile.firstElementChild.textContent.length * 0.7;
                    if (display[5] !== undefined) {
                        if (Array.isArray(display[5])) fontmin = CalcArray(display[5], vcoord, hcoord, 0, 0, [1, Infinity, 0], container, [], vars);
                        else fontmin = display[5];
                        if (fontmin == 0) fontmin = 2;
                        if (fontmin < 0) fontmin = tile.firstElementChild.textContent.length * Math.abs(fontmin);
                    }
                    if (display[6] !== undefined) {
                        if (Array.isArray(display[6])) fontmax = CalcArray(display[6], vcoord, hcoord, 0, 0, [1, Infinity, 0], container, [], vars);
                        else fontmax = display[6];
                        if (fontmax == 0) fontmax = -0.7;
                        if (fontmax < 0) fontmax = tile.firstElementChild.textContent.length * Math.abs(fontmax);
                    }
                    if (dType == "Viewer") tile.style.setProperty("font-size", "calc(var(--secondary_size) * " + (40 / Math.max(fontmin, fontmax)) * (hexagonal ? Math.sqrt(3)/2 : 1) + ")");
                    else {
                        if (dType == "Grid") sizeExpression = (tsize / 100 / Math.max(fontmin, fontmax));
                        else if (dType == "Score" || dType == "ScoreSelf") sizeExpression = (6/33 / Math.max(fontmin, fontmax));
                        else sizeExpression = (4/33 / Math.max(fontmin, fontmax));
                        sizeExpression *= ((hexagonal) ? Math.sqrt(3)/2 : 1)
                        tile.style.setProperty("font-size", "calc(1vw * var(--grid_vw) * " + sizeExpression + ")");
                    }
                }
            }
            else if (display[3] == "mod 27") {
                let degrees = "180deg";
                if (params.length > 0) degrees = params[0] + "deg";
                tile.style.setProperty("color", "#ffffff");
                let negative = false;
                if (value < 0) {
                    negative = true;
                    value = abs(value);
                    tile.style.setProperty("color", "#000000");
                }
                if (value == 0) {
                    tile.style.setProperty("background-color", "#444444");
                    tile.style.setProperty("background-image", "none");
                }
                else if (value == 1) {
                    if (negative) tile.style.setProperty("background-image", evaluateColor(["@rotate", 180, true, ["@multi-gradient", ["@radial-gradient", "#000000", "#0008"], ["@conic-gradient", "#ff0000", "#ffff00", "#00ff00", "#00ffff", "#0000ff", "#ff00ff", "#ff0000"]]]));
                    else tile.style.setProperty("background-image", evaluateColor(["@multi-gradient", ["@radial-gradient", "#000000", "#0008"], ["@conic-gradient", "#ff0000", "#ffff00", "#00ff00", "#00ffff", "#0000ff", "#ff00ff", "#ff0000"]]));
                }
                else {
                    let background = ["@linear-gradient", degrees];
                    if (value < 40000) {
                        value = Number(value) - 2;
                        background = ["@linear-gradient", degrees, ["@HSVA", value * 55.623, Math.abs((value/13) % 4 - 2) * 35 + 30, Math.abs((value/50) % 4 - 2) * 25 + 50, 1], ["@HSVA", (value * 0.995) * 55.623, Math.abs(((value * 0.995)/13) % 4 - 2) * 35 + 30, Math.abs(((value * 0.995)/50) % 4 - 2) * 25 + 50, 1]];
                    }
                    else {
                        let bValue = BigInt(value);
                        let tier = ilog(bValue, 200n);
                        value = bValue - 200n**tier;
                        let baseValue = value;
                        background.push(["@HSVA", Number(BigRational.mul(value, 55.623).mod(360)), Math.abs(BigRational.div(value, 13).mod(4).sub(2)) * 35 + 30, Math.abs(BigRational.div(value, 50).mod(4).sub(2)) * 25 + 50, 1]);
                        let zebraStart = 0;
                        for (let i = 0; i < Number(tier); i++) {
                            zebraStart = (zebraStart + 1) % 2
                            value = value / 200n;
                            background.push(["@HSVA", (BigRational.mod(baseValue, 360/55.623).sub(BigRational.mod(value, 360/55.623)) + zebraStart) * 55.623, Math.abs(BigRational.sub(BigRational.mod(baseValue, 52), BigRational.mod(value, 52)).plus(zebraStart).div(13).mod(4).sub(2)) * 35 + 30, Math.abs(BigRational.sub(BigRational.mod(baseValue, 200), BigRational.mod(value, 200)).plus(zebraStart).div(50).mod(4).sub(2)) * 25 + 50, 1]);
                        }
                    }
                    if (negative) tile.style.setProperty("background-image", evaluateColor(["@rotate", 180, true, background]));
                    else tile.style.setProperty("background-image", evaluateColor(background));
                    tile.style.setProperty("text-shadow", "none");
                }
            }
            else if (display[3] == "1321") { // This one was originally just made via the usual CalcArrays but it's been used in enough places that I'm putting it here for lag reduction
                try {
                    value = BigInt(value);
                }
                catch {
                    value = 0n;
                }
                let speed = 1;
                if (params.length > 0) speed = params[0];
                let speedStart = 0;
                if (params.length > 1) speedStart = params[1];
                let negative = false;
                if (value < 0n) {
                    negative = true;
                    value *= -1n;
                }
                let hue, saturation, lightness, power, leftover;
                let powColor = 0;
                if (value == 1n) {
                    hue = 0; saturation = 0; lightness = 100;
                }
                else if (value == 0n) {
                    hue = 0; saturation = 0; lightness = 50; 
                }
                else {
                    power = expomod(value, 2n);
                    leftover = Number(value / 2n**power);
                    powColor = Number(power) * speed + speedStart;
                    hue = (Math.log2(leftover + 15) - 4) * 300;
                    saturation = 0.85**(Math.log2(leftover)) * 100;
                    if (powColor < 4.8) lightness = 90 - (100/12 * powColor);
                    else lightness = 50 * 0.85**(powColor - 4.8);
                }
                let textColor;
                if (negative) {
                    hue += 180; lightness = 100 - lightness;
                    if (powColor < 4.8) textColor = "#d0ccd0";
                    else textColor = "#211122";
                }
                else {
                    if (powColor < 4.8) textColor = "#2f332f";
                    else textColor = "#deeedd";
                }
                tile.style.setProperty("background-color", evaluateColor(["@HSLA", hue, saturation, lightness, 1]));
                tile.style.setProperty("color", textColor);
            }
            else if (display[3] == "180") {
                let scheme = display[3];
                let prime_amount = 48;
                if (params.length > 0) prime_amount = params[0];
                while (primes.length < prime_amount && primes[primes.length - 1] < abs(value)) primesUpdate(primes[primes.length - 1] * 2n);
                let subtile_size = 0.6;
                let all_factors = [];
                let negative = false;
                if (Array.isArray(value)) {
                    all_factors = value;
                }
                else {
                    try {
                        value = BigInt(value);
                    }
                    catch {
                        value = 0n;
                    }
                    tile.style.setProperty("color", "#fff");
                    tile.style.setProperty("text-shadow", "0px 0px 5px #000");
                    if (value < 0n) {
                        value *= -1n;
                        negative = true;
                    }
                    if (value == 0n) {
                        tile.style.setProperty("color", "#888");
                        tile.style.setProperty("background-color", "#444");
                        tile.style.setProperty("text-shadow", "0px 0px 5px #222");
                        return;
                    }
                    else all_factors = primeFactorize(value, prime_amount);
                }
                let factors = all_factors[0];
                while (factors[factors.length - 1] === 0) factors.pop();
                while (factors.length < 3) factors.push(0);
                tile.style.setProperty("background-image", "none");
                tile.style.setProperty("background-color", threeFactorColor(factors.slice(0, 3), scheme, negative));
                if (negative) tile.style.setProperty("color", threeFactorColor(factors.slice(0, 3), scheme));
                else tile.style.setProperty("background-color", threeFactorColor(factors.slice(0, 3), scheme));
                let borderWidth = "calc(" + getComputedStyle(tile).getPropertyValue("width") + " / 40)";
                if (getComputedStyle(tile).getPropertyValue("border-style") != "none") borderWidth = getComputedStyle(tile).getPropertyValue("border-width");
                if (factors.length > 3) {
                    let bcol = RGBtoArray(getComputedStyle(tile).getPropertyValue("background-color"));
                    let rcol = "#444";
                    if (bcol[0] == 0 && bcol[1] == 0 && bcol[2] == 0) rcol = "#444";
                    else {
                        bcol[0] *= 0.5; bcol[1] *= 0.5; bcol[2] *= 0.5;
                        rcol = ArraytoRGB(bcol);
                    }
                    for (let p = 3; p < factors.length && p < 12; p++) {
                        if (factors[p] > 0) {
                            let primePower = primeFactorize(factors[p], 3);
                            if (p == 3) {
                                for (let p = 0; p < primePower.length; p++) {
                                    let icol = threeFactorColor(primePower[p], scheme);
                                        let pImage = document.createElement("div");
                                        pImage.classList.add("primeImage");
                                        tile.appendChild(pImage);
                                        if (primeDefactorize(primePower[p]) == 1n) pImage.style.setProperty("background-image", "radial-gradient(#0000 0% 48%, " + rcol + " 48% 56%, #0000 56%)");
                                        else pImage.style.setProperty("background-image", "radial-gradient(#0000 0% 48%, " + rcol + " 48% 50%, " + icol + " 50% 54%, " + rcol + " 54% 56%, #0000 56%)");
                                        if (primePower.length > 1) {
                                            if (p == 0) pImage.style.setProperty("mask-image", "conic-gradient(#000 0deg " + 360/primePower.length * 0.49 + "deg, #0000 " + 360/primePower.length * 0.49 + "deg " + (360 - 360/primePower.length * 0.49) + "deg, #000 " + (360 - 360/primePower.length * 0.49) + "deg)");
                                            else pImage.style.setProperty("mask-image", "conic-gradient(#0000 0deg " + 360/primePower.length * (p - 0.49) + "deg, #000 " + 360/primePower.length * (p - 0.49) + "deg " + 360/primePower.length * (p + 0.49) + "deg, #0000 " + 360/primePower.length * (p + 0.49) + "deg)");
                                    }
                                }
                            }
                            else if (p < 12) {
                                let pImage = document.createElement("div");
                                tile.appendChild(pImage);
                                if (p == 4) {
                                    pImage.classList.add("VSideBox");
                                    pImage.style.setProperty("left", "25%");
                                    pImage.style.setProperty("top", "0%");
                                }
                                else if (p == 5) {
                                    pImage.classList.add("VSideBox");
                                    pImage.style.setProperty("left", "25%");
                                    pImage.style.setProperty("bottom", "0%");
                                }
                                else if (p == 6) {
                                    pImage.classList.add("HSideBox");
                                    pImage.style.setProperty("left", "0%");
                                    pImage.style.setProperty("top", "25%");
                                }
                                else if (p == 7) {
                                    pImage.classList.add("HSideBox");
                                    pImage.style.setProperty("right", "0%");
                                    pImage.style.setProperty("top", "25%");
                                }
                                else if (p == 8) {
                                    pImage.classList.add("cornerBox");
                                    pImage.style.setProperty("left", "0%");
                                    pImage.style.setProperty("top", "0%");
                                }
                                else if (p == 9) {
                                    pImage.classList.add("cornerBox");
                                    pImage.style.setProperty("right", "0%");
                                    pImage.style.setProperty("top", "0%");
                                }
                                else if (p == 10) {
                                    pImage.classList.add("cornerBox");
                                    pImage.style.setProperty("left", "0%");
                                    pImage.style.setProperty("bottom", "0%");
                                }
                                else if (p == 11) {
                                    pImage.classList.add("cornerBox");
                                    pImage.style.setProperty("right", "0%");
                                    pImage.style.setProperty("bottom", "0%");
                                }
                                pImage.style.setProperty("background-color", rcol);
                                let subimage = document.createElement("div");
                                subimage.classList.add("subBox");
                                pImage.appendChild(subimage);
                                let icol = threeFactorColor(primePower[0], scheme);
                                subimage.style.setProperty("background-color", icol);
                                if (primePower.length > 1) {
                                    for (let layer = 1; layer < primePower.length; layer++) {
                                        pImage = subimage;
                                        let rcol = RGBtoArray(getComputedStyle(pImage).getPropertyValue("background-color"));
                                        if (rcol[0] == 0 && rcol[1] == 0 && rcol[2] == 0) rcol = "#444";
                                        else {
                                        rcol[0] *= 0.5; rcol[1] *= 0.5; rcol[2] *= 0.5;
                                        rcol = ArraytoRGB(rcol);
                                        }
                                        subimage = document.createElement("div");
                                        subimage.classList.add("subBox");
                                        pImage.appendChild(subimage);
                                        subimage.style.setProperty("background-color", rcol);
                                        pImage = subimage;
                                        subimage = document.createElement("div");
                                        subimage.classList.add("subBox");
                                        pImage.appendChild(subimage);
                                        icol = threeFactorColor(primePower[layer], scheme);
                                        subimage.style.setProperty("background-color", icol);
                                    }
                                }
                            }
                        }
                    }
                    if (factors.length >= 13) {
                        while (factors.length % 3 != 0) factors.push(0);
                        let post37colors = [];
                        for (let p = 12; p < factors.length; p += 3) {
                            post37colors.push(threeFactorColor([factors[p], factors[p + 1], factors[p + 2]], scheme));
                        }
                        let width = 240 / Math.max(4, post37colors.length);
                        for (let c = 0; c < post37colors.length; c++) {
                            let center = 360 / post37colors.length * c;
                            let pImage = document.createElement("div");
                            pImage.classList.add("primeImage");
                            tile.appendChild(pImage);
                            if (c == 0) pImage.style.setProperty("background-image", "conic-gradient(" + post37colors[c] + " 0deg " + (width / 4) + "deg, " + rcol + " " + (width / 2) + "deg, #0000 " + (width / 2) + "deg " + (360 - width / 2) + "deg, " + rcol + " " + (360 - width / 2) + "deg, " + post37colors[c] + " " + (360 - width / 4) + "deg 360deg)")
                            else pImage.style.setProperty("background-image", "conic-gradient(#0000 0deg " + (center - width / 2) + "deg, " + rcol + " " + (center - width / 2) + "deg, " + post37colors[c] + " " + (center - width / 4) + "deg " + (center + width / 4) + "deg, " + rcol + " " + (center + width / 2) + "deg, #0000 " + (center + width / 2) + "deg)");
                            pImage.style.setProperty("mask-image", "radial-gradient(#000, #0000)");
                        }
                    }
                }
                if (all_factors.length > 1) {
                    let subtile = document.createElement("div");
                    subtile.classList.add("subtile");
                    tile.appendChild(subtile);
                    if (hexagonal) subtile.classList.add("hexagon_clip");
                    let bcol = RGBtoArray(getComputedStyle(tile).getPropertyValue("background-color"));
                    if (bcol[0] == 0 && bcol[1] == 0 && bcol[2] == 0) subtile.style.setProperty("border-color", "#444");
                    else {
                        bcol[0] *= 0.5; bcol[1] *= 0.5; bcol[2] *= 0.5;
                        bcol = ArraytoRGB(bcol);
                        subtile.style.setProperty("border-color", bcol);
                    }
                    subtile.style.setProperty("width", subtile_size * 100 + "%");
                    subtile.style.setProperty("height", subtile_size * 100 + "%");
                    subtile.style.setProperty("left", 50 - subtile_size * 50 - (hexagonal ? 4/3 : 2) + "%");
                    subtile.style.setProperty("top", 50 - subtile_size * 50 - (hexagonal ? 4/3 : 2) + "%");
                    subtile.style.setProperty("border-width", "calc(" + borderWidth + " * " + subtile_size + ")");
                    display[4][0] = ["@Literal"].concat(all_factors.slice(1));
                    displayTile("Subtile", subtile, "None", "None", all_factors.slice(1), display.slice(0, 5));
                }
            }
            else if (display[3] == "DIVE" || display[3] == "SQUARTSingle") {
                let scheme = display[3];
                let prime_amount = 168;
                if (params.length > 0) prime_amount = params[0];
                while ((!Array.isArray(value) && primes.length < prime_amount && primes[primes.length - 1] < abs(value)) || (Array.isArray(value) && primes.length < value[0].length)) primesUpdate(primes[primes.length - 1] * 2n);
                let subtile_size = 0.5;
                let all_factors = [];
                let negative = false;
                if (Array.isArray(value)) {
                    all_factors = value;
                }
                else {
                    try {
                        value = BigInt(value);
                    }
                    catch {
                        value = 0n;
                    }
                    tile.style.setProperty("color", "#fff");
                    tile.style.setProperty("text-shadow", "0px 0px 5px #000");
                    if (value < 0n) {
                        value *= -1n;
                        negative = true;
                    }
                    if (value == 0n) {
                        tile.style.setProperty("color", "#888");
                        while (primes.length < 73) primesUpdate(primes[primes.length - 1] * 2n);
                        all_factors = [([7n, 4n, 3n]).concat(Array(70).fill(2n))];
                    }
                    else all_factors = primeFactorize(value, prime_amount);
                }
                let factors = compendiumStructuredClone(all_factors[0]);
                while (factors[factors.length - 1] === 0) factors.pop();
                while (factors.length < 3) factors.push(0n);
                tile.style.setProperty("background-image", "none");
                tile.style.setProperty("background-color", threeFactorColor(factors.slice(0, 3), scheme));
                let borderWidth = "calc(" + getComputedStyle(tile).getPropertyValue("width") + " / 40)";
                if (getComputedStyle(tile).getPropertyValue("border-style") != "none") borderWidth = getComputedStyle(tile).getPropertyValue("border-width");
                if (factors.length > 3) {
                    for (let p = 3; p < factors.length; p++) {
                        if (factors[p] > 0) {
                            let pImage = document.createElement("div");
                            pImage.classList.add("primeImage");
                            tile.appendChild(pImage);
                            if (p == 3) pImage.style.setProperty("background-image", "conic-gradient(#0000 0deg 10deg, #fff 35deg 55deg, #0000 80deg 100deg, #000 125deg 145deg, #0000 170deg 190deg, #fff 215deg 235deg, #0000 260deg 280deg, #000 305deg 325deg, #0000 350deg");
                            else if (p == 4) {
                                if (hexagonal) pImage.style.setProperty("background-image", "radial-gradient(#fff 0%, #0000 15% 25%, #000 32% 36%, #0000 43% 52%, #fff 58% 63%, #0000 70%, #000 80%)");
                                else pImage.style.setProperty("background-image", "radial-gradient(#fff 0%, #0000 19.666% 30.333%, #000 38.888% 44.444%, #0000 53% 63.666%, #fff 72.222% 77.777%, #0000 86.333%, #000 100%)");
                            } 
                            else if (p == 5) { // 13 in the original DIVE uses the same generation rules as the rest of the primes above 11, but my version looks good for the rest of the primes but not 13, so I'm setting 13 manually to retain its iconic look
                                if (hexagonal) {
                                    pImage.style.setProperty("background-image", "repeating-linear-gradient(#0000 6.69%, #fff 19.689%, #0000 32.679%, #000 45.67%, #0000 58.66%)");
                                    pImage.style.setProperty("mask-image", "repeating-linear-gradient(90deg, #000 6.69% 18.823%, #0000 18.823% 43.072%");
                                }
                                else {
                                    pImage.style.setProperty("background-image", "repeating-linear-gradient(#0000 0%, #fff 15%, #0000 30%, #000 45%, #0000 60%)");
                                    pImage.style.setProperty("mask-image", "repeating-linear-gradient(90deg, #000 0% 14%, #0000 14% 42%");
                                }
                            }
                            else {
                                let prime = primes[p];
                                let basenum = (prime + 1n)/2n;
                                let basefactors = (primeFactorize(basenum, 4))[0];
                                while (basefactors.length < 4) basefactors.push(0n);
                                let basecolor = threeFactorColor(basefactors.slice(0, 3), scheme + "_primeGrey");
                                let residuenum = basenum / primeDefactorize(basefactors);
                                let residueList = DIVEresidueFactor(residuenum, 4, prime_amount);
                                let layerDepth = arrayDepth(residueList) / 2;
                                let layerNum = 1;
                                let width = 110 / Math.sqrt(Number(prime));
                                let direction = 45 + 291.246118 * (p - 3);
                                if (residuenum == 1n) {
                                    if (basefactors[3] == 0) { // No sevens
                                        pImage.style.setProperty("background-image", "linear-gradient(" + (direction + 90) + "deg, #000, " + basecolor + ", #000)");
                                    }
                                    else { // Sevens
                                        let sevensWidth = 40 / Number(basefactors[3]);
                                        let bottomcolor = "#000";
                                        pImage.style.setProperty("background-image", "repeating-linear-gradient(" + (direction + 90) + "deg, " + bottomcolor + " 0% " + (sevensWidth / 12) + "%, " + basecolor + " " + (sevensWidth / 4) + "%, #fff " + (5 * sevensWidth / 12) + "% " + (7 * sevensWidth/ 12) + "%, " + basecolor + " " + (sevensWidth * 3/4) + "%, " + bottomcolor + " " + (11 * sevensWidth / 12) + "% " + sevensWidth + "%)");
                                    }
                                }
                                else {
                                    let longBar = ((residueList.length > 2) || (residueList[1][2].length > 1) || (residueList[1][2][0][3] > 0));
                                    let outercolor = threeFactorColor(basefactors.slice(0, 3), scheme + "_primeGrey", false, 0.5);
                                    let innermax = residueList.slice(1).reduce(
                                        function(total, value) {
                                            return max(total, value[1] ** value[0]);
                                        }, 0n
                                    );
                                    let length = 100 / Math.sqrt(Number(innermax)) / (residueList.length - 1);
                                    let innercolors = [];
                                    for (let i = 1; i < residueList.length; i++) {
                                        innercolors.push([residueList[i][1], residueList[i][2][0], residueList[i][0]]);
                                    }
                                    let result = "repeating-linear-gradient(" + (direction + 90) + "deg";
                                    let innerBars = [];
                                    let length_to_add = 0;
                                    let length_thus_far = 0;
                                    let iteration_length = 0;
                                    for (let b = 0; b < innercolors.length * 2; b++) {
                                        let inner_color = innercolors[b % innercolors.length];
                                        if (longBar) length_to_add = length / 2;
                                        else length_to_add = length * 2/3;
                                        if (basefactors[3] == 0n) {
                                            result += (", " + outercolor + " " + length_thus_far + "% " + (length_thus_far + length_to_add) + "%, ");
                                        }
                                        else {
                                            result += ", ";
                                            for (let s = 0; s < Number(basefactors[3]) * 2; s++) {
                                                if ((b + s) % 2 == 0) result += outercolor;
                                                else result += "#fff";
                                                result += " " + (length_thus_far + length_to_add*s/(Number(basefactors[3]) * 2 - 1)) + "%, "
                                            }
                                        }
                                        length_thus_far += length_to_add;
                                        if (longBar) length_to_add = length / 2;
                                        else length_to_add = length/3;
                                        length_to_add *= Math.sqrt(Number(inner_color[0]) ** Number(inner_color[2]) / Number(innermax));
                                        result += DIVERenderInnerBar(inner_color[1], length_thus_far, length_to_add, layerNum, layerDepth, scheme);
                                        if (b < innercolors.length) innerBars.push([[b + 1], length_thus_far, length_to_add]);
                                        length_thus_far += length_to_add;
                                        if (b == innercolors.length - 1) iteration_length = length_thus_far;
                                    }
                                    result += ")";
                                    pImage.style.setProperty("background-image", result);
                                    while (innerBars.length > 0) {
                                        layerNum++;
                                        let layerLength = innerBars.length;
                                        let layerBars = [];
                                        for (let b = 0; b < layerLength; b++) {
                                            let target = nestedElement(residueList, innerBars[0][0])[2];
                                            if (target.length > 1) {
                                                let deepmax = target.slice(1).reduce(
                                                    function(total, value) {
                                                        return max(total, value[1] ** value[0]);
                                                    }, 0n
                                                );
                                                let segments = [];
                                                length_thus_far = 0;
                                                length_to_add = 0;
                                                for (let t = 1; t < target.length; t++) {
                                                    length_to_add = 1;
                                                    segments.push(["#0000", length_thus_far, length_thus_far + length_to_add]);
                                                    length_thus_far += length_to_add;
                                                    length_to_add = Math.sqrt(Number(target[t][1]) ** Number(target[t][0]) / Number(deepmax));
                                                    segments.push([target[t][2][0], length_thus_far, length_thus_far + length_to_add]);
                                                    length_thus_far += length_to_add;
                                                }
                                                length_to_add = 1;
                                                segments.push(["#0000", length_thus_far, length_thus_far + length_to_add]);
                                                length_thus_far += length_to_add;
                                                for (let s = 1; s < segments.length; s += 2) {
                                                    layerBars.push([DIVERenderInnerBar(segments[s][0], innerBars[0][1] + innerBars[0][2] * segments[s][1]/length_thus_far, innerBars[0][2] * (segments[s][2] - segments[s][1])/length_thus_far, layerNum, layerDepth, scheme), innerBars[0][1] + innerBars[0][2] * segments[s][1]/length_thus_far, innerBars[0][1] + innerBars[0][2] * segments[s][2]/length_thus_far]);
                                                    innerBars.push([innerBars[0][0].concat(2, (s + 1)/2), innerBars[0][1] + innerBars[0][2] * segments[s][1]/length_thus_far, innerBars[0][2] * (segments[s][2] - segments[s][1])/length_thus_far]);
                                                }
                                            }
                                            innerBars.shift();
                                        }
                                        if (layerBars.length > 0) {
                                            let layerImage = document.createElement("div");
                                            layerImage.classList.add("primeImage");
                                            pImage.appendChild(layerImage);
                                            let layerBackground = "repeating-linear-gradient(" + (direction + 90) + "deg";
                                            let previousend = 0;
                                            for (let b = 0; b < layerBars.length; b++) {
                                                layerBackground += ", #0000 " + previousend + "% " + layerBars[b][1] + "%, " + layerBars[b][0];
                                                previousend = layerBars[b][2];
                                            }
                                            layerBackground += ", #0000 " + previousend + "% " + iteration_length + "%)";
                                            layerImage.style.setProperty("background-image", layerBackground);
                                            layerImage.style.setProperty("mask-image", "repeating-linear-gradient(" + direction + "deg, #000 0% " + (width * 1/6) + "%, #0000 " + (width * 1/6) + "% " + (width * 5/6) + "%, #000 " + (width * 5/6) + "% " + width + "%)");
                                        }
                                    }
                                }
                                pImage.style.setProperty("mask-image", "repeating-linear-gradient(" + direction + "deg, #000 0% " + (width * 1/6) + "%, #0000 " + (width * 1/6) + "% " + (width * 5/6) + "%, #000 " + (width * 5/6) + "% " + width + "%)");
                            }
                            pImage.style.setProperty("opacity", 0.5 * Number(factors[p]));
                        }
                    }
                }
                if (negative) {
                    let pImage = document.createElement("div");
                    tile.appendChild(pImage);
                    pImage.classList.add("primeImage");
                    pImage.style.setProperty("background-image", "radial-gradient(#0000 0% 70%, " + threeFactorColor(factors.slice(0, 3), scheme, true) + ")");
                    tile.style.setProperty("color", "black");
                    tile.style.setProperty("text-shadow", "0px 0px 5px #fff");
                }
                if (all_factors.length > 1) {
                    let subtile = document.createElement("div");
                    subtile.classList.add("subtile");
                    tile.appendChild(subtile);
                    if (hexagonal) subtile.classList.add("hexagon_clip");
                    let bcol = RGBtoArray(getComputedStyle(tile).getPropertyValue("background-color"));
                    if (bcol[0] == 0 && bcol[1] == 0 && bcol[2] == 0) subtile.style.setProperty("border-color", "#444");
                    else {
                        bcol[0] *= 0.5; bcol[1] *= 0.5; bcol[2] *= 0.5;
                        bcol = ArraytoRGB(bcol);
                        subtile.style.setProperty("border-color", bcol);
                    }
                    subtile.style.setProperty("width", subtile_size * 100 + "%");
                    subtile.style.setProperty("height", subtile_size * 100 + "%");
                    subtile.style.setProperty("left", 50 - subtile_size * 50 - (hexagonal ? 4/3 : 2) + "%");
                    subtile.style.setProperty("top", 50 - subtile_size * 50 - (hexagonal ? 4/3 : 2) + "%");
                    subtile.style.setProperty("border-width", "calc(" + borderWidth + " * " + subtile_size + ")");
                    display[4][0] = ["@Literal"].concat(all_factors.slice(1));
                    displayTile("Subtile", subtile, "None", "None", all_factors.slice(1), display.slice(0, 5));
                }
            }
            else if (display[3] == "2295" || display[3] == "3069" || display[3] == "Odds-Only 3069") {
                let negative = false;
                let scheme = display[3];
                try {
                    value = BigInt(value);
                }
                catch {
                    value = 0n;
                }
                if (value == 0n) {
                    tile.style.setProperty("color", "#444");
                    tile.style.setProperty("background-color", "#888");
                    tile.style.setProperty("text-shadow", "none");
                    tile.style.setProperty("background-image", "none");
                    return;
                }
                if (value < 0n) {
                    value *= -1n;
                    negative = true;
                }
                let background;
                if (scheme == "2295") {
                    if (negative) tile.style.setProperty("color", "#000");
                    else tile.style.setProperty("color", "#fff");
                    background = [];
                    let minusBackground = [];
                    let powerPlusFactors = [
                        [-3, 285, 100], [4, 295, 100], [-5, 0, 75], [5, 55, 100], [6, 265, 100], [-7, 75, 75],
                        [7, 310, 50], [8, 50, 50], [-9, 165, 33], [9, 90, 50], [10, 160, 50], [-11, 265, 33], [11, 330, 50],
                        [12, 270, 50], [-13, 210, 33], [13, 30, 50], [14, 225, 50], [-15, 300, 33], [15, 10, 50], [16, 185, 50],
                        [-17, -40, 33], [17, 120, 50], [18, 208, 50], [-19, 15, 33], [19, 300, 25], [20, 270, 25],
                        [-21, 120, 15], [21, 240, 25], [22, 210, 25], [-23, 60, 15], [23, 180, 25], [24, 150, 25],
                        [-25, 0, 15], [25, 120, 25], [26, 90, 25], [-27, 300, 15], [27, 60, 25], [28, 30, 25], 
                        [-29, 240, 15], [29, 0, 25], [30, 330, 25]
                    ];
                    for (let p = powerPlusFactors.length - 1; p >= 0; p--) {
                        let powerNum = 2n**BigInt(Math.abs(powerPlusFactors[p][0])) + BigInt(Math.sign(powerPlusFactors[p][0]));
                        let amount = Number(expomod(value, powerNum));
                        if (amount != 0) {
                            let powerBackground = ["@HSLA", powerPlusFactors[p][1], powerPlusFactors[p][2], 0.75**(amount - 1) * 75, 1];
                            if (powerPlusFactors[p][0] > 0) background.push(powerBackground, powerBackground);
                            else minusBackground.push(powerBackground, powerBackground);
                            value /= powerNum**BigInt(amount);
                        }
                    }
                    // Skip 2^3 + 1 because it's just two factors of 3
                    if (value % 5n == 0n) {
                        let fivesColor = Number(expomod(value, 5n));
                        let fivesBackground = ["@HSLA", 200, 100, 0.75**(fivesColor - 1) * 75, 1];
                        background.push(fivesBackground, fivesBackground);
                        value /= 5n**BigInt(fivesColor);
                    }
                    if (value % 3n == 0n) {
                        let threesColor = Number(expomod(value, 3n)) - 1;
                        let threesBackground = ["@HSLA", [80, 120, 140][threesColor % 3], 100, 0.75**(Math.floor(threesColor/3)) * 75, 1];
                        background.push(threesBackground, threesBackground);
                        value /= 3n**BigInt(threesColor + 1);
                    }
                    if (value % 2n == 0n) {
                        let twosColor = Number(expomod(value, 2n)) - 1;
                        let twosBackground = ["@HSLA", [320, 340, 0, 13, 26, 40][twosColor % 6], 100, 0.75**(Math.floor(twosColor/6)) * 75, 1];
                        background.push(twosBackground, twosBackground);
                        value /= 2n**BigInt(twosColor + 1);
                    }
                    if (background.length == 0) background.push("#ccc", "#ccc");
                    background.push("@linear-gradient");
                    background.reverse();
                    if (minusBackground.length > 0) {
                        minusBackground.push("@linear-gradient");
                        minusBackground.reverse();
                        let pImage = document.createElement("div");
                        pImage.classList.add("primeImage");
                        tile.appendChild(pImage);
                        if (negative) pImage.style.setProperty("background-image", evaluateColor(["@rotate", 180, true, minusBackground]));
                        else pImage.style.setProperty("background-image", evaluateColor(minusBackground));
                        pImage.style.setProperty("mask-image", evaluateColor(["@linear-gradient", 90, "#0000", "#0000", "#000", "#000"]))
                    }
                }
                else if (scheme == "3069" || scheme == "Odds-Only 3069") {
                    let prime_amount = Infinity;
                    if (params.length > 0) prime_amount = params[0];
                    if (negative != (scheme == "Odds-Only 3069")) tile.style.setProperty("color", "#fff");
                    else tile.style.setProperty("color", "#000");
                    background = ["@linear-gradient"];
                    let p = 0;
                    while (value > 1n && p < prime_amount) {
                        while (primes.length < p + 1) primesUpdate(primes[primes.length - 1] * 2n);
                        let prime = primes[p];
                        let amount = Number(expomod(value, prime));
                        if (amount != 0) {
                            let hue;
                            let colorLayer = 0;
                            if (scheme == "Odds-Only 3069") p--;
                            if (p < 3) hue = p * 120;
                            else {
                                let colorThreshold = 6;
                                colorLayer = 1;
                                while (p >= colorThreshold) {
                                    colorThreshold *= 2;
                                    colorLayer += 1;
                                }
                                colorThreshold /= 2;
                                hue = (p - colorThreshold + 0.5) * 360 / colorThreshold;
                            }
                            if (scheme == "Odds-Only 3069") p++;
                            let saturation;
                            if (colorLayer < 4) saturation = 100;
                            else saturation = 0.875**(colorLayer - 3) * 100;
                            if (scheme == "Odds-Only 3069" && p == 0) {
                                hue = 0; saturation = 0;
                            }
                            let lightness;
                            lightness = 100 - 0.8**(amount) * 90;
                            if (scheme == "Odds-Only 3069") {
                                if (p < 4) hue += 60;
                                else if (p < 7) hue -= 60;
                                else hue += 180;
                                lightness = 100 - lightness;
                            }
                            let primeBackground = ["@HSLA", hue, saturation, lightness, 1];
                            background.push(primeBackground, primeBackground);
                            value /= prime**BigInt(amount);
                        }
                        p++;
                    }
                    if (background.length == 1) {
                        if (scheme == "Odds-Only 3069") background.push("#ddd", "#ddd");
                        else background.push("#444", "#444");
                    }
                }
                if (negative) tile.style.setProperty("background-image", evaluateColor(["@rotate", 180, true, background]));
                else tile.style.setProperty("background-image", evaluateColor(background));
                tile.style.setProperty("text-shadow", "none");
                if (value > 1n) {
                    value -= 1n;
                    if (negative) value *= -1n;
                    let subtile_size = 0.6;
                    let borderWidth = "calc(" + getComputedStyle(tile).getPropertyValue("width") + " / 40)";
                    if (getComputedStyle(tile).getPropertyValue("border-style") != "none") borderWidth = getComputedStyle(tile).getPropertyValue("border-width");
                    let subtile = document.createElement("div");
                    subtile.classList.add("subtile");
                    tile.appendChild(subtile);
                    if (hexagonal) subtile.classList.add("hexagon_clip");
                    if (scheme == "Odds-Only 3069") subtile.style.setProperty("border-color", "#000");
                    else subtile.style.setProperty("border-color", "#fff");
                    subtile.style.setProperty("width", subtile_size * 100 + "%");
                    subtile.style.setProperty("height", subtile_size * 100 + "%");
                    subtile.style.setProperty("left", 50 - subtile_size * 50 - (hexagonal ? 4/3 : 2) + "%");
                    subtile.style.setProperty("top", 50 - subtile_size * 50 - (hexagonal ? 4/3 : 2) + "%");
                    subtile.style.setProperty("border-width", "calc(" + borderWidth + " * " + subtile_size + ")");
                    display[4][0] = value;
                    displayTile("Subtile", subtile, "None", "None", value, display.slice(0, 5));
                }
            }
            else if (display[3] == "SQUART") {
                let prime_amount = 168;
                if (params.length > 0) prime_amount = params[0];
                let subtile_size = 0.5;
                let all_factors = [];
                let negative = false;
                if (Array.isArray(value)) {
                    all_factors = value;
                    while (primes.length < all_factors[0].length) primesUpdate(primes[primes.length - 1] * 2n);
                }
                else {
                    try {
                        value = BigInt(value);
                    }
                    catch {
                        value = 0n;
                    }
                    tile.style.setProperty("color", "#fff");
                    tile.style.setProperty("text-shadow", "0px 0px 5px #000");
                    if (value < 0n) {
                        value *= -1n;
                        negative = true;
                    }
                    if (value == 0n) {
                        while (primes.length < 73) primesUpdate(primes[primes.length - 1] * 2n);
                        all_factors = [([10n, 6n, 4n]).concat(Array(70).fill(4n))];
                    }
                    else all_factors = primeFactorize(value, prime_amount);
                }
                let factors = all_factors[0];
                while (factors[factors.length - 1] === 0n) factors.pop();
                let lowerFactors = factors.map(f => f/2n);
                let upperFactors = factors.map(f => f - f/2n);
                let upperImage = document.createElement("div");
                upperImage.classList.add("primeImage");
                tile.appendChild(upperImage);
                let lowerImage = document.createElement("div");
                lowerImage.classList.add("primeImage");
                tile.appendChild(lowerImage);
                let singleDisplay = compendiumStructuredClone(display).slice(0, 5);
                singleDisplay[3] = "SQUARTSingle";
                singleDisplay[4][0] = ["@Literal", upperFactors];
                displayTile("Subtile", upperImage, "None", "None", upperFactors, singleDisplay);
                singleDisplay[4][0] = ["@Literal", lowerFactors]
                displayTile("Subtile", lowerImage, "None", "None", lowerFactors, singleDisplay);
                lowerImage.style.setProperty("mask-image", "linear-gradient(#0000 0% 25%, #000 75%)")
                if (negative) {
                    let pImage = document.createElement("div");
                    tile.appendChild(pImage);
                    pImage.classList.add("primeImage");
                    pImage.style.setProperty("background-image", "radial-gradient(#0000 0% 70%, " + threeFactorColor(lowerFactors.slice(0, 3), "SQUARTSingle", true) + ")");
                    tile.style.setProperty("color", "black");
                    tile.style.setProperty("text-shadow", "0px 0px 5px #fff");
                }
                if (all_factors.length > 1) {
                    let subtile = document.createElement("div");
                    subtile.classList.add("subtile");
                    tile.appendChild(subtile);
                    let borderWidth = "calc(" + getComputedStyle(tile).getPropertyValue("width") + " / 40)";
                    if (hexagonal) subtile.classList.add("hexagon_clip");
                    let upperBCol = RGBtoArray(getComputedStyle(upperImage).getPropertyValue("background-color"));
                    if (upperBCol[0] == 0 && upperBCol[1] == 0 && upperBCol[2] == 0) upperBCol = "#444";
                    else {
                        upperBCol[0] *= 0.5; upperBCol[1] *= 0.5; upperBCol[2] *= 0.5;
                        upperBCol = ArraytoRGB(upperBCol);
                    }
                    let lowerBCol = RGBtoArray(getComputedStyle(lowerImage).getPropertyValue("background-color"));
                    if (lowerBCol[0] == 0 && lowerBCol[1] == 0 && lowerBCol[2] == 0) lowerBCol = "#444";
                    else {
                        lowerBCol[0] *= 0.5; lowerBCol[1] *= 0.5; lowerBCol[2] *= 0.5;
                        lowerBCol = ArraytoRGB(lowerBCol);
                    }
                    subtile.style.setProperty("border-image-source", "linear-gradient(" + upperBCol + " 0% 25%, " + lowerBCol + " 75%)");
                    subtile.style.setProperty("border-image-slice", 1);
                    subtile.style.setProperty("width", subtile_size * 100 + "%");
                    subtile.style.setProperty("height", subtile_size * 100 + "%");
                    subtile.style.setProperty("left", 50 - subtile_size * 50 - (hexagonal ? 4/3 : 2) + "%");
                    subtile.style.setProperty("top", 50 - subtile_size * 50 - (hexagonal ? 4/3 : 2) + "%");
                    subtile.style.setProperty("border-width", "calc(" + borderWidth + " * " + subtile_size + ")");
                    display[4][0] = ["@Literal"].concat(all_factors.slice(1));
                    displayTile("Subtile", subtile, "None", "None", all_factors.slice(1), display.slice(0, 5));
                }
            }
            else if (display[3] == "Turatin") {
                while (primes.length < 40 && primes[primes.length - 1] < abs(value)) primesUpdate(primes[primes.length - 1] * 2n);
                let all_factors = [];
                let negative = false;
                if (Array.isArray(value)) {
                    all_factors = value;
                }
                else {
                    try {
                        value = BigInt(value);
                    }
                    catch {
                        value = 0n;
                    }
                    tile.style.setProperty("color", "#fff");
                    tile.style.setProperty("text-shadow", "0px 0px 5px #000");
                    if (value < 0n) {
                        value *= -1n;
                        negative = true;
                        tile.style.setProperty("color", "#000");
                        tile.style.setProperty("text-shadow", "0px 0px 5px #fff");
                    }
                    if (value == 0n) {
                        tile.style.setProperty("color", "#888");
                        tile.style.setProperty("background-color", "#444");
                        tile.style.setProperty("background-image", "none");
                        tile.style.setProperty("text-shadow", "0px 0px 5px #222");
                        return;
                    }
                    else all_factors = primeFactorize(value, 40);
                }
                let images = [];
                let p2colors = ["#ffffff", "#ffe4b8", "#ffc76c", "#ff9d00", "#ff6f00", "#ff3300", "#ff0051", "#fff8ae", "#fff26b", "#ffea00", "#d4c300", "#a39600", "#f6b9ff", "#eb75fd", "#e229ff", "#b200ce", "#770089", "#635ef5", "#2c26e1", "#120e93"]
                for (let a = 0; a < all_factors.length; a++) {
                    let factors = all_factors[a];
                    while (factors.length < 40) factors.push(0);
                    let twosImage = document.createElement("div");
                    twosImage.classList.add("primeImage");
                    images.push(twosImage);
                    if (factors[0] < 20) twosImage.style.setProperty("background-color", p2colors[factors[0]]);
                    else twosImage.style.setProperty("background-color", evaluateColor(["@HSLA", [-34, "*", factors, "+", 495], 100, [0.95, "^", [factors[0], "-", 19], "*", 36], 1]));
                    if (a == 0 && negative) {
                        let negaColor;
                        if (factors[0] < 20) negaColor = evaluateColor(rotateColor(p2colors[factors[0]], 180, true));
                        else negaColor = evaluateColor(["@rotate", 180, true, ["@HSLA", [-34, "*", factors, "+", 495], 100, [0.95, "^", [factors[0], "-", 19], "*", 36], 1]]);
                        let negaImage = document.createElement("div");
                        negaImage.classList.add("primeImage");
                        twosImage.appendChild(negaImage);
                        negaImage.style.setProperty("background-image", "conic-gradient(#0000 0deg 40deg, " + negaColor + " 40deg 50deg, #0000 50deg 130deg, " + negaColor + " 130deg 140deg, #0000 140deg 220deg, " + negaColor + " 220deg 230deg, #0000 230deg 310deg, " + negaColor + " 310deg 320deg, #0000 320deg");
                    }
                    let higherImage = document.createElement("div");
                    higherImage.classList.add("primeImage");
                    images.push(higherImage);
                    let bcol = threeFactorColor(factors.slice(1, 4), "Turatin");
                    higherImage.style.setProperty("background-color", bcol);
                    bcol = RGBtoArray(bcol);
                    bcol[0] = bcol[0].slice(1);
                    bcol[1] = bcol[1].slice(0, bcol[1].length - 1);
                    bcol[2] = bcol[2].slice(0, bcol[2].length - 1);
                    bcol.unshift("@HSLA")
                    bcol = convertColor(bcol, "@RGBA");
                    bcol.shift();
                    let rcol = "#444";
                    if (bcol[0] == 0 && bcol[1] == 0 && bcol[2] == 0) rcol = "#444";
                    else {
                        bcol[0] *= 0.5; bcol[1] *= 0.5; bcol[2] *= 0.5;
                        rcol = ArraytoRGB(bcol);
                    }
                    for (let p = 4; p < 40; p += 3) {
                        if (factors[p] > 0 || factors[p + 1] > 0 || factors[p + 2] > 0) {
                            let conecolor = threeFactorColor([factors[p], factors[p + 1], factors[p + 2]], "TuratinInner");
                            let width = (p < 16) ? 35 : 15;
                            let center = [0, 180, 90, 270, 35, 55, 125, 145, 215, 235, 305, 325][(p - 4)/3];
                            let pImage = document.createElement("div");
                            pImage.classList.add("primeImage");
                            higherImage.appendChild(pImage);
                            if (p == 4) {
                                pImage.style.setProperty("background-image", "conic-gradient(" + conecolor + " 0deg " + (width / 4) + "deg, " + rcol + " " + (width / 2) + "deg, #0000 " + (width / 2) + "deg " + (360 - width / 2) + "deg, " + rcol + " " + (360 - width / 2) + "deg, " + conecolor + " " + (360 - width / 4) + "deg 360deg)")
                            }
                            else {
                                pImage.style.setProperty("background-image", "conic-gradient(#0000 0deg " + (center - width / 2) + "deg, " + rcol + " " + (center - width / 2) + "deg, " + conecolor + " " + (center - width / 4) + "deg " + (center + width / 4) + "deg, " + rcol + " " + (center + width / 2) + "deg, #0000 " + (center + width / 2) + "deg)");
                            }
                            // pImage.style.setProperty("mask-image", "radial-gradient(#000, #0000)");
                        }
                    }
                }
                tile.appendChild(images[0]);
                tile.appendChild(images[1]);
                images[1].style.setProperty("mask-image", "radial-gradient(#000 0% 50%, #0000 75%)");
                for (i = 2; i < images.length; i += 2) {
                    tile.appendChild(images[i]);
                    let imageStart, imageEnd;
                    imageStart = 40 - (40 * (i * 3 - 5)/(images.length * 3 - 6));
                    imageEnd = 40 - (40 * (i * 3 - 6)/(images.length * 3 - 6))
                    images[i].style.setProperty("mask-image", "radial-gradient(#000 0% " + imageStart + "%, #0000 " + imageEnd + "%)");
                    tile.appendChild(images[i + 1]);
                    imageStart = 40 - (40 * (i * 3 - 3)/(images.length * 3 - 6));
                    imageEnd = 40 - (40 * (i * 3 - 5)/(images.length * 3 - 6))
                    images[i + 1].style.setProperty("mask-image", "radial-gradient(#000 0% " + imageStart + "%, #0000 " + imageEnd + "%)");
                }
            }
            else if (display[3] == "3307" || display[3] == "2379") {
                let scheme = display[3];
                let basefactors = [2n, 3n, 7n].concat(factorsFor3307.map(f => f[0]));
                let all_factors = [];
                let negative = false;
                let subtile_size = 0.6;
                if (Array.isArray(value)) {
                    all_factors = value;
                }
                else {
                    try {
                        value = BigInt(value);
                    }
                    catch {
                        value = 0n;
                    }
                    tile.style.setProperty("color", "#fff");
                    tile.style.setProperty("text-shadow", "0px 0px 5px #000");
                    if (value < 0n) {
                        value *= -1n;
                        negative = true;
                        tile.style.setProperty("color", "#000");
                        tile.style.setProperty("text-shadow", "0px 0px 5px #fff");
                    }
                    if (value == 0n) {
                        tile.style.setProperty("color", "#888");
                        tile.style.setProperty("background-image", "linear-gradient(#f00, #ff0, #0f0, #0ff, #00f, #f0f, #f00)");
                        tile.style.setProperty("text-shadow", "0px 0px 5px #222");
                        return;
                    }
                    else all_factors = primeFactorize(value, basefactors, true);
                }
                let factors = all_factors[0];
                while (factors[factors.length - 1] === 0) factors.pop();
                tile.style.setProperty("background-color", threeFactorColor(factors.slice(0, 3), "3307"));
                let extrafactors = [];
                for (let f = 3; f < factors.length; f++) {
                    for (let i = 0; i < factors[f]; i++) {
                        extrafactors.push(factorsFor3307[f - 3]);
                    }
                }
                for (let e = 0; e < extrafactors.length; e++) {
                    let leftImage = document.createElement("div");
                    leftImage.classList.add("primeImage");
                    tile.appendChild(leftImage);
                    leftImage.style.setProperty("width", "50%");
                    leftImage.style.setProperty("height", (200 / (extrafactors.length * 3 + 1)) + "%");
                    leftImage.style.setProperty("left", "0%");
                    leftImage.style.setProperty("top", (100 / (extrafactors.length * 3 + 1) * (e * 3 + 1)) + "%");
                    let leftDisplay = compendiumStructuredClone(display).slice(0, 5);
                    leftDisplay[4][0] = extrafactors[e][2];
                    displayTile("Subtile", leftImage, "None", "None", extrafactors[e][2], leftDisplay);
                    let rightImage = document.createElement("div");
                    rightImage.classList.add("primeImage");
                    tile.appendChild(rightImage);
                    rightImage.style.setProperty("width", "50%");
                    rightImage.style.setProperty("height", (200 / (extrafactors.length * 3 + 1)) + "%");
                    rightImage.style.setProperty("left", "50%");
                    rightImage.style.setProperty("top", (100 / (extrafactors.length * 3 + 1) * (e * 3 + 1)) + "%");
                    let rightDisplay = compendiumStructuredClone(display).slice(0, 5);
                    rightDisplay[4][0] = extrafactors[e][3];
                    displayTile("Subtile", rightImage, "None", "None", extrafactors[e][3], rightDisplay);
                }
                if (negative) {
                    let pImage = document.createElement("div");
                    tile.appendChild(pImage);
                    pImage.classList.add("primeImage");
                    pImage.style.setProperty("background-image", "radial-gradient(#0000 0% 70%, " + threeFactorColor(factors.slice(0, 3), "3307", true) + ")");
                    tile.style.setProperty("color", "black");
                    tile.style.setProperty("text-shadow", "0px 0px 5px #fff");
                }
                if (all_factors.length > 1) {
                    let subtile = document.createElement("div");
                    subtile.classList.add("subtile");
                    tile.appendChild(subtile);
                    let borderWidth = "calc(" + getComputedStyle(tile).getPropertyValue("width") + " / 40)";
                    if (hexagonal) subtile.classList.add("hexagon_clip");
                    let bcol = RGBtoArray(getComputedStyle(tile).getPropertyValue("background-color"));
                    if (bcol[0] == 0 && bcol[1] == 0 && bcol[2] == 0) subtile.style.setProperty("border-color", "#444");
                    else {
                        bcol[0] *= 0.5; bcol[1] *= 0.5; bcol[2] *= 0.5;
                        bcol = ArraytoRGB(bcol);
                        subtile.style.setProperty("border-color", bcol);
                    }
                    subtile.style.setProperty("width", subtile_size * 100 + "%");
                    subtile.style.setProperty("height", subtile_size * 100 + "%");
                    subtile.style.setProperty("left", 50 - subtile_size * 50 - (hexagonal ? 4/3 : 2) + "%");
                    subtile.style.setProperty("top", 50 - subtile_size * 50 - (hexagonal ? 4/3 : 2) + "%");
                    subtile.style.setProperty("border-width", "calc(" + borderWidth + " * " + subtile_size + ")");
                    display[4][0] = ["@Literal"].concat(all_factors.slice(1));
                    displayTile("Subtile", subtile, "None", "None", all_factors.slice(1), display.slice(0, 5));
                }
            }
            else if (display[3] == "Bitwise 2048") {
                let base = 2n;
                if (params.length > 0) {
                    try {
                        base = BigInt(params[0]);
                    }
                    catch {
                        base = 2n;
                    }
                }
                try {
                    value = BigInt(value);
                }
                catch {
                    try {
                        value = baseConvert(value, 0n);
                    }
                    catch {
                        value = 0n;
                    }
                }
                if (value == 0n) {
                    tile.style.setProperty("color", "#888");
                    tile.style.setProperty("background-color", "#000");
                    tile.style.setProperty("text-shadow", "none");
                    return;
                }
                let baseArray = baseConvert(value, base, false);
                let baseN = Number(base);
                let digits = baseArray[2];
                let background = [];
                for (let d = 0; d < digits.length; d++) {
                    let power = digits.length - d - 1;
                    let digitN = Number(digits[d]);
                    if (digits[d] > 0) {
                        let color = ["@HSLA", ((baseN - 2) * 222.49223595 + 26.5 * power * Math.log2(baseN)), (digitN / (baseN - 1) * 100), (80 - 8 * ((power * Math.log2(baseN)) % 8)), 1];
                        background.push(color, color, color);
                    }
                }
                background.unshift("@linear-gradient");
                tile.style.setProperty("color", "#000");
                if (baseArray[1] == -1n) {
                    tile.style.setProperty("color", "#fff");
                    background = ["@rotate", 180, true, background]
                }
                tile.style.setProperty("background-image", evaluateColor(background));
                let fontmin = 2;
                let fontmax = tile.firstElementChild.textContent.length * 0.7;
                //Normally, the font size on a tile is dependent on the size of the text, but if the TileTypes entry has more than four entries, the 4th and 5th entries place restrictions on the font size
                if (display[5] !== undefined) {
                    if (Array.isArray(display[5])) fontmin = CalcArray(display[5], vcoord, hcoord, 0, 0, [1, Infinity, 0], container, [], vars);
                    else fontmin = display[5];
                    if (fontmin == 0) fontmin = 2.5;
                    if (fontmin < 0) fontmin = tile.firstElementChild.textContent.length * Math.abs(fontmin);
                }
                if (display[6] !== undefined) {
                    if (Array.isArray(display[6])) fontmax = CalcArray(display[6], vcoord, hcoord, 0, 0, [1, Infinity, 0], container, [], vars);
                    else fontmax = display[6];
                    if (fontmax == 0) fontmax = -0.7;
                    if (fontmax < 0) fontmax = tile.firstElementChild.textContent.length * Math.abs(fontmax);
                }
                if (dType == "Viewer") tile.style.setProperty("font-size", "calc(var(--secondary_size) * " + (40 / Math.max(fontmin, fontmax)) * (hexagonal ? Math.sqrt(3)/2 : 1) + ")");
                else {
                    if (dType == "Grid") sizeExpression = (tsize / 100 / Math.max(fontmin, fontmax));
                    else if (dType == "Score" || dType == "ScoreSelf") sizeExpression = (6/33 / Math.max(fontmin, fontmax));
                    else sizeExpression = (4/33 / Math.max(fontmin, fontmax));
                    sizeExpression *= ((hexagonal) ? Math.sqrt(3)/2 : 1)
                    tile.style.setProperty("font-size", "calc(1vw * var(--grid_vw) * " + sizeExpression + ")");
                }
                if (base <= 64n) extraentries.push(["Innerscript", baseConvert(value, base, true), "bottom-center", 6, 0]);
                else extraentries.push(["Innerscript", [baseConvert(value, base, false)[2], "String"], "bottom-center", 6, 0])
            }
            else if (display[3] == "SCAPRIM" || display[3] == "1845") {
                let prime_amount = (display[3] == "1845") ? 1229 : Infinity;
                if (params.length > 0) prime_amount = params[0];
                let negative = false;
                let all_factors;
                if (Array.isArray(value)) {
                    all_factors = value;
                    value = primeDefactorize(value, 2);
                }
                else {
                    try {
                        value = BigInt(value);
                    }
                    catch {
                        value = 0n;
                    }
                    if (value == 0n) {
                        tile.style.setProperty("color", "#444");
                        tile.style.setProperty("background-color", "#888");
                        tile.style.setProperty("text-shadow", "none");
                        tile.style.setProperty("background-image", "none");
                        return;
                    }
                    if (value < 0n) {
                        value *= -1n;
                        negative = true;
                    }
                    all_factors = primeFactorize(value, prime_amount, false, 2, true);
                }
                let defactoredValue = Number(primeDefactorize(all_factors[0], 2));
                let factors = all_factors[0];
                if (display[3] == "SCAPRIM") {
                    if (negative) {
                        tile.style.setProperty("color", "#000");
                        tile.style.setProperty("text-shadow", "0px 0px 5px #fff");
                    }
                    else {
                        tile.style.setProperty("color", "#fff");
                        tile.style.setProperty("text-shadow", "0px 0px 5px #000");
                    }
                    let background = ["@HSLA", 200 - Math.log2(Number(defactoredValue)) * 53, 100, 90 - 90 * Number(defactoredValue)**-0.15, 1];
                    if (negative) background = ["@HSLA", 20 - Math.log2(Number(defactoredValue)) * 53, 100, 10 + 90 * Number(defactoredValue)**-0.15, 1];
                    tile.style.setProperty("background-color", evaluateColor(background));
                    if (negative) factors.unshift(-1n);
                    for (let f = 0; f < factors.length; f++) {
                        let pImage = document.createElement("div");
                        pImage.classList.add("primeImage");
                        tile.appendChild(pImage);
                        pImage.style.setProperty("width", "100%");
                        pImage.style.setProperty("height", (100 / (factors.length * 2 + 1)) + "%");
                        pImage.style.setProperty("top", (100 / (factors.length * 2 + 1) * (f * 2 + 1)) + "%");
                        pImage.style.setProperty("mask-image", "linear-gradient(#0000 0%, #000 7.5%, #4444 15%, #000 50%, #4444 85%, #000 92.5%, #0000 100%)");
                        if (factors[f] == -1n) pImage.style.setProperty("background-image", "linear-gradient(90deg, #000 0%, #fff 100%)");
                        else if (factors[f] == 1n) {
                            pImage.style.setProperty("background-image", "linear-gradient(#fff 0%, #000 25% 75%, #fff 100%)");
                        }
                        else {
                            let fiveSmooth = [0, 0, 0];
                            let gradientEntries = [];
                            let factorVal = factors[f];
                            while (factorVal > 1n) {
                                fiveSmooth = [0, 0, 0];
                                while (factorVal % 2n == 0n) {
                                    factorVal /= 2n;
                                    fiveSmooth[0]++;
                                }
                                while (factorVal % 3n == 0n) {
                                    factorVal /= 3n;
                                    fiveSmooth[1]++;
                                }
                                while (factorVal % 5n == 0n) {
                                    factorVal /= 5n;
                                    fiveSmooth[2]++;
                                }
                                gradientEntries.push(threeFactorColor(fiveSmooth, "180"));
                                factorVal -= 1n;
                                if (gradientEntries.length > 1) factorVal /= 2n;
                            }
                            let gLen = gradientEntries.length;
                            if (gradientEntries.length > 1) gradientEntries.shift();
                            if (gradientEntries.length == 1) gradientEntries.push(gradientEntries[0]);
                            gradientEntries.unshift("@linear-gradient", 90);
                            let edgesBackground;
                            if (gLen == 1) edgesBackground = "#fff";
                            else edgesBackground = evaluateColor(["@HSLA", 222.49223595 * gLen, 100, 90 - 90 * 0.8**(gLen - 2), 1]);
                            let betweenSame = [];
                            if (gLen > 1) {
                                for (let g = 0; g < gLen - 2; g++) {
                                    if (gradientEntries[g + 2] == gradientEntries[g + 3]) betweenSame.push(g + 1);
                                }
                            }
                            let betweenSameBackground = ["@linear-gradient", 90, "#0000", 0];
                            for (let b = 0; b < betweenSame.length; b++) {
                                betweenSameBackground.push("#0000", 100 / (gLen - 1) * (betweenSame[b] - 0.2), "#909090cc", 100 / (gLen - 1) * (betweenSame[b]), "#0000", 100 / (gLen - 1) * (betweenSame[b] + 0.2))
                            }
                            betweenSameBackground.push("#0000", 100);
                            pImage.style.setProperty("background-image", evaluateColor(["@multi-gradient", ["@linear-gradient", edgesBackground, 0, "#0000", 25, 75, edgesBackground, 100], betweenSameBackground, gradientEntries]))
                        }
                    }
                }
                else if (display[3] == "1845") {
                    if (negative) {
                        tile.style.setProperty("color", "#fff");
                        tile.style.setProperty("text-shadow", "0px 0px 5px #000");
                    }
                    else {
                        tile.style.setProperty("color", "#000");
                        tile.style.setProperty("text-shadow", "0px 0px 5px #fff");
                    }
                    let background = ["@HSLA", 100 + Math.log2(defactoredValue) * 43, 100, Math.abs(6 - (Math.log2(defactoredValue) % 12)) * 10 + 15, 1];
                    if (negative) {
                        background[1] += 180; background[3] = 100 - background[3];
                    }
                    let evens = 0;
                    while (factors[0] == 2n) {
                        factors.shift();
                        evens++;
                    }
                    let evensColor = ["@HSLA", evens * -37 + 100, 65, 0.9**evens * 100, 1];
                    if (negative) {
                        evensColor[1] += 180; evensColor[3] = 100 - evensColor[3];
                    }
                    tile.style.setProperty("background-image", evaluateColor(["@linear-gradient", evensColor, evensColor, background, background, evensColor, evensColor]));
                    let SCAPRIMdisplay = compendiumStructuredClone(display).slice(0, 5);
                    SCAPRIMdisplay[3] = "SCAPRIM"; SCAPRIMdisplay[4][0] = ["@Literal", factors];
                    let upperImage = document.createElement("div");
                    upperImage.classList.add("primeImage");
                    upperImage.style.setProperty("height", "25%");
                    displayTile("Subtile", upperImage, "None", "None", [factors], SCAPRIMdisplay);
                    upperImage.style.setProperty("background-color", "#0000");
                    let lowerImage = upperImage.cloneNode(true);
                    upperImage.style.setProperty("top", "0%");
                    lowerImage.style.setProperty("bottom", "0%");
                    lowerImage.style.setProperty("scale", "1 -1");
                    tile.appendChild(upperImage);
                    tile.appendChild(lowerImage);
                }
                if (all_factors.length > 1) {
                    let subtile = document.createElement("div");
                    subtile.classList.add("subtile");
                    tile.appendChild(subtile);
                    if (hexagonal) subtile.classList.add("hexagon_clip");
                    let bcol = RGBtoArray(getComputedStyle(tile).getPropertyValue("background-color"));
                    if (bcol[0] == 0 && bcol[1] == 0 && bcol[2] == 0) subtile.style.setProperty("border-color", "#444");
                    else {
                        bcol[0] *= 0.5; bcol[1] *= 0.5; bcol[2] *= 0.5;
                        bcol = ArraytoRGB(bcol);
                        subtile.style.setProperty("border-color", bcol);
                    }
                    let subtile_size = 0.6;
                    let borderWidth = "calc(" + getComputedStyle(tile).getPropertyValue("width") + " / 40)";
                    subtile.style.setProperty("width", subtile_size * 100 + "%");
                    subtile.style.setProperty("height", subtile_size * 100 + "%");
                    subtile.style.setProperty("left", 50 - subtile_size * 50 - (hexagonal ? 4/3 : 2) + "%");
                    subtile.style.setProperty("top", 50 - subtile_size * 50 - (hexagonal ? 4/3 : 2) + "%");
                    subtile.style.setProperty("border-width", "calc(" + borderWidth + " * " + subtile_size + ")");
                    display[4][0] = ["@Literal"].concat(all_factors.slice(1));
                    displayTile("Subtile", subtile, "None", "None", all_factors.slice(1), display.slice(0, 5));
                }
            }
            else if (display[3] == "3385Single") {
                let prime_amount = 168;
                if (params.length > 0) prime_amount = params[0];
                let negative = false;
                let all_factors;
                if (Array.isArray(value)) {
                    all_factors = value;
                    value = primeDefactorize(value, 2);
                }
                else {
                    try {
                        value = BigInt(value);
                    }
                    catch {
                        value = 0n;
                    }
                    if (value == 0n) {
                        tile.style.setProperty("color", "#444");
                        tile.style.setProperty("background-color", "#888");
                        tile.style.setProperty("text-shadow", "none");
                        tile.style.setProperty("background-image", "none");
                        return;
                    }
                    if (value < 0n) {
                        value *= -1n;
                        negative = true;
                    }
                    all_factors = primeFactorize(value, prime_amount, false, 2, true);
                }
                let defactoredValue = Number(primeDefactorize(all_factors[0], 2));
                let factors = all_factors[0];
                let firstThree = [0, 0, 0];
                while (factors[0] == 2n) {
                    firstThree[0]++;
                    factors.shift();
                }
                while (factors[0] == 3n) {
                    firstThree[1]++;
                    factors.shift();
                }
                while (factors[0] == 5n) {
                    firstThree[2]++;
                    factors.shift();
                }
                tile.style.setProperty("background-color", threeFactorColor(firstThree, "3385"));
                for (let f = 0; f < factors.length; f++) {
                    let pImage = document.createElement("div");
                    pImage.classList.add("primeImage");
                    tile.appendChild(pImage);
                    pImage.style.setProperty("height", "100%");
                    pImage.style.setProperty("width", (150 / (factors.length * 2 + 1)) + "%");
                    pImage.style.setProperty("left", (100 / (factors.length * 2 + 1) * (f * 2 + 0.75)) + "%");
                    pImage.style.setProperty("mask-image", "linear-gradient(90deg, #0000 0%, #000 45% 55%, #0000 100%)");
                    let factorValue = factors[f];
                    let squares = [];
                    while (factorValue != 0n) {
                        let toSubtract = 0n;
                        if (factorValue < 0n) toSubtract = -1n;
                        else if (factorValue < 2n) toSubtract = 1n;
                        else if (factorValue < 4n) toSubtract = 2n;
                        else if (factorValue < 8n) toSubtract = 4n;
                        else toSubtract = iroot(factorValue + 1n, 2n)**2n;
                        squares.push(toSubtract);
                        factorValue -= toSubtract;
                    }
                    let mod27display = compendiumStructuredClone(display).slice(0, 5);
                    mod27display[3] = "mod 27";
                    mod27display[4][1] = 90;
                    for (let s = 0; s < squares.length; s++) {
                        let squareImage = document.createElement("div");
                        squareImage.classList.add("primeImage");
                        pImage.appendChild(squareImage);
                        let widthMult = 3;
                        if (squares.length == 1) widthMult = 1;
                        else if (s == 0 || s == squares.length - 1) widthMult = 2;
                        if (s == 0) {
                            squareImage.style.setProperty("mask-image", "none");
                        }
                        else {
                            squareImage.style.setProperty("mask-image", "linear-gradient(#0000 0% " + (100 / (squares.length * 2 - 1) * (s * 2 - 1)) + "%, #000 " + (100 / (squares.length * 2 - 1) * (s * 2)) + "%)");
                        }
                        if (squares[s] == -1n) squareImage.style.setProperty("background-color", "#fff"); 
                        else if (squares[s] == 1n) squareImage.style.setProperty("background-color", "#000");
                        else if (squares[s] == 2n) squareImage.style.setProperty("background-color", "#800");
                        else if (squares[s] == 4n) squareImage.style.setProperty("background-color", "#f00");
                        else {
                            mod27display[4][0] = iroot(squares[s], 2n);
                            displayTile("Subtile", squareImage, "None", "None", mod27display[4][0], mod27display);
                        }
                    }
                }
                if (negative) {
                    tile.style.setProperty("color", "#000");
                    tile.style.setProperty("text-shadow", "0px 0px 5px #fff");
                    let pImage = document.createElement("div");
                    tile.appendChild(pImage);
                    pImage.classList.add("primeImage");
                    pImage.style.setProperty("background-image", "radial-gradient(#0000 0% 70%, " + threeFactorColor(firstThree, "3385", true) + ")");
                }
                else {
                    tile.style.setProperty("color", "#fff");
                    tile.style.setProperty("text-shadow", "0px 0px 5px #000");
                }
                if (all_factors.length > 1) {
                    let subtile = document.createElement("div");
                    subtile.classList.add("subtile");
                    tile.appendChild(subtile);
                    if (hexagonal) subtile.classList.add("hexagon_clip");
                    let bcol = RGBtoArray(getComputedStyle(tile).getPropertyValue("background-color"));
                    if (bcol[0] == 0 && bcol[1] == 0 && bcol[2] == 0) subtile.style.setProperty("border-color", "#444");
                    else {
                        bcol[0] *= 0.5; bcol[1] *= 0.5; bcol[2] *= 0.5;
                        bcol = ArraytoRGB(bcol);
                        subtile.style.setProperty("border-color", bcol);
                    }
                    let subtile_size = 0.5;
                    let borderWidth = "calc(" + getComputedStyle(tile).getPropertyValue("width") + " / 40)";
                    subtile.style.setProperty("width", subtile_size * 100 + "%");
                    subtile.style.setProperty("height", subtile_size * 100 + "%");
                    subtile.style.setProperty("left", 50 - subtile_size * 50 - (hexagonal ? 4/3 : 2) + "%");
                    subtile.style.setProperty("top", 50 - subtile_size * 50 - (hexagonal ? 4/3 : 2) + "%");
                    subtile.style.setProperty("border-width", "calc(" + borderWidth + " * " + subtile_size + ")");
                    display[4][0] = ["@Literal"].concat(all_factors.slice(1));
                    displayTile("Subtile", subtile, "None", "None", all_factors.slice(1), display.slice(0, 5));
                }
            }
            else if (display[3] == "3385") {
                let prime_amount = 168;
                if (params.length > 0) prime_amount = params[0];
                let subtile_size = 0.5;
                let all_factors = [];
                let negative = false;
                if (Array.isArray(value)) {
                    all_factors = value;
                }
                else {
                    try {
                        value = BigInt(value);
                    }
                    catch {
                        value = 0n;
                    }
                    if (value < 0n) {
                        value *= -1n;
                        negative = true;
                    }
                    if (value == 0n) {
                        tile.style.setProperty("color", "#444");
                        tile.style.setProperty("background-color", "#888");
                        tile.style.setProperty("text-shadow", "none");
                        tile.style.setProperty("background-image", "none");
                        return;
                    }
                    else all_factors = primeFactorize(value, prime_amount, false, 1, true);
                }
                let factors = all_factors[0];
                let leftFactors = []
                let rightFactors = [];
                for (let f = 0; f < factors.length; f++) {
                    if (factors[f][1] % 2n == 1n) leftFactors.push(factors[f][0]);
                    let squarePower = factors[f][1] / 2n;
                    for (let p = 0; p < squarePower; p++) rightFactors.push(factors[f][0])
                }
                let leftImage = document.createElement("div");
                leftImage.classList.add("primeImage");
                tile.appendChild(leftImage);
                leftImage.style.setProperty("width", "50%");
                leftImage.style.setProperty("left", "0%");
                let rightImage = document.createElement("div");
                rightImage.classList.add("primeImage");
                tile.appendChild(rightImage);
                rightImage.style.setProperty("width", "50%");
                rightImage.style.setProperty("right", "0%");
                let singleDisplay = compendiumStructuredClone(display).slice(0, 5);
                singleDisplay[3] = "3385Single";
                singleDisplay[4][0] = ["@Literal", leftFactors];
                displayTile("Subtile", leftImage, "None", "None", [leftFactors], singleDisplay);
                singleDisplay[4][0] = ["@Literal", rightFactors]
                displayTile("Subtile", rightImage, "None", "None", [rightFactors], singleDisplay);
                let leftColor = getComputedStyle(leftImage).getPropertyValue("background-color");
                let rightColor = getComputedStyle(rightImage).getPropertyValue("background-color");
                tile.style.setProperty("background-image", "linear-gradient(90deg, " + leftColor + " 0% 30%, " + rightColor + " 70%)");
                leftImage.style.setProperty("background-color", "transparent");
                rightImage.style.setProperty("background-color", "transparent");
                if (negative) {
                    let pImage = document.createElement("div");
                    tile.appendChild(pImage);
                    pImage.classList.add("primeImage");
                    pImage.style.setProperty("background-image", "radial-gradient(#0000 0% 70%, " + evaluateColor(rotateColor(["@RGBA"].concat(RGBtoArray(leftColor).map(x => Number(x)), [1]), 180, true)) + " 100%)");
                    tile.style.setProperty("color", "#000");
                    tile.style.setProperty("text-shadow", "0px 0px 5px #fff");
                }
                else {
                    tile.style.setProperty("color", "#fff");
                    tile.style.setProperty("text-shadow", "0px 0px 5px #000");
                }
                if (all_factors.length > 1) {
                    let subtile = document.createElement("div");
                    subtile.classList.add("subtile");
                    tile.appendChild(subtile);
                    let borderWidth = "calc(" + getComputedStyle(tile).getPropertyValue("width") + " / 40)";
                    if (hexagonal) subtile.classList.add("hexagon_clip");
                    let upperBCol = RGBtoArray(getComputedStyle(leftImage).getPropertyValue("background-color"));
                    if (upperBCol[0] == 0 && upperBCol[1] == 0 && upperBCol[2] == 0) upperBCol = "#444";
                    else {
                        upperBCol[0] *= 0.5; upperBCol[1] *= 0.5; upperBCol[2] *= 0.5;
                        upperBCol = ArraytoRGB(upperBCol);
                    }
                    let lowerBCol = RGBtoArray(getComputedStyle(rightImage).getPropertyValue("background-color"));
                    if (lowerBCol[0] == 0 && lowerBCol[1] == 0 && lowerBCol[2] == 0) lowerBCol = "#444";
                    else {
                        lowerBCol[0] *= 0.5; lowerBCol[1] *= 0.5; lowerBCol[2] *= 0.5;
                        lowerBCol = ArraytoRGB(lowerBCol);
                    }
                    subtile.style.setProperty("border-image-source", "linear-gradient(" + upperBCol + " 0% 25%, " + lowerBCol + " 75%)");
                    subtile.style.setProperty("border-image-slice", 1);
                    subtile.style.setProperty("width", subtile_size * 100 + "%");
                    subtile.style.setProperty("height", subtile_size * 100 + "%");
                    subtile.style.setProperty("left", 50 - subtile_size * 50 - (hexagonal ? 4/3 : 2) + "%");
                    subtile.style.setProperty("top", 50 - subtile_size * 50 - (hexagonal ? 4/3 : 2) + "%");
                    subtile.style.setProperty("border-width", "calc(" + borderWidth + " * " + subtile_size + ")");
                    display[4][0] = ["@Literal"].concat(all_factors.slice(1));
                    displayTile("Subtile", subtile, "None", "None", all_factors.slice(1), display.slice(0, 5));
                }
            }
            else if (display[3] == "LOCEF") {
                let prime_amount = 168;
                if (params.length > 0) prime_amount = params[0];
                let all_factors = [];
                let negative = false;
                if (Array.isArray(value)) {
                    all_factors = value;
                }
                else {
                    try {
                        value = BigInt(value);
                    }
                    catch {
                        value = 0n;
                    }
                    tile.style.setProperty("color", "#fff");
                    tile.style.setProperty("text-shadow", "0px 0px 5px #000");
                    if (value < 0n) {
                        value *= -1n;
                        negative = true;
                    }
                    if (value == 0n) {
                        tile.style.setProperty("color", "#444");
                        tile.style.setProperty("background-color", "#888");
                        tile.style.setProperty("text-shadow", "none");
                        tile.style.setProperty("background-image", "none");
                        return;
                    }
                    else all_factors = primeFactorize(value, prime_amount, false, 1, true);
                }
                let factors = all_factors[0];
                factors.push([1n, 0n]);
                let evens = 0;
                if (factors[0][0] == 2n) {
                    evens = Number(factors[0][1]);
                    factors.shift();
                }
                let firstThree = [0, 0, 0];
                if (factors[0][0] == 3n) {
                    firstThree[0] = Number(factors[0][1]);
                    factors.shift();
                }
                if (factors[0][0] == 5n) {
                    firstThree[1] = Number(factors[0][1]);
                    factors.shift();
                }
                if (factors[0][0] == 7n) {
                    firstThree[2] = Number(factors[0][1]);
                    factors.shift();
                }
                factors.pop();
                tile.style.setProperty("background-color", threeFactorColor(firstThree, "LOCEF", negative));
                for (let f = 0; f < factors.length; f++) {
                    let binaryDigits = baseConvert(factors[f][0] + 1n, 2n)[2];
                    let sectionDigits = [];
                    for (let b = 0; b < binaryDigits.length; b++) {
                        if (binaryDigits[b] == 1n) sectionDigits.push([binaryDigits.length - b - 1, 1]);
                        else sectionDigits[sectionDigits.length - 1][1]++;
                    }
                    let startColor = (Number(factors[f][0]) + 1) * 36.4057647469;
                    let background = ["@linear-gradient", 90];
                    for (let s = 0; s < sectionDigits.length; s++) {
                        let currentColor = ["@HSLA", startColor + 43 * sectionDigits[s][0], 100, 0.8**sectionDigits[s][1] * 80 + 10, 1];
                        if (negative) {
                            currentColor[1] += 180;
                            currentColor[3] = 100 - currentColor[3];
                        }
                        background.push(evaluateColor(currentColor));
                    }
                    if (background.length == 3) background = [background[0], background[1], background[2], background[2]];
                    let overlay = evaluateColor(["@HSLA", startColor, 100, 50, 0.75])
                    background = ["@multi-gradient", ["@linear-gradient", 90, "#0000", overlay], background];
                    let direction = (Number(factors[f][0]) + 1) * 131.769145362;
                    let width = 150 / (Math.log2(Number(factors[f][0]) + 1)**1.25);
                    let power = Number(factors[f][1]);
                    for (let p = 0; p < power; p++) {
                        let pImage = document.createElement("div");
                        tile.appendChild(pImage);
                        pImage.classList.add("primeImage");
                        background[1][1] = direction; background[2][1] = direction;
                        pImage.style.setProperty("background-image", evaluateColor(background));
                        pImage.style.setProperty("mask-image", "repeating-linear-gradient(" + (direction + 90) + "deg, #0000 0% " + width * 3/4 + "%, #000b " + width * 3/4 + "% " + width + "%)")
                        direction += 180 / power;
                    }
                }
                if (evens > 0) {
                    let pImage = document.createElement("div");
                    pImage.classList.add("primeImage");
                    tile.appendChild(pImage);
                    let evensColor = ["@HSLA", evens * 37, 75, 0.95**evens * 50, 1];
                    if (negative) {
                        evensColor[1] += 180;
                        evensColor[3] = 100 - evensColor[3];
                    }
                    pImage.style.setProperty("background-image", evaluateColor(["@radial-gradient", "#0000", 0, 65, evensColor, 90, 100]));
                }
                if (negative) {
                    tile.style.setProperty("color", "#fff");
                    tile.style.setProperty("text-shadow", "0px 0px 5px #000");
                }
                else {
                    tile.style.setProperty("color", "#000");
                    tile.style.setProperty("text-shadow", "0px 0px 5px #fff");
                }
                if (all_factors.length > 1) {
                    let subtile = document.createElement("div");
                    subtile.classList.add("subtile");
                    tile.appendChild(subtile);
                    if (hexagonal) subtile.classList.add("hexagon_clip");
                    let bcol = RGBtoArray(getComputedStyle(tile).getPropertyValue("background-color"));
                    if (bcol[0] == 0 && bcol[1] == 0 && bcol[2] == 0) subtile.style.setProperty("border-color", "#444");
                    else {
                        bcol[0] *= 0.5; bcol[1] *= 0.5; bcol[2] *= 0.5;
                        bcol = ArraytoRGB(bcol);
                        subtile.style.setProperty("border-color", bcol);
                    }
                    let subtile_size = 0.55;
                    let borderWidth = "calc(" + getComputedStyle(tile).getPropertyValue("width") + " / 40)";
                    subtile.style.setProperty("width", subtile_size * 100 + "%");
                    subtile.style.setProperty("height", subtile_size * 100 + "%");
                    subtile.style.setProperty("left", 50 - subtile_size * 50 - (hexagonal ? 4/3 : 2) + "%");
                    subtile.style.setProperty("top", 50 - subtile_size * 50 - (hexagonal ? 4/3 : 2) + "%");
                    subtile.style.setProperty("border-width", "calc(" + borderWidth + " * " + subtile_size + ")");
                    display[4][0] = ["@Literal"].concat(all_factors.slice(1));
                    displayTile("Subtile", subtile, "None", "None", all_factors.slice(1), display.slice(0, 5));
                }
            }
            else if (display[3] == "TRIGAT") {
                try {
                    value = BigInt(value);
                }
                catch {
                    value = 0n;
                }
                let negative = false;
                if (value == 0n) {
                    tile.style.setProperty("color", "#444");
                    tile.style.setProperty("background-color", "#888");
                    tile.style.setProperty("text-shadow", "none");
                    tile.style.setProperty("background-image", "none");
                    return;
                }
                if (value < 0n) {
                    value *= -1n;
                    negative = true;
                }
                if (negative) {
                    tile.style.setProperty("color", "#000");
                    tile.style.setProperty("text-shadow", "0px 0px 5px #fff");
                }
                else {
                    tile.style.setProperty("color", "#fff");
                    tile.style.setProperty("text-shadow", "0px 0px 5px #000");
                }
                let triangularFactors = function(n) {
                    let factorList = listFactors(n);
                    let result = [];
                    for (let f of factorList) {
                        if (f % 2n == 1n && f > 1n) {
                            if (n % (f * (f - 1n)/2n) == 0n && binarySearch(result, f - 1n) == -1) binaryInsert(result, f - 1n);
                            if (n % (f * (f + 1n)/2n) == 0n && binarySearch(result, f) == -1) binaryInsert(result, f);
                        }
                    }
                    return result;
                }
                let conesInProgress = [];
                let finalCones = [];
                let currentTriangulars = triangularFactors(value);
                let leftover = value / currentTriangulars.reduce((a, b) => lcm(a, b * (b + 1n)/2n), 1n);
                let color = ["@HSLA", (Math.log2(Number(leftover) + 2) - 2) * 141, (leftover == 1n ? 0 : 100), (leftover == 1n ? 0 : (80 * (1 - Number(leftover)**(-1/4)) + 10)), 1];
                let backgroundColor = evaluateColor(color);
                let rotatedBackground = evaluateColor(rotateColor(color, 180, true));
                tile.style.setProperty("background-color", backgroundColor);
                let coneWidth = min(360 / currentTriangulars.length, 120);
                let angle;
                for (let t = 0; t < currentTriangulars.length; t++) {
                    angle = 360 / currentTriangulars.length * t;
                    conesInProgress.push([1, currentTriangulars[t], angle - coneWidth * 1/3, angle + coneWidth * 1/3])
                }
                let currentCone, currentValue, outerConeWidth;
                while (conesInProgress.length > 0) {
                    currentCone = conesInProgress[0];
                    currentValue = currentCone[1];
                    currentTriangulars = triangularFactors(currentValue);
                    leftover = currentValue / currentTriangulars.reduce((a, b) => lcm(a, b * (b + 1n)/2n), 1n);
                    color = ["@HSLA", (Math.log2(Number(leftover) + 2) - 2) * 141, (leftover == 1n ? 0 : 100), (leftover == 1n ? 0 : (80 * (1 - Number(leftover)**(-1/4)) + 10)), 1];
                    color[3] = 95 - ((95 - color[3]) * 0.9**currentCone[0]);
                    finalCones.push([currentCone[0], evaluateColor(color), currentCone[2], currentCone[3]]);
                    outerConeWidth = modularDistance(currentCone[2], currentCone[3], 360) * 0.8
                    coneWidth = outerConeWidth / (currentTriangulars.length * 2 + 1) * 1.5;
                    for (let t = 0; t < currentTriangulars.length; t++) {
                        angle = currentCone[2] + outerConeWidth * 0.125 + outerConeWidth / (currentTriangulars.length * 2) * (t * 2 + 1);
                        conesInProgress.push([currentCone[0] + 1, currentTriangulars[t], angle - coneWidth * 1/2, angle + coneWidth * 1/2]);
                    }
                    conesInProgress.shift();
                }
                let tierCones, startAngle; let currentTier = 0;
                while (finalCones.length > 0) {
                    tierCones = [];
                    currentTier++;
                    while (finalCones.length > 0 && finalCones[0][0] == currentTier) {
                        tierCones.push(finalCones.shift());
                    }
                    startAngle = 0;
                    if (tierCones.length == 1) startAngle = -90;
                    else startAngle = (tierCones[tierCones.length - 1][3] - 360) + modularDistance(tierCones[tierCones.length - 1][3], tierCones[0][2], 360)/2;
                    for (let t = 0; t < tierCones.length; t++) {
                        tierCones[t][2] -= startAngle; tierCones[t][3] -= startAngle;
                    }
                    let gradient = ["@conic-gradient", startAngle, "#0000", 0];
                    for (let t = 0; t < tierCones.length; t++) {
                        gradient.push(tierCones[t][2], tierCones[t][1], (tierCones[t][2] + (tierCones[t][3] - tierCones[t][2]) * 0.1), (tierCones[t][2] + (tierCones[t][3] - tierCones[t][2]) * 0.9), "#0000", tierCones[t][3]);
                    }
                    let pImage = document.createElement("div");
                    pImage.classList.add("primeImage");
                    tile.appendChild(pImage);
                    pImage.style.setProperty("background-image", evaluateColor(gradient));
                }
                if (negative) {
                    let pImage = document.createElement("div");
                    tile.appendChild(pImage);
                    pImage.classList.add("primeImage");
                    pImage.style.setProperty("background-image", "radial-gradient(#0000 0% 70%, " + rotatedBackground + ")");
                }
            }
            else if (display[3] == "Gaussian DIVE") {
                let prime_amount = 1232;
                if (params.length > 0) prime_amount = params[0];
                let subtile_size = 0.5;
                let all_factors = [];
                if (Array.isArray(value)) {
                    all_factors = value;
                    leftover = gaussian_primeDefactorize(value);
                    while (gaussian_primes.length < prime_amount) gaussianPrimesUpdate(gaussian_primes[gaussian_primes.length - 1].norm() * 2n);
                }
                else {
                    try {
                        value = new GaussianBigInt(value);
                    }
                    catch {
                        value = new GaussianBigInt(0n, 0n);
                    }
                    while (gaussian_primes.length < prime_amount && gaussian_primes[gaussian_primes.length - 1].norm() < value.norm()) gaussianPrimesUpdate(gaussian_primes[gaussian_primes.length - 1].norm() * 2n);
                    leftover = value;
                    let leftoverhue = leftover.quadrant();
                    tile.style.setProperty("color", "white");
                    if (leftoverhue == 0n) tile.style.setProperty("color", "hsla(0, 100%, 75%, 1)");
                    if (leftoverhue == 1n) tile.style.setProperty("color", "hsla(90, 100%, 75%, 1)");
                    if (leftoverhue == 2n) tile.style.setProperty("color", "hsla(180, 100%, 75%, 1)");
                    if (leftoverhue == 3n) tile.style.setProperty("color", "hsla(270, 100%, 75%, 1)");
                    tile.style.setProperty("--shadow-color", "black");
                    if (value.eq([0n, 0n])) {
                        tile.style.setProperty("color", "#888");
                        tile.style.setProperty("background-color", "#444");
                        return;
                    }
                    else all_factors = gaussian_primeFactorize(value, prime_amount);
                }
                let factors = all_factors[0];
                while (factors[factors.length - 1] == 0) factors.pop();
                while (factors.length < 6) factors.push(0);
                tile.style.setProperty("background-image", "linear-gradient(" + threeFactorColor(factors.slice(0, 3), "GaussianDIVE1") + "0% 33.333%, " + threeFactorColor(factors.slice(3, 6), "GaussianDIVE2") + " 66.666% 100%)");
                if (factors.length > 6) {
                    for (let p = 6; p < factors.length; p++) {
                        if (factors[p] > 0) {
                            let pImage = document.createElement("div");
                            pImage.classList.add("primeImage");
                            tile.appendChild(pImage);
                            if (p == 6) {
                                pImage.style.setProperty("background-image", "conic-gradient(at 50% -10%, #0000 0% 35%, #000 40% 45%, #fff 47.5% 52.5%, #000 55% 60%, #0000 65%)");
                                pImage.style.setProperty("mask-image", "radial-gradient(at 50% 0%, #000, #0000 50%)")
                            }
                            else if (p == 7) {
                                pImage.style.setProperty("background-image", "conic-gradient(from 180deg at 50% 110%, #0000 0% 35%, #000 40% 45%, #fff 47.5% 52.5%, #000 55% 60%, #0000 65%)");
                                pImage.style.setProperty("mask-image", "radial-gradient(at 50% 100%, #000, #0000 50%)")
                            }
                            else if (p == 8) {
                                pImage.style.setProperty("background-image", "conic-gradient(from 90deg at 110% 50%, #0000 0% 35%, #000 40% 45%, #fff 47.5% 52.5%, #000 55% 60%, #0000 65%)");
                                pImage.style.setProperty("mask-image", "radial-gradient(at 100% 50%, #000, #0000 50%)")
                            }
                            else if (p == 9) {
                                pImage.style.setProperty("background-image", "conic-gradient(from 270deg at -10% 50%, #0000 0% 35%, #000 40% 45%, #fff 47.5% 52.5%, #000 55% 60%, #0000 65%)");
                                pImage.style.setProperty("mask-image", "radial-gradient(at 0% 50%, #000, #0000 50%)")
                            }
                            else {
                                let prime = gaussian_primes[p];
                                let reversedTerms = (prime.real < prime.imaginary);
                                let direction = 45 + 291.246118 * (Number(prime.norm()) - 3) + 90 * reversedTerms;
                                if (reversedTerms) prime = new GaussianBigInt(prime.imaginary, prime.real);
                                let basenum;
                                basenum = prime.add([0n, 1n]).div([1n, -1n]);
                                let bfCombined = gaussian_primeFactorize(basenum, 6);
                                let basefactors = bfCombined[0];
                                let baseunit = bfCombined[1]
                                while (basefactors.length < 6) basefactors.push(0);
                                let basecolor1 = threeFactorColor(basefactors.slice(0, 3), "GaussianDIVE1_primeGrey");
                                let basecolor2 = threeFactorColor(basefactors.slice(3, 6), "GaussianDIVE2_primeGrey");
                                let residuenum = basenum.div(gaussian_primeDefactorize([basefactors, baseunit]));
                                let residueList = GaussianDIVEresidueFactor(residuenum, 6, prime_amount);
                                let layerDepth = arrayDepth(residueList) / 2;
                                let layerNum = 1;
                                let width = 80 / Math.pow(Number(prime.norm()), 1/4);
                                if (residuenum.norm() == 1n) {
                                    pImage.style.setProperty("background-image", "repeating-linear-gradient(" + (direction + 90) + "deg, " + basecolor1 + " " + (width * 0) + "% " + (width * 1/4) + "%, " + basecolor2 + " " + (width * 1/2) + "% " + (width * 3/4) + "%, " + basecolor1 + " " + (width * 1) + "%)");
                                }
                                else {
                                    let longBar = ((residueList.length > 3) || (residueList[2][2].length > 2));
                                    let outercolor1 = threeFactorColor(basefactors.slice(0, 3), "GaussianDIVE1_primeGrey", false, 0.75);
                                    let outercolor2 = threeFactorColor(basefactors.slice(3, 6), "GaussianDIVE2_primeGrey", false, 0.75)
                                    let innermax = residueList.slice(2).reduce(
                                        function(total, value) {
                                            return max(total, value[1].norm() ** value[0]);
                                        }, 0n
                                    );
                                    let length = 80 / Math.pow(Number(innermax), 1/4) / (residueList.length - 2);
                                    let innercolors = [];
                                    for (let i = 2; i < residueList.length; i++) {
                                        innercolors.push([residueList[i][1], residueList[i][2][0], residueList[i][0]]);
                                    }
                                    let result = "repeating-linear-gradient(" + (direction + 90) + "deg";
                                    let innerBars = [];
                                    let length_to_add = 0;
                                    let length_thus_far = 0;
                                    let iteration_length = 0;
                                    for (let b = 0; b < innercolors.length * 2; b++) {
                                        let inner_color = innercolors[b % innercolors.length];
                                        if (longBar) length_to_add = length / 2;
                                        else length_to_add = length * 2/3;
                                        if (b % 2 == 1) result += (", " + outercolor2 + " " + length_thus_far + "% " + (length_thus_far + length_to_add * 1/4) + "%, " + outercolor1 + " " + (length_thus_far + length_to_add * 3/4) + "% " + (length_thus_far + length_to_add) + "%, ");
                                        else result += (", " + outercolor1 + " " + length_thus_far + "% " + (length_thus_far + length_to_add * 1/4) + "%, " + outercolor2 + " " + (length_thus_far + length_to_add * 3/4) + "% " + (length_thus_far + length_to_add) + "%, ");
                                        length_thus_far += length_to_add;
                                        if (longBar) length_to_add = length / 2;
                                        else length_to_add = length/3;
                                        length_to_add *= Math.pow(Number(inner_color[0].norm()) ** Number(inner_color[2]) / Number(innermax), 1/4);
                                        result += GaussianDIVERenderInnerBar(inner_color[1], length_thus_far, length_to_add, layerNum, layerDepth);
                                        if (b < innercolors.length) innerBars.push([[b + 2], length_thus_far, length_to_add]);
                                        length_thus_far += length_to_add;
                                        if (b == innercolors.length - 1) iteration_length = length_thus_far;
                                    }
                                    result += ")";
                                    pImage.style.setProperty("background-image", result);
                                    while (innerBars.length > 0) {
                                        layerNum++;
                                        let layerLength = innerBars.length;
                                        let layerBars = [];
                                        for (let b = 0; b < layerLength; b++) {
                                            let target = nestedElement(residueList, innerBars[0][0])[2];
                                            if (target.length > 1) {
                                                let deepmax = target.slice(2).reduce(
                                                    function(total, value) {
                                                        return max(total, value[1].norm() ** value[0]);
                                                    }, 0n
                                                );
                                                let segments = [];
                                                length_thus_far = 0;
                                                length_to_add = 0;
                                                for (let t = 2; t < target.length; t++) {
                                                    length_to_add = 1;
                                                    segments.push(["#0000", length_thus_far, length_thus_far + length_to_add]);
                                                    length_thus_far += length_to_add;
                                                    length_to_add = Math.pow(Number(target[t][1].norm()) ** Number(target[t][0]) / Number(deepmax), 1/3);
                                                    segments.push([target[t][2][0], length_thus_far, length_thus_far + length_to_add]);
                                                    length_thus_far += length_to_add;
                                                }
                                                length_to_add = 1;
                                                segments.push(["#0000", length_thus_far, length_thus_far + length_to_add]);
                                                length_thus_far += length_to_add;
                                                for (let s = 1; s < segments.length; s += 2) {
                                                    layerBars.push([GaussianDIVERenderInnerBar(segments[s][0], innerBars[0][1] + innerBars[0][2] * segments[s][1]/length_thus_far, innerBars[0][2] * (segments[s][2] - segments[s][1])/length_thus_far, layerNum, layerDepth), innerBars[0][1] + innerBars[0][2] * segments[s][1]/length_thus_far, innerBars[0][1] + innerBars[0][2] * segments[s][2]/length_thus_far]);
                                                    innerBars.push([innerBars[0][0].concat(2, (s + 3)/2), innerBars[0][1] + innerBars[0][2] * segments[s][1]/length_thus_far, innerBars[0][2] * (segments[s][2] - segments[s][1])/length_thus_far]);
                                                }
                                            }
                                            innerBars.shift();
                                        }
                                        if (layerBars.length > 0) {
                                            let layerImage = document.createElement("div");
                                            layerImage.classList.add("primeImage");
                                            pImage.appendChild(layerImage);
                                            let layerBackground = "repeating-linear-gradient(" + (direction + 90) + "deg";
                                            let previousend = 0;
                                            for (let b = 0; b < layerBars.length; b++) {
                                                layerBackground += ", #0000 " + previousend + "% " + layerBars[b][1] + "%, " + layerBars[b][0];
                                                previousend = layerBars[b][2];
                                            }
                                            layerBackground += ", #0000 " + previousend + "% " + iteration_length + "%)";
                                            layerImage.style.setProperty("background-image", layerBackground);
                                            layerImage.style.setProperty("mask-image", "repeating-linear-gradient(" + direction + "deg, #000 0% " + (width * 1/8) + "%, #0000 " + (width * 1/8) + "% " + (width * 7/8) + "%, #000 " + (width * 7/8) + "% " + width + "%)");
                                        }
                                    }
                                }
                                pImage.style.setProperty("mask-image", "repeating-linear-gradient(" + direction + "deg, #000 0% " + (width * 1/8) + "%, #0000 " + (width * 1/8) + "% " + (width * 7/8) + "%, #000 " + (width * 7/8) + "% " + width + "%)");
                            }
                            pImage.style.setProperty("opacity", 0.5 * Number(factors[p]));
                        }
                    }
                }
                // let quadrant = all_factors[1];
                // if (!eqPrimArrays(quadrant, [0n, 0n])) {
                //     let quadrantHue = 0;
                //     if (eqPrimArrays(quadrant, [0n, 1n])) quadrantHue = 90;
                //     if (eqPrimArrays(quadrant, [-1n, 0n])) quadrantHue = 180;
                //     if (eqPrimArrays(quadrant, [0n, -1n])) quadrantHue = 270;
                //     let pImage = document.createElement("div");
                //     tile.appendChild(pImage);
                //     pImage.classList.add("primeImage");
                //     pImage.style.setProperty("background-image", "radial-gradient(#0000 0% 80%, " + ("hsla(" + quadrantHue + ", 100%, 70%, 0.5)") + ", " + ("hsla(" + quadrantHue + ", 100%, 30%, 1)") + ")");
                // }
                if (all_factors.length > 2) {
                    let subtile = document.createElement("div");
                    subtile.classList.add("subtile");
                    tile.appendChild(subtile);
                    if (all_factors[2] == true) subtile.style.setProperty("border-color", "#fff");
                    else subtile.style.setProperty("border-color", "#000");
                    subtile.style.setProperty("width", subtile_size * 100 + "%");
                    subtile.style.setProperty("height", subtile_size * 100 + "%");
                    subtile.style.setProperty("left", 50 - subtile_size * 50 - 2 + "%");
                    subtile.style.setProperty("top", 50 - subtile_size * 50 - 2 + "%");
                    subtile.style.setProperty("border-width", "calc(" + getComputedStyle(tile).getPropertyValue("border-width") + " * " + subtile_size + ")");
                    displayTile("Subtile", subtile, "None", "None", [all_factors.slice(3)], display.slice(0, 5));
                }
            }
        }
        for (let d = 7; d < display.length; d++) {
            if (display[d][0] == "ExtraEntriesList") extraentries = extraentries.concat(CalcArray(display[d].slice(1), vcoord, hcoord, 0, 0, [1, Infinity, 0], container, [], vars))
            else extraentries.push(display[d]);
        }
        for (let elem of extraentries) { //If a TileTypes entry has more than six entries, all entries after the 5th relate to additional pieces of text or additional images on the tile, such as how Isotopic 256 displays the radioactivity counters
            if (elem[0] === "Innerscript") {
                let innerdisplay = elem.slice(1);
                let innerscript = document.createElement("p");
                let innertext = document.createElement("span");
                innerscript.appendChild(innertext);
                tile.appendChild(innerscript);
                innerscript.classList.add("tile_text");
                innerscript.style.setProperty("position", "absolute");
                let vert = (innerdisplay[1].split("-"))[0];
                let horiz = (innerdisplay[1].split("-"))[1];
                innerscript.style.setProperty("display", "flex");
                if (hexagonal) {
                    innerscript.style.setProperty("width", "80%");
                    innerscript.style.setProperty("height", "80%");
                }
                else {
                    innerscript.style.setProperty("width", "100%");
                    innerscript.style.setProperty("height", "100%");
                }
                if (vert == "top") {
                    innerscript.style.setProperty("align-items", "flex-start");
                }
                else if (vert == "bottom") {
                    innerscript.style.setProperty("align-items", "flex-end");
                }
                else {
                    innerscript.style.setProperty("align-items", "center");
                }
                if (horiz == "left") {
                    innerscript.style.setProperty("justify-content", "flex-start");
                }
                else if (horiz == "right") {
                    innerscript.style.setProperty("justify-content", "flex-end");
                }
                else {
                    innerscript.style.setProperty("justify-content", "center");
                }
                if (hiddenTileText || (dType == "Viewer" && !screenVars[2])) innertext.innerHTML = "";
                else innertext.innerHTML = defaultAbbreviate(CalcArray(innerdisplay[0], vcoord, hcoord, 0, 0, [1, Infinity, 0], container, [], vars));
                let fontmin = 2;
                let fontmax = innerscript.textContent.length * 0.7;
                if (innerdisplay.length > 2) {
                    if (innerdisplay[2] > 0) fontmin = innerdisplay[2];
                    else if (innerdisplay[2] < 0) fontmin = innerscript.textContent.length * innerdisplay[2];
                }
                if (innerdisplay.length > 3) {
                    if (innerdisplay[3] > 0) fontmax = innerdisplay[3];
                    else if (innerdisplay[3] < 0) fontmax = innerscript.textContent.length * innerdisplay[3];
                }
                if (dType == "Viewer") innerscript.style.setProperty("font-size", "calc(var(--secondary_size) * " + (40 / Math.max(fontmin, fontmax)) * (hexagonal ? Math.sqrt(3)/2 : 1) + ")");
                else {
                    if (dType == "Grid") sizeExpression = (tsize / 100 / Math.max(fontmin, fontmax));
                    else if (dType == "Score" || dType == "ScoreSelf") sizeExpression = (6/33 / Math.max(fontmin, fontmax));
                    else sizeExpression = (4/33 / Math.max(fontmin, fontmax));
                    sizeExpression *= ((hexagonal) ? Math.sqrt(3)/2 : 1)
                    innerscript.style.setProperty("font-size", "calc(1vw * var(--grid_vw) * " + sizeExpression + ")");
                }
                // if (dType == "Grid") sizeExpression = (tsize / 100 / Math.max(fontmin, fontmax));
                // else if (dType == "Score" || dType == "ScoreSelf") sizeExpression = (6/33 / Math.max(fontmin, fontmax));
                // else sizeExpression = (4/33 / Math.max(fontmin, fontmax));
                // innerscript.style.setProperty("font-size", "calc(1vw * var(--grid_vw) * " + sizeExpression + ")");
                if (innerdisplay.length > 4) innerscript.style.setProperty("color", (evaluateColor(innerdisplay[4], vcoord, hcoord, container, vars)));
                if (innerdisplay.length > 5) {
                    if (typeof innerdisplay[5] == "string") innerscript.style.setProperty("text-shadow", innerdisplay[5]);
                    else if (Array.isArray(innerdisplay[5]) && innerdisplay[5].length > 3) {
                        let offset1 = "calc(1vw * var(--grid_vw) * " + sizeExpression + " * " + innerdisplay[5][0] + ") ";
                        let offset2 = "calc(1vw * var(--grid_vw) * " + sizeExpression + " * " + innerdisplay[5][1] +  ") ";
                        let blur = "calc(1vw * var(--grid_vw) * " + sizeExpression + " * " + innerdisplay[5][2] +  ") ";
                        let color = evaluateColor(innerdisplay[5][3], vcoord, hcoord, container, vars);
                        let shadow = offset1 + offset2 + blur + color;
                        innerscript.style.setProperty("text-shadow", shadow);
                    }
                }
            }
            else if (elem[0] === "PrimeImage") {
                let pImage = document.createElement("div");
                pImage.classList.add("primeImage");
                tile.appendChild(pImage);
                if (elem[1][0] == "@ColorScheme") {
                    displayTile("Subtile", pImage, "None", "None", [CalcArray(elem[1][2], vcoord, hcoord, 0, 0, [1, Infinity, 0], container, [], vars)], [true, "@This 0", "@ColorScheme", elem[1][1], ["@This 0"].concat(elem[1].slice(3).map(x => CalcArray(x, vcoord, hcoord, 0, 0, [1, Infinity, 0], container, [], vars)))]);
                }
                else {
                    let dispbackground = evaluateColor(elem[1], vcoord, hcoord, container, vars);
                    if (dispbackground.includes("gradient")) {
                        pImage.style.setProperty("background-image", dispbackground);
                    }
                    else {
                        pImage.style.setProperty("background-color", dispbackground);
                        pImage.style.setProperty("background-image", "none");
                    }
                }
                if (elem.length > 2) pImage.style.setProperty("mask-image", (evaluateColor(elem[2], vcoord, hcoord, container, vars)));
            }
        }
        if (knownDisplayIndex == -1 && tileDisplayKnownLevel > 0) {
            knownTileDisplayArrays.push([location, dType]);
            knownTileDisplayNodes.push(tile.cloneNode(true));
        }
    }
}

function displayButtons(shown) {
    for (let button of document.getElementsByClassName("button")) {
        if (shown) button.style.setProperty("display", "flex");
        else button.style.setProperty("display", "none");
    }
    if (currentScreen != "Gameplay") document.getElementById("return_button").style.setProperty("display", "flex");
    for (let d = 0; d < directions.length; d++) colorArrow(d, "Arrow_" + d);
}

function colorArrow(index, ID) { //An arrow button goes black if its direction isn't available
    if (directions[index].length > 9 && CalcArray(directions[index][9]) === false) directionsAvailable[index] = false;
    if (directionsAvailable[index]) {
        document.getElementById(ID).style.setProperty("color", "#ff6666");
        document.getElementById(ID).style.setProperty("border-color", "#ff6666");
        document.getElementById(ID).style.setProperty("background-color", "#ffff88");
    }
    else {
        document.getElementById(ID).style.setProperty("color", "#666666");
        document.getElementById(ID).style.setProperty("border-color", "#666666");
        document.getElementById(ID).style.setProperty("background-color", "#222222");
    }
}

function displayRules(ID, ...elements) { //This basically just clears the element with the corresponding ID and adds elements to it. Each argument after the ID is an array of two entries: the first is the type of element to add, the second is the content of that element
    document.getElementById(ID).innerHTML = "";
    for (let elem of elements) {
        let outer = document.createElement(elem[0]);
        outer.innerHTML = elem[1];
        document.getElementById(ID).appendChild(outer);
    }
}

function loadModifiers() {
    start_modifier_vars = [];
    if (gamemode != 0) {
        if (gamemode == 1) { // 2048
            if (mode_vars[0]) startTileSpawns = [[[1], 90], [[2], 10]];
        }
        else if (gamemode == 4) { // 3125
            if (!(mode_vars[0])) {
                MergeRules = [
                    [2, [["@Next 1 0", "=", "@This 0"], "&&", ["@Next 1 1", "+", "@This 1", "<", 5], "&&", [["@Next 1 1", "+", "@This 1", "!=", 4], "||", ["@This 1", "=", 2]]], true, [["@This 0", ["@Next 1 1", "+", "@This 1"]]], [5, "^", "@This 0", "*", ["@Next 1 1", "+", "@This 1"]], [false, true]],
                    [2, [["@Next 1 0", "=", "@This 0"], "&&", ["@Next 1 1", "+", "@This 1", "=", 5]], true, [[["@This 0", "+", 1], 1]], [5, "^", ["@This 0", "+", 1]], [false, true]]
                ]
                startTileSpawns = [[[0, 1], 80], [[0, 2], 10], [[0, 3], 4], [[0, 4], 4], [[1, 1], 2]];
            }
        }
        else if (gamemode == 25) { // XXXX
            MergeRules[0][0] = mode_vars[0];
            if (mode_vars[1] == Infinity) {
                MergeRules[0][9] = Math.max(width, height);
                MergeRules[1][0] = Math.max(width, height);
                MergeRules[1][9] = Math.max(width, height);
                knownMergeMaxLength = Math.max(width, height);
            }
            else {
                MergeRules[0][9] = mode_vars[1];
                MergeRules[1][0] = mode_vars[1];
                MergeRules[1][9] = mode_vars[1];
                knownMergeMaxLength = mode_vars[1];
            }
            if (mode_vars[0] == mode_vars[1]) { // If the minimum and maximum merge lengths are the same, you're effectively playing a "merge n tiles" gamemode, and XXXX makes the colors of the tiles more varied since there's only one "chain" of tiles now.
                TileTypes = [[[1, 0], 1, "#ffffff", "#000000"],
                [[["@This 0", ">", 1], "&&", ["@This 1", "<", 5]], ["@This 0", "^", "@This 1"], ["@HSLA", [222.49223595, "*", "@This 0", "-", 444.9844719, "+", ["@This 1", "-", 1, "*", 19]], 100, [100, "-", ["@This 1", "*", 12.5]], 1], "#000000"],
                [true, ["@This 0", "^", "@This 1"], ["@HSLA", [222.49223595, "*", "@This 0", "-", 444.9844719, "+", ["@This 1", "-", 1, "*", 19]], 100, [0.85, "^", ["@This 1", "-", 5], "*", 50], 1], "#ffffff"],];
                winRequirement = 1;
                displayRules("rules_text", ["h2", "Only Powers of " + mode_vars[1]], ["h1", mode_vars[1]**Math.ceil(Math.log(999.99)/Math.log(mode_vars[1])) + ": XXXX Variant"], ["p", "Merges occur between " + mode_vars[1] + " of the same tile. Get to the " + mode_vars[1]**Math.ceil(Math.log(999.99)/Math.log(mode_vars[1])) + " tile to win!"],
                ["p", "Spawning tiles: 1 (100%)"]);
                statBoxes = [["Score", "@Score"]];
            }
        }
        else if (gamemode == 31) { // Isotopic 256
            MergeRules[1][3][0][1][4] = mode_vars[0];
            displayRules("rules_text", ["h1", "Isotopic 256"], ["p", "Regular 2048, but odd powers of 2 other than 2 itself (8, 32, 128, etc.) are radioactive, disappearing if they go without merging for more than " + mode_vars[0] + "x its number of turns. For aesthetic purposes, the tiles are associated with isotopes of elements with the corresponding atomic mass (though they stop making chemical sense for 256 and above; 256 should be radioactive but isn't, and higher tiles don't have real elements that are that heavy). Get to the <sup>256</sup>No tile to win!"],
            ["p", "Spawning tiles: <sup>2</sup>H (90%), <sup>4</sup>He (10%)"]);
        }
        else if (gamemode == 37) { // 2216.8378200531005859375
            if (mode_vars[0] == 1) {
                MergeRules = [
                    [2, [["@Next 1 0", "=", "@This 0"], "&&", ["@This 1", "=", 1], "&&", ["@Next 1 1", "=", 2]], false, [[["@This 0", "+", 1], 1]], [1.5, "^", "@This 0", "*", 1.5], [false, true]],
                    [2, [["@Next 1 0", "=", "@This 0"], "&&", ["@This 1", "=", 2], "&&", ["@Next 1 1", "=", 2]], true, [["@This 0", 1]], [1.5, "^", "@This 0"], [false, true]],
                    [2, [["@This 1", "=", 1], "&&", ["@Next 1 0", "=", "Div2"]], false, [["@This 0", 2]], [1.5, "^", "@This 0", "/", 2], [false, true]],
                    [2, [["@This 0", "=", "Div2"], "&&", ["@Next 1 0", "=", "Div2"]], true, [["Div2", "@Signless"]], 0, [false, true]],
                ];
                startTileSpawns = [[[0, 1], 50], [["Div2", "@Signless"], 50]];
                knownMergeMaxLength = 2;
                knownMergeLookbackDistance = 0;
            }
            else if (mode_vars[0] == 2) {
                MergeRules = [
                    [3, [["@Next 1 0", "=", "@This 0"], "&&", ["@Next 2 0", "=", "@This 0"], "&&", ["@Next 1 1", "=", "@This 1"], "&&", ["@Next 2 1", "=", "@This 1"]], true, [[["@This 0", "+", 1], 1], [["@This 0", "+", 1], 1]], [1.5, "^", "@This 0", "*", 3], [false, false, true]]
                ]
                startTileSpawns = [[[0, 1], 72], [[1, 1], 16], [[2, 1], 8], [[3, 1], 4]];
                knownMergeMaxLength = 3;
                knownMergeLookbackDistance = 0;
            }
            else if (mode_vars[0] == 0) {
                // MergeRules = [
                //     [2, [["@Next 1 0", "=", "@This 0"], "&&", ["@This 1", "=", 1], "&&", ["@Next 1 1", "=", 1]], true, [[["@This 0", "+", 1], 1], ["@This 0", 2]], [1.5, "^", "@This 0", "*", 1.5], [false, false]],
                //     [2, [["@Next 1 0", "=", "@This 0"], "&&", ["@This 1", "=", 2], "&&", ["@Next 1 1", "=", 2]], true, [["@This 0", 1]], [1.5, "^", "@This 0"], [false, true]]
                // ];
                if (mode_vars[1] == 1) MergeRules.pop();
                if (mode_vars[1] != 0) MergeRules.push([2, [["@Next 1 0", "=", "@This 0"], "&&", ["@This 1", "=", 1], "&&", ["@Next 1 1", "=", 2]], false, [[["@This 0", "+", 1], 1]], [1.5, "^", "@This 0", "*", 1.5], [false, true]]);
            }
        }
        else if (gamemode == 38) { // 180
            if (mode_vars[0] != 0) {
                TileNumAmount = 1;
                TileTypes = [
                    [true, "@This 0", "@ColorScheme", "180", ["@This 0"]]
                ];
                MergeRules = [
                    [2, [["@NextNE -1 0", "!=", "@This 0"], "&&", [["@NextNE", "arr_elem", ["@MLength", "-", 1], "arr_elem", 0], "!=", "@This 0"], "&&", ["@Next 1 0", "=", "@This 0"]], true, [[["@This 0", "*B", "@MLength"]]], ["@This 0", "*B", "@MLength"], [], 2, [0, 1, 1], 1, Math.max(width, height)]
                ];
                knownMergeMaxLength = Infinity;
                knownMergeLookbackDistance = 1;
                if (mode_vars[0] == 1) {
                    primesUpdate(BigInt(Math.max(width, height)));
                    MergeRules[0][1].unshift(["@Primes", "arr_indexOf", ["@MLength", "BigInt"], ">", -1], "&&");
                }
                if (modifiers[13] == "None") {
                    startTileSpawns = [[[1n], 100]];
                    winConditions = [[180n]];
                    winRequirement = 1;
                }
                else {
                    startTileSpawns = [[[1n], 100 * modifiers[22]], [[-1n], 100 * modifiers[23]]];
                    winConditions = [[180n], [-180n]];
                    winRequirement = 2;
                    if (modifiers[13] == "Interacting") MergeRules.push([2, ["@This 0", "*B", -1n, "=", "@Next 1 0"], false, [], 0]);
                }
                if (mode_vars[1] > 0) {
                    scripts.push([["@var_retain", 0, "@if", ["@var_retain", "@Var -1", "arr_elem", 0, "arr_elem", 0, "=", "@GVar 0"], "@edit_gvar", 2, true, "@end-if"], "Merge"]);
                    if (mode_vars[1] == 1) {
                        scripts.push([[0, "@if", "@GVar 2", "@edit_gvar", 1, ["@var_retain", "@GVar 1", "+", 1], "@edit_gvar", 2, false, "rand_float", 1, "@if", ["@Parent -2", "<", "@GVar 3"], "@edit_gvar", 0, ["@GVar 0", "*B", 2n], "@end-if", "@else-if", ["@Parent -2", "<", "@GVar 4"], "@edit_gvar", 0, ["@GVar 0", "*B", 3n], "@end-else-if", "@else", "@edit_gvar", 0, ["@GVar 0", "*B", 5n], "@end-else", "@end-if"], "EndTurn"])
                    }
                    else {
                        scripts.push([[1n, "@end_vars", 0, "@if", "@GVar 2", "@edit_gvar", 1, ["@var_retain", "@GVar 1", "+", 1], "@edit_gvar", 2, false, "@edit_gvar", 0, ["@var_retain", 0, "rand_float", 1, "@repeat", ["@var_retain", "@Var 0", "<=", "@GVar 0"], "@if", ["@Parent -2", "<", "@GVar 3"], "@edit_var", 0, ["@var_retain", "@Var 0", "*B", 2n], "@end-if", "@else-if", ["@Parent -2", "<", "@GVar 4"], "@edit_var", 0, ["@var_retain", "@Var 0", "*B", 3n], "@end-else-if", "@else", "@edit_var", 0, ["@var_retain", "@Var 0", "*B", 5n], "@end-else", "@end-repeat", "2nd", "@Var 0"], "@end-if"], "EndTurn"])
                    }
                    statBoxes.push(["Current Goal", "@GVar 0", false, false, "Tile", "180"], ["Goals Reached", "@GVar 1"]);
                }
            }
            else if (mode_vars[1] > 0) {
                scripts.push([["@var_retain", 0, "@if", ["@var_retain", "@Var -1", "arr_elem", 0, "arr_slice", 0, 3, "=", "@GVar 0"], "@edit_gvar", 2, true, "@end-if"], "Merge"]);
                if (mode_vars[1] == 1) {
                    scripts.push([[0, "@if", "@GVar 2", "@edit_gvar", 1, ["@var_retain", "@GVar 1", "+", 1], "@edit_gvar", 2, false, "rand_float", 1, "@if", ["@Parent -2", "<", "@GVar 3"], "@edit_gvar", 0, ["@Literal", ["@CalcArray", "@GVar 0", "arr_elem", 0, "+", 1], ["@CalcArray", "@GVar 0", "arr_elem", 1], ["@CalcArray", "@GVar 0", "arr_elem", 2]], "@end-if", "@else-if", ["@Parent -2", "<", "@GVar 4"], "@edit_gvar", 0, ["@Literal", ["@CalcArray", "@GVar 0", "arr_elem", 0], ["@CalcArray", "@GVar 0", "arr_elem", 1, "+", 1], ["@CalcArray", "@GVar 0", "arr_elem", 2]], "@end-else-if", "@else", "@edit_gvar", 0, ["@Literal", ["@CalcArray", "@GVar 0", "arr_elem", 0], ["@CalcArray", "@GVar 0", "arr_elem", 1], ["@CalcArray", "@GVar 0", "arr_elem", 2, "+", 1]], "@end-else", "@end-if"], "EndTurn"])
                }
                else {
                    scripts.push([[[[2, "^", ["@GVar 0", "arr_elem", 0]], "*", [3, "^", ["@GVar 0", "arr_elem", 1]], "*", [5, "^", ["@GVar 0", "arr_elem", 2]]], "@end_vars", 0, "@if", "@GVar 2", "@edit_gvar", 1, ["@var_retain", "@GVar 1", "+", 1], "@edit_gvar", 2, false, "@edit_gvar", 0, ["@var_retain", 0, 0, 0, "@end_vars", 0, "rand_float", 1, "@repeat", ["@var_retain", ["@var_retain", 2, "^", "@Var 1"], "*", ["@var_retain", 3, "^", "@Var 2"], "*", ["@var_retain", 5, "^", "@Var 3"], "<=", "@Var 0"], "@if", ["@Parent -2", "<", "@GVar 3"], "@edit_var", 1, ["@var_retain", "@Var 1", "+", 1], "@end-if", "@else-if", ["@Parent -2", "<", "@GVar 4"], "@edit_var", 2, ["@var_retain", "@Var 2", "+", 1], "@end-else-if", "@else", "@edit_var", 3, ["@var_retain", "@Var 3", "+", 1], "@end-else", "@end-repeat", "2nd", ["@Literal"], "arr_push", "@Var 1", "arr_push", "@Var 2", "arr_push", "@Var 3"], "@end-if"], "EndTurn"])
                }
                if (mode_vars[13] == "None") {
                    statBoxes.push(["Current Goal", "@GVar 0", false, false, "Tile", "Self"], ["Goals Reached", "@GVar 1"]);
                }
                else {
                    statBoxes.push(["Current Goal", ["@GVar 0", "arr_push", 1], false, false, "Tile", "Self"], ["Goals Reached", "@GVar 1"]);
                }
            }
        }
        else if (gamemode == 39) { // 2592
            if (mode_vars[0] == 0) {
                statBoxes = [["Moves", "@Moves"], ["Discovered Tiles", ["@DiscTiles", "arr_length"], false, ...[,,,], ["@GVar 5", "=", 0], [0, "@edit_gvar", 5, 1], true], ["Discovered Tiles", ["@DiscTiles"], true, false, "TileArray", "Self", ["@GVar 5", "=", 1], [0, "@edit_gvar", 5, 0], true], ["Score", "@Score"]];
                MergeRules[0][1][8][0] = "@Moves";
                MergeRules[1][1][4][0] = "@Moves";
            }
            else if (mode_vars[0] == 1) {
                statBoxes = [["Moves Where A Merge Occured", "@MergeMoves"], ["Discovered Tiles", ["@DiscTiles", "arr_length"], false, ...[,,,], ["@GVar 5", "=", 0], [0, "@edit_gvar", 5, 1], true], ["Discovered Tiles", ["@DiscTiles"], true, false, "TileArray", "Self", ["@GVar 5", "=", 1], [0, "@edit_gvar", 5, 0], true], ["Score", "@Score"]];
                MergeRules[0][1][8][0] = "@MergeMoves";
                MergeRules[1][1][4][0] = "@MergeMoves";
            }
            else if (mode_vars[0] == 2) {
                statBoxes = [["Discovered Tiles", ["@DiscTiles", "arr_length"], false, ...[,,,], ["@GVar 5", "=", 0], [0, "@edit_gvar", 5, 1], true], ["Discovered Tiles", ["@DiscTiles"], true, false, "TileArray", "Self", ["@GVar 5", "=", 1], [0, "@edit_gvar", 5, 0], true], ["Score", "@Score"], ["Merges Before This Move", "@MergesBefore"]];
                MergeRules[0][1][8][0] = "@MergesBefore";
                MergeRules[1][1][4][0] = "@MergesBefore";
            }
            else if (mode_vars[0] == 3) {
                statBoxes = [["Discovered Tiles", ["@DiscTiles", "arr_length"], false, ...[,,,], ["@GVar 5", "=", 0], [0, "@edit_gvar", 5, 1], true], ["Discovered Tiles", ["@DiscTiles"], true, false, "TileArray", "Self", ["@GVar 5", "=", 1], [0, "@edit_gvar", 5, 0], true], ["Score", "@Score"], ["Merges", "@Merges"]];
                MergeRules[0][1][8][0] = "@Merges";
                MergeRules[1][1][4][0] = "@Merges";
            }
            if (mode_vars[1] > 0) {
                scripts.push([["@var_retain", 0, "@if", ["@var_retain", "@Var -1", "arr_elem", 0, "arr_slice", 0, 2, "=", "@GVar 0"], "@edit_gvar", 2, true, "@end-if"], "Merge"]);
                if (mode_vars[1] == 1) {
                    scripts.push([[0, "@if", "@GVar 2", "@edit_gvar", 1, ["@var_retain", "@GVar 1", "+", 1], "@edit_gvar", 2, false, "rand_float", 1, "@if", ["@Parent -2", "<", "@GVar 3"], "@edit_gvar", 0, ["@Literal", ["@CalcArray", "@GVar 0", "arr_elem", 0, "+", 1], ["@CalcArray", "@GVar 0", "arr_elem", 1]], "@end-if", "@else", "@edit_gvar", 0, ["@Literal", ["@CalcArray", "@GVar 0", "arr_elem", 0], ["@CalcArray", "@GVar 0", "arr_elem", 1, "+", 1]], "@end-else", "@end-if"], "EndTurn"])
                }
                else {
                    scripts.push([[[[2, "^", ["@GVar 0", "arr_elem", 0]], "*", [3, "^", ["@GVar 0", "arr_elem", 1]]], "@end_vars", 0, "@if", "@GVar 2", "@edit_gvar", 1, ["@var_retain", "@GVar 1", "+", 1], "@edit_gvar", 2, false, "@edit_gvar", 0, ["@var_retain", 0, 0, "@end_vars", 0, "rand_float", 1, "@repeat", ["@var_retain", ["@var_retain", 2, "^", "@Var 1"], "*", ["@var_retain", 3, "^", "@Var 2"], "<=", "@Var 0"], "@if", ["@Parent -2", "<", "@GVar 3"], "@edit_var", 1, ["@var_retain", "@Var 1", "+", 1], "@end-if", "@else", "@edit_var", 2, ["@var_retain", "@Var 2", "+", 1], "@end-else", "@end-repeat", "2nd", ["@Literal"], "arr_push", "@Var 1", "arr_push", "@Var 2"], "@end-if"], "EndTurn"])
                }
                if (mode_vars[13] == "None") {
                    statBoxes.push(["Current Goal", "@GVar 0", false, false, "Tile", "Self"], ["Goals Reached", "@GVar 1"]);
                }
                else {
                    statBoxes.push(["Current Goal", ["@GVar 0", "arr_push", 1], false, false, "Tile", "Self"], ["Goals Reached", "@GVar 1"]);
                }
            }
        }
        else if (gamemode == 40) { // Wildcard 2048
            if (mode_vars[0] == 1) {
                MergeRules[0][5] = [[["@This 0", "+", "@Next 1 0"]]];
                MergeRules[0][6] = ["@This 0", "+", "@Next 1 0"]
                if (modifiers[13] != "None") MergeRules[0][5] = [[["@This 0", "+", "@Next 1 0"], "@This 1"]];
                if (modifiers[13] == "Interacting") {
                    MergeRules[1] = [2, [["@This 0", "=", "@Next 1 0"], "&&", ["@This 1", "!=", "@Next 1 1"]], true, [], 0, [true, true]];
                    MergeRules.push([["@This 0", "bit&", "@Next 1 0"], "@end_vars", 2, ["@var_retain", "@Var 0", ">", 0, "&&", ["@This 1", "=", 1], "&&", ["@Next 1 1", "=", -1], "&&", ["@This 0", "!=", "@Next 1 0"]], false, [[["@This 0", "-", "@Next 1 0", "abs"], ["@This 0", "-", "@Next 1 0", "sign"]]], 0, [false, true]]);
                }
            }
            else if (mode_vars[0] == 2) {
                MergeRules[0] = [["@This 0", "bit&", "@Next 1 0"], "@end_vars", 2, ["@var_retain", "@Var 0", "=", "@This 0"], false, [[["@var_retain", ["@This 0", "*", 2], "bit|", ["@Next 1 0", "bit^", "@This 0"]]]], ["@var_retain", "@This 0", "*", 2], [false, true]]
                if (modifiers[13] != "None") {
                    MergeRules[0][3].push("&&", ["@This 1", "=", "@Next 1 1"]);
                    MergeRules[0][5][0].push("@This 1");
                }
                if (modifiers[13] == "Interacting") {
                    MergeRules[1] = [2, [["@This 0", "=", "@Next 1 0"], "&&", ["@This 1", "!=", "@Next 1 1"]], true, [], 0, [true, true]];
                    MergeRules.push([["@This 0", "bit&", "@Next 1 0"], "@end_vars", 2, ["@var_retain", "@Var 0", "=", "@This 0", "&&", ["@This 1", "!=", "@Next 1 1"], "&&", ["@This 0", "!=", "@Next 1 0"]], false, [[["@Next 1 0", "bit^", "@This 0"], "@Next 1 1"]], 0, [false, true]]);
                }
            }
            if (mode_vars[1]) {
                if (modifiers[13] == "None") {
                    startTileSpawns = [[[[2, "^", ["@DiscTiles", "arr_reduce", 0, ["@if", ["@var_retain", "@Var -1", "arr_elem", 0, ">", "@Parent -2"], "2nd", ["@var_retain", "@Var -1", "arr_elem", 0], "@end-if"], "+", 0.5, "log", 2, "floor", 1, "rand_float", 1], "round", 1, "-", 1, "max", 1]], 1]];
                }
                else {
                    startTileSpawns = [[[[2, "^", ["@DiscTiles", "arr_reduce", 0, ["@if", ["@var_retain", "@Var -1", "arr_elem", 0, ">", "@Parent -2"], "2nd", ["@var_retain", "@Var -1", "arr_elem", 0], "@end-if"], "+", 0.5, "log", 2, "floor", 1, "rand_float", 1], "round", 1, "-", 1, "max", 1], 1], modifiers[22]], [[[2, "^", ["@DiscTiles", "arr_reduce", 0, ["@if", ["@var_retain", "@Var -1", "arr_elem", 0, ">", "@Parent -2"], "2nd", ["@var_retain", "@Var -1", "arr_elem", 0], "@end-if"], "+", 0.5, "log", 2, "floor", 1, "rand_float", 1], "round", 1, "-", 1, "max", 1], -1], modifiers[23]]]
                }
            }
        }
        else if (gamemode == 41) { // X^Y
            MergeRules[0][11] = mode_vars[1];
            knownMergeMaxLength = mode_vars[1];
            for (let m = 0; m < MergeRules.length; m++) {
                MergeRules[m][0][MergeRules[m][0].length - 1] = mode_vars[0];
            }
        }
        else if (gamemode == 43) { // 1321
            if (mode_vars[0]) {
                if (modifiers[13] == "None") {
                    MergeRules = [
                        [2, [["@This 0", "=", "@Next 1 0"], "&&", ["@This 1", "=", 0], "&&", ["@Next 1 1", "=", 0]], true, [[["@This 0", "+", "@Next 1 0"], 0]], ["@This 0", "+", "@Next 1 0"], [false, true]],
                        [2, [["@This 1", "=", 0], "&&", ["@Next 1 1", "=", 1], "&&", ["@This 0", "mod", 2, "=", 0]], false, [[["@This 0", "+", "@Next 1 0"], 0]], ["@This 0", "+", "@Next 1 0"], [false, true]],
                        [2, [["@This 1", "=", 1], "&&", ["@Next 1 1", "=", 1]], true, [[["@This 0", "+", "@Next 1 0"], 1]], ["@This 0", "+", "@Next 1 0"], [false, true]]
                    ];
                }
                else if (modifiers[13] == "Non-Interacting") {
                    MergeRules = [
                        [2, [["@This 0", "=", "@Next 1 0"], "&&", ["@This 1", "=", 0], "&&", ["@Next 1 1", "=", 0]], true, [[["@This 0", "+", "@Next 1 0"], 0]], ["@This 0", "+", "@Next 1 0"], [false, true]],
                        [2, [["@This 1", "=", 0], "&&", ["@Next 1 1", "=", 1], "&&", [["@This 0", "sign"], "=", ["@Next 1 0", "sign"]], "&&", ["@This 0", "mod", 2, "=", 0]], false, [[["@This 0", "+", "@Next 1 0"], 0]], ["@This 0", "+", "@Next 1 0", "abs"], [false, true]],
                        [2, [["@This 1", "=", 1], "&&", ["@Next 1 1", "=", 1], "&&", [["@This 0", "sign"], "=", ["@Next 1 0", "sign"]]], true, [[["@This 0", "+", "@Next 1 0"], 1]], ["@This 0", "+", "@Next 1 0", "abs"], [false, true]]
                    ];
                }
                else if (modifiers[13] == "Interacting") {
                    MergeRules = [
                        [2, ["@This 0", "+", "@Next 1 0", "=", 0], true, [], 0],
                        [2, [["@This 0", "=", "@Next 1 0"], "&&", ["@This 1", "=", 0], "&&", ["@Next 1 1", "=", 0]], true, [[["@This 0", "+", "@Next 1 0"], 0]], ["@This 0", "+", "@Next 1 0", "abs"], [false, true]],
                        [2, [["@This 1", "=", 0], "&&", ["@Next 1 1", "=", 1], "&&", ["@This 0", "mod", 2, "=", 0]], false, [[["@This 0", "+", "@Next 1 0"], 0]], ["@This 0", "+", "@Next 1 0", "abs"], [false, true]],
                        [2, [["@This 1", "=", 1], "&&", ["@Next 1 1", "=", 1]], true, [[["@This 0", "+", "@Next 1 0"], 1]], ["@This 0", "+", "@Next 1 0", "abs"], [false, true]]
                    ];
                }
            }
            if (mode_vars[1] > 0) {
                start_game_vars[3] = mode_vars[2];
                scripts.push([["@var_retain", 0, "@if", ["@var_retain", "@Var -1", "arr_elem", 0, "arr_elem", 0, "=", "@GVar 0"], "@edit_gvar", 2, true, "@end-if"], "Merge"]);
                if (mode_vars[1] == 1) {
                    scripts.push([[0, "@if", "@GVar 2", "@edit_gvar", 1, ["@var_retain", "@GVar 1", "+", 1], "@edit_gvar", 2, false, "@edit_gvar", 0, ["@GVar 0", "*", 2, "+", [0, "rand_int", 1]], "@end-if"], "EndTurn"])
                }
                else {
                    scripts.push([[0, "@if", "@GVar 2", "@edit_gvar", 1, ["@var_retain", "@GVar 1", "+", 1], "@edit_gvar", 2, false, "@edit_gvar", 0, [[2, "^", ["@GVar 1", "+", "@GVar 3", "-", 1]], "rand_int", [2, "^", ["@GVar 1", "+", "@GVar 3"], "-", 1]], "@end-if"], "EndTurn"])
                }
                let sBox = ["@Literal", ["@CalcArray", "@GVar 0"], 0];
                if (modifiers[13] != "None") sBox.push(1);
                if (modifiers[24]) sBox.push(1);
                statBoxes.push(["Current Goal", sBox, false, false, "Tile", "Self"], ["Goals Reached", "@GVar 1"]);
            }
        }
        else if (gamemode == 44) { // mod 27
            MergeRules[0][9] = Math.max(width, height);
        }
        else if (gamemode == 49) { // 378
            MergeRules[0][12] = mode_vars[1];
            knownMergeMaxLength = mode_vars[1];
            if (!mode_vars[0]) {
                winRequirement = false;
                loseRequirement = false;
                scripts = [];
                statBoxes = [["Discovered Tiles", ["@DiscTiles", "arr_length"], false, ...[,,,], ["@GVar 0", "=", 0], [0, "@edit_gvar", 0, 1], true], ["Discovered Tiles", ["@DiscTiles"], true, false, "TileArray", "Self", ["@GVar 0", "=", 1], [0, "@edit_gvar", 0, 0], true], ["Score", "@Score"]];
                MergeRules.pop();
            }
        }
        else if (gamemode == 50) { // DIVE
            if (mode_vars[0] > 0) {
                scripts = [];
                statBoxes = [statBoxes[0]];
                if (modifiers[13] == "None") {
                    if (mode_vars[1]) startTileSpawns = [[[[0, "rand_int", mode_vars[0], "BigInt", "primeB"]], 1]];
                    else startTileSpawns = [[[[1, "rand_int", mode_vars[0], "BigInt", "primeB"]], 1]];
                }
                else {
                    if (mode_vars[1]) startTileSpawns = [[[[0, "rand_int", mode_vars[0], "BigInt", "primeB"]], modifiers[22]], [[[0, "rand_int", mode_vars[0], "BigInt", "primeB", "*B", -1n]], modifiers[23]]];
                    else startTileSpawns = [[[[1, "rand_int", mode_vars[0], "BigInt", "primeB"]], modifiers[22]], [[[1, "rand_int", mode_vars[0], "BigInt", "primeB", "*B", -1n]], modifiers[23]]];
                }
            }
            else {
                if (mode_vars[1]) {
                    start_game_vars[0] = [1n];
                    start_game_vars[1] = [1n];
                }
                if (mode_vars[0] == -1) {
                    scripts = [scripts[0], scripts[2]];
                    statBoxes.pop(); statBoxes.pop();
                }
            }
            start_game_vars[4] = mode_vars[2];
            if (mode_vars[3] > 0) {
                start_game_vars[9] = mode_vars[4];
                scripts.push([["@var_retain", 0, "@if", ["@var_retain", "@Var -1", "arr_elem", 0, "arr_elem", 0, "=", "@GVar 5"], "@edit_gvar", 7, true, "@end-if"], "Merge"]);
                scripts.push([["@var_retain", 0, "@add_var", 0, "@repeat", ["@var_retain", "@Var 0", "arr_length", ">", "@Var 1"], "@if", ["@var_retain", "@Var 0", "arr_elem", "@Var 1", "arr_elem", 0, "=", "@GVar 5"], "@edit_gvar", 7, true, "@end-if", "@edit_var", 1, ["@var_retain", "@Var 1", "+", 1], "@end-repeat"], "PostSpawn"]);
                if (mode_vars[3] == 1) {
                    scripts.push([[0, "@if", "@GVar 7", "@edit_gvar", 6, ["@var_retain", "@GVar 6", "+", 1], "@edit_gvar", 7, false, "@edit_gvar", 5, ["@GVar 5", "+B", [0, "rand_bigint", ["@GVar 5", "logB", 2n]], "*B", [0, "rand_float", 1, "@if", ["@Parent -2", "=", 0], "2nd", 1, "@end-if", "log", 2, "*", -1, "floor", 1, "+", 2, "BigInt"]], "@end-if"], "EndTurn"])
                }
                else {
                    scripts.push([[0, "@if", "@GVar 7", "@edit_gvar", 6, ["@var_retain", "@GVar 6", "+", 1], "@edit_gvar", 7, false, "@edit_gvar", 5, [[2n, "^B", ["@GVar 6", "BigInt"], "*B", "@GVar 9"], "rand_bigint", [2n, "^B", ["@GVar 6", "+", 1, "BigInt"], "*B", "@GVar 9", "-B", 1n]], "@end-if"], "EndTurn"])
                }
                statBoxes.push(["Current Goal", "@GVar 5", false, false, "Tile", "DIVE"], ["Goals Reached", "@GVar 6"]);
            }
            start_game_vars[8] = modifiers[21];
        }
        else if (gamemode == 54) { // 3888
            if (mode_vars[0] > 0) {
                start_game_vars[4] = mode_vars[1];
                scripts.push([["@var_retain", 0, "@if", ["@var_retain", "@Var -1", "arr_elem", 0, "arr_slice", 0, 2, "=", "@GVar 0"], "@edit_gvar", 2, true, "@end-if"], "Merge"]);
                if (mode_vars[0] == 1) {
                    scripts.push([[["@Literal"], "@end_vars", 0, "@if", "@GVar 2", "@edit_gvar", 1, ["@var_retain", "@GVar 1", "+", 1], "@edit_gvar", 2, false, "@if", ["@GVar 0", "arr_elem", 0, ">", 0], "@edit_var", 0, ["@var_retain", "@Var 0", "arr_push", 0], "@end-if", "@if", ["@GVar 0", "arr_elem", 1, ">", 0], "@edit_var", 0, ["@var_retain", "@Var 0", "arr_push", 1], "@end-if", "rand_float", 1, "@if", ["@var_retain", "@Var 0", "arr_length", "=", 1], "2nd", ["@var_retain", "@Var 0", "arr_elem", 0], "@end-if", "@else", "2nd", ["@var_retain", "@Var 0", "arr_elem", [0, "@if", ["@Parent -4", "<", "@GVar 3"], "2nd", 1, "@end-if"]], "@end-else", "@if", ["@Parent -2", "=", 0], "@edit_gvar", 0, ["@Literal", ["@CalcArray", "@GVar 0", "arr_elem", 0, "-", 1], ["@CalcArray", "@GVar 0", "arr_elem", 1, "+", 1]], "@end-if", "@if", ["@Parent -2", "=", 1], "@edit_gvar", 0, ["@Literal", ["@CalcArray", "@GVar 0", "arr_elem", 0, "+", 2], ["@CalcArray", "@GVar 0", "arr_elem", 1, "-", 1]], "@end-if", "@end-if"], "EndTurn"])
                }
                else {
                    scripts.push([[[[2, "^", ["@GVar 0", "arr_elem", 0]], "*", [3, "^", ["@GVar 0", "arr_elem", 1]]], "@end_vars", 0, "@if", "@GVar 2", "@edit_gvar", 1, ["@var_retain", "@GVar 1", "+", 1], "@edit_gvar", 2, false, "@edit_gvar", 0, ["@var_retain", 0, 0, "@end_vars", 0, "@repeat", ["@var_retain", ["@var_retain", 2, "^", "@Var 1"], "*", ["@var_retain", 3, "^", "@Var 2"], "<=", "@Var 0"], "@if", [0, "rand_float", 1, "<", "@GVar 3"], "@edit_var", 1, ["@var_retain", "@Var 1", "+", 1], "@end-if", "@else", "@edit_var", 2, ["@var_retain", "@Var 2", "+", 1], "@end-else", "@end-repeat", "2nd", ["@Literal"], "arr_push", "@Var 1", "arr_push", "@Var 2"], "@end-if"], "EndTurn"])
                }
                let sBox = ["@GVar 0"];
                if (modifiers[13] != "None") sBox.push("arr_push", 1);
                if (modifiers[24]) sBox.push("arr_push", 1);
                statBoxes.push(["Current Goal", sBox, false, false, "Tile", "Self"], ["Goals Reached", "@GVar 1"]);
            }
        }
        else if (gamemode == 55) { // 2000
            if (mode_vars[0] > 0) {
                start_game_vars[4] = mode_vars[1];
                scripts.push([["@var_retain", 0, "@if", ["@var_retain", "@Var -1", "arr_elem", 0, "arr_slice", 0, 2, "=", "@GVar 0"], "@edit_gvar", 2, true, "@end-if"], "Merge"]);
                if (mode_vars[0] == 1) {
                    scripts.push([[["@Literal"], "@end_vars", 0, "@if", "@GVar 2", "@edit_gvar", 1, ["@var_retain", "@GVar 1", "+", 1], "@edit_gvar", 2, false, "@if", ["@GVar 0", "arr_elem", 0, ">", 1], "@edit_var", 0, ["@var_retain", "@Var 0", "arr_push", 0], "@end-if", "@if", ["@GVar 0", "arr_elem", 1, ">", 0], "@edit_var", 0, ["@var_retain", "@Var 0", "arr_push", 1], "@end-if", "rand_float", 1, "@if", ["@var_retain", "@Var 0", "arr_length", "=", 1], "2nd", ["@var_retain", "@Var 0", "arr_elem", 0], "@end-if", "@else", "2nd", ["@var_retain", "@Var 0", "arr_elem", [0, "@if", ["@Parent -4", "<", "@GVar 3"], "2nd", 1, "@end-if"]], "@end-else", "@if", ["@Parent -2", "=", 0], "@edit_gvar", 0, ["@Literal", ["@CalcArray", "@GVar 0", "arr_elem", 0, "-", 2], ["@CalcArray", "@GVar 0", "arr_elem", 1, "+", 1]], "@end-if", "@if", ["@Parent -2", "=", 1], "@edit_gvar", 0, ["@Literal", ["@CalcArray", "@GVar 0", "arr_elem", 0, "+", 3], ["@CalcArray", "@GVar 0", "arr_elem", 1, "-", 1]], "@end-if", "@end-if"], "EndTurn"])
                }
                else {
                    scripts.push([[[[2, "^", ["@GVar 0", "arr_elem", 0]], "*", [5, "^", ["@GVar 0", "arr_elem", 1]]], "@end_vars", 0, "@if", "@GVar 2", "@edit_gvar", 1, ["@var_retain", "@GVar 1", "+", 1], "@edit_gvar", 2, false, "@edit_gvar", 0, ["@var_retain", 0, 0, "@end_vars", 0, "@repeat", ["@var_retain", ["@var_retain", 2, "^", "@Var 1"], "*", ["@var_retain", 5, "^", "@Var 2"], "<=", "@Var 0"], "@if", [0, "rand_float", 1, "<", "@GVar 3"], "@edit_var", 1, ["@var_retain", "@Var 1", "+", 1], "@end-if", "@else", "@edit_var", 2, ["@var_retain", "@Var 2", "+", 1], "@end-else", "@end-repeat", "2nd", ["@Literal"], "arr_push", "@Var 1", "arr_push", "@Var 2"], "@end-if"], "EndTurn"])
                }
                let sBox = ["@GVar 0"];
                if (modifiers[13] != "None") sBox.push("arr_push", 1);
                statBoxes.push(["Current Goal", sBox, false, false, "Tile", "Self"], ["Goals Reached", "@GVar 1"]);
            }
        }
        else if (gamemode == 56) { // 3645
            if (mode_vars[0] > 0) {
                start_game_vars[4] = mode_vars[1];
                scripts.push([["@var_retain", 0, "@if", ["@var_retain", "@Var -1", "arr_elem", 0, "arr_slice", 0, 2, "=", "@GVar 0"], "@edit_gvar", 2, true, "@end-if"], "Merge"]);
                if (mode_vars[0] == 1) {
                    scripts.push([[["@Literal"], "@end_vars", 0, "@if", "@GVar 2", "@edit_gvar", 1, ["@var_retain", "@GVar 1", "+", 1], "@edit_gvar", 2, false, "@if", ["@GVar 0", "arr_elem", 0, ">", 0], "@edit_var", 0, ["@var_retain", "@Var 0", "arr_push", 0], "@end-if", "@if", ["@GVar 0", "arr_elem", 1, ">", 0], "@edit_var", 0, ["@var_retain", "@Var 0", "arr_push", 1], "@end-if", "rand_float", 1, "@if", ["@var_retain", "@Var 0", "arr_length", "=", 1], "2nd", ["@var_retain", "@Var 0", "arr_elem", 0], "@end-if", "@else", "2nd", ["@var_retain", "@Var 0", "arr_elem", [0, "@if", ["@Parent -4", "<", "@GVar 3"], "2nd", 1, "@end-if"]], "@end-else", "@if", ["@Parent -2", "=", 0], "@edit_gvar", 0, ["@Literal", ["@CalcArray", "@GVar 0", "arr_elem", 0, "-", 1], ["@CalcArray", "@GVar 0", "arr_elem", 1, "+", 1]], "@end-if", "@if", ["@Parent -2", "=", 1], "@edit_gvar", 0, ["@Literal", ["@CalcArray", "@GVar 0", "arr_elem", 0, "+", 2], ["@CalcArray", "@GVar 0", "arr_elem", 1, "-", 1]], "@end-if", "@end-if"], "EndTurn"])
                }
                else {
                    scripts.push([[[[3, "^", ["@GVar 0", "arr_elem", 0]], "*", [5, "^", ["@GVar 0", "arr_elem", 1]]], "@end_vars", 0, "@if", "@GVar 2", "@edit_gvar", 1, ["@var_retain", "@GVar 1", "+", 1], "@edit_gvar", 2, false, "@edit_gvar", 0, ["@var_retain", 0, 0, "@end_vars", 0, "@repeat", ["@var_retain", ["@var_retain", 3, "^", "@Var 1"], "*", ["@var_retain", 5, "^", "@Var 2"], "<=", "@Var 0"], "@if", [0, "rand_float", 1, "<", "@GVar 3"], "@edit_var", 1, ["@var_retain", "@Var 1", "+", 1], "@end-if", "@else", "@edit_var", 2, ["@var_retain", "@Var 2", "+", 1], "@end-else", "@end-repeat", "2nd", ["@Literal"], "arr_push", "@Var 1", "arr_push", "@Var 2"], "@end-if"], "EndTurn"])
                }
                let sBox = ["@GVar 0"];
                if (modifiers[13] != "None") sBox.push("arr_push", 1);
                if (modifiers[24]) sBox.push("arr_push", 1);
                statBoxes.push(["Current Goal", sBox, false, false, "Tile", "Self"], ["Goals Reached", "@GVar 1"]);
            }
        }
        // else if (gamemode == 57) { // 2700
        //     if (mode_vars[2] > 0) {
        //         scripts.push([["@var_retain", 0, "@if", ["@var_retain", "@Var -1", "arr_elem", 0, "arr_slice", 0, 3, "=", "@GVar 0"], "@edit_gvar", 2, true, "@end-if"], "Merge"]);
        //         if (mode_vars[2] == 1) {
        //             scripts.push([[["@Literal"], "@end_vars", 0, "@if", "@GVar 2", "@edit_gvar", 1, ["@var_retain", "@GVar 1", "+", 1], "@edit_gvar", 2, false, "@if", ["@GVar 0", "arr_elem", 0, ">", 0], "@edit_var", 0, ["@var_retain", "@Var 0", "arr_push", 0], "@end-if", "@if", ["@GVar 0", "arr_elem", 1, ">", 0], "@edit_var", 0, ["@var_retain", "@Var 0", "arr_push", 1], "@end-if", "@if", ["@GVar 0", "arr_elem", 2, ">", 0], "@edit_var", 0, ["@var_retain", "@Var 0", "arr_push", 2], "@end-if", "rand_float", 1, "@if", ["@var_retain", "@Var 0", "arr_length", "=", 1], "2nd", ["@var_retain", "@Var 0", "arr_elem", 0], "@end-if", "@else-if", ["@var_retain", "@Var 0", "arr_length", "=", 2], "2nd", ["@var_retain", "@Var 0", "arr_elem", [0, "@if", ["@Parent -4", "<", "@GVar 3"], "2nd", 1, "@end-if"]], "@end-else-if", "@else", "2nd", ["@var_retain", "@Var 0", "arr_elem", [0, "@if", ["@Parent -4", "<", "@GVar 4"], "2nd", 2, "@end-if", "@else-if", ["@Parent -4", "<", "@GVar 5"], "2nd", 1, "@end-if"]], "@end-else", "@if", ["@Parent -2", "=", 0], "@edit_gvar", 0, ["@Literal", ["@CalcArray", "@GVar 0", "arr_elem", 0, "-", 1], ["@CalcArray", "@GVar 0", "arr_elem", 1, "+", 1], ["@CalcArray", "@GVar 0", "arr_elem", 2]], "@end-if", "@if", ["@Parent -2", "=", 1], "@edit_gvar", 0, ["@Literal", ["@CalcArray", "@GVar 0", "arr_elem", 0], ["@CalcArray", "@GVar 0", "arr_elem", 1, "-", 1], ["@CalcArray", "@GVar 0", "arr_elem", 2, "+", 1]], "@end-if", "@if", ["@Parent -2", "=", 2], "@edit_gvar", 0, ["@Literal", ["@CalcArray", "@GVar 0", "arr_elem", 0, "+", 3], ["@CalcArray", "@GVar 0", "arr_elem", 1], ["@CalcArray", "@GVar 0", "arr_elem", 2, "-", 1]], "@end-if", "@end-if"], "EndTurn"])
        //         }
        //         else {
        //             scripts.push([[[[2, "^", ["@GVar 0", "arr_elem", 0]], "*", [3, "^", ["@GVar 0", "arr_elem", 1]], "*", [5, "^", ["@GVar 0", "arr_elem", 2]]], "@end_vars", 0, "@if", "@GVar 2", "@edit_gvar", 1, ["@var_retain", "@GVar 1", "+", 1], "@edit_gvar", 2, false, "@edit_gvar", 0, ["@var_retain", 0, 0, 0, "@end_vars", 0, "rand_float", 1, "@repeat", ["@var_retain", ["@var_retain", 2, "^", "@Var 1"], "*", ["@var_retain", 3, "^", "@Var 2"], "*", ["@var_retain", 5, "^", "@Var 3"], "<=", "@Var 0"], "@if", ["@Parent -2", "<", "@GVar 4"], "@edit_var", 1, ["@var_retain", "@Var 1", "+", 1], "@end-if", "@else-if", ["@Parent -2", "<", "@GVar 5"], "@edit_var", 2, ["@var_retain", "@Var 2", "+", 1], "@end-else-if", "@else", "@edit_var", 3, ["@var_retain", "@Var 3", "+", 1], "@end-else", "@end-repeat", "2nd", ["@Literal"], "arr_push", "@Var 1", "arr_push", "@Var 2"], "@end-if"], "EndTurn"])
        //         }
        //         if (mode_vars[13] == "None") {
        //             statBoxes.push(["Current Goal", "@GVar 0", false, false, "Tile", "Self"], ["Goals Reached", "@GVar 1"]);
        //         }
        //         else {
        //             statBoxes.push(["Current Goal", ["@GVar 0", "arr_push", 1], false, false, "Tile", "Self"], ["Goals Reached", "@GVar 1"]);
        //         }
        //     }
        // }
        else if (gamemode == 59) { // 1825
            if (mode_vars[0] > 0) {
                start_game_vars[3] = mode_vars[1];
                scripts.push([["@var_retain", 0, "@if", ["@var_retain", "@Var -1", "arr_elem", 0, "arr_elem", 0, "=", "@GVar 0"], "@edit_gvar", 2, true, "@end-if"], "Merge"]);
                if (mode_vars[0] == 1) {
                    scripts.push([[0, "@if", "@GVar 2", "@edit_gvar", 1, ["@var_retain", "@GVar 1", "+", 1], "@edit_gvar", 2, false, "@edit_gvar", 0, ["@GVar 0", "*", [2, "^", [2, "-", ["@GVar 0", "expomod", 2]]], "-", [1, "rand_int", ["@GVar 0", "^", 0.5, "floor", 1], "@if", ["@Parent -2", "%", 4, "=", 0], "-", 1, "@end-if"]], "@end-if"], "EndTurn"])
                }
                else {
                    scripts.push([[0, "@if", "@GVar 2", "@edit_gvar", 1, ["@var_retain", "@GVar 1", "+", 1], "@edit_gvar", 2, false, "@edit_gvar", 0, [[2, "^", ["@GVar 1", "+", "@GVar 3", "-", 1]], "rand_int", [2, "^", ["@GVar 1", "+", "@GVar 3"], "-", 1]], "@end-if"], "EndTurn"])
                }
                let sBox = ["@Literal", ["@CalcArray", "@GVar 0"], 1];
                if (modifiers[24]) sBox.push(1);
                statBoxes.push(["Current Goal", sBox, false, false, "Tile", "Self"], ["Goals Reached", "@GVar 1"]);
            }
        }
        else if (gamemode == 61) { // 3069
            if (mode_vars[2]) {
                TileTypes = [
                    [true, ["@This 0", "arr_reduce", 1n, ["*B", ["@var_retain", "@Var -1", "prime"]]], "@ColorScheme", "Odds-Only 3069", [["@This 0", "arr_reduce", 1n, ["*B", ["@var_retain", "@Var -1", "prime"]]]]]
                ];
                MergeRules = [
                    [3, [["@This 0", "=", "@Next 1 0"], "&&", ["@This 0", "=", "@Next 2 0"]], false, [[["@This 0", "arr_unshift", 2n]]], ["@This 0", "arr_reduce", 1n, ["*B", ["@var_retain", "@Var -1", "prime"]], "*B", 3n, "Number"], [false, true, true]],
                    [3, ["@This 0", [["@This 0", "arr_reduce", 1n, ["*B", ["@var_retain", "@Var -1", "prime"]]], "+B", ["@Next 1 0", "arr_reduce", 1n, ["*B", ["@var_retain", "@Var -1", "prime"]]], "+B", ["@Next 2 0", "arr_reduce", 1n, ["*B", ["@var_retain", "@Var -1", "prime"]]]], 0, false, "@end_vars", false, "@repeat", ["@var_retain", "@Var 2", "<", ["@This 0", "arr_length"], "&&", ["@var_retain", "@Parent -3", "!"]], "@edit_gvar", 0, ["@var_retain", "@Var 0", "arr_copy", "arr_edit_elem", "@Var 2", ["@var_retain", "@Var 0", "arr_elem", "@Var 2", "+B", 1n], "arr_sort", ["@var_retain", "@Var -2", "-B", "@Var -1", "Number"]], "@if", ["@var_retain", ["@var_retain", "@GVar 0", "arr_reduce", 1n, ["*B", ["@var_retain", "@Var -1", "prime"]]], "=", "@Var 1"], "2nd", true, "@end-if", "@edit_var", 2, ["@var_retain", "@Var 2", "+", 1], "@end-repeat"], false, [[["@GVar 0"]]], ["@GVar 0", "arr_reduce", 1n, ["*B", ["@var_retain", "@Var -1", "prime"]], "Number"], [false, true]]
                ];
                if (mode_vars[0] > 0) {
                    start_game_vars[4] = (mode_vars[1] + 1n) / 2n;
                    scripts.push([["@var_retain", 0, "@if", ["@var_retain", "@Var -1", "arr_elem", 0, "arr_elem", 0, "=", "@GVar 1"], "@edit_gvar", 3, true, "@end-if"], "Merge"]);
                    if (mode_vars[0] == 1) {
                        scripts.push([[0, "@if", "@GVar 3", "@edit_gvar", 2, ["@var_retain", "@GVar 2", "+", 1], "@edit_gvar", 3, false, "@add_var", ["@GVar 1", "arr_reduce", 1n, ["*B", ["@var_retain", "@Var -1", "prime"]]], "@add_var", ["@var_retain", "@Var -1", "arr_copy"], "@if", ["@GVar 2", "%", 4, "=", 1], "@edit_gvar", 1, ["@GVar 1", "arr_unshift", 2n], "@edit_gvar", 1, [[0, "rand_int", ["@GVar 1", "arr_length", "-", 1]], "@end_vars", "@GVar 1", "arr_edit_elem", "@Var 0", ["@var_retain", "@GVar 1", "arr_elem", "@Var 0", "+B", 1n]], "@end-if", "@else", "@repeat", ["@var_retain", "@Var -2", "*B", 3n, "/B", 2n, ">", "@Var -1"], "@edit_gvar", 1, [[0, "rand_int", ["@GVar 1", "arr_length", "-", 1]], "@end_vars", "@GVar 1", "arr_edit_elem", "@Var 0", ["@var_retain", "@GVar 1", "arr_elem", "@Var 0", "+B", 1n]], "@edit_var", -1, ["@GVar 1", "arr_reduce", 1n, ["*B", ["@var_retain", "@Var -1", "prime"]]], "@end-repeat", "@end-else", "@edit_gvar", 1, ["@GVar 1", "arr_sort", ["@Var -2", "-B", "@Var -1", "Number"]], "@end-if"], "EndTurn"])
                    }
                    else {
                        scripts.push([[0, "@if", "@GVar 3", "@edit_gvar", 2, ["@var_retain", "@GVar 2", "+", 1], "@edit_gvar", 3, false, "@add_var", 1n, "@add_var", 2n, "@add_var", [[2n, "^B", ["@GVar 2", "BigInt"], "*B", "@GVar 4"], "rand_bigint", [2n, "^B", ["@GVar 2", "+", 1], "BigInt", "*B", "@GVar 4", "-B", 1n], "*B", 2n, "-B", 1n], "@edit_gvar", 1, ["@Literal"], "@repeat", ["@var_retain", "@Var -1", ">", 1n], "@repeat", ["@var_retain", "@Var -1", "%B", "@Var -2", "=", 0n], "@edit_var", -1, ["@var_retain", "@Var -1", "/B", "@Var -2"], "@edit_gvar", 1, ["@var_retain", "@GVar 1", "arr_push", "@Var -3"], "@end-repeat", "@edit_var", -3, ["@var_retain", "@Var -3", "+B", 1n], "@edit_var", -2, ["@var_retain", "@Var -3", "prime"], "@end-repeat", "@end-if"], "EndTurn"])
                    }
                    let sBox = ["@GVar 1", "arr_reduce", 1n, ["*B", ["@var_retain", "@Var -1", "prime"]]];
                    if (modifiers[13] != "None") sBox.push("arr_push", 1);
                    if (modifiers[24]) sBox.push("arr_push", 1);
                    statBoxes.push(["Current Goal", sBox, false, false, "Tile", "Odds-Only 3069"], ["Goals Reached", "@GVar 2"]);
                }
                knownMergeMaxLength = 3;
                knownMergeLookbackDistance = 0;
            }  
            else if (mode_vars[0] > 0) {
                start_game_vars[4] = mode_vars[1];
                scripts.push([["@var_retain", 0, "@if", ["@var_retain", "@Var -1", "arr_elem", 0, "arr_elem", 0, "=", "@GVar 1"], "@edit_gvar", 3, true, "@end-if"], "Merge"]);
                if (mode_vars[0] == 1) {
                    scripts.push([[0, "@if", "@GVar 3", "@edit_gvar", 2, ["@var_retain", "@GVar 2", "+", 1], "@edit_gvar", 3, false, "@add_var", ["@GVar 1", "arr_reduce", 1n, ["*B", ["@var_retain", "@Var -1", "prime"]]], "@add_var", ["@var_retain", "@Var -1", "arr_copy"], "@if", ["@GVar 2", "%", 3, "=", 1], "@edit_gvar", 1, ["@GVar 1", "arr_unshift", 1n], "@edit_gvar", 1, [[0, "rand_int", ["@GVar 1", "arr_length", "-", 1]], "@end_vars", "@GVar 1", "arr_edit_elem", "@Var 0", ["@var_retain", "@GVar 1", "arr_elem", "@Var 0", "+B", 1n]], "@end-if", "@else", "@repeat", ["@var_retain", "@Var -2", "*B", 3n, "/B", 2n, ">", "@Var -1"], "@edit_gvar", 1, [[0, "rand_int", ["@GVar 1", "arr_length", "-", 1]], "@end_vars", "@GVar 1", "arr_edit_elem", "@Var 0", ["@var_retain", "@GVar 1", "arr_elem", "@Var 0", "+B", 1n]], "@edit_var", -1, ["@GVar 1", "arr_reduce", 1n, ["*B", ["@var_retain", "@Var -1", "prime"]]], "@end-repeat", "@end-else", "@edit_gvar", 1, ["@GVar 1", "arr_sort", ["@Var -2", "-B", "@Var -1", "Number"]], "@end-if"], "EndTurn"])
                }
                else {
                    scripts.push([[0, "@if", "@GVar 3", "@edit_gvar", 2, ["@var_retain", "@GVar 2", "+", 1], "@edit_gvar", 3, false, "@add_var", 1n, "@add_var", 2n, "@add_var", [[2n, "^B", ["@GVar 2", "BigInt"], "*B", "@GVar 4"], "rand_bigint", [2n, "^B", ["@GVar 2", "+", 1], "BigInt", "*B", "@GVar 4", "-B", 1n]], "@edit_gvar", 1, ["@Literal"], "@repeat", ["@var_retain", "@Var -1", ">", 1n], "@repeat", ["@var_retain", "@Var -1", "%B", "@Var -2", "=", 0n], "@edit_var", -1, ["@var_retain", "@Var -1", "/B", "@Var -2"], "@edit_gvar", 1, ["@var_retain", "@GVar 1", "arr_push", "@Var -3"], "@end-repeat", "@edit_var", -3, ["@var_retain", "@Var -3", "+B", 1n], "@edit_var", -2, ["@var_retain", "@Var -3", "prime"], "@end-repeat", "@end-if"], "EndTurn"])
                }
                let sBox = ["@GVar 1", "arr_reduce", 1n, ["*B", ["@var_retain", "@Var -1", "prime"]]];
                if (modifiers[13] != "None") sBox.push("arr_push", 1);
                if (modifiers[24]) sBox.push("arr_push", 1);
                statBoxes.push(["Current Goal", sBox, false, false, "Tile", "3069"], ["Goals Reached", "@GVar 2"]);
            }
        }
        else if (gamemode == 67) { // 1762
            if (mode_vars[0] > 0) {
                start_game_vars[3] = mode_vars[1];
                scripts.push([["@var_retain", 0, "@if", ["@var_retain", "@Var -1", "arr_elem", 0, "arr_elem", 0, "=", "@GVar 0"], "@edit_gvar", 2, true, "@end-if"], "Merge"]);
                if (mode_vars[0] == 1) {
                    scripts.push([[0, "@if", "@GVar 2", "@edit_gvar", 1, ["@var_retain", "@GVar 1", "+", 1], "@edit_gvar", 2, false, "@edit_gvar", 0, ["@GVar 0", "*B", 2n, "+B", [-1n, "rand_bigint", 1n]], "@end-if"], "EndTurn"])
                }
                else {
                    scripts.push([[0, "@if", "@GVar 2", "@edit_gvar", 1, ["@var_retain", "@GVar 1", "+", 1], "@edit_gvar", 2, false, "@edit_gvar", 0, [[2n, "^B", ["@GVar 1", "+B", "@GVar 3", "-B", 1n], "+B", 1n], "rand_bigint", [2n, "^B", ["@GVar 1", "+B", "@GVar 3"]]], "@end-if"], "EndTurn"])
                }
                let sBox = ["@Literal", ["@CalcArray", "@GVar 0"], 0];
                if (modifiers[13] != "None") sBox.push(1);
                if (modifiers[24]) sBox.push(1);
                statBoxes.push(["Current Goal", sBox, false, false, "Tile", "Self"], ["Goals Reached", "@GVar 1"]);
            }
        }
        else if (gamemode == 71 || gamemode == 71.37) { // 3,188,646 and 145.965
            MergeRules[(modifiers[13] == "Interacting") ? 2 : 1][2] = mode_vars[0];
        }
        else if (gamemode == 72) { // 3026
            if (mode_vars[0]) {
                TileTypes = [
                    [
                        [true, "@repeat", ["@GVar 0", "arr_length", "<=", "@This 1"], "@edit_gvar", 0, ["@GVar 0", "arr_push", [["@GVar 0", "arr_elem", -1], "+B", ["@GVar 0", "arr_elem", -2]]], "@end-repeat"], 
                        [["@GVar 0", "arr_elem", "@This 0"], "*B", ["@GVar 0", "arr_elem", "@This 1"]],
                        ["@linear-gradient", ["@HSLA", ["@This 0", "*", 23, "+", 53], [0.8, "^", ["@This 1", "/", 30, "floor", 1], "*", 100], ["@This 0", "%", 10, "*", -6, "+", 85], 1], 0, 33, ["@HSLA", ["@This 1", "*", 23, "+", 53], [0.8, "^", ["@This 1", "/", 30, "floor", 1], "*", 100], ["@This 1", "%", 10, "*", -6, "+", 85], 1], 66, 100], 
                        "#19202e", "none", 2.5, 0,
                        ["Innerscript", [["@GVar 0", "arr_elem", "@This 0", "defaultAbbrevB"], "str_concat", " &#215; ", "str_concat", ["@GVar 0", "arr_elem", "@This 1", "defaultAbbrevB"]], "bottom-center", 6, 0]
                    ]
                ]
                if (modifiers[13] == "Interacting") {
                    MergeRules = [
                        [2, [["@This 0", "=", "@Next 1 0"], "&&", ["@This 1", "=", "@Next 1 1"], "&&", ["@This 2", "!=", "@Next 1 2"]], true, [], 0, [true, true]],
                        [
                        2, [
                            [[["@GVar 0", "arr_elem", "@This 0"], "*B", ["@GVar 0", "arr_elem", "@This 1"], "*B", "@This 2"], "+B", [["@GVar 0", "arr_elem", "@Next 1 0"], "*B", ["@GVar 0", "arr_elem", "@Next 1 1"], "*B", "@Next 1 2"]], false, "@end_vars", 0, "@repeat", ["@var_retain", "@GVar 0", "arr_elem", -1, "<=", ["@var_retain", "@Var 0", "absB"]], "@edit_gvar", 0, ["@GVar 0", "arr_push", [["@GVar 0", "arr_elem", -1], "+B", ["@GVar 0", "arr_elem", -2]]], "@end-repeat",
                            "@repeat", ["@var_retain", "@GVar 0", "arr_elem", "@Parent -2", "<=", ["@var_retain", "@Var 0", "absB"]], "+", 1, "@end-repeat", "-", 1, "max", 0, "@add_var", "@Parent -1", "@add_var", "@Parent -1",
                            "@repeat", ["@var_retain", ["@var_retain", "@Var 2", ">=", 0], "&&", ["@var_retain", "@Var 1", "!"]], "@if", ["@var_retain", ["@var_retain", "@GVar 0", "arr_elem", "@Var 2"], "*B", ["@var_retain", "@GVar 0", "arr_elem", "@Var 3"], "=", ["@var_retain", "@Var 0", "absB"]], "@edit_var", 1, true, "@end-if", "@else", "@edit_var", 3, ["@var_retain", "@Var 3", "-", 1], "@if", ["@var_retain", "@Var 3", "<", 0], "@edit_var", 2, ["@var_retain", "@Var 2", "-", 1], "@edit_var", 3, "@Var 2", "@end-if", "@end-else", "@end-repeat",
                            "@edit_gvar", 1, "@Var 3", "@edit_gvar", 2, "@Var 2", "@edit_gvar", 3, ["@var_retain", 1, "@if", ["@var_retain", "@Var 0", "<", 0n], "2nd", -1], "2nd", "@Var 1"
                        ], true, [["@GVar 1", "@GVar 2", "@GVar 3"]], [["@GVar 0", "arr_elem", "@GVar 1"], "*B", ["@GVar 0", "arr_elem", "@GVar 2"]], [false, true]
                        ]
                    ]
                }
                else {
                    MergeRules = [[
                        2, [
                            [[["@GVar 0", "arr_elem", "@This 0"], "*B", ["@GVar 0", "arr_elem", "@This 1"]], "+B", [["@GVar 0", "arr_elem", "@Next 1 0"], "*B", ["@GVar 0", "arr_elem", "@Next 1 1"]]], false, "@end_vars", 0, "@repeat", ["@var_retain", "@GVar 0", "arr_elem", -1, "<=", "@Var 0"], "@edit_gvar", 0, ["@GVar 0", "arr_push", [["@GVar 0", "arr_elem", -1], "+B", ["@GVar 0", "arr_elem", -2]]], "@end-repeat",
                            "@repeat", ["@var_retain", "@GVar 0", "arr_elem", "@Parent -2", "<=", "@Var 0"], "+", 1, "@end-repeat", "-", 1, "max", 0, "@add_var", "@Parent -1", "@add_var", "@Parent -1",
                            "@repeat", ["@var_retain", ["@var_retain", "@Var 2", ">=", 0], "&&", ["@var_retain", "@Var 1", "!"]], "@if", ["@var_retain", ["@var_retain", "@GVar 0", "arr_elem", "@Var 2"], "*B", ["@var_retain", "@GVar 0", "arr_elem", "@Var 3"], "=", "@Var 0"], "@edit_var", 1, true, "@end-if", "@else", "@edit_var", 3, ["@var_retain", "@Var 3", "-", 1], "@if", ["@var_retain", "@Var 3", "<", 0], "@edit_var", 2, ["@var_retain", "@Var 2", "-", 1], "@edit_var", 3, "@Var 2", "@end-if", "@end-else", "@end-repeat",
                            "@edit_gvar", 1, "@Var 3", "@edit_gvar", 2, "@Var 2", "2nd", "@Var 1"
                        ], true, [["@GVar 1", "@GVar 2"]], [["@GVar 0", "arr_elem", "@GVar 1"], "*B", ["@GVar 0", "arr_elem", "@GVar 2"]], [false, true]
                    ]]
                }
            }
            if (mode_vars[1] > 0) {
                start_game_vars[8] = mode_vars[2];
                scripts.push([["@var_retain", 0, "@if", ["@var_retain", "@Var -1", "arr_elem", 0, "=", "@GVar 4"], "@edit_gvar", 6, true, "@end-if"], "Merge"]);
                if (mode_vars[1] == 1) {
                    scripts.push([[0, "@if", "@GVar 6", "@edit_gvar", 5, ["@var_retain", "@GVar 5", "+", 1], "@edit_gvar", 6, false, "@edit_gvar", 4, [["@Literal", 2, 2], "@if", [[["@GVar 4", "arr_elem", 0], "=", ["@GVar 4", "arr_elem", 1]], "||", [0, "rand_float", 1, "<", "@GVar 7"]], "2nd", ["@Literal", ["@CalcArray", "@GVar 4", "arr_elem", 0], ["@CalcArray", "@GVar 4", "arr_elem", 1, "+", 1]], "@end-if", "@else", "2nd", ["@Literal", ["@CalcArray", "@GVar 4", "arr_elem", 0, "+", 1], ["@CalcArray", "@GVar 4", "arr_elem", 1]]], "@end-if"], "EndTurn"])
                }
                else {
                    scripts.push([[0, "@if", "@GVar 6", "@edit_gvar", 5, ["@var_retain", "@GVar 5", "+", 1], "@edit_gvar", 6, false, "@edit_gvar", 4, [["@Literal"], "arr_push", [0, "rand_int", ["@GVar 5", "+", "@GVar 8", "floor", 2, "/", 2]], "arr_push", ["@var_retain", "@GVar 5", "+", "@GVar 8", "-", ["@Parent -3", "arr_elem", 0]]], "@end-if"], "EndTurn"])
                }
                let sBox = ["@GVar 4"];
                if (modifiers[13] != "None") sBox.push("arr_push", 1);
                if (modifiers[24]) sBox.push("arr_push", 1);
                statBoxes.push(["Current Goal", sBox, false, false, "Tile", "Self"], ["Goals Reached", "@GVar 5"]);
            }
        }
        else if (gamemode == 73) { // SQUART
            if (mode_vars[0] > 0) {
                scripts.push([["@var_retain", 0, "@if", ["@var_retain", "@Var -1", "arr_elem", 0, "arr_elem", 0, "=", "@GVar 0"], "@edit_gvar", 2, true, "@end-if"], "Merge"]);
                if (mode_vars[0] == 1) {
                    scripts.push([["@global_var_retain_inner", ["@Literal"], 0, "@end_vars", 0, "@if", "@GVar 2", "@edit_gvar", 1, ["@GVar 1", "+", 1], "@edit_gvar", 2, false, "@repeat", ["@GVar 3", "arr_length", ">", "@Var 1"], "@if", ["@GVar 3", "arr_elem", "@Var 1", ">", "@GVar 0"], "@edit_var", 1, 1e300, "@end-if", "@else-if", ["@GVar 3", "arr_elem", "@Var 1", "^B", 2, "%B", "@GVar 0", "=", 0n], "@edit_var", 0, ["@Var 0", "arr_push", ["@GVar 3", "arr_elem", "@Var 1"]], "@end-else-if", "@edit_var", 1, ["@Var 1", "+", 1], "@end-repeat", "2nd", ["@GVar 0", "+B", ["@Var 0", "arr_elem", ["@Var 0", "arr_length", "-", 1, "rand_int", 0]]], "@edit_gvar", 0, "@Parent -1", "@edit_gvar", 3, ["@GVar 3", "arr_push", "@Parent -2"], "@end-if"], "EndTurn"])
                }
                else if (mode_vars[0] == 2) {
                    scripts.push([["@global_var_retain_inner", ["@Literal"], 0, "@end_vars", 0, "@if", "@GVar 2", "@edit_gvar", 1, ["@GVar 1", "+", 1], "@edit_gvar", 2, false, "@repeat", ["@GVar 3", "arr_length", ">", "@Var 1"], "@if", ["@GVar 3", "arr_elem", "@Var 1", ">", "@GVar 0"], "@edit_var", 1, 1e300, "@end-if", "@else-if", ["@GVar 3", "arr_elem", "@Var 1", "^B", 2, "%B", "@GVar 0", "=", 0n], "@edit_var", 0, ["@Var 0", "arr_push", ["@GVar 3", "arr_elem", "@Var 1", "+B", "@GVar 0"]], "@end-else-if", "@edit_var", 1, ["@Var 1", "+", 1], "@end-repeat", "@edit_gvar", 0, ["@Var 0", "arr_elem", ["@Var 0", "arr_length", "-", 1, "rand_int", 0]], "@edit_var", 1, 0, "@repeat", ["@Var 0", "arr_length", ">", "@Var 1"], "@if", ["@GVar 3", "arr_indexOf", ["@Var 0", "arr_elem", "@Var 1"], "=", -1], "@edit_gvar", 3, ["@GVar 3", "arr_binaryInsert", ["@Var 0", "arr_elem", "@Var 1"]], "@end-if", "@edit_var", 1, ["@Var 1", "+", 1], "@end-repeat", "@end-if"], "EndTurn"])
                }
                else {
                    scripts.push([["@global_var_retain_inner", ["@Literal"], 0, 0n, "@end_vars", 0, "@if", "@GVar 2", "@edit_gvar", 1, ["@GVar 1", "+", 1], "@edit_gvar", 2, false, "@edit_var", 2, ["@GVar 3", "arr_elem", ["@GVar 3", "arr_length", "-", 1, "rand_int", 0]], "@repeat", ["@Var 2", "<=", "@GVar 0"], "@edit_var", 1, 0, "@repeat", ["@GVar 3", "arr_length", ">", "@Var 1"], "@if", ["@GVar 3", "arr_elem", "@Var 1", ">", "@Var 2"], "@edit_var", 1, 1e300, "@end-if", "@else-if", ["@GVar 3", "arr_elem", "@Var 1", "^B", 2, "%B", "@Var 2", "=", 0n], "@edit_var", 0, ["@Var 0", "arr_push", ["@GVar 3", "arr_elem", "@Var 1", "+B", "@Var 2"]], "@end-else-if", "@edit_var", 1, ["@Var 1", "+", 1], "@end-repeat", "@edit_var", 2, ["@Var 0", "arr_elem", ["@Var 0", "arr_length", "-", 1, "rand_int", 0]], "@edit_var", 1, 0, "@repeat", ["@Var 0", "arr_length", ">", "@Var 1"], "@if", ["@GVar 3", "arr_indexOf", ["@Var 0", "arr_elem", "@Var 1"], "=", -1], "@edit_gvar", 3, ["@GVar 3", "arr_binaryInsert", ["@Var 0", "arr_elem", "@Var 1"]], "@end-if", "@edit_var", 1, ["@Var 1", "+", 1], "@end-repeat", "@edit_var", 0, ["@Literal"], "@end-repeat", "@edit_gvar", 0, "@Var 2", "@end-if"], "EndTurn"])
                }
                let sBox = ["@Literal", ["@CalcArray", "@GVar 0"], 0];
                if (modifiers[24]) sBox.push(1);
                statBoxes.push(["Current Goal", sBox, false, false, "Tile", "Self"], ["Goals Reached", "@GVar 1"]);
                start_game_vars[4] = mode_vars[1];
            }
        }
        else if (gamemode == 74) { // Turatin
            start_game_vars[1] = mode_vars[0];
            start_game_vars[2] = mode_vars[0];
            if (mode_vars[1]) {
                if (modifiers[13] == "None") {
                    MergeRules = [
                        [2, [["@This 0", ">=", "@Next 1 0"], "&&", ["@GVar 0", "%B", ["@This 0", "/B", ["@This 0", "gcdB", "@Next 1 0"]], "=", 0n]], false, [[["@This 0", "+B", "@Next 1 0"]]], ["@This 0", "/", "@Next 1 0"], [false, true]]
                    ]
                }
                else {
                    if (modifiers[13] == "Non-Interacting") {
                        MergeRules = [
                            [2, [[["@This 0", "absB"], ">=", ["@Next 1 0", "absB"]], "&&", ["@GVar 0", "%B", [["@This 0", "absB"], "/B", [["@This 0", "absB"], "gcdB", ["@Next 1 0", "absB"]]], "=", 0n], "&&", [["@This 0", "signB"], "=", ["@Next 1 0", "signB"]]], false, [[["@This 0", "+B", "@Next 1 0"]]], ["@This 0", "/", "@Next 1 0", "abs"], [false, true]]
                        ]
                    }
                    else {
                        MergeRules = [
                            [2, ["@This 0", "*B", -1n, "=", "@Next 1 0"], false, [], 0, [true, true]],
                            [2, [[["@This 0", "absB"], ">=", ["@Next 1 0", "absB"]], "&&", ["@GVar 0", "%B", [["@This 0", "absB"], "/B", [["@This 0", "absB"], "gcdB", ["@Next 1 0", "absB"]]], "=", 0n]], false, [[["@This 0", "+B", "@Next 1 0"]]], ["@This 0", "/", "@Next 1 0", "abs"], [false, true]]
                        ]
                    }
                }
            }
            if (mode_vars[2] == 0) {
                statBoxes = [["Turns Until Merge Change", "@GVar 1"], ["Merge Number", "@GVar 0", false, false, "Tile", "Turatin"], ["Score", "@Score"]];
                scripts = [
                    [[0, "@edit_gvar", 1, ["@Moves", "%B", "@GVar 2", "*B", -1n, "+B", "@GVar 2"], "@edit_gvar", 0, ["@Moves", "/B", "@GVar 2", "+B", 1]], "EndTurn"]
                ];
            }
            else if (mode_vars[2] == 1) {
                statBoxes = [["Turns with Merges Until Merge Change", "@GVar 1"], ["Merge Number", "@GVar 0", false, false, "Tile", "Turatin"], ["Score", "@Score"]];
                scripts = [
                    [[0, "@edit_gvar", 1, ["@MergeMoves", "%B", "@GVar 2", "*B", -1n, "+B", "@GVar 2"], "@edit_gvar", 0, ["@MergeMoves", "/B", "@GVar 2", "+B", 1]], "EndTurn"]
                ];
            }
            else if (mode_vars[2] == 2) {
                statBoxes = [["Merges Until Merge Change", "@GVar 1"], ["Merge Number", "@GVar 0", false, false, "Tile", "Turatin"], ["Score", "@Score"]];
                scripts = [
                    [[0, "@edit_gvar", 1, ["@MergesBefore", "%B", "@GVar 2", "*B", -1n, "+B", "@GVar 2"], "@edit_gvar", 0, ["@MergesBefore", "/B", "@GVar 2", "+B", 1]], "EndTurn"]
                ];
            }
        }
        else if (gamemode == 77) { // 1668
            if (mode_vars[0] > 0) {
                start_game_vars[3] = mode_vars[1];
                scripts.push([["@var_retain", 0, "@if", ["@var_retain", "@Var -1", "arr_elem", 0, "arr_elem", 0, "=", "@GVar 0"], "@edit_gvar", 2, true, "@end-if"], "Merge"]);
                if (mode_vars[0] == 1) {
                    scripts.push([[0, "@if", "@GVar 2", "@edit_gvar", 1, ["@var_retain", "@GVar 1", "+", 1], "@edit_gvar", 2, false, "@edit_gvar", 0, ["@GVar 0", "*B", 3n, "+B", [-1n, "rand_bigint", 1n]], "@end-if"], "EndTurn"])
                }
                else {
                    scripts.push([[0, "@if", "@GVar 2", "@edit_gvar", 1, ["@var_retain", "@GVar 1", "+", 1], "@edit_gvar", 2, false, "@edit_gvar", 0, [[3n, "^B", ["@GVar 1", "+B", "@GVar 3", "-B", 1n], "+B", 1n], "rand_bigint", [3n, "^B", ["@GVar 1", "+B", "@GVar 3"]]], "@end-if"], "EndTurn"])
                }
                let sBox = ["@Literal", ["@CalcArray", "@GVar 0"], 0];
                if (modifiers[13] != "None") sBox.push(1);
                if (modifiers[24]) sBox.push(1);
                statBoxes.push(["Current Goal", sBox, false, false, "Tile", "Self"], ["Goals Reached", "@GVar 1"]);
            }
        }
        else if (gamemode == 78) { // 1847
            if (mode_vars[0] > 0) {
                start_game_vars[3] = mode_vars[1];
                scripts.push([["@var_retain", 0, "@if", ["@var_retain", "@Var -1", "arr_elem", 0, "arr_elem", 0, "=", "@GVar 0"], "@edit_gvar", 2, true, "@end-if"], "Merge"]);
                if (mode_vars[0] == 1) {
                    scripts.push([[0, "@if", "@GVar 2", "@edit_gvar", 1, ["@var_retain", "@GVar 1", "+", 1], "@edit_gvar", 2, false, "@edit_gvar", 0, ["@GVar 0", "*BR", 1.5, "@if", [0n, "rand_bigint", 1n], "floorBR", 1, "@end-if", "@else", "ceilBR", 1, "@end-else", "BigInt"], "@end-if"], "EndTurn"])
                }
                else {
                    scripts.push([[0, "@if", "@GVar 2", "@edit_gvar", 1, ["@var_retain", "@GVar 1", "+", 1], "@edit_gvar", 2, false, "@edit_gvar", 0, [[1.5, "^BR", ["@GVar 1", "+B", "@GVar 3", "-B", 1n], "ceilBR", 1, "BigInt"], "rand_bigint", [1.5, "^BR", ["@GVar 1", "+B", "@GVar 3"], "floorBR", 1, "BigInt"]], "@end-if"], "EndTurn"])
                }
                let sBox = ["@Literal", ["@CalcArray", "@GVar 0"], 0];
                if (modifiers[13] != "None") sBox.push(1);
                if (modifiers[24]) sBox.push(1);
                statBoxes.push(["Current Goal", sBox, false, false, "Tile", "Self"], ["Goals Reached", "@GVar 1"]);
            }
        }
        else if (gamemode == 80) { // 1429
            if (mode_vars[0] > 0) {
                start_game_vars[3] = mode_vars[1];
                scripts.push([["@var_retain", 0, "@if", ["@var_retain", "@Var -1", "arr_elem", 0, "arr_elem", 0, "=", "@GVar 0"], "@edit_gvar", 2, true, "@end-if"], "Merge"]);
                if (mode_vars[0] == 1) {
                    scripts.push([[0, "@if", "@GVar 2", "@edit_gvar", 1, ["@var_retain", "@GVar 1", "+", 1], "@edit_gvar", 2, false, "@edit_gvar", 0, ["@GVar 0", "*B", 2n, "+B", [0n, "rand_bigint", 1n, "*B", 2n, "-B", 1n]], "@end-if"], "EndTurn"])
                }
                else {
                    scripts.push([[0, "@if", "@GVar 2", "@edit_gvar", 1, ["@var_retain", "@GVar 1", "+", 1], "@edit_gvar", 2, false, "@edit_gvar", 0, [[2n, "^B", ["@GVar 1", "+B", "@GVar 3", "-B", 2n], "+B", 1n], "rand_bigint", [2n, "^B", ["@GVar 1", "+B", "@GVar 3", "-B", 1n]], "*B", 2n, "-B", 1n], "@end-if"], "EndTurn"])
                }
                let sBox = ["@Literal", ["@CalcArray", "@GVar 0"], 1n];
                if (modifiers[24]) sBox.push(1);
                statBoxes.push(["Current Goal", sBox, false, false, "Tile", "Self"], ["Goals Reached", "@GVar 1"]);
            }
        }
        else if (gamemode == 81) { // 2058
            if (mode_vars[0] == 1) {
                MergeRules.splice(8, 1); MergeRules.splice(6, 1); MergeRules.splice(4, 1); MergeRules.splice(2, 1);
                statBoxes = [["Score", "@Score"]];
            }
            else {
                MergeRules[8] = [0, [[["@This 0", "=", "@GVar 0"], "&&", ["@This 1", ">=", mode_vars[0]]], "||", [["@This 0", "+", 1, "=", "@GVar 0"], "&&", ["@This 2", ">=", mode_vars[0]]]], true, [["@This 0", "@This 1", "@This 2"]], [0, "@edit_gvar", 0, ["@GVar 0", "+", 1]]];
                start_game_vars[0] = mode_vars[1];
            }
        }
        else if (gamemode == 82) { // 1716
            if (mode_vars[0]) {
                MergeRules.push([2, [["@This 0", "=", "@Next 1 0"], "&&", ["@This 1", "=", "@Next 1 1"]], false, [], [0, "@edit_gvar", 0, ["@GVar 0", "+", 1]], [true, true]]);
                statBoxes = [["Disappeared Tiles", "@GVar 0"]];
            }
        }
        else if (gamemode == 85) { // 2669
            if (mode_vars[0] > 0) {
                start_game_vars[4] = mode_vars[1];
                scripts.push([["@var_retain", 0, "@if", ["@var_retain", "@Var -1", "arr_elem", 0, "arr_elem", 0, "=", "@GVar 0"], "@edit_gvar", 2, true, "@end-if"], "Merge"]);
                if (mode_vars[0] == 1) {
                    scripts.push([[["@GVar 3", "arr_copy"], "@end_vars", 0, "@if", "@GVar 2", "@edit_gvar", 1, ["@GVar 1", "+", 1], "@edit_gvar", 2, false, "@if", [["@GVar 3", "arr_elem", 2, ">=", 2], "||", [0, "rand_float", 1, ">", 0.5]], "@edit_gvar", 3, ["@GVar 0", "arr_concat", ["@GVar 3", "arr_elem", 0], "arr_concat", 1], "@edit_gvar", 0, ["@var_retain", "@Var 0", "arr_elem", 0, "+B", "@GVar 0"], "@end-if", "@else", "@edit_gvar", 3, ["@GVar 0", "arr_concat", ["@GVar 3", "arr_elem", 1], "arr_concat", ["@GVar 3", "arr_elem", 2, "+", 1]], "@edit_gvar", 0, ["@var_retain", "@Var 0", "arr_elem", 1, "+B", "@GVar 0"], "@end-else", "@end-if"], "EndTurn"])
                }
                else {
                    scripts.push([[["@Literal", 3n, 2n, 1], ["@GVar 0", "*B", 3n, "/B", 2n], "@end_vars", 0, "@if", "@GVar 2", "@edit_gvar", 1, ["@GVar 1", "+", 1], "@edit_gvar", 2, false, "@edit_gvar", 0, 5n, "@edit_gvar", 3, ["@Literal", 3n, 2n, 1], "@repeat", ["@var_retain", "@GVar 0", "<", "@Var 1"], "@if", [["@GVar 3", "arr_elem", 2, ">=", 2], "||", [0, "rand_float", 1, ">", 0.5]], "@edit_gvar", 3, ["@GVar 0", "arr_concat", ["@GVar 3", "arr_elem", 0], "arr_concat", 1], "@edit_gvar", 0, ["@var_retain", "@Var 0", "arr_elem", 0, "+B", "@GVar 0"], "@end-if", "@else", "@edit_gvar", 3, ["@GVar 0", "arr_concat", ["@GVar 3", "arr_elem", 1], "arr_concat", ["@GVar 3", "arr_elem", 2, "+", 1]], "@edit_gvar", 0, ["@var_retain", "@Var 0", "arr_elem", 1, "+B", "@GVar 0"], "@end-else", "@edit_var", 0, ["@GVar 3", "arr_copy"], "@end-repeat", "@end-if"], "EndTurn"])
                }
                let sBox = ["@GVar 0", "arr_concat", "@GVar 3"];
                if (modifiers[13] != "None") sBox.push("arr_push", 1);
                if (modifiers[24]) sBox.push("arr_push", 1);
                statBoxes.push(["Current Goal", sBox, false, false, "Tile", "Self"], ["Goals Reached", "@GVar 1"]);
            }
        }
        else if (gamemode == 88) { // FACTUP
            if (mode_vars[0]) {
                if (modifiers[13] == "None") {
                    MergeRules = [
                        [2, [["@This 0", "+B", "@Next 1 0", "factorAmountB"], ">=", [["@This 0", "factorAmountB"], "max", ["@Next 1 0", "factorAmountB"]]], true, [[["@This 0", "+B", "@Next 1 0"]]], ["@This 0", "+", "@Next 1 0"], [false, true]],
                    ];
                }
                else {
                    MergeRules = [
                        [2, [[["@This 0", "signB"], "=", ["@Next 1 0", "signB"]], "&&", [["@This 0", "+B", "@Next 1 0", "absB", "factorAmountB"], ">=", [["@This 0", "absB", "factorAmountB"], "max", ["@Next 1 0", "absB", "factorAmountB"]]]], true, [[["@This 0", "+B", "@Next 1 0"]]], ["@This 0", "+", "@Next 1 0", "abs"], [false, true]]
                    ];
                    if (modifiers[13] == "Interacting") MergeRules.push(
                        [2, ["@This 0", "*B", -1n, "=", "@Next 1 0"], true, [], 0, [true, true]],
                        [2, [[["@This 0", "signB"], "!=", ["@Next 1 0", "signB"]], "&&", [["@This 0", "absB"], ">", ["@Next 1 0", "absB"]], "&&", [["@This 0", "+B", "@Next 1 0", "absB", "factorAmountB"], ">=", [["@This 0", "absB", "factorAmountB"], "max", ["@Next 1 0", "absB", "factorAmountB"]]]], false, [[["@This 0", "+B", "@Next 1 0"]]], ["@This 0", "+", "@Next 1 0", "abs"], [false, true]]
                    )
                }
            }
            if (mode_vars[1] > 0) {
                let factorInequality = (mode_vars[0]) ? ">=" : ">";
                scripts.push([["@var_retain", 0, "@if", ["@var_retain", "@Var -1", "arr_elem", 0, "arr_elem", 0, "=", "@GVar 0"], "@edit_gvar", 2, true, "@end-if"], "Merge"]);
                if (mode_vars[1] == 1) {
                    scripts.push([["@global_var_retain_inner", ["@Literal"], 0, "@end_vars", 0, "@if", "@GVar 2", "@edit_gvar", 1, ["@GVar 1", "+", 1], "@edit_gvar", 2, false, "@repeat", ["@GVar 3", "arr_length", ">", "@Var 1"], "@if", ["@GVar 3", "arr_elem", "@Var 1", ">", "@GVar 0"], "@edit_var", 1, 1e300, "@end-if", "@else-if", [["@GVar 3", "arr_elem", "@Var 1", "+B", "@GVar 0", "factorAmountB"], factorInequality, [["@GVar 3", "arr_elem", "@Var 1", "factorAmountB"], "max", ["@GVar 0", "factorAmountB"]]], "@edit_var", 0, ["@Var 0", "arr_push", ["@GVar 3", "arr_elem", "@Var 1"]], "@end-else-if", "@edit_var", 1, ["@Var 1", "+", 1], "@end-repeat", "2nd", ["@GVar 0", "+B", ["@Var 0", "arr_elem", ["@Var 0", "arr_length", "-", 1, "rand_int", 0]]], "@edit_gvar", 0, "@Parent -1", "@edit_gvar", 3, ["@GVar 3", "arr_push", "@Parent -2"], "@end-if"], "EndTurn"])
                }
                else if (mode_vars[1] == 2) {
                    scripts.push([["@global_var_retain_inner", ["@Literal"], 0, "@end_vars", 0, "@if", "@GVar 2", "@edit_gvar", 1, ["@GVar 1", "+", 1], "@edit_gvar", 2, false, "@repeat", ["@GVar 3", "arr_length", ">", "@Var 1"], "@if", ["@GVar 3", "arr_elem", "@Var 1", ">", "@GVar 0"], "@edit_var", 1, 1e300, "@end-if", "@else-if", [["@GVar 3", "arr_elem", "@Var 1", "+B", "@GVar 0", "factorAmountB"], factorInequality, [["@GVar 3", "arr_elem", "@Var 1", "factorAmountB"], "max", ["@GVar 0", "factorAmountB"]]], "@edit_var", 0, ["@Var 0", "arr_push", ["@GVar 3", "arr_elem", "@Var 1", "+B", "@GVar 0"]], "@end-else-if", "@edit_var", 1, ["@Var 1", "+", 1], "@end-repeat", "@edit_gvar", 0, ["@Var 0", "arr_elem", ["@Var 0", "arr_length", "-", 1, "rand_int", 0]], "@edit_var", 1, 0, "@repeat", ["@Var 0", "arr_length", ">", "@Var 1"], "@if", ["@GVar 3", "arr_indexOf", ["@Var 0", "arr_elem", "@Var 1"], "=", -1], "@edit_gvar", 3, ["@GVar 3", "arr_binaryInsert", ["@Var 0", "arr_elem", "@Var 1"]], "@end-if", "@edit_var", 1, ["@Var 1", "+", 1], "@end-repeat", "@end-if"], "EndTurn"])
                }
                else {
                    scripts.push([["@global_var_retain_inner", ["@Literal"], 0, 0n, "@end_vars", 0, "@if", "@GVar 2", "@edit_gvar", 1, ["@GVar 1", "+", 1], "@edit_gvar", 2, false, "@edit_var", 2, ["@GVar 3", "arr_elem", ["@GVar 3", "arr_length", "-", 1, "rand_int", 0]], "@repeat", ["@Var 2", "<=", "@GVar 0"], "@edit_var", 1, 0, "@repeat", ["@GVar 3", "arr_length", ">", "@Var 1"], "@if", ["@GVar 3", "arr_elem", "@Var 1", ">", "@Var 2"], "@edit_var", 1, 1e300, "@end-if", "@else-if", [["@GVar 3", "arr_elem", "@Var 1", "+B", "@Var 2", "factorAmountB"], factorInequality, [["@GVar 3", "arr_elem", "@Var 1", "factorAmountB"], "max", ["@Var 2", "factorAmountB"]]], "@edit_var", 0, ["@Var 0", "arr_push", ["@GVar 3", "arr_elem", "@Var 1", "+B", "@Var 2"]], "@end-else-if", "@edit_var", 1, ["@Var 1", "+", 1], "@end-repeat", "@edit_var", 2, ["@Var 0", "arr_elem", ["@Var 0", "arr_length", "-", 1, "rand_int", 0]], "@edit_var", 1, 0, "@repeat", ["@Var 0", "arr_length", ">", "@Var 1"], "@if", ["@GVar 3", "arr_indexOf", ["@Var 0", "arr_elem", "@Var 1"], "=", -1], "@edit_gvar", 3, ["@GVar 3", "arr_binaryInsert", ["@Var 0", "arr_elem", "@Var 1"]], "@end-if", "@edit_var", 1, ["@Var 1", "+", 1], "@end-repeat", "@edit_var", 0, ["@Literal"], "@end-repeat", "@edit_gvar", 0, "@Var 2", "@end-if"], "EndTurn"])
                }
                let sBox = ["@Literal", ["@CalcArray", "@GVar 0"], 0];
                if (modifiers[24]) sBox.push(1);
                statBoxes.push(["Current Goal", sBox, false, false, "Tile", "Self"], ["Goals Reached", "@GVar 1"]);
                start_game_vars[4] = mode_vars[2];
            }
        }
        else if (gamemode == 89) { // 2496
            if (mode_vars[0] > 0) {
                start_game_vars[3] = mode_vars[1];
                scripts.push([["@var_retain", 0, "@if", ["@var_retain", "@Var -1", "arr_elem", 0, "=", "@GVar 0"], "@edit_gvar", 2, true, "@end-if"], "Merge"]);
                if (mode_vars[0] == 1) {
                    scripts.push([[0, "@if", "@GVar 2", "@edit_gvar", 1, ["@var_retain", "@GVar 1", "+", 1], "@edit_gvar", 2, false, "@edit_gvar", 0, [["@Literal"], "arr_push", ["@GVar 0", "arr_elem", 1], "@if", ["@GVar 0", "arr_elem", 1, "/B", [2n, "^B", ["@GVar 0", "arr_elem", 1, "expomodB", 2n]], "=", 1n], "arr_push", ["@GVar 0", "arr_elem", 0, "+B", [["@GVar 0", "arr_elem", 1, "/B", 2n], "rand_bigint", ["@GVar 0", "arr_elem", 1]]], "@end-if", "@else", "arr_push", ["@GVar 0", "arr_elem", 0, "*B", 2n]], "@end-if"], "EndTurn"])
                }
                else {
                    scripts.push([[0, "@if", "@GVar 2", "@edit_gvar", 1, ["@var_retain", "@GVar 1", "+", 1], "@edit_gvar", 2, false, "@edit_gvar", 0, [["@Literal"], "@if", ["@GVar 0", "arr_elem", 1, "/B", [2n, "^B", ["@GVar 0", "arr_elem", 1, "expomodB", 2n]], "=", 1n], "arr_push", ["@GVar 0", "arr_elem", 1], "arr_push", [["@GVar 0", "arr_elem", 1], "rand_bigint", ["@GVar 0", "arr_elem", 1, "*B", 2n]], "@end-if", "@else", "arr_push", [["@GVar 0", "arr_elem", 0], "rand_bigint", ["@GVar 0", "arr_elem", 0, "*B", 2n]], "arr_push", ["@GVar 0", "arr_elem", 0, "*B", 2n]], "@end-if"], "EndTurn"])
                }
                let sBox = ["@GVar 0"];
                if (modifiers[13] != "None") sBox.push("arr_push", 1);
                if (modifiers[24]) sBox.push(1);
                statBoxes.push(["Current Goal", sBox, false, false, "Tile", "Self"], ["Goals Reached", "@GVar 1"]);
            }
        }
        else if (gamemode == 91) { // 1845
            if (mode_vars[0] > 0) {
                start_game_vars[3] = mode_vars[1];
                scripts.push([["@var_retain", 0, "@if", ["@var_retain", "@Var -1", "arr_elem", 0, "arr_elem", 0, "=", "@GVar 0"], "@edit_gvar", 2, true, "@end-if"], "Merge"]);
                if (mode_vars[0] == 1) {
                    scripts.push([[0, "@if", "@GVar 2", "@edit_gvar", 1, ["@var_retain", "@GVar 1", "+", 1], "@edit_gvar", 2, false, "@edit_gvar", 0, ["@GVar 0", "@add_var", ["@GVar 0", "factorListB", "arr_elem", [0, "rand_int", ["@Parent -3", "arr_length", "-", 1]]], "/B", "@Var 0", "*B", ["@var_retain", "@Var 0", "*B", 2n, "+B", [0n, "rand_bigint", 1n, "*B", 2n, "-B", 1n], "@if", ["@var_retain", "@Var 0", "=", 1n], "2nd", 2n, "@end-if"]], "@end-if"], "EndTurn"])
                }
                else {
                    scripts.push([[0, "@if", "@GVar 2", "@edit_gvar", 1, ["@var_retain", "@GVar 1", "+", 1], "@edit_gvar", 2, false, "@edit_gvar", 0, [[2n, "^B", ["@GVar 1", "BigInt"], "*B", "@GVar 3"], "rand_bigint", [2n, "^B", ["@GVar 1", "+B", 1n], "*B", "@GVar 3", "-B", 1n]], "@end-if"], "EndTurn"])
                }
                let sBox = ["@Literal", ["@CalcArray", "@GVar 0"]];
                if (modifiers[13] != "None") sBox.push("arr_push", 1);
                if (modifiers[24]) sBox.push("arr_push", 1);
                statBoxes.push(["Current Goal", sBox, false, false, "Tile", "Self"], ["Goals Reached", "@GVar 1"]);
            }
        }
        else if (gamemode == 92) { // SCAPRIM
            if (mode_vars[0] > 0) {
                start_game_vars[3] = mode_vars[1];
                scripts.push([["@var_retain", 0, "@if", ["@var_retain", "@Var -1", "arr_elem", 0, "arr_elem", 0, "=", "@GVar 0"], "@edit_gvar", 2, true, "@end-if"], "Merge"]);
                scripts.push([[0, "@if", "@GVar 2", "@edit_gvar", 1, ["@var_retain", "@GVar 1", "+", 1], "@edit_gvar", 2, false, "@edit_gvar", 0, [[2n, "^B", ["@GVar 1", "BigInt"], "*B", "@GVar 3"], "rand_bigint", [2n, "^B", ["@GVar 1", "+B", 1n], "*B", "@GVar 3", "-B", 1n]], "@end-if"], "EndTurn"])
                let sBox = ["@Literal", ["@CalcArray", "@GVar 0"]];
                if (modifiers[24]) sBox.push("arr_push", 1);
                statBoxes.push(["Current Goal", sBox, false, false, "Tile", "Self"], ["Goals Reached", "@GVar 1"]);
            }
        }
        else if (gamemode == 93) { // TRIGAT
            if (mode_vars[0] > 0) {
                scripts.push([["@var_retain", 0, "@if", ["@var_retain", "@Var -1", "arr_elem", 0, "arr_elem", 0, "=", "@GVar 0"], "@edit_gvar", 2, true, "@end-if"], "Merge"]);
                if (mode_vars[0] == 1) {
                    scripts.push([["@global_var_retain_inner", ["@Literal"], 0, "@end_vars", 0, "@if", "@GVar 2", "@edit_gvar", 1, ["@GVar 1", "+", 1], "@edit_gvar", 2, false, "@repeat", ["@GVar 3", "arr_length", ">", "@Var 1"], "@if", ["@GVar 3", "arr_elem", "@Var 1", ">", "@GVar 0"], "@edit_var", 1, 1e300, "@end-if", "@else-if", ["@GVar 3", "arr_elem", "@Var 1", "^B", 2, "%B", ["@GVar 0", "*B", 2n, "-B", ["@GVar 3", "arr_elem", "@Var 1"]], "=", 0n], "@edit_var", 0, ["@Var 0", "arr_push", ["@GVar 3", "arr_elem", "@Var 1"]], "@end-else-if", "@edit_var", 1, ["@Var 1", "+", 1], "@end-repeat", "2nd", ["@GVar 0", "+B", ["@Var 0", "arr_elem", ["@Var 0", "arr_length", "-", 1, "rand_int", 0]]], "@edit_gvar", 0, "@Parent -1", "@edit_gvar", 3, ["@GVar 3", "arr_push", "@Parent -2"], "@end-if"], "EndTurn"])
                }
                else if (mode_vars[0] == 2) {
                    scripts.push([["@global_var_retain_inner", ["@Literal"], 0, "@end_vars", 0, "@if", "@GVar 2", "@edit_gvar", 1, ["@GVar 1", "+", 1], "@edit_gvar", 2, false, "@repeat", ["@GVar 3", "arr_length", ">", "@Var 1"], "@if", ["@GVar 3", "arr_elem", "@Var 1", ">", "@GVar 0"], "@edit_var", 1, 1e300, "@end-if", "@else-if", ["@GVar 3", "arr_elem", "@Var 1", "^B", 2, "%B", ["@GVar 0", "*B", 2n, "-B", ["@GVar 3", "arr_elem", "@Var 1"]], "=", 0n], "@edit_var", 0, ["@Var 0", "arr_push", ["@GVar 3", "arr_elem", "@Var 1", "+B", "@GVar 0"]], "@end-else-if", "@edit_var", 1, ["@Var 1", "+", 1], "@end-repeat", "@edit_gvar", 0, ["@Var 0", "arr_elem", ["@Var 0", "arr_length", "-", 1, "rand_int", 0]], "@edit_var", 1, 0, "@repeat", ["@Var 0", "arr_length", ">", "@Var 1"], "@if", ["@GVar 3", "arr_indexOf", ["@Var 0", "arr_elem", "@Var 1"], "=", -1], "@edit_gvar", 3, ["@GVar 3", "arr_binaryInsert", ["@Var 0", "arr_elem", "@Var 1"]], "@end-if", "@edit_var", 1, ["@Var 1", "+", 1], "@end-repeat", "@end-if"], "EndTurn"])
                }
                else {
                    scripts.push([["@global_var_retain_inner", ["@Literal"], 0, 0n, "@end_vars", 0, "@if", "@GVar 2", "@edit_gvar", 1, ["@GVar 1", "+", 1], "@edit_gvar", 2, false, "@edit_var", 2, ["@GVar 3", "arr_elem", ["@GVar 3", "arr_length", "-", 1, "rand_int", 0]], "@repeat", ["@Var 2", "<=", "@GVar 0"], "@edit_var", 1, 0, "@repeat", ["@GVar 3", "arr_length", ">", "@Var 1"], "@if", ["@GVar 3", "arr_elem", "@Var 1", ">", "@Var 2"], "@edit_var", 1, 1e300, "@end-if", "@else-if", ["@GVar 3", "arr_elem", "@Var 1", "^B", 2, "%B", ["@Var 2", "*B", 2n, "-B", ["@GVar 3", "arr_elem", "@Var 1"]], "=", 0n], "@edit_var", 0, ["@Var 0", "arr_push", ["@GVar 3", "arr_elem", "@Var 1", "+B", "@Var 2"]], "@end-else-if", "@edit_var", 1, ["@Var 1", "+", 1], "@end-repeat", "@edit_var", 2, ["@Var 0", "arr_elem", ["@Var 0", "arr_length", "-", 1, "rand_int", 0]], "@edit_var", 1, 0, "@repeat", ["@Var 0", "arr_length", ">", "@Var 1"], "@if", ["@GVar 3", "arr_indexOf", ["@Var 0", "arr_elem", "@Var 1"], "=", -1], "@edit_gvar", 3, ["@GVar 3", "arr_binaryInsert", ["@Var 0", "arr_elem", "@Var 1"]], "@end-if", "@edit_var", 1, ["@Var 1", "+", 1], "@end-repeat", "@edit_var", 0, ["@Literal"], "@end-repeat", "@edit_gvar", 0, "@Var 2", "@end-if"], "EndTurn"])
                }
                let sBox = ["@Literal", ["@CalcArray", "@GVar 0"], 0];
                if (modifiers[24]) sBox.push(1);
                statBoxes.push(["Current Goal", sBox, false, false, "Tile", "Self"], ["Goals Reached", "@GVar 1"]);
                start_game_vars[4] = mode_vars[1];
            }
        }
        else if (gamemode == 96) { // LOCEF
            if (mode_vars[1] > 0) {
                scripts.push([["@var_retain", 0, "@if", ["@var_retain", "@Var -1", "arr_elem", 0, "arr_elem", 0, "=", "@GVar 0"], "@edit_gvar", 2, true, "@end-if"], "Merge"]);
                if (mode_vars[1] == 1) {
                    scripts.push([["@global_var_retain_inner", ["@Literal"], 0, "@end_vars", 0, "@if", "@GVar 2", "@edit_gvar", 1, ["@GVar 1", "+", 1], "@edit_gvar", 2, false, "@repeat", ["@GVar 3", "arr_length", ">", "@Var 1"], "@if", ["@GVar 3", "arr_elem", "@Var 1", ">", "@GVar 0"], "@edit_var", 1, 1e300, "@end-if", "@else-if", ["@GVar 0", "%B", ["@GVar 3", "arr_elem", "@Var 1"], "=", 0n], "@edit_var", 0, ["@Var 0", "arr_push", ["@GVar 3", "arr_elem", "@Var 1"]], "@end-else-if", "@edit_var", 1, ["@Var 1", "+", 1], "@end-repeat", "2nd", ["@GVar 0", "*B", 2n, "+B", ["@Var 0", "arr_elem", ["@Var 0", "arr_length", "-", 1, "rand_int", 0]]], "@edit_gvar", 0, "@Parent -1", "@edit_gvar", 3, ["@GVar 3", "arr_push", "@Parent -2"], "@end-if"], "EndTurn"])
                }
                else if (mode_vars[1] == 2) {
                    scripts.push([["@global_var_retain_inner", ["@Literal"], 0, "@end_vars", 0, "@if", "@GVar 2", "@edit_gvar", 1, ["@GVar 1", "+", 1], "@edit_gvar", 2, false, "@repeat", ["@GVar 3", "arr_length", ">", "@Var 1"], "@if", ["@GVar 3", "arr_elem", "@Var 1", ">", "@GVar 0"], "@edit_var", 1, 1e300, "@end-if", "@else-if", ["@GVar 0", "%B", ["@GVar 3", "arr_elem", "@Var 1"], "=", 0n], "@edit_var", 0, ["@Var 0", "arr_push", ["@GVar 3", "arr_elem", "@Var 1", "+B", ["@GVar 0", "*B", 2n]]], "@end-else-if", "@edit_var", 1, ["@Var 1", "+", 1], "@end-repeat", "@edit_gvar", 0, ["@Var 0", "arr_elem", ["@Var 0", "arr_length", "-", 1, "rand_int", 0]], "@edit_var", 1, 0, "@repeat", ["@Var 0", "arr_length", ">", "@Var 1"], "@if", ["@GVar 3", "arr_indexOf", ["@Var 0", "arr_elem", "@Var 1"], "=", -1], "@edit_gvar", 3, ["@GVar 3", "arr_binaryInsert", ["@Var 0", "arr_elem", "@Var 1"]], "@end-if", "@edit_var", 1, ["@Var 1", "+", 1], "@end-repeat", "@end-if"], "EndTurn"])
                }
                else {
                    scripts.push([["@global_var_retain_inner", ["@Literal"], 0, 0n, "@end_vars", 0, "@if", "@GVar 2", "@edit_gvar", 1, ["@GVar 1", "+", 1], "@edit_gvar", 2, false, "@edit_var", 2, ["@GVar 3", "arr_elem", ["@GVar 3", "arr_length", "-", 1, "rand_int", 0]], "@repeat", ["@Var 2", "<=", "@GVar 0"], "@edit_var", 1, 0, "@repeat", ["@GVar 3", "arr_length", ">", "@Var 1"], "@if", ["@GVar 3", "arr_elem", "@Var 1", ">", "@Var 2"], "@edit_var", 1, 1e300, "@end-if", "@else-if", ["@Var 2", "%B", ["@GVar 3", "arr_elem", "@Var 1"], "=", 0n], "@edit_var", 0, ["@Var 0", "arr_push", ["@GVar 3", "arr_elem", "@Var 1", "+B", ["@Var 2", "*B", 2n]]], "@end-else-if", "@edit_var", 1, ["@Var 1", "+", 1], "@end-repeat", "@edit_var", 2, ["@Var 0", "arr_elem", ["@Var 0", "arr_length", "-", 1, "rand_int", 0]], "@edit_var", 1, 0, "@repeat", ["@Var 0", "arr_length", ">", "@Var 1"], "@if", ["@GVar 3", "arr_indexOf", ["@Var 0", "arr_elem", "@Var 1"], "=", -1], "@edit_gvar", 3, ["@GVar 3", "arr_binaryInsert", ["@Var 0", "arr_elem", "@Var 1"]], "@end-if", "@edit_var", 1, ["@Var 1", "+", 1], "@end-repeat", "@edit_var", 0, ["@Literal"], "@end-repeat", "@edit_gvar", 0, "@Var 2", "@end-if"], "EndTurn"])
                }
                let sBox = ["@Literal", ["@CalcArray", "@GVar 0"], 0];
                if (modifiers[24]) sBox.push(1);
                statBoxes.push(["Current Goal", sBox, false, false, "Tile", "Self"], ["Goals Reached", "@GVar 1"]);
                start_game_vars[4] = mode_vars[2];
            }
        }
        else if (gamemode == 50.1) { // Gaussian DIVE
            if (mode_vars[0] == 0) start_game_vars[0] = [new GaussianBigInt(1n, 1n)];
            else if (mode_vars[0] == 1) start_game_vars[0] = [new GaussianBigInt(1n, 1n), new GaussianBigInt(1n, -1n)];
            else if (mode_vars[0] == 2) start_game_vars[0] = [new GaussianBigInt(1n, 1n), new GaussianBigInt(1n, -1n), new GaussianBigInt(-1n, 1n), new GaussianBigInt(-1n, -1n)];
            else if (mode_vars[0] == 3) start_game_vars[0] = [new GaussianBigInt(1n, 0n), new GaussianBigInt(0n, 1n)];
            else if (mode_vars[0] == 4) start_game_vars[0] = [new GaussianBigInt(1n, 0n), new GaussianBigInt(0n, 1n), new GaussianBigInt(-1n, 0n), new GaussianBigInt(0n, -1n)];
            else if (mode_vars[0] == 5) start_game_vars[0] = [new GaussianBigInt(1n, 0n)];
            start_game_vars[1] = compendiumStructuredClone(start_game_vars[0]);
            scripts[0] = [["@var_retain", ["@var_retain", "@Var -1", "arr_elem", 0, "arr_elem", 0], "@end_vars", "@Var -1", "GaussianDIVESeedUnlock", "@GVar 0", mode_vars[4], mode_vars[2], "@if", [["@Parent -3", "normGB", ">", 1n], "&&", ["@GVar 2", "arr_indexOf", "@Parent -3", "=", -1]], "@edit_gvar", 2, ["@GVar 2", "arr_push", "@Parent -2"], "@end-if"], "Merge"];
            startTileSpawns = [[[["@GVar 0", "arr_elem", [0, "rand_bigint", ["@GVar 0", "arr_length", "-", 1]], "*GB", new GaussianBigInt(1n, 0n)]], mode_vars[3][0]], [[["@GVar 0", "arr_elem", [0, "rand_bigint", ["@GVar 0", "arr_length", "-", 1]], "*GB", new GaussianBigInt(0n, 1n)]], mode_vars[3][1]], [[["@GVar 0", "arr_elem", [0, "rand_bigint", ["@GVar 0", "arr_length", "-", 1]], "*GB", new GaussianBigInt(-1n, 0n)]], mode_vars[3][2]], [[["@GVar 0", "arr_elem", [0, "rand_bigint", ["@GVar 0", "arr_length", "-", 1]], "*GB", new GaussianBigInt(0n, -1n)]], mode_vars[3][3]]];
            start_game_vars[5] = modifiers[21];
            if (!mode_vars[1]) scripts = [scripts[0], scripts[2]];
        }
        randomTileAmount = modifiers[1];
        startTileAmount = modifiers[2];
        multiMerge = modifiers[3];
        spawnLocation = modifiers[4];
        if (modifiers[5] != "Custom") { //Adding directions based on the grid shape and available directions modifiers; if the Custom Grid is enabled, this is skipped so the directions you chose remain
            directions = [];
            if (modifiers[5] == "Checkerboard") {
                if (modifiers[10] == "Orthogonal" || modifiers[10] == "Both") {
                    directions.push([[-1, -1, modifiers[0], 0, [1, true, true, true]], "&#8592;", 5/33, 5/33, 3/33, 6/33, 6/33, ["KeyQ"], 45]);
                    directions.push([[-1, 1, modifiers[0], 0, [1, true, true, true]], "&#8593;", 5/33, 5/33, 3/33, 6/33, 22/33, ["KeyE"], 45]);
                    directions.push([[1, -1, modifiers[0], 0, [1, true, true, true]], "&#8595;", 5/33, 5/33, 3/33, 22/33, 6/33, ["KeyZ"], 45]);
                    directions.push([[1, 1, modifiers[0], 0, [1, true, true, true]], "&#8594;", 5/33, 5/33, 3/33, 22/33, 22/33, ["KeyC"], 45]);
                }
                if (modifiers[10] == "Diagonal" || modifiers[10] == "Both") {
                    directions.push([[-2, 0, modifiers[0], 0, [1, true, true, true]], "&#8593;&#8593;", 5/33, 5/33, 2.5/33, 6/33, 14/33, ["ArrowUp", "KeyW"], 0]);
                    directions.push([[2, 0, modifiers[0], 0, [1, true, true, true]], "&#8595;&#8595;", 5/33, 5/33, 2.5/33, 22/33, 14/33, ["ArrowDown", "KeyS", "KeyX"], 0]);
                    directions.push([[0, -2, modifiers[0], 0, [1, true, true, true]], "&#8592;&#8592;", 5/33, 5/33, 2.5/33, 14/33, 6/33, ["ArrowLeft", "KeyA"], 0]);
                    directions.push([[0, 2, modifiers[0], 0, [1, true, true, true]], "&#8594;&#8594;", 5/33, 5/33, 2.5/33, 14/33, 22/33, ["ArrowRight", "KeyD"], 0]);
                }
            }
            else if (modifiers[5] == "Hexagon" || modifiers[5] == "HexaTriangle") {
                if (modifiers[10] == "Orthogonal" || modifiers[10] == "Both") {
                    directions.push([[-1, -1, modifiers[0], 0, [1, true, true, true]], "&#8592;", 5/33, 5/33, 3/33, 6/33, 9/33, ["KeyQ"], 60]);
                    directions.push([[-1, 1, modifiers[0], 0, [1, true, true, true]], "&#8593;", 5/33, 5/33, 3/33, 6/33, 19/33, ["KeyW"], 30]);
                    directions.push([[1, -1, modifiers[0], 0, [1, true, true, true]], "&#8595;", 5/33, 5/33, 3/33, 22/33, 9/33, ["KeyZ"], 30]);
                    directions.push([[1, 1, modifiers[0], 0, [1, true, true, true]], "&#8594;", 5/33, 5/33, 3/33, 22/33, 19/33, ["KeyX"], 60]);
                    directions.push([[0, -2, modifiers[0], 0, [1, true, true, true]], "&#8592;", 5/33, 5/33, 3/33, 14/33, 4/33, ["KeyA"], 0]);
                    directions.push([[0, 2, modifiers[0], 0, [1, true, true, true]], "&#8594;", 5/33, 5/33, 3/33, 14/33, 24/33, ["KeyS"], 0]);
                }
                if (modifiers[10] == "Diagonal" || modifiers[10] == "Both") {
                    directions.push([[-2, 0, modifiers[0], 0, [1, true, true, true]], "&#8593;", 4/33, 4/33, 2.5/33, 0/33, 14/33, ["KeyO"], 0]);
                    directions.push([[2, 0, modifiers[0], 0, [1, true, true, true]], "&#8595;", 4/33, 4/33, 2.5/33, 28/33, 14/33, ["KeyK"], 0]);
                    directions.push([[-1, -3, modifiers[0], 0, [1, true, true, true]], "&#8592;", 4/33, 4/33, 2.5/33, 7/33, 2/33, ["KeyI"], 30]);
                    directions.push([[-1, 3, modifiers[0], 0, [1, true, true, true]], "&#8593;", 4/33, 4/33, 2.5/33, 7/33, 26/33, ["KeyP"], 60]);
                    directions.push([[1, -3, modifiers[0], 0, [1, true, true, true]], "&#8595;", 4/33, 4/33, 2.5/33, 21/33, 2/33, ["KeyJ"], 60]);
                    directions.push([[1, 3, modifiers[0], 0, [1, true, true, true]], "&#8594;", 4/33, 4/33, 2.5/33, 21/33, 26/33, ["KeyL"], 30]);
                }
            }
            else if (modifiers[5] == "4D") {
                if (modifiers[6] > 1) {
                    directions.push([[0, -1, modifiers[0], 0, [1, true, true, true]], "&#8592;", 4/33, 4/33, 2.5/33, 14.5/33, 8.5/33, ["ArrowLeft", "KeyA"], 0]);
                    directions.push([[0, 1, modifiers[0], 0, [1, true, true, true]], "&#8594;", 4/33, 4/33, 2.5/33, 14.5/33, 20.5/33, ["ArrowRight", "KeyD"], 0]);
                }
                if (modifiers[7] > 1) {
                    directions.push([[-1, 0, modifiers[0], 0, [1, true, true, true]], "&#8593;", 4/33, 4/33, 2.5/33, 8.5/33, 14.5/33, ["ArrowUp", "KeyW"], 0]);
                    directions.push([[1, 0, modifiers[0], 0, [1, true, true, true]], "&#8595;", 4/33, 4/33, 2.5/33, 20.5/33, 14.5/33, ["ArrowDown", "KeyS"], 0]);
                }
                if (modifiers[8] > 1) {
                    directions.push([[0, modifiers[6] * -1 - 1, modifiers[0], 0, [1, true, true, true]], "&#8592;&#8592;", 4/33, 4/33, 2/33, 14.5/33, 2.5/33, ["KeyJ"], 0]);
                    directions.push([[0, modifiers[6] + 1, modifiers[0], 0, [1, true, true, true]], "&#8594;&#8594;", 4/33, 4/33, 2/33, 14.5/33, 26.5/33, ["KeyL"], 0]);
                }
                if (modifiers[9] > 1) {
                    directions.push([[modifiers[7] * -1 - 1, 0, modifiers[0], 0, [1, true, true, true]], "&#8593;&#8593;", 4/33, 4/33, 2/33, 2.5/33, 14.5/33, ["KeyI"], 0]);
                    directions.push([[modifiers[7] + 1, 0, modifiers[0], 0, [1, true, true, true]], "&#8595;&#8595;", 4/33, 4/33, 2/33, 26.5/33, 14.5/33, ["KeyK"], 0]);
                }
            }
            else {
                if (modifiers[10] == "Orthogonal" || modifiers[10] == "Both") {
                    directions.push([[-1, 0, modifiers[0], 0, [1, true, true, true]], "&#8593;", 5/33, 5/33, 3/33, 6/33, 14/33, ["ArrowUp", "KeyW"], 0]);
                    directions.push([[1, 0, modifiers[0], 0, [1, true, true, true]], "&#8595;", 5/33, 5/33, 3/33, 22/33, 14/33, ["ArrowDown", "KeyS", "KeyX"], 0]);
                    directions.push([[0, -1, modifiers[0], 0, [1, true, true, true]], "&#8592;", 5/33, 5/33, 3/33, 14/33, 6/33, ["ArrowLeft", "KeyA"], 0]);
                    directions.push([[0, 1, modifiers[0], 0, [1, true, true, true]], "&#8594;", 5/33, 5/33, 3/33, 14/33, 22/33, ["ArrowRight", "KeyD"], 0]);
                }
                if (modifiers[10] == "Diagonal" || modifiers[10] == "Both") {
                    directions.push([[-1, -1, modifiers[0], 0, [1, true, true, true]], "&#8592;", 5/33, 5/33, 3/33, 6/33, 6/33, ["KeyQ"], 45]);
                    directions.push([[-1, 1, modifiers[0], 0, [1, true, true, true]], "&#8593;", 5/33, 5/33, 3/33, 6/33, 22/33, ["KeyE"], 45]);
                    directions.push([[1, -1, modifiers[0], 0, [1, true, true, true]], "&#8595;", 5/33, 5/33, 3/33, 22/33, 6/33, ["KeyZ"], 45]);
                    directions.push([[1, 1, modifiers[0], 0, [1, true, true, true]], "&#8594;", 5/33, 5/33, 3/33, 22/33, 22/33, ["KeyC"], 45]);
                }
            }
            if (modifiers[11]) {
                if (modifiers[5] == "4D") directions.push([[0, 0, 0, 0, [1, true, true, true]], "&#8226;", 4/33, 4/33, 2.5/33, 14.5/33, 14.5/33, ["Space"], 0]);
                else directions.push([[0, 0, 0, 0, [1, true, true, true]], "&#8226;", 5/33, 5/33, 3/33, 14/33, 14/33, ["Space"], 0]);
            }
        }
        if (gamemode == 99) { // Four-Sides 625, whose rules depend on the directions
            TileNumAmount = 2;
            let sideDirections = [];
            // Directions of movement
            for (let d of directions) {
                let currentDirection = d[0].slice(0, 2);
                if (currentDirection[0] != 0 || currentDirection[1] != 0) sideDirections.push(currentDirection);
            }
            // Combine identical directions and convert into angle and magnitude form for the graphics
            let sideAngles = [];
            for (let sd = 0; sd < sideDirections.length; sd++) {
                let index = indexOfPrimArray(sideDirections[sd], sideAngles.map(x => x.slice(0, 2)))
                if (index == -1) sideAngles.push(sideDirections[sd].concat([sd]));
                else sideAngles[index].push(sd);
            }
            for (let sa = 0; sa < sideAngles.length; sa++) {
                let angle = mod(Math.atan2(-sideAngles[sa][0] * (hexagonal ? Math.sqrt(3) : 1), sideAngles[sa][1]) * -180 / Math.PI - 90, 360);
                let magnitude = abs(gcd(sideAngles[sa][0], sideAngles[sa][1]));
                sideAngles[sa][0] = angle;
                sideAngles[sa][1] = magnitude;
            }
            // Sort each angle by its magnitudes
            let finalSideAngles = [];
            while (sideAngles.length > 0) {
                let angle = sideAngles[0][0];
                let matchingAngles = [];
                for (let sa = 0; sa < sideAngles.length; sa++) {
                    if (sideAngles[sa][0] == angle) {
                        matchingAngles.push(sideAngles.splice(sa, 1)[0]);
                        sa--;
                    }
                }
                let magnitudes = matchingAngles.map(x => x[1]).sort((a, b) => a - b);
                let coneWidth = 100 / magnitudes.length;
                for (let m of matchingAngles) {
                    index = magnitudes.indexOf(m[1]);
                    m.splice(1, 1, coneWidth * index, coneWidth * (index + 1));
                }
                finalSideAngles = finalSideAngles.concat(matchingAngles);
            }
            // Find the nearest two angles, so we know how big to make the cones
            let gap = 360; let angleDistance;
            for (let a = 1; a < finalSideAngles.length; a++) {
                for (let b = 0; b < a; b++) {
                    angleDistance = modularDistance(finalSideAngles[a][0], finalSideAngles[b][0], 360)
                    if (angleDistance > 0 && angleDistance < gap) gap = angleDistance;
                }
            }
            gap *= 2/3;
            // Gameplay stuff
            start_game_vars = [sideDirections.length + 1, sideDirections, finalSideAngles, 0]; // game_vars[0] is the base, game_vars[1] is a list of the directions (for gameplay), game_vars[2] is a list of the angles and magnitudes of the directions (for tile graphics), game_vars[3] helps with merges
            TileTypes = [
                [true, ["@GVar 0", "^", "@This 0", "*", ["@This 1", "arr_reduce", 1, ["+", "@Var -1"]]], ["@HSLA", [0, "@if", ["@This 0", "<", 12], "2nd", ["@Literal", 0, 0, 238, 57, 280, 74, 323, 140, 21, 187, 45, 218], "arr_elem", "@This 0", "@end-if", "@else", "2nd", [23.5, "*", "@This 0", "-", 212, "+", ["@This 0", "%", 2, "*", 156.5]], "@end-else"], [100, "@if", ["@This 0", ">=", 12], "2nd", [0.95, "^", ["@This 0", "-", 12], "*", 75], "@end-if", "@if", ["@This 0", "=", 0], "2nd", 0, "@end-if"], ["@This 1", "arr_reduce", 0, ["+", "@Var -1"], "/", ["@GVar 0", "-", 2], "*", -40, "+", 70], 1], ["#f4f7e9", "@if", ["@This 1", "arr_reduce", 0, ["+", "@Var -1"], "=", 0], "2nd", "#ffebe9", "@end-if"], "0px 0px 5px #000", 0, 0,
                    ["ExtraEntriesList", "@global_var_retain_inner", 0, "@end_vars", ["@Literal"], "@repeat", ["@Var 0", "<", ["@GVar 2", "arr_length"]], "arr_push", ["@Literal", "PrimeImage", ["@conic-gradient", ["@CalcArray", "@GVar 2", "arr_elem", "@Var 0", "arr_elem", 0, "-", (gap/2)], "#0000", 0, ["@HSLA", 0, 0, ["@CalcArray", "@GVar 2", "arr_elem", "@Var 0", "arr_slice", 3, Infinity, "arr_reduce", 0, ["+", ["@var_retain", "@This 1", "arr_elem", "@Var -1"]], "/", ["@GVar 2", "arr_elem", "@Var 0", "arr_length", "-", 3], "*", 100], 0.75], gap * 1/3, gap * 2/3, "#0000", gap], ["@radial-gradient", "#0000", 0, ["@CalcArray", "@GVar 2", "arr_elem", "@Var 0", "arr_elem", 1], "#000", ["@CalcArray", "@GVar 2", "arr_elem", "@Var 0", "arr_elem", 1], ["@CalcArray", "@GVar 2", "arr_elem", "@Var 0", "arr_elem", 2], "#0000", ["@CalcArray", "@GVar 2", "arr_elem", "@Var 0", "arr_elem", 2]]], "@edit_var", 0, ["@Var 0", "+", 1], "@end-repeat"]]
            ];
            MergeRules = [
                [2, [["@This 0", "=", "@Next 1 0"], "&&", ["@This 1", "arr_reduce", 0, ["+", "@Var -1"], "=", 0], "&&", ["@Next 1 1", "arr_reduce", 0, ["+", "@Var -1"], "=", ["@GVar 0", "-", 2]], "&&", ["@VDir", "=", ["@GVar 1", "arr_elem", ["@Next 1 1", "arr_indexOf", false], "arr_elem", 0]], "&&", ["@HDir", "=", ["@GVar 1", "arr_elem", ["@Next 1 1", "arr_indexOf", false], "arr_elem", 1]]], true, [[["@Next 1 0", "+", 1], [["@Literal"], "@repeat", ["@GVar 0", "-", 1], "arr_push", false, "@end-repeat"]]], ["@GVar 0", "^", ["@Next 1 0", "+", 1]], [false, true]],
                [2, [["@This 0", "=", "@Next 1 0"], "&&", ["@Next 1 1", "arr_reduce", 0, ["+", "@Var -1"], "=", 0], "&&", ["@This 1", "arr_reduce", 0, ["+", "@Var -1"], "=", ["@GVar 0", "-", 2]], "&&", ["@VDir", "*", -1, "=", ["@GVar 1", "arr_elem", ["@This 1", "arr_indexOf", false], "arr_elem", 0]], "&&", ["@HDir", "*", -1, "=", ["@GVar 1", "arr_elem", ["@This 1", "arr_indexOf", false], "arr_elem", 1]]], true, [[["@This 0", "+", 1], [["@Literal"], "@repeat", ["@GVar 0", "-", 1], "arr_push", false, "@end-repeat"]]], ["@GVar 0", "^", ["@This 0", "+", 1]], [false, true]],
                [2, [false, "@if", [["@This 0", "=", "@Next 1 0"], "&&", ["@This 1", "arr_reduce", 0, ["+", "@Var -1"], "=", 0]], "@edit_gvar", 3, -1, "@repeat", ["@Parent -2", "!", "&&", ["@GVar 3", "<", ["@GVar 0", "-", 2]]], "@edit_gvar", 3, ["@GVar 3", "+", 1], "2nd", [["@Next 1 1", "arr_elem", "@GVar 3", "!"], "&&", ["@VDir", "=", ["@GVar 1", "arr_elem", "@GVar 3", "arr_elem", 0]], "&&", ["@HDir", "=", ["@GVar 1", "arr_elem", "@GVar 3", "arr_elem", 1]]], "@end-repeat", "@end-if"], true, [["@Next 1 0", ["@Next 1 1", "arr_edit_elem", "@GVar 3", true]]], ["@GVar 0", "^", "@Next 1 0", "*", ["@Next 1 1", "arr_reduce", 2, ["+", "@Var -1"]]], [false, true]],
                [2, [false, "@if", [["@This 0", "=", "@Next 1 0"], "&&", ["@Next 1 1", "arr_reduce", 0, ["+", "@Var -1"], "=", 0]], "@edit_gvar", 3, -1, "@repeat", ["@Parent -2", "!", "&&", ["@GVar 3", "<", ["@GVar 0", "-", 2]]], "@edit_gvar", 3, ["@GVar 3", "+", 1], "2nd", [["@This 1", "arr_elem", "@GVar 3", "!"], "&&", ["@VDir", "*", -1, "=", ["@GVar 1", "arr_elem", "@GVar 3", "arr_elem", 0]], "&&", ["@HDir", "*", -1, "=", ["@GVar 1", "arr_elem", "@GVar 3", "arr_elem", 1]]], "@end-repeat", "@end-if"], true, [["@This 0", ["@This 1", "arr_edit_elem", "@GVar 3", true]]], ["@GVar 0", "^", "@This 0", "*", ["@This 1", "arr_reduce", 2, ["+", "@Var -1"]]], [false, true]]
            ];
            let start1falses = ["@Literal"].concat(Array(start_game_vars[0] - 1).fill(false));
            startTileSpawns = [[[0, start1falses], 1]];
        }
        if (modifiers[15] == "Simple" && gamemode != 14 && (gamemode != 37 || mode_vars[0] != 1) && gamemode != 40 && gamemode != 43 && gamemode != 50 && gamemode != 58 && gamemode != 59 && gamemode != 69 && gamemode != 70 && gamemode != 71 && gamemode != 80 && gamemode != 81 && gamemode != 82 && gamemode != 97 && gamemode != 50.1 && gamemode != 37.71 && gamemode != 71.37 && gamemode != -1) { // 2049, Wildcard 2048, 2216.838, 1321, DIVE, 10, 1825, (232, 240), 16+16i, 3,188,646, 1429, 2058, 1716, Pro-Add-Uct, Gaussian DIVE, 839,808, and 145.965 ignore the simple spawns: 2049, 10, 1825, and 1429 need both 1s and -1s, 16+16i needs all four quadrants, 2216.838, 1321, 3,188,646, 839,808, and 145.965 have special tiles that make them work (2s, +1s, s, 2s, and s respectively), simple spawns would reduce (232, 240) and Pro-Add-Uct to a single dimension, 2058 and 1716 would never end if they only spawned 1s, the different spawning tiles are a fundamental part of DIVE and Gaussian DIVE, and simple spawns would defeat the whole point of Wildcard 2048. We also can't trust that simple spawns wouldn't break a Custom Mode.
            if (gamemode == 30) startTileSpawns = [["Box", 20, [-1], 4, [-2], 4]];
            else if (gamemode == 47) startTileSpawns = [["Box", 1, [1, -1], 3, [1, 1], 3]];
            else {
                if (modifiers[13] != "None" && (gamemode == 31 || (gamemode == 38 && mode_vars[0] != 0) || gamemode == 41 || gamemode == 44 || gamemode == 49)) startTileSpawns = startTileSpawns.slice(0, 2);
                else startTileSpawns = [startTileSpawns[0]];
            }
        }
        else if (modifiers[15] == "Equal" && gamemode != 29 && gamemode != 30 && gamemode != 47 && gamemode != -1) { //1535 1536 1537, 3072, and 1093 1094 ignore the equal spawns; honestly I don't remember why 1535 1536 1537 and 1093 1094 do, but 3072 ignores it so the bonus tiles aren't messed up, as their probability changes depending on whether you've unlocked them or not. We also can't trust that equal spawns wouldn't break a Custom Mode.
            for (let t = 0; t < startTileSpawns.length; t++) {
                startTileSpawns[t][1] = 1;
            }
        }
        if (modifiers[19] > 1) {
            spawnConditions = ["@Moves", "+", 1, "%", modifiers[19], "=", 0];
            if (indexOfNestedPrimArray("@Moves", statBoxes) == -1) statBoxes.push(["Moves", "@Moves"]);
        }
        else spawnConditions = true;
        if (modifiers[20]) {
            let mnum = start_modifier_vars.length;
            start_modifier_vars.push([0, 0, 0]);
            scripts.push([[["@VDir", "arr_push", "@HDir", "arr_push", "@SlideAmount"], "@end_vars", 0, "@edit_mvar", mnum, ["@var_retain", "@Var 0", "@if", ["@var_retain", "@Var 0", "=", ("@MVar " + mnum)], "2nd", ["@Literal", 0, 0, 0], "@end-if"]], "EndTurn"]);
            for (let m = 0; m < MergeRules.length; m++) {
                let mstart = 0;
                if (MergeRules[m][0] === "@include_gvars") mstart = 1;
                if ((MergeRules[m]).indexOf("@end_vars") > -1) mstart = (MergeRules[m]).indexOf("@end_vars") + 1;
                MergeRules[m][mstart + 1].push("&&", [["@VDir", "arr_push", "@HDir", "arr_push", "@SlideAmount"], "=", ("@MVar " + mnum)]);
            }
        }
        hiddenTileText = modifiers[21];
    }
    let exrule = 0;
    while (exrule < MergeRules.length) { //This script expands the multi-length merge rules into several single-length merge rules. This was originally in StartGame, but I had to move it here so it would come after XXXX's merge length but before black boxes
        let exm = compendiumStructuredClone(MergeRules[exrule]);
        let vars = [];
        if (exm[0] === "@var_retain" || exm[0] == "@var_copy") {
            vars.push(exm[0]);
            exm.shift();
        }
        if (exm[0] === "@include_gvars") {
            vars.push(exm[0]);
            exm.shift();
        }
        if (exm.indexOf("@end_vars") > -1) {
            let newvars = exm.slice(0, exm.indexOf("@end_vars"));
            vars = vars.concat(newvars);
            exm.splice(0, exm.indexOf("@end_vars") + 1);
        }
        if (exm[0] == 0) break;
        if (exm.length > 9 && exm[9] > exm[0]) {
            let arbrule = exm;
            let length = exm[6];
            let maxlength = exm[9];
            let iterations = 0;
            while (length <= maxlength) {
                let crule = compendiumStructuredClone(arbrule);
                crule[0] = length;
                crule[9] = length;
                crule = evaluateMergeRule(crule);
                if (length >= exm[0]) {
                    iterations++;
                    if (vars.length > 0) MergeRules.splice(exrule + 1, 0, vars.concat("@end_vars", crule));
                    else MergeRules.splice(exrule + 1, 0, crule);
                }
                length += crule[8];
            }
            MergeRules.splice(exrule, 1);
            exrule += iterations;
        }
        else exrule++;
    }
    if (gamemode != 0) {
        let validMergeModifiers = ["@MergeReverseStart", "@MergeOverflowEmpty", "@MergeOverflowSlot", "@MergeOverflowOverwrite"];
        if (modifiers[13] != "None" && gamemode != 14 && gamemode != 31 && (gamemode != 38 || mode_vars[0] == 0) && gamemode != 40 && gamemode != 41 && gamemode != 43 && gamemode != 44 && gamemode != 49 && gamemode != 50 && gamemode != 58 && gamemode != 59 && gamemode != 60 && !(gamemode >= 69 && gamemode <= 75 && gamemode != 72) && gamemode != 80 && gamemode != 86 && gamemode != 88 && gamemode != 89 && gamemode != 92 && gamemode != 93 && gamemode != 96 && gamemode != 97 && gamemode != 50.1 && gamemode != 34.39 && (gamemode != -1 || !mode_vars[0])) { // 2049, Isotopic 256, 180 (with prime merges or all merges), Wildcard 2048, X^Y, 1321, mod 27, 378, DIVE, 10, 1825, 2295, (232, 240), 16+16i, 3,188,646, SQUART, Turatin, 3307, 1429, Bitwise 2048, FACTUP, 2496, SCAPRIM, TRIGAT, LOCEF, Pro-Add-Uct, Gaussian DIVE, and Partial Absorb 19,683 all do special things with negative tiles, and some Custom Modes already have negative tiles, but this script is what adds the negative tiles to the rest of the modes
            TileNumAmount++;
            let neganum = TileNumAmount - 1;
            let positiveTiles = [];
            let negativeTiles = [];
            let signlessTiles = [];
            if (gamemode == 61) { // 3069, 1845, and 3385 behave like most other modes with negatives, but they need special consideration for their graphics because they use special color schemes
                TileTypes = [
                    [true, ["@This 0", "arr_reduce", 1n, ["*B", ["@var_retain", "@Var -1", "prime"]], "*B", "@This 1"], "@ColorScheme", (mode_vars[2] ? "Odds-Only 3069" : "3069"), [["@This 0", "arr_reduce", 1n, ["*B", ["@var_retain", "@Var -1", "prime"]], "*B", "@This 1"]]]
                ];
            }
            else if (gamemode == 91) {
                TileTypes = [
                    [true, ["@This 0", "*B", "@This 1"], "@ColorScheme", "1845", [["@This 0", "*B", "@This 1"]]]
                ];
            }
            else if (gamemode == 95) {
                TileTypes = [
                    [true, ["@This 0", "*B", "@This 1"], "@ColorScheme", "3385", [["@This 0", "*B", "@This 1"]]]
                ];
            }
            else {
                for (let t = 0; t < TileTypes.length - signlessTiles.length; t++) {
                    let startindex = 0;
                    if (TileTypes[t + signlessTiles.length][startindex] === "@include_gvars") startindex = 1;
                    if (TileTypes[t + signlessTiles.length].indexOf("@end_vars") > -1) startindex = TileTypes[t + signlessTiles.length].indexOf("@end_vars") + 1;
                    if (Array.isArray(TileTypes[t + signlessTiles.length][startindex]) && indexOfNestedPrimArray("@Signless", TileTypes[t + signlessTiles.length][startindex]) != -1) {
                        signlessTiles.push(compendiumStructuredClone(TileTypes[t + signlessTiles.length]));
                        signlessTiles[signlessTiles.length - 1][startindex].push(0);
                        t--;
                        continue;
                    }
                    positiveTiles.push(compendiumStructuredClone(TileTypes[t + signlessTiles.length]));
                    negativeTiles.push(compendiumStructuredClone(TileTypes[t + signlessTiles.length]));
                    if (eqPrimArrays(arrayTypes(TileTypes[t + signlessTiles.length][startindex]), ["number"]) || eqPrimArrays(arrayTypes(TileTypes[t + signlessTiles.length][startindex]), ["bigint"]) || eqRearrangeArrays(arrayTypes(TileTypes[t + signlessTiles.length][startindex]), ["number", "bigint"])) {
                        positiveTiles[t][startindex].push(1);
                        negativeTiles[t][startindex].push(-1);
                    }
                    else if (TileTypes[t + signlessTiles.length][startindex] === true) {
                        positiveTiles[t][startindex] = ["@This " + neganum, "=", 1];
                        negativeTiles[t][startindex] = ["@This " + neganum, "=", -1];
                    }
                    else {
                        positiveTiles[t][startindex].push("&&", ["@This " + neganum, "=", 1]);
                        negativeTiles[t][startindex].push("&&", ["@This " + neganum, "=", -1]);
                    }
                    if (typeof negativeTiles[t][startindex + 1] == "number") negativeTiles[t][startindex + 1] *= -1;
                    else if (typeof negativeTiles[t][startindex + 1] == "bigint") negativeTiles[t][startindex + 1] *= -1n;
                    else if (typeof negativeTiles[t][startindex + 1] == "string") negativeTiles[t][startindex + 1] = "-" + negativeTiles[t][startindex + 1];
                    else if (typeof negativeTiles[t][startindex + 1] instanceof BigRational) negativeTiles[t][startindex + 1]  = negativeTiles[t][startindex + 1].neg();
                    else if (Array.isArray(negativeTiles[t][startindex + 1]) && negativeTiles[t][startindex + 1].indexOf("@no-negative-sign") == -1) negativeTiles[t][startindex + 1] = [negativeTiles[t][startindex + 1], "defaultAbbrevAny", "str_concat_front", "-"];
                    negativeTiles[t][2] = ["@rotate", 180, true, negativeTiles[t][startindex + 2]];
                    negativeTiles[t][3] = ["@rotate", 180, true, negativeTiles[t][startindex + 3]];
                }
                TileTypes = signlessTiles.concat(positiveTiles, negativeTiles);
            }
            let signlessSpawns = [];
            for (let s = 0; s < startTileSpawns.length; s++) {
                if (Array.isArray(startTileSpawns[s][0]) && indexOfNestedPrimArray("@Signless", startTileSpawns[s][0]) != -1) {
                    signlessSpawns.push(compendiumStructuredClone(startTileSpawns[s]));
                    signlessSpawns[signlessSpawns.length - 1][0].push(0);
                    startTileSpawns.splice(s, 1);
                    if (typeof signlessSpawns[signlessSpawns.length - 1][1] == "number") signlessSpawns[signlessSpawns.length - 1][1] *= 2;
                    else if (Array.isArray(signlessSpawns[signlessSpawns.length - 1][1])) signlessSpawns[signlessSpawns.length - 1][1] = [signlessSpawns[signlessSpawns.length - 1][1], "*", 2];
                    s--;
                }
            }
            let positiveSpawns = compendiumStructuredClone(startTileSpawns);
            let negativeSpawns = compendiumStructuredClone(startTileSpawns);
            for (let i = 0; i < startTileSpawns.length; i++) {
                for (let j = 0; j < startTileSpawns[i].length; j++) {
                    if (j == 1) {
                        if (Array.isArray(startTileSpawns[i][j])) {
                            positiveSpawns[i][1].push("*", modifiers[22]);
                            negativeSpawns[i][1].push("*", modifiers[23]);
                        }
                        else {
                            positiveSpawns[i][1] *= modifiers[22];
                            negativeSpawns[i][1] *= modifiers[23];
                        }
                    }
                    else if (Array.isArray(startTileSpawns[i][j])) {
                        if (startTileSpawns[i][j][0] == "@CalcArray") {
                            positiveSpawns[i][j].push("arr_push", 1);
                            negativeSpawns[i][j].push("arr_push", -1);
                        }
                        else {
                            positiveSpawns[i][j].push(1);
                            negativeSpawns[i][j].push(-1);
                        }
                    }
                }
            }
            startTileSpawns = signlessSpawns.concat(positiveSpawns, negativeSpawns);
            if (typeof winRequirement == "number") winRequirement *= 2;
            let wlength = winConditions.length;
            for (let w = 0; w < wlength; w++) {
                if (Array.isArray(winConditions[w]) && (eqPrimArrays(arrayTypes(winConditions[w]), ["number"]) || eqPrimArrays(arrayTypes(winConditions[w]), ["bigint"]))) {
                    winConditions.push(compendiumStructuredClone(winConditions[w]));
                    winConditions[winConditions.length - 1].push(-1);
                    winConditions[w].push(1);
                }
            }
            if (!(gamemode == 72 && mode_vars[0] && modifiers[13] == "Interacting")) { // 3026 with all merges has special negatives behavior, but only the merge behavior is special, not the display behavior
                for (let m = 0; m < MergeRules.length; m++) {
                    let mstart = 0;
                    if (MergeRules[m][0] === "@include_gvars") mstart = 1;
                    if ((MergeRules[m]).indexOf("@end_vars") > -1) mstart = (MergeRules[m]).indexOf("@end_vars") + 1;
                    let addInfo = MergeRules[m][mstart];
                    if (MergeRules[m].length > 6) addInfo = MergeRules[m][mstart + 6];
                    if (signlessTiles.length == 0) {
                        for (let i = 1; i < addInfo; i++) MergeRules[m][mstart + 1].push("&&", ["@Next " + i + " " + neganum, "=", "@This " + neganum]);
                        if (eqPrimArrays(MergeRules[m][mstart + 1][0], ["@NextNE -1 0", "!=", "@This 0"])) MergeRules[m][mstart + 1].unshift(["@NextNE -1 " + neganum, "!=", "@This " + neganum], "||");
                        for (let r = 0; r < MergeRules[m][mstart + 3].length; r++) if (validMergeModifiers.indexOf(MergeRules[m][mstart + 3][r]) == -1) MergeRules[m][mstart + 3][r].push("@This " + neganum);
                    }
                    else {
                        let negadetector = ["@This " + neganum, "@if", ["@Parent -2", "=", 0], "2nd", "@Next", "arr_reduce", 0, ["@if", ["@var_retain", "@Var -1", "arr_elem", neganum, "!=", 0, "&&", ["@Parent -3", "=", 0]], "2nd", "@Var -1", "arr_elem", neganum, "@end-if"], "@end-if"];
                        for (let i = 1; i < addInfo; i++) MergeRules[m][mstart + 1].push("&&", [["@Next " + i + " " + neganum, "=", negadetector, "||", ["@Next " + i + " " + neganum, "=", 0]]]);
                        if (eqPrimArrays(MergeRules[m][mstart + 1][0], ["@NextNE -1 0", "!=", "@This 0"])) MergeRules[m][mstart + 1].unshift(["@NextNE -1 " + neganum, "!=", negadetector, "&&", ["@Next " + i + " " + neganum, "!=", 0]], "||");
                        for (let r = 0; r < MergeRules[m][mstart + 3].length; r++) if (validMergeModifiers.indexOf(MergeRules[m][mstart + 3][r]) == -1) MergeRules[m][mstart + 3][r].push(negadetector);
                    }
                }
                if (modifiers[13] == "Interacting") {
                    let annihilate_reqs = [["@Next 1 0", "=", "@This 0"]];
                    for (let i = 1; i < neganum; i++) {
                        annihilate_reqs.push("&&", ["@Next 1 " + i, "=", "@This " + i]);
                    }
                    if (signlessTiles.length == 0) {
                        annihilate_reqs.push("&&", ["@Next 1 " + neganum, "!=", "@This " + neganum]);
                    }
                    else {
                        annihilate_reqs.push("&&", ["@Next 1 " + neganum, "!=", "@This " + neganum], "&&", ["@This " + neganum, "!=", 0], "&&", ["@Next 1 " + neganum, "!=", 0]);
                    }
                    MergeRules.unshift([2, annihilate_reqs, true, [], 0, [true, true]]);
                }
            }
            if (gamemode == 26) { // 2584 has some special merge rules with negatives, but not special display rules
                if (mode_vars[0] == 1) MergeRules.push([2, [["@This 0", "-", 1, "=", "@Next 1 0"], "&&", ["@This 1", "!=", "@Next 1 1"]], false, [[["@This 0", "-", 2, "max", 0], "@This 1"]], [[((1 + Math.sqrt(5))/2), "^", "@This 0"], "-", [((1 + Math.sqrt(5))/-2), "^", ["@This 0", "*", -1]], "/", Math.sqrt(5), "round", 1], [false, true]]);
                else if (mode_vars[0] == 2) MergeRules.push([2, [["@This 0", "-", "@Next 1 0", "abs", "=", 1], "&&", ["@This 1", "=", 1], "&&", ["@Next 1 1", "=", -1], "&&", ["@This 0", "%", 2, "=", 1], "&&", ["@Next 1 0", "%", 2, "=", 0]], false, [[["@This 0", "-", 2, "max", 0], "@This 1"]], [[((1 + Math.sqrt(5))/2), "^", "@This 0"], "-", [((1 + Math.sqrt(5))/-2), "^", ["@This 0", "*", -1]], "/", Math.sqrt(5), "round", 1], [false, true]])
            }
        }
        if (modifiers[24]) {
            let threecolormodes = [1, 2, 4, 7, 16, 17, 26, 27, 29, 40, 43, 45, 47, 51, 53, 54, 59, 60, 61, 66, 67, 69, 70, 72, 73, 74, 78, 81, 82, 83, 84, 85, 86, 87, 88, 89, 91, 92, 93, 95, 97, 99];
            let fourcolormodes = [12, 18, 33, 56, 63, 68, 80, 90, 96];
            // let fourcolormodes_colorless1s = [13, 24, 28, 46, 52];
            // let specialcases = [14, 30, 31, 37, 50, 57, 58];
            if (threecolormodes.includes(gamemode) || fourcolormodes.includes(gamemode) || (gamemode == -1 && mode_vars[1] != 0) || (gamemode == 100 && (mode_vars[0] == 0))) {
                let yellowIncluded = fourcolormodes.includes(gamemode) || (gamemode == -1 && mode_vars[1] == 2) || (gamemode == 61 && mode_vars[2]);
                TileNumAmount++;
                let colornum = TileNumAmount - 1;
                let redTiles = [];
                let blueTiles = [];
                let greenTiles = [];
                let yellowTiles = [];
                for (let t = 0; t < TileTypes.length; t++) {
                    redTiles.push(compendiumStructuredClone(TileTypes[t]));
                    blueTiles.push(compendiumStructuredClone(TileTypes[t]));
                    greenTiles.push(compendiumStructuredClone(TileTypes[t]));
                    if (yellowIncluded) yellowTiles.push(compendiumStructuredClone(TileTypes[t]));
                    let startindex = 0;
                    if (TileTypes[t][startindex] === "@include_gvars") startindex = 1;
                    if (TileTypes[t].indexOf("@end_vars") > -1) startindex = TileTypes[t].indexOf("@end_vars") + 1;
                    if (eqPrimArrays(arrayTypes(TileTypes[t][startindex]), ["number"]) || eqPrimArrays(arrayTypes(TileTypes[t][startindex]), ["bigint"]) || eqRearrangeArrays(arrayTypes(TileTypes[t][startindex]), ["number", "bigint"])) {
                        redTiles[t][startindex].push(0);
                        blueTiles[t][startindex].push(1);
                        greenTiles[t][startindex].push(2);
                        if (yellowIncluded) yellowTiles[t][startindex].push(3);
                    }
                    else if (TileTypes[t][startindex] === true) {
                        redTiles[t][startindex] = ["@This " + colornum, "=", 0];
                        blueTiles[t][startindex] = ["@This " + colornum, "=", 1];
                        greenTiles[t][startindex] = ["@This " + colornum, "=", 2];
                        if (yellowIncluded) yellowTiles[t][startindex] = ["@This " + colornum, "=", 3];
                    }
                    else {
                        redTiles[t][startindex].push("&&", ["@This " + colornum, "=", 0]);
                        blueTiles[t][startindex].push("&&", ["@This " + colornum, "=", 1]);
                        greenTiles[t][startindex].push("&&", ["@This " + colornum, "=", 2]);
                        if (yellowIncluded) yellowTiles[t][startindex].push("&&", ["@This " + colornum, "=", 3]);
                    }
                    while (redTiles[t].length < startindex + 7) redTiles[t].push(undefined);
                    redTiles[t].push(["PrimeImage", ["@radial-gradient", "#0000", 0, 37.5, "#c008", "#f008", "#c008", "#0000", 62.5, 100]]);
                    while (blueTiles[t].length < startindex + 7) blueTiles[t].push(undefined);
                    blueTiles[t].push(["PrimeImage", ["@radial-gradient", "#0000", 0, 37.5, "#00c8", "#00f8", "#00c8", "#0000", 62.5, 100]]);
                    while (greenTiles[t].length < startindex + 7) greenTiles[t].push(undefined);
                    greenTiles[t].push(["PrimeImage", ["@radial-gradient", "#0000", 0, 37.5, "#0c08", "#0f08", "#0c08", "#0000", 62.5, 100]]);
                    if (yellowIncluded) {
                        while (yellowTiles[t].length < 7) yellowTiles[t].push(undefined);
                        yellowTiles[t].push(["PrimeImage", ["@radial-gradient", "#0000", 0, 37.5, "#cc08", "#ff08", "#cc08", "#0000", 62.5, 100]]);
                    }
                }
                TileTypes = redTiles.concat(blueTiles, greenTiles, yellowTiles);
                for (let i = 0; i < startTileSpawns.length; i++) {
                    if (startTileSpawns[i][0] == "Box") {
                        let chance = startTileSpawns[i][1];
                        let newSpawn = ["Box", chance];
                        for (let e = 2; e < startTileSpawns[i].length; e++) {
                            let tile = startTileSpawns[i][e];
                            if (typeof startTileSpawns[i][e + 1] == "number") {
                                let amount = startTileSpawns[i][e + 1];
                                newSpawn.push([...tile, 0], amount, [...tile, 1], amount, [...tile, 2], amount);
                                if (yellowIncluded) newSpawn.push([...tile, 3], amount);
                                e++;
                            }
                            else {
                                newSpawn.push([...tile, 0], [...tile, 1], [...tile, 2]);
                                if (yellowIncluded) newSpawn.push([...tile, 3]);
                            }
                        }
                        startTileSpawns[i] = newSpawn;
                    }
                    else {
                        let tile = startTileSpawns[i][0];
                        let chance = startTileSpawns[i][1];
                        let newSpawn = ["Box", chance];
                        newSpawn.push([...tile, 0], 1, [...tile, 1], 1, [...tile, 2], 1);
                        if (yellowIncluded) newSpawn.push([...tile, 3], 1);
                        startTileSpawns[i] = newSpawn;
                    }
                }
                let wlength = winConditions.length;
                for (let w = 0; w < wlength; w++) {
                    if (Array.isArray(winConditions[w]) && (eqPrimArrays(arrayTypes(winConditions[w]), ["number"]) || eqPrimArrays(arrayTypes(winConditions[w]), ["bigint"]) || eqPrimArrays(arrayTypes(winConditions[w]), ["number", "bigint"]))) {
                        winConditions.push(compendiumStructuredClone(winConditions[w]));
                        winConditions.push(compendiumStructuredClone(winConditions[w]));
                        if (yellowIncluded) winConditions.push(compendiumStructuredClone(winConditions[w]));
                        winConditions[winConditions.length - 1].push(2);
                        winConditions[winConditions.length - 2].push(1);
                        if (yellowIncluded) winConditions[winConditions.length - 3].push(3);
                        winConditions[w].push(0);
                    }
                }
                for (let m = 0; m < MergeRules.length; m++) {
                    let mstart = 0;
                    if (MergeRules[m][0] === "@include_gvars") mstart = 1;
                    if ((MergeRules[m]).indexOf("@end_vars") > -1) mstart = (MergeRules[m]).indexOf("@end_vars") + 1;
                    if (MergeRules[m].length > 6) addInfo = MergeRules[m][mstart + 6];
                    if (yellowIncluded && (MergeRules[m][mstart] === 3)) {
                        MergeRules[m][mstart + 1].push("&&", ["@Next 1 " + colornum, "!=", "@This " + colornum], "&&", ["@Next 2 " + colornum, "!=", "@This " + colornum], "&&", ["@Next 2 " + colornum, "!=", "@Next 1 " + colornum]);
                        if (eqPrimArrays(MergeRules[m][mstart + 1][0], ["@NextNE -1 0", "!=", "@This 0"])) MergeRules[m][mstart + 1].unshift(["@NextNE -1 " + colornum, "==", "@This " + colornum], "||", ["@NextNE -1 " + colornum, "==", "@Next 1 " + colornum], "||", ["@NextNE -1 " + colornum, "==", "@Next 2 " + colornum], "||");
                        for (let r = 0; r < MergeRules[m][mstart + 3].length; r++) if (validMergeModifiers.indexOf(MergeRules[m][mstart + 3][r]) == -1) MergeRules[m][mstart + 3][r].push([6, "-", ("@This " + colornum), "-", ("@Next 1 " + colornum), "-", ("@Next 2 " + colornum)]);
                    }
                    else {
                        MergeRules[m][mstart + 1].push("&&", ["@Next 1 " + colornum, "!=", "@This " + colornum]);
                        if (eqPrimArrays(MergeRules[m][mstart + 1][0], ["@NextNE -1 0", "!=", "@This 0"])) MergeRules[m][mstart + 1].unshift(["@NextNE -1 " + colornum, "==", "@This " + colornum], "||", ["@NextNE -1 " + colornum, "==", "@Next 1 " + colornum], "||");
                        for (let r = 0; r < MergeRules[m][mstart + 3].length; r++) if (validMergeModifiers.indexOf(MergeRules[m][mstart + 3][r]) == -1) MergeRules[m][mstart + 3][r].push([3, "-", ("@This " + colornum), "-", ("@Next 1 " + colornum)]);
                    }
                }
            }
        }
        if (modifiers[12]) {
            let ZArray = ["Zero"];
            for (let i = 1; i < TileNumAmount; i++) ZArray.push(0);
            if (gamemode == 44) ZArray[0] = 0; // mod 27 already has 0 tiles, so the modifier co-opts those to use as the Garbage 0s
            else TileTypes.unshift([ZArray, "0", "#444444", "#888888"]);
            for (let m = 0; m < MergeRules.length; m++) {
                let mstart = 0;
                if (MergeRules[m][0] === "@include_gvars") mstart = 1;
                if ((MergeRules[m]).indexOf("@end_vars") > -1) mstart = (MergeRules[m]).indexOf("@end_vars") + 1;
                if (gamemode == 61) { // Hotfix because 3069 was letting 2s merge with 0s as if the 0s were 1s
                    MergeRules[m][mstart + 1].push("&&");
                    MergeRules[m][mstart + 1].push(["@Next 1 0", "!=", ZArray[0]]);
                }
                MergeRules[m][mstart + 1].push("&&");
                MergeRules[m][mstart + 1].push(["@This 0", "!=", ZArray[0]]);
                if (MergeRules[m].length - mstart > 5) {
                    MergeRules[m][mstart + 5] = [];
                    for (let e = 0; e < MergeRules[m][mstart]; e++) MergeRules[m][mstart + 5].push(false);
                }
                if (MergeRules[m][mstart] == 0) {
                    if (MergeRules[m][mstart + 3].length == 0) MergeRules[m][mstart + 3].push(ZArray);
                }
                else {
                    MergeRules[m][mstart + 3].push("fill", ZArray);
                    let mergelength = MergeRules[m][mstart];
                    if (MergeRules[m].length > mstart + 6) mergelength = MergeRules[m][mstart + 6];
                    for (let n = 1; n < mergelength; n++) {
                        MergeRules[m][mstart + 1].push("&&");
                        MergeRules[m][mstart + 1].push(["@Next " + n + " 0", "!=", ZArray[0]]);
                    }
                }
            }
            let ZRid = [];
            for (let z = 0; z < ZArray.length; z++) {
                ZRid.push(["@This " + z, "=", ZArray[z]], "&&", ["@Next 1 " + z, "=", ZArray[z]], "&&");
            }
            ZRid.pop();
            MergeRules.unshift([2, ZRid, true, [ZArray], 0, [true, true]]);
        }
        let BlackBox = ["BlackBox"];
        for (let i = 1; i < TileNumAmount; i++) BlackBox.push(0);
        let temporaryHole = ["@TemporaryHole", modifiers[27]];
        for (let i = 1; i < TileNumAmount; i++) temporaryHole.push(0);
        if (modifiers[18] > 0 || (modifiers[5] == "Custom" && (indexOfNestedPrimArray("BlackBox", startingGrid) != -1 || indexOfNestedPrimArray("@BlackBox", startingGrid) != -1))) {
            TileTypes.unshift([BlackBox, "", ["@radial-gradient", "#000000", 0, 80, "#ffffff", 90], "#ffffff"]);
            for (let m = 0; m < MergeRules.length; m++) {
                let mstart = 0;
                if (MergeRules[m][0] === "@include_gvars") mstart = 1;
                if ((MergeRules[m]).indexOf("@end_vars") > -1) mstart = (MergeRules[m]).indexOf("@end_vars") + 1;
                let blackBoxProtect = ["@This 0", "!=", "BlackBox"];
                let mergelength = MergeRules[m][mstart];
                if (MergeRules[m].length > mstart + 6) mergelength = MergeRules[m][mstart + 6];
                for (let n = 1; n < mergelength; n++) {
                    blackBoxProtect.push("&&");
                    blackBoxProtect.push(["@Next " + n + " 0", "!=", "BlackBox"]);
                }
                MergeRules[m][mstart + 1] = [blackBoxProtect, "&&", ["@var_retain"].concat(MergeRules[m][mstart + 1])];
            }
            for (let row = 0; row < height; row++) {
                for (let column = 0; column < width; column++) {
                    if (Array.isArray(startingGrid[row][column]) && startingGrid[row][column][0] == "BlackBox") {
                        Grid[row][column] = BlackBox;
                        startingGrid[row][column] = BlackBox;
                    }
                }
            }
        }
        if (modifiers[25] > 0) {
            let THSpawn = [["@Moves", "%", modifiers[26], "=", 0], "AfterSpawns", false];
            for (let h = 0; h < modifiers[25]; h++) THSpawn.push("@TemporaryHole " + modifiers[27]);
            forcedSpawns.push(THSpawn);
        }
    }
}

function loadResettingModifiers() { //Randomly-Placed Holes and Randomly-Placed Box Tiles re-randomize after each game, but the rest of the modifiers don't, so those two are loaded here instead of in loadModifiers
    if (gamemode != 0) {
        let BlackBox = ["BlackBox"];
        for (let i = 1; i < TileNumAmount; i++) BlackBox.push(0);
        let availableTiles = [];
        for (let h = 0; h < height; h++) {
            for (let w = 0; w < width; w++) {
                availableTiles.push([h, w]);
            }
        }
        let voidboxes = 0;
        let chosen = 0;
        while (voidboxes < modifiers[17] && availableTiles.length > 0) {
            chosen = getRndInteger(0, availableTiles.length - 1);
            if (Grid[availableTiles[chosen][0]][availableTiles[chosen][1]] == "@Empty") {
                Grid[availableTiles[chosen][0]][availableTiles[chosen][1]] = "@Void";
                voidboxes++;
            }
            availableTiles.splice(chosen, 1);
        }
        voidboxes = 0;
        while (voidboxes < modifiers[18] && availableTiles.length > 0) {
            chosen = getRndInteger(0, availableTiles.length - 1);
            if (Grid[availableTiles[chosen][0]][availableTiles[chosen][1]] == "@Empty") {
                Grid[availableTiles[chosen][0]][availableTiles[chosen][1]] = BlackBox;
                voidboxes++;
            }
            availableTiles.splice(chosen, 1);
        }
        voidboxes = 0;
        while (voidboxes < modifiers[28] && availableTiles.length > 0) {
            chosen = getRndInteger(0, availableTiles.length - 1);
            if (Grid[availableTiles[chosen][0]][availableTiles[chosen][1]] == "@Empty") {
                Grid[availableTiles[chosen][0]][availableTiles[chosen][1]] = "@Slippery";
                voidboxes++;
            }
            availableTiles.splice(chosen, 1);
        }
        // Random goals
        if (gamemode == 38) { // 180
            if (mode_vars[1] > 0) {
                let r1 = Math.random();
                let r2 = Math.random();
                let r3 = Math.random();
                let rsum = r1+r2+r3;
                r1 /= rsum;
                r2 /= rsum;
                r3 /= rsum;
                start_game_vars[3] = r1;
                start_game_vars[4] = r1 + r2;
                start_game_vars[5] = mode_vars[2];
                start_game_vars[0] = [0, 0, 0];
                while (2**start_game_vars[0][0] * 3**start_game_vars[0][1] * 5**start_game_vars[0][2] < start_game_vars[5]) {
                    if (Math.random() < start_game_vars[3]) start_game_vars[0][0]++;
                    else if (Math.random() < start_game_vars[4]) start_game_vars[0][1]++;
                    else start_game_vars[0][2]++
                }
                if (mode_vars[0] != 0) start_game_vars[0] = 2n**BigInt(start_game_vars[0][0]) * 3n**BigInt(start_game_vars[0][1]) * 5n**BigInt(start_game_vars[0][2])
            }
        }
        if (gamemode == 39) { // 2592
            if (mode_vars[1] > 0) {
                start_game_vars[3] = Math.random();
                start_game_vars[4] = mode_vars[2];
                start_game_vars[0] = [0, 0];
                while (2**start_game_vars[0][0] * 3**start_game_vars[0][1] < start_game_vars[4]) {
                    if (Math.random() < start_game_vars[3]) start_game_vars[0][0]++;
                    else start_game_vars[0][1]++
                }
            }
        }
        if (gamemode == 43) { // 1321
            if (mode_vars[1] > 0) {
                start_game_vars[0] = getRndInteger(2**(start_game_vars[3] - 1), 2**(start_game_vars[3]) - 1);
            }
        }
        if (gamemode == 50) { // DIVE
            if (mode_vars[3] > 0) {
                start_game_vars[5] = getRndBigInt(start_game_vars[9], start_game_vars[9]*2n-1n);
            }
        }
        if (gamemode == 54) { // 3888
            if (mode_vars[0] > 0) {
                start_game_vars[3] = Math.random();
                start_game_vars[4] = mode_vars[1];
                start_game_vars[0] = [0, 0];
                while (2**start_game_vars[0][0] * 3**start_game_vars[0][1] < start_game_vars[4]) {
                    if (Math.random() < start_game_vars[3]) start_game_vars[0][0]++;
                    else start_game_vars[0][1]++
                }
            }
        }
        if (gamemode == 55) { // 2000
            if (mode_vars[0] > 0) {
                start_game_vars[3] = Math.random();
                start_game_vars[4] = mode_vars[1];
                start_game_vars[0] = [0, 0];
                while (2**start_game_vars[0][0] * 5**start_game_vars[0][1] < start_game_vars[4]) {
                    if (Math.random() < start_game_vars[3]) start_game_vars[0][0]++;
                    else start_game_vars[0][1]++
                }
            }
        }
        if (gamemode == 56) { // 3645
            if (mode_vars[0] > 0) {
                start_game_vars[3] = Math.random();
                start_game_vars[4] = mode_vars[1];
                start_game_vars[0] = [0, 0];
                while (3**start_game_vars[0][0] * 5**start_game_vars[0][1] < start_game_vars[4]) {
                    if (Math.random() < start_game_vars[3]) start_game_vars[0][0]++;
                    else start_game_vars[0][1]++
                }
            }
        }
        if (gamemode == 59) { // 1825
            if (mode_vars[0] > 0) {
                start_game_vars[0] = getRndInteger(2**(start_game_vars[3] - 1), 2**(start_game_vars[3]) - 1);
            }
        }
        if (gamemode == 61) { // 3069
            if (mode_vars[0] > 0) {
                if (mode_vars[2]) {
                    start_game_vars[1] = [[3n], [4n], [2n, 2n]][getRndInteger(0, 2)];
                    game_vars = compendiumStructuredClone(start_game_vars);
                    game_vars[3] = true;
                    game_vars[2] = -1;
                    CalcArray([0, "@if", "@GVar 3", "@edit_gvar", 2, ["@var_retain", "@GVar 2", "+", 1], "@edit_gvar", 3, false, "@add_var", 1n, "@add_var", 2n, "@add_var", [[2n, "^B", ["@GVar 2", "BigInt"], "*B", "@GVar 4"], "rand_bigint", [2n, "^B", ["@GVar 2", "+", 1], "BigInt", "*B", "@GVar 4", "-B", 1n], "*B", 2n, "-B", 1n], "@edit_gvar", 1, ["@Literal"], "@repeat", ["@var_retain", "@Var -1", ">", 1n], "@repeat", ["@var_retain", "@Var -1", "%B", "@Var -2", "=", 0n], "@edit_var", -1, ["@var_retain", "@Var -1", "/B", "@Var -2"], "@edit_gvar", 1, ["@var_retain", "@GVar 1", "arr_push", "@Var -3"], "@end-repeat", "@edit_var", -3, ["@var_retain", "@Var -3", "+B", 1n], "@edit_var", -2, ["@var_retain", "@Var -3", "prime"], "@end-repeat", "@end-if"]);
                    start_game_vars = compendiumStructuredClone(game_vars);
                }
                else {
                    start_game_vars[1] = [[1n, 1n], [3n], [1n, 2n], [4n]][getRndInteger(0, 3)];
                    game_vars = compendiumStructuredClone(start_game_vars);
                    game_vars[3] = true;
                    game_vars[2] = -1;
                    CalcArray([0, "@if", "@GVar 3", "@edit_gvar", 2, ["@var_retain", "@GVar 2", "+", 1], "@edit_gvar", 3, false, "@add_var", 1n, "@add_var", 2n, "@add_var", [[2n, "^B", ["@GVar 2", "BigInt"], "*B", "@GVar 4"], "rand_bigint", [2n, "^B", ["@GVar 2", "+", 1], "BigInt", "*B", "@GVar 4", "-B", 1n]], "@edit_gvar", 1, ["@Literal"], "@repeat", ["@var_retain", "@Var -1", ">", 1n], "@repeat", ["@var_retain", "@Var -1", "%B", "@Var -2", "=", 0n], "@edit_var", -1, ["@var_retain", "@Var -1", "/B", "@Var -2"], "@edit_gvar", 1, ["@var_retain", "@GVar 1", "arr_push", "@Var -3"], "@end-repeat", "@edit_var", -3, ["@var_retain", "@Var -3", "+B", 1n], "@edit_var", -2, ["@var_retain", "@Var -3", "prime"], "@end-repeat", "@end-if"]);
                    start_game_vars = compendiumStructuredClone(game_vars);
                }
            }
        }
        if (gamemode == 67) { // 1762
            if (mode_vars[0] > 0) {
                start_game_vars[0] = getRndBigInt(2n**(start_game_vars[3] - 1n) + 1n, 2n**(start_game_vars[3]));
            }
        }
        if (gamemode == 72) { // 3026
            if (mode_vars[1] > 0) {
                start_game_vars[7] = Math.random();
                let lower = getRndInteger(0, Math.floor(start_game_vars[8] / 2));
                let upper = start_game_vars[8] - lower;
                start_game_vars[4] = [lower, upper];
            }
        }
        if (gamemode == 73) { // SQUART
            if (mode_vars[0] > 0) {
                start_game_vars[0] = [6n, 8n][getRndInteger(0, 1)];
                start_game_vars[3] = [1n, 2n, 4n, start_game_vars[0]];
                game_vars = compendiumStructuredClone(start_game_vars);
                while (game_vars[0] < game_vars[4]) {
                    game_vars[2] = true;
                    CalcArray(scripts[scripts.length - 1][0]);
                }
                game_vars[1] = 0;
                game_vars[2] = false;
                start_game_vars = compendiumStructuredClone(game_vars);
            }
        }
        if (gamemode == 77) { // 1668
            if (mode_vars[0] > 0) {
                start_game_vars[0] = getRndBigInt(3n**(start_game_vars[3] - 1n) + 1n, 3n**(start_game_vars[3]));
            }
        }
        if (gamemode == 78) { // 1847
            if (mode_vars[0] > 0) {
                start_game_vars[0] = getRndBigInt(BigRational.pow(1.5, start_game_vars[3] - 1n).ceil().toBigInt(), BigRational.pow(1.5, start_game_vars[3]).floor().toBigInt());
            }
        }
        if (gamemode == 80) { // 1429
            if (mode_vars[0] > 0) {
                start_game_vars[0] = getRndBigInt(2n**(start_game_vars[3] - 2n) + 1n, 2n**(start_game_vars[3] - 1n)) * 2n - 1n;
            }
        }
        if (gamemode == 85) { // 2669
            if (mode_vars[0] > 0) {
                start_game_vars[0] = 5n;
                start_game_vars[3] = [3n, 2n, 1];
                game_vars = compendiumStructuredClone(start_game_vars);
                game_vars[2] = true;
                game_vars[1] = -1;
                CalcArray([["@Literal", 3n, 2n, 1], start_game_vars[4], "@end_vars", 0, "@if", "@GVar 2", "@edit_gvar", 1, ["@GVar 1", "+", 1], "@edit_gvar", 2, false, "@edit_gvar", 0, 5n, "@edit_gvar", 3, ["@Literal", 3n, 2n, 1], "@repeat", ["@var_retain", "@GVar 0", "<", "@Var 1"], "@if", [["@GVar 3", "arr_elem", 2, ">=", 2], "||", [0, "rand_float", 1, ">", 0.5]], "@edit_gvar", 3, ["@GVar 0", "arr_concat", ["@GVar 3", "arr_elem", 0], "arr_concat", 1], "@edit_gvar", 0, ["@var_retain", "@Var 0", "arr_elem", 0, "+B", "@GVar 0"], "@end-if", "@else", "@edit_gvar", 3, ["@GVar 0", "arr_concat", ["@GVar 3", "arr_elem", 1], "arr_concat", ["@GVar 3", "arr_elem", 2, "+", 1]], "@edit_gvar", 0, ["@var_retain", "@Var 0", "arr_elem", 1, "+B", "@GVar 0"], "@end-else", "@edit_var", 0, ["@GVar 3", "arr_copy"], "@end-repeat", "@end-if"])
                start_game_vars = compendiumStructuredClone(game_vars);
            }
        }
        if (gamemode == 88) { // FACTUP
            if (mode_vars[1] > 0) {
                start_game_vars[0] = 2n;
                start_game_vars[3] = [1n, 2n];
                game_vars = compendiumStructuredClone(start_game_vars);
                while (game_vars[0] < game_vars[4]) {
                    game_vars[2] = true;
                    CalcArray(scripts[scripts.length - 1][0]);
                }
                game_vars[1] = 0;
                game_vars[2] = false;
                start_game_vars = compendiumStructuredClone(game_vars);
            }
        }
        if (gamemode == 89) { // 2496
            if (mode_vars[0] > 0) {
                if (start_game_vars[3] % 2n == 0n) {
                    start_game_vars[0] = [getRndBigInt(2n**(start_game_vars[3] / 2n - 1n) + 1n, 2n**(start_game_vars[3] / 2n)), 2n**(start_game_vars[3] / 2n)];
                }
                else {
                    start_game_vars[0] = [2n**((start_game_vars[3] - 1n) / 2n), getRndBigInt(2n**((start_game_vars[3] - 1n) / 2n) + 1n, 2n**((start_game_vars[3] - 1n) / 2n + 1n))];
                }
            }
        }
        if (gamemode == 91 || gamemode == 92) { // 1845, SCAPRIM
            if (mode_vars[0] > 0) {
                start_game_vars[0] = getRndBigInt(start_game_vars[3], start_game_vars[3]*2n-1n);
            }
        }
        if (gamemode == 93) { // TRIGAT
            if (mode_vars[0] > 0) {
                start_game_vars[0] = [9n, 12n][getRndInteger(0, 1)];
                start_game_vars[3] = [3n, 6n, start_game_vars[0]];
                game_vars = compendiumStructuredClone(start_game_vars);
                while (game_vars[0] < game_vars[4]) {
                    game_vars[2] = true;
                    CalcArray(scripts[scripts.length - 1][0]);
                }
                game_vars[1] = 0;
                game_vars[2] = false;
                start_game_vars = compendiumStructuredClone(game_vars);
            }
        }
        if (gamemode == 96) { // LOCEF
            if (mode_vars[1] > 0) {
                start_game_vars[0] = [7n, 9n][getRndInteger(0, 1)];
                start_game_vars[3] = [1n, 3n, start_game_vars[0]];
                game_vars = compendiumStructuredClone(start_game_vars);
                while (game_vars[0] < game_vars[4]) {
                    game_vars[2] = true;
                    CalcArray(scripts[scripts.length - 1][0]);
                }
                game_vars[1] = 0;
                game_vars[2] = false;
                start_game_vars = compendiumStructuredClone(game_vars);
            }
        }
    }
}

//Custom grid and directions in modifiers

function createCustomGrid() {
    while (document.getElementById("modifiers_customGrid").lastElementChild) document.getElementById("modifiers_customGrid").removeChild(document.getElementById("modifiers_customGrid").lastElementChild);
    let varHeight = (hexagonal ? (height * 2 - 1) : height)
    document.documentElement.style.setProperty("--width", width);
    document.documentElement.style.setProperty("--height", varHeight);
    tsize = 100 * Math.min(1, width/varHeight)/(hexagonal ? (width + 1)/2 * (width > 1 ? Math.sqrt(3) / 2 : 1) : width);
    document.documentElement.style.setProperty("--tile_size", tsize * 0.9 + "%");
    document.documentElement.style.setProperty("--th_dist", tsize * (1 - 0.1 * 1/(width + 1)) * Math.max(1, varHeight/width) * (hexagonal ? Math.sqrt(3)/4 : 1));
    document.documentElement.style.setProperty("--tv_dist", tsize * (1 - 0.1 * 1/(height + 1)) * Math.max(1, width/varHeight) * (hexagonal ? 3/4 : 1));
    startingGrid = [];
    for (let row = 0; row < height; row++) {
        startingGrid.push([]);
        for (let column = 0; column < width; column++) {
            if ((row + column + (height - 1)/2) % 2 == 0 || !hexagonal) {
                startingGrid[row].push("@Empty");
                let newEmpty = document.createElement("div");
                newEmpty.id = "Empty_" + row + "_" + column;
                newEmpty.classList.add("customGridTile");
                if (hexagonal) newEmpty.classList.add("hexagon_clip");
                document.getElementById("modifiers_customGrid").appendChild(newEmpty);
            }
            else {
                startingGrid[row].push("@Void");
            }
        }
    }
    customGridTiles = document.getElementById("modifiers_customGrid").children;
    let Positions = [];
    for (let row = 0; row < height; row++) {
        Positions.push([]);
        for (let column = 0; column < width; column++) {
            Positions[row].push([]);
        }
    }
    for (let t of customGridTiles) {
        let char = 6;
        let hcoord = "";
        let vcoord = "";
        while (t.id[char] != "_") {vcoord += t.id[char]; char++;}
        char++;
        while (char < t.id.length) {hcoord += t.id[char]; char++;}
        hcoord = Number(hcoord);
        vcoord = Number(vcoord);
        let hsize = Number(getComputedStyle(document.documentElement).getPropertyValue("--th_dist"));
        let vsize = Number(getComputedStyle(document.documentElement).getPropertyValue("--tv_dist"));
        let offset = 0.075 * (hexagonal ? Math.sqrt(3)/4 : 1)
        t.style.setProperty("left", hsize * (offset + hcoord) + "%");
        t.style.setProperty("top", vsize * (offset + vcoord) + (hexagonal ? (2 - Math.sqrt(3))*25*(1 - 1/height) : 0) + "%");
        Positions[vcoord][hcoord] = [hsize * (offset + hcoord), vsize * (offset + vcoord) + (hexagonal ? (2 - Math.sqrt(3))*25*(1 - 1/height) : 0)];
        t.addEventListener("click", function(){
            if (startingGrid[vcoord][hcoord] == "@Empty") {
                startingGrid[vcoord][hcoord] = "@Void";
            }
            else if (startingGrid[vcoord][hcoord] == "@Void") {
                startingGrid[vcoord][hcoord] = "@BlackBox";
            }
            else if (startingGrid[vcoord][hcoord] == "@BlackBox" || (Array.isArray(startingGrid[vcoord][hcoord]) && startingGrid[vcoord][hcoord][0] === "BlackBox")) {
                startingGrid[vcoord][hcoord] = "@Slippery";
            }
            else {
                startingGrid[vcoord][hcoord] = "@Empty";
            }
            displayCustomTile(this);
        })
    }
}

function displayCustomTile(tile) {
    let char = 6;
    let hcoord = "";
    let vcoord = "";
    while (tile.id[char] != "_") {vcoord += tile.id[char]; char++;}
    char++;
    while (char < tile.id.length) {hcoord += tile.id[char]; char++;}
    hcoord = Number(hcoord);
    vcoord = Number(vcoord);
    if (Array.isArray(startingGrid[vcoord][hcoord]) && startingGrid[vcoord][hcoord][0] === "BlackBox") {
        startingGrid[vcoord][hcoord] = "@BlackBox";
    }
    if (startingGrid[vcoord][hcoord] === "@Void") {
        tile.style.setProperty("background-color", "#e8de8110");
        tile.style.setProperty("background-image", "none");
    }
    else if (startingGrid[vcoord][hcoord] === "@BlackBox") {
        tile.style.setProperty("background-color", "#e8de81");
        if (hexagonal) tile.style.setProperty("background-image", "radial-gradient(#000000 0% 60%, #ffffff 66.666%)");
        else tile.style.setProperty("background-image", "radial-gradient(#000000 0% 80%, #ffffff 90%)");
    }
    else if (startingGrid[vcoord][hcoord] === "@Slippery") {
        tile.style.setProperty("background-color", "#e8de81");
        if (hexagonal) tile.style.setProperty("background-image", 'url("SlipperyHexagonal.png")');
        else tile.style.setProperty("background-image", 'url("Slippery.png")');
    }
    else {
        tile.style.setProperty("background-color", "#e8de81");
        tile.style.setProperty("background-image", "none");
    }
}

function createCustomArrows() {
    while (document.getElementById("modifiers_customArrowContainer").children.length > 0) document.getElementById("modifiers_customArrowContainer").removeChild(document.getElementById("modifiers_customArrowContainer").lastElementChild);
    directionsAvailable = [];
    for (let d = 0; d < directions.length; d++) {
        directionsAvailable.push(true);
        let newArrow = document.createElement("div");
        newArrow.id = "CustomArrow_" + d;
        newArrow.classList.add("arrow");
        newArrow.classList.add("button");
        newArrow.classList.add("hover_grow");
        document.getElementById("modifiers_customArrowContainer").appendChild(newArrow);
        let newArrowp = document.createElement("p");
        newArrow.appendChild(newArrowp);
        newArrowp.innerHTML = directions[d][1];
        newArrow.style.setProperty("width", directions[d][2] * 100 + "%");
        newArrow.style.setProperty("height", directions[d][3] * 100 + "%");
        newArrow.style.setProperty("border-width", "calc(var(--modifiers_base_size) * 2.24 * " + Math.min(directions[d][2], directions[d][3]) + ")");
        newArrow.style.setProperty("font-size", "calc(var(--modifiers_base_size) * 56 *" + directions[d][4] + ")");
        newArrow.style.setProperty("top", directions[d][5] * 100 + "%");
        newArrow.style.setProperty("left", directions[d][6] * 100 + "%");
        if (directions[d].length > 8) newArrowp.style.setProperty("rotate", directions[d][8] + "deg");
        if (screenVars[0] === d) newArrow.style.setProperty("box-shadow", "0px 0px calc(var(--modifiers_base_size) * 2) calc(var(--modifiers_base_size) * 1) #fff");
        else newArrow.style.setProperty("box-shadow", "none");
        newArrow.addEventListener("click",  function(){
            if (screenVars[0] === d) screenVars[0] = -1;
            else screenVars[0] = d;
            createCustomArrows();
            displayModifiers(3.2);
        }
        )
    }
}

//Calculations for CalcArrays, the kinds of arrays seen all across the project, especially in TileTypes and MergeRules

function operation(n1, operator, n2) {
    let additional = [];
    if (arguments.length > 3) additional = arguments[3];
    let result = n1;
    switch (operator) {
        //number operators (mostly)
        case "+":
        case "+B":
        case "str_concat":
            result = n1 + n2;
        break;
        case "-":
        case "-B":
            result = n1 - n2;
        break;
        case "*":
        case "*B":
            result = n1 * n2;
        break;
        case "/":
        case "/B":
            result = n1 / n2;
        break;
        case "%":
        case "%B":
            result = n1 % n2;
        break;
        case "mod":
        case "modB":
            result = mod(n1, n2);
        break;
        case "^":
        case "**":
        case "^B":
        case "**B":
            result = n1 ** n2;
        break;
        case "log":
            result = Math.log(n1)/Math.log(n2);
        break;
        case "round":
            result = Math.round(n1/n2) * n2;
        break;
        case "floor":
            result = Math.floor(n1/n2) * n2;
        break;
        case "ceil":
        case "ceiling":
            result = Math.ceil(n1/n2) * n2;
        break;
        case "trunc":
            result = Math.trunc(n1/n2) * n2;
        break;
        case "abs":
        case "absB":
            result = abs(n1);
        break;
        case "sign":
        case "signB":
            result = sign(n1);
        break;
        case "sin":
            result = Math.sin(n1);
        break;
        case "cos":
            result = Math.cos(n1);
        break;
        case "tan":
            result = Math.tan(n1);
        break;
        case "gcd":
        case "gcdB":
            result = gcd(n1, n2);
        break;
        case "lcm":
        case "lcmB":
            result = lcm(n1, n2);
        break;
        case "factorial":
        case "factorialB":
            result = factorial(n1);
        break;
        case "prime":
        case "primeB":
            result = prime(n1);
        break;
        case "expomod":
        case "expomodB":
            result = expomod(n1, n2);
        break;
        case "bit&":
        case "bit&B":
            result = n1 & n2;
        break;
        case "bit|":
        case "bit|B":
            result = n1 | n2;
        break;
        case "bit~":
        case "bit~B":
            result = ~n1;
        break;
        case "bit^":
        case "bit^B":
            result = n1 ^ n2;
        break;
        case "bit<<":
        case "bit<<B":
            result = n1 << n2;
        break;
        case "bit>>":
        case "bit>>B":
            result = n1 >> n2;
        break;
        case "bit>>>":
        case "bit>>>B":
            result = n1 >>> n2;
        break;
        case "rand_int":
            result = getRndInteger(Math.ceil(n1), Math.floor(n2));
        break;
        case "rand_float":
            result = getRndFloat(n1, n2);
        break;
        case "defaultAbbrev":
        case "defaultAbbrevB":
        case "defaultAbbrevGB":
        case "defaultAbbrevBR":
        case "defaultAbbrevAny":
            result = defaultAbbreviate(n1);
        break;
        //comparisons
        case "=":
            if (Array.isArray(n1) && Array.isArray(n2)) result = eqPrimArrays(n1, n2);
            else if ((n1 instanceof GaussianBigInt && n2 instanceof GaussianBigInt) || ((n1 instanceof BigRational && n2 instanceof BigRational))) result = n1.eq(n2);
            else result = (n1 === n2);
        break;
        case ">":
            if (n1 instanceof GaussianBigInt || n2 instanceof GaussianBigInt) result = false; // The complex numbers are not ordered
            else if (n1 instanceof BigRational || n2 instanceof BigRational) result = BigRational.gt(n1, n2);
            else result = (n1 > n2);
        break;
        case "<":
            if (n1 instanceof GaussianBigInt || n2 instanceof GaussianBigInt) result = false;
            else if (n1 instanceof BigRational || n2 instanceof BigRational) result = BigRational.lt(n1, n2);
            else result = (n1 < n2);
        break;
        case ">=":
            if (n1 instanceof GaussianBigInt || n2 instanceof GaussianBigInt) result = false;
            else if (n1 instanceof BigRational || n2 instanceof BigRational) result = BigRational.gte(n1, n2);
            else result = (n1 >= n2);
        break;
        case "<=":
            if (n1 instanceof GaussianBigInt || n2 instanceof GaussianBigInt) result = false;
            else if (n1 instanceof BigRational || n2 instanceof BigRational) result = BigRational.lte(n1, n2);
            else result = (n1 <= n2);
        break;
        case "!=":
            if (Array.isArray(n1) && Array.isArray(n2)) result = !eqPrimArrays(n1, n2);
            else if ((n1 instanceof GaussianBigInt && n2 instanceof GaussianBigInt) || ((n1 instanceof BigRational && n2 instanceof BigRational))) result = n1.neq(n2);
            else result = (n1 !== n2);
        break;
        case "max":
            if (n1 instanceof GaussianBigInt || n2 instanceof GaussianBigInt) throw new TypeError("Gaussian integers do not have maximums since they are not ordered");
            else if (n1 instanceof BigRational || n2 instanceof BigRational) result = BigRational.max(n1, n2);
            result = max(n1, n2);
        break;
        case "min":
            if (n1 instanceof GaussianBigInt || n2 instanceof GaussianBigInt) throw new TypeError("Gaussian integers do not have minimums since they are not ordered");
            else if (n1 instanceof BigRational || n2 instanceof BigRational) result = BigRational.min(n1, n2);
            result = min(n1, n2);
        break;
        //boolean operators
        case "&&":
        case "&&nsc":
            result = (n1 && n2);
        break;
        case "||":
        case "||nsc":
            result = (n1 || n2);
        break;
        case "!":
            result = !n1;
        break;
        //string operators, some of which are also array operators
        case "str_char":
        case "arr_elem":
            result = n1.at(n2);
        break;
        case "str_length":
        case "arr_length":
            result = n1.length;
        break;
        case "str_concat_front":
            result = n2 + n1;
        break;
        case "str_slice":
            result = n1.slice(n2, additional[0]);
        break;
        case "str_substr":
            result = n1.substr(n2, additional[0]);
        break;
        case "str_replace":
            result = n1.replace(n2, additional[0]);
        break;
        case "str_indexOf":
            result = n1.indexOf(n2);
        break;
        case "str_lastIndexOf":
            result = n1.lastIndexOf(n2);
        break;
        case "str_indexOfFrom":
            result = n1.indexOf(n2, additional[0]);
        break;
        case "str_lastIndexOfFrom":
            result = n1.lastIndexOf(n2, additional[0]);
        break;
        case "str_includes":
            result = n1.includes(n2);
        break;
        case "str_splice":
            result = string_splice(n1, n2, additional[0], additional[1]);
        break;
        case "str_toUpperCase":
            result = n1.toUpperCase();
        break;
        case "str_toLowerCase":
            result = n1.toLowerCase();
        break;
        case "str_split":
            result = n1.split(n2);
        break;
        //Array operators
        case "arr_indexOf":
            result = indexOfPrimArray(n2, n1);
        break;
        case "arr_lastIndexOf":
            result = lastIndexOfPrimArray(n2, n1);
        break;
        case "arr_indexOfFrom":
            result = indexOfPrimArray(n2, n1, additional[0]);
        break;
        case "arr_lastIndexOfFrom":
            result = lastIndexOfPrimArray(n2, n1, additional[0]);
        break;
        case "arr_includes":
            result = (indexOfPrimArray(n2, n1) != -1);
        break;
        case "arr_copy":
            result = compendiumStructuredClone(n1);
        break;
        case "arr_edit_elem":
            result = compendiumStructuredClone(n1);
            result[n2] = additional[0];
        break;
        case "arr_push":
            result = compendiumStructuredClone(n1);
            result.push(n2);
        break;
        case "arr_pop":
            result = compendiumStructuredClone(n1);
            result.pop();
        break;
        case "arr_unshift":
            result = compendiumStructuredClone(n1);
            result.unshift(n2);
        break;
        case "arr_shift":
            result = compendiumStructuredClone(n1);
            result.shift();
        break;
        case "arr_concat":
            result = n1.concat(n2);
        break;
        case "arr_concat_front":
            result = n2.concat(n1);
        break;
        case "arr_flat":
            result = n1.flat(n2);
        break;
        case "arr_splice":
            result = compendiumStructuredClone(n1);
            result.splice(n2, additional[0], ...(additional[1]));
        break;
        case "arr_slice":
            result = n1.slice(n2, additional[0]);
        break;
        case "arr_reverse":
            result = n1.reverse();
        break;
        case "arr_sort":
            result = n1.sort(
                function(a, b) {
                    let nn2 = compendiumStructuredClone(n2);
                    let vpos = 0;
                    while (nn2[vpos] === "@var_retain" || nn2[vpos] === "@var_copy" || nn2[vpos] === "@global_var_retain" || nn2[vpos] === "@global_var_copy" || nn2[vpos] === "@global_var_none" || nn2[vpos] === "@global_var_retain_inner" || nn2[vpos] === "@global_var_copy_inner" || nn2[vpos] === "@global_var_none_inner") vpos++;
                    if (nn2.indexOf("@end_vars") == -1) nn2.splice(vpos, 0, "@end_vars");
                    vpos = nn2.indexOf("@end_vars");
                    nn2.splice(vpos, 0, a, b);
                    return CalcArray(nn2, ...additional[0]);
                }
            )
        break;
        case "arr_map":
            result = n1.map(
                function(value, index) {
                    let nn2 = compendiumStructuredClone(n2);
                    let vpos = 0;
                    while (nn2[vpos] === "@var_retain" || nn2[vpos] === "@var_copy" || nn2[vpos] === "@global_var_retain" || nn2[vpos] === "@global_var_copy" || nn2[vpos] === "@global_var_none" || nn2[vpos] === "@global_var_retain_inner" || nn2[vpos] === "@global_var_copy_inner" || nn2[vpos] === "@global_var_none_inner") vpos++;
                    if (nn2.indexOf("@end_vars") == -1) nn2.splice(vpos, 0, "@end_vars");
                    vpos = nn2.indexOf("@end_vars");
                    nn2.splice(vpos, 0, index, value);
                    return CalcArray(nn2, ...additional[0]);
                }
            )
        break;
        case "arr_filter":
            result = n1.filter(
                function(value, index) {
                    let nn2 = compendiumStructuredClone(n2);
                    let vpos = 0;
                    while (nn2[vpos] === "@var_retain" || nn2[vpos] === "@var_copy" || nn2[vpos] === "@global_var_retain" || nn2[vpos] === "@global_var_copy" || nn2[vpos] === "@global_var_none" || nn2[vpos] === "@global_var_retain_inner" || nn2[vpos] === "@global_var_copy_inner" || nn2[vpos] === "@global_var_none_inner") vpos++;
                    if (nn2.indexOf("@end_vars") == -1) nn2.splice(vpos, 0, "@end_vars");
                    vpos = nn2.indexOf("@end_vars");
                    nn2.splice(vpos, 0, index, value);
                    return CalcArray(nn2, ...additional[0]);
                }
            )
        break;
        case "arr_reduce":
            result = n1.reduce(
                function(total, value, index) {
                    if (Array.isArray(total)) total.unshift("@Literal");
                    if (Array.isArray(value)) value.unshift("@Literal");
                    let nn2 = compendiumStructuredClone(n2);
                    let vpos = 0;
                    while (nn2[vpos] === "@var_retain" || nn2[vpos] === "@var_copy" || nn2[vpos] === "@global_var_retain" || nn2[vpos] === "@global_var_copy" || nn2[vpos] === "@global_var_none" || nn2[vpos] === "@global_var_retain_inner" || nn2[vpos] === "@global_var_copy_inner" || nn2[vpos] === "@global_var_none_inner") vpos++;
                    if (nn2.indexOf("@end_vars") == -1) nn2.splice(vpos, 0, "@end_vars");
                    vpos = nn2.indexOf("@end_vars");
                    nn2.splice(vpos + 1, 0, total);
                    nn2.splice(vpos, 0, index, value);
                    return CalcArray(nn2, ...additional[0]);
                }, additional[1]
            )
        break;
        case "arr_reduceRight":
            result = n1.reduceRight(
                function(total, value, index) {
                    let nn2 = compendiumStructuredClone(n2);
                    let vpos = 0;
                    while (nn2[vpos] === "@var_retain" || nn2[vpos] === "@var_copy" || nn2[vpos] === "@global_var_retain" || nn2[vpos] === "@global_var_copy" || nn2[vpos] === "@global_var_none" || nn2[vpos] === "@global_var_retain_inner" || nn2[vpos] === "@global_var_copy_inner" || nn2[vpos] === "@global_var_none_inner") vpos++;
                    if (nn2.indexOf("@end_vars") == -1) nn2.splice(vpos, 0, "@end_vars");
                    vpos = nn2.indexOf("@end_vars");
                    nn2.splice(vpos + 1, 0, total);
                    nn2.splice(vpos, 0, index, value);
                    return CalcArray(nn2, ...additional[0]);
                }, additional[1]
            )
        break;
        case "arr_binarySearch":
            result = binarySearch(n1, n2);
        break;
        case "arr_binaryInsert":
            result = binaryInsert(n1, n2);
        break;
        case "arr_eqRearrange":
            result = eqRearrangeArrays(n1, n2);
        break;
        //BigInt operators
        case "rootB":
            result = iroot(n1, n2);
        break;
        case "logB":
            result = ilog(n1, n2);
        break;
        case "floorB":
            result = n1/n2 * n2;
            if (result > n1) result -= n2;
        break;
        case "ceilB":
        case "ceilingB":
            result = n1/n2 * n2;
            if (result < n1) result += n2;
        break;
        case "roundB":
            let floor = n1/n2 * n2;
            if (floor > n1) floor -= n2;
            let ceiling = n1/n2 * n2;
            if (ceiling < n1) ceiling += n2;
            if (ceiling - n1 <= n1 - floor) result = ceiling;
            else result = floor;
        break;
        case "rand_bigint":
            result = getRndBigInt(n1, n2);
        break;
        case "perfectPowerFormB":
            result = perfectPowerForm(n1, n2);
        break;
        case "primeFactorizeB":
            result = primeFactorize(n1, Infinity, false, n2, false)[0];
        break;
        case "primeDefactorizeB":
            result = primeDefactorize(n1, n2);
        break;
        case "factorAmountB":
            result = listFactors(n1, true);
        break;
        case "factorListB":
            result = listFactors(n1, false);
        break;
        case "basebit&B":
            result = baseBitMin(n1, n2, additional[0]);
        break;
        case "basebit|B":
            result = baseBitMax(n1, n2, additional[0]);
        break;
        case "basebit~B":
            result = baseBitComplement(n1, n2);
        break;
        case "basebit^B":
            result = baseBitModAdd(n1, n2, additional[0]);
        break;
        case "ipowGB":
            result = GaussianBigInt.ipow(n1);
        break;
        // GaussianBigInt and BigRational operators
        case "reGB":
            result = n1.real;
        break;
        case "imGB":
            result = n1.imaginary;
        break;
        case "numeratorBR":
            result = n1.numerator;
        break;
        case "denominatorBR":
            result = n1.denominator;
        break;
        case "+GB":
        case "+BR":
            result = n1.add(n2);
        break;
        case "-GB":
        case "-BR":
            result = n1.sub(n2);
        break;
        case "*GB":
        case "*BR":
            result = n1.mul(n2);
        break;
        case "/GB":
        case "/BR":    
            result = n1.div(n2);
        break;
        case "/mGB":
            result = n1.divM(n2);
        break;
        case "modGB":
        case "modBR":    
            result = n1.mod(n2);
        break;
        case "**GB":
        case "^GB":
        case "**BR":
        case "^BR":
            result = n1.pow(n2);
        break;
        case "negGB":
        case "negBR":
            result = n1.neg();
        break;
        case "recipBR":
            result = n1.recip();
        break;
        case "absBR":
            result = n1.abs();
        break;
        case "roundBR":
            result = n1.round(n2);
        break;
        case "floorBR":
            result = n1.floor(n2);
        break;
        case "ceilBR":
        case "ceilingBR":
            result = n1.ceiling(n2);
        break;
        case "signBR":
            result = n1.sign();
        break;
        case "normGB":
            result = n1.norm();
        break;
        case "normGGB":
            result = n1.normG();
        break;
        case "rot90GB":
            result = n1.rot90();
        break;
        case "rot270GB":
            result = n1.rot270();
        break;
        case "conjGB":
            result = n1.conj();
        break;
        case "toFirstQuadrantGB":
            result = n1.toFirstQuadrant();
        break;
        case "firstQuadrantUnitGB":
            result = n1.firstQuadrantUnit();
        break;
        case "gcdGB":
        case "gcdBR":
            result = n1.gcd(n2);
        break;
        case "lcmGB":
        case "lcmBR":
            result = n1.lcm(n2);
        break;
        case "expomodGB":
            result = expomodGaussian(n1, n2);
        break;
        case "expomodBR":
            result = expomodRational(n1, n2);
        break;
        case "perfectPowerFormBR":
            result = perfectPowerFormRational(n1, n2);
        break;
        case "gaussian_prime":
            result = gaussian_prime(n1);
        break;
        case "gaussianSort":
            result = gaussianSort(n1, n2);
        break;
        //CalcArray shenanigans
        case "CalcArray":
            result = CalcArray(n1, ...n2);
        break;
        case "CalcArrayParent":
            if (Array.isArray(n1)) n1.unshift("@Literal");
            let nn2 = compendiumStructuredClone(n2);
            let vpos = 0;
            while (nn2[vpos] === "@var_retain" || nn2[vpos] === "@var_copy" || nn2[vpos] === "@global_var_retain" || nn2[vpos] === "@global_var_copy" || nn2[vpos] === "@global_var_none" || nn2[vpos] === "@global_var_retain_inner" || nn2[vpos] === "@global_var_copy_inner" || nn2[vpos] === "@global_var_none_inner") vpos++;
            if (nn2.indexOf("@end_vars") == -1) nn2.splice(vpos, 0, "@end_vars");
            vpos = nn2.indexOf("@end_vars");
            nn2.splice(vpos + 1, 0, n1);
            result = CalcArray(nn2);
        break;
        case "evaluateColor":
            result = evaluateColor(n1, ...n2);
        break;
        case "mergeRuleApplies":
            result = mergeRuleApplies(MergeRules[n1], ...additional[0], n2);
            if (result[0] === false) result = false;
            else result = true;
        break;
        case "mergeRuleApplies_nonRecursive":
            result = mergeRuleApplies(removeMergeRuleApplies(MergeRules[n1]), ...additional[0], n2);
            if (result[0] === false) result = false;
            else result = true;
        break;
        //Type conversions
        case "Number":
            result = Number(result);
            if (Number.isNaN(result)) result = 0;
        break;
        case "String":
            result = String(result);
        break;
        case "Boolean":
            result = Boolean(result);
        break;
        case "Array":
            result = [result];
        break;
        case "BigInt":
            try {result = BigInt(result);}
            catch {
                try {result = BigInt(Math.round(result));}
                catch {result = 0n;}
            }
        break;
        case "GaussianBigInt":
            try {result = new GaussianBigInt(result);}
            catch {
                result = new GaussianBigInt(0n, 0n);
            }
        break;
        case "BigRational":
            try {result = new BigRational(result);}
            catch {
                result = new BigRational(0n, 0n);
            }
        break;
        case "typeof":
            if (Array.isArray(result)) result = "array";
            else if (result instanceof GaussianBigInt) result = "gaussianbigint"
            else if (result instanceof BigRational) result = "bigrational"
            else result = typeof result;
        break;
        //Leftover cases
        case "1st":
        case "first":
            result = n1;
        break;
        case "2nd":
        case "second":
            result = n2;
        break;
        case "@add_score":
            score += n2;
        break;
        case "@primesUpdate":
            primesUpdate(n2);
        break;
        case "DIVESeedUnlock":
            result = DIVESeedUnlock(n1, n2, additional[0])
        break;
        case "GaussianDIVESeedUnlock":
            result = GaussianDIVESeedUnlock(n1, n2, additional[0], additional[1])
        break;
        case "customDIVESeedUnlock":
            let functionArguments = [];
            for (let a = 1; a < 6; a++) {
                if (additional[a] !== undefined) functionArguments.push(
                    function(value1, value2) {
                        let argArray = compendiumStructuredClone(additional[a]);
                        let vpos = 0;
                        while (argArray[vpos] === "@var_retain" || argArray[vpos] === "@var_copy" || argArray[vpos] === "@global_var_retain" || argArray[vpos] === "@global_var_copy" || argArray[vpos] === "@global_var_none" || argArray[vpos] === "@global_var_retain_inner" || argArray[vpos] === "@global_var_copy_inner" || argArray[vpos] === "@global_var_none_inner") vpos++;
                        if (argArray.indexOf("@end_vars") == -1) argArray.splice(vpos, 0, "@end_vars");
                        vpos = argArray.indexOf("@end_vars");
                        if (Array.isArray(value1)) value1 = ["@Literal"].concat(value1);
                        if (Array.isArray(value2)) value2 = ["@Literal"].concat(value2);
                        argArray.splice(vpos, 0, value1, value2);
                        return CalcArray(argArray, ...additional[9]);
                    }
                )
            }
            functionArguments.push(additional[6]);
            for (let a = 7; a < 9; a++) {
                if (additional[a] !== undefined) functionArguments.push(
                    function(value) {
                        let argArray = compendiumStructuredClone(additional[a]);
                        let vpos = 0;
                        while (argArray[vpos] === "@var_retain" || argArray[vpos] === "@var_copy" || argArray[vpos] === "@global_var_retain" || argArray[vpos] === "@global_var_copy" || argArray[vpos] === "@global_var_none" || argArray[vpos] === "@global_var_retain_inner" || argArray[vpos] === "@global_var_copy_inner" || argArray[vpos] === "@global_var_none_inner") vpos++;
                        if (argArray.indexOf("@end_vars") == -1) argArray.splice(vpos, 0, "@end_vars");
                        vpos = argArray.indexOf("@end_vars");
                        if (Array.isArray(value)) value = ["@Literal"].concat(value);
                        argArray.splice(vpos, 0, value);
                        return CalcArray(argArray, ...additional[9]);
                    }
                )
            }
            result = customDIVESeedUnlock(n1, n2, additional[0], ...functionArguments);
        break;
        case "ignore":
            //Does nothing; this is used for leaving comments in CalcArray expressions, and in particular leaving "@no-negative-sign" is how to prevent loadModifiers from trying to multiply an expression by -1 for auto-generated negative tiles
            result = n1;
        break;
        case "announce":
            announce(n2, additional[0]);
            result = n1;
        break;
        case "output": //For testing purposes only
            output(n2);
            result = n1;
        break;
        case "console.log": //For testing purposes only
            console.log(n2);
            result = n1;
        break;
        default: result = n1;
    }
    return result;
}

function CalcArray(arr) {
    /*
    CalcArrays, in their most basic form, are something like [2, "+", 3, "*", 5]. The CalcArray function evaluates a CalcArray into its result, working from left
    to right: for example, [2, "+", 3, "*", 5] = [5, "*", 5] = 25. What makes these useful is that they can use properties of the tiles they're working with in
    TileTypes and MergeRules: for example, ["@This 0", "*", 2] evaluates to double the 0th number of that tile's internal representation, so for a 162 tile in 2187,
    which internally is a [4, 2] tile, ["@This 0", "*", 2] evaluates to 8. CalcArrays can work with numbers, strings, booleans, bigints, and other arrays -
    but avoid using the @ character in strings if you want to work with them as strings, as strings beginning with @ mean special things, as seen in CalcArrayString.
    With all the features that CalcArrays support, they're almost a miniature programming language...
    */
    let vcoord = 0; let hcoord = 0; let vdir = 0; let hdir = 0; let addInfo = [1, Infinity, 0]; let gri = Grid; let parents = []; let vars = []; let globalVarStat = 0; let inner = true;
    if (arguments.length > 1) vcoord = arguments[1]; // If this CalcArray is basing itself at a certain tile (usually via "@This" or "@Next" strings), this is the vertical coordinate of that tile
    if (arguments.length > 2) hcoord = arguments[2]; // Horizontal coordinate
    if (arguments.length > 3) vdir = arguments[3]; // For MergeRules, this is the vertical movement magnitude of the direction being moved
    if (arguments.length > 4) hdir = arguments[4]; // Horizontal movement magnitude
    if (arguments.length > 5) addInfo = arguments[5]; // An array with two entries: the first is the length of the current merge, the second is the slide amount of the current direction
    if (arguments.length > 6) gri = arguments[6]; // If we're looking at a grid that isn't the regular Grid, this specifies what the grid is
    if (arguments.length > 7) parents = arguments[7]; // The last entry of parents is the first entry of the current CalcArray. The second-to-last entry of parents is the first entry of the CalcArray that the current CalcArray is contained in, and so on, up to the first entry of parents being the first entry of the outermost CalcArray.
    if (arguments.length > 9) globalVarStat = arguments[9]; // If this is 1, variables are automatically retained into inner arrays. If this is -1, variables are automatically copied into inner arrays. If this is 0 (which is the default), neither happens. Controlled by @global_var_retain, @global_var_copy, and @global_var_none.
    if (arguments.length > 10) inner = arguments[10]; // If inner is true, then this counts as an inner CalcArray, so it adds to the parents array. This is set to false for things like repeats, ifs, and elses, since they call CalcArray despite not actually being inner arrays
    if ((typeof arr == "string")) return CalcArrayString(arr, vcoord, hcoord, vdir, hdir, addInfo, gri, parents, vars, globalVarStat);
    let carr = compendiumStructuredClone(arr);
    if (!Array.isArray(carr)) return carr;
    vars = [];
    if (arr[0] == "@global_var_retain") globalVarStat = 1;
    else if (arr[0] == "@global_var_copy") globalVarStat = -1;
    else if (arr[0] == "@global_var_none") globalVarStat = 0;
    if ((arguments.length > 8 && arr[0] === "@var_retain") || globalVarStat == 1) vars = arguments[8]; // CalcArray expressions can store and manipulate internal variables. @var_retain tells the CalcArray to use the exact same variables (by reference, which works since they're stored in an array) as the parent CalcArray, @var_copy tells the CalcArray to use the same variables (by value) as the parent CalcArray
    else if ((arguments.length > 8 && arr[0] === "@var_copy") || globalVarStat == -1) vars = compendiumStructuredClone(arguments[8]);
    if (vars === undefined) vars = [];
    if (typeof arr[0] == "string" && arr[0][0] == "@") {
        if (arr[0] == "@global_var_retain_inner") globalVarStat = 1;
        else if (arr[0] == "@global_var_copy_inner") globalVarStat = -1;
        else if (arr[0] == "@global_var_none_inner") globalVarStat = 0;
        while (carr[0] === "@var_retain" || carr[0] === "@var_copy" || carr[0] === "@global_var_retain" || carr[0] === "@global_var_copy" || carr[0] === "@global_var_none" || carr[0] === "@global_var_retain_inner" || carr[0] === "@global_var_copy_inner" || carr[0] === "@global_var_none_inner") carr.shift();
        if (carr[0] === "@Literal") return CalcArrayConvert(carr, "=", vcoord, hcoord, vdir, hdir, addInfo, gri, parents, vars, globalVarStat);
        if (carr[0] === "@include_gvars") { // Include the variables from game_vars as the first variables in this CalcArray
            let newvars = compendiumStructuredClone(game_vars);
            for (let v = 0; v < newvars.length; v++) {
                newvars[v] = CalcArrayConvert(newvars[v], "=", vcoord, hcoord, vdir, hdir, addInfo, gri, parents, vars, globalVarStat);
                if (Array.isArray(newvars[v])) newvars[v].unshift("@Literal");
                vars.push(newvars[v]);
            }
            carr.shift();
        }
    }
    if (carr.indexOf("@end_vars") > -1) { // When a CalcArray includes variables, it uses "@end_vars" to mark where the list of variables ends and the actual expression to evaluate begins.
        let newvars = carr.slice(0, carr.indexOf("@end_vars"));
        for (let v = 0; v < newvars.length; v++) {
            newvars[v] = CalcArrayConvert(newvars[v], "=", vcoord, hcoord, vdir, hdir, addInfo, gri, parents, vars, globalVarStat);
            if (Array.isArray(newvars[v])) newvars[v].unshift("@Literal");
            vars.push(newvars[v]);
        }
        carr.splice(0, carr.indexOf("@end_vars") + 1);
    }
    if (inner) {
        parents = compendiumStructuredClone(parents);
        parents.push(carr[0]);
    }
    let n1 = 0;
    let n2 = 0;
    let additional_args = [];
    let operator = "";
    let to_pop = 2; // How many entries (starting from the 1st, since the 0th is where the result is) should be removed after an operation?
    let if_skipped = false; // Is set to true only right after an if or else_if's condition is false; this is used so the CalcArray knows when to look at elses and else_ifs.
    while (carr.length > 1) {
        if (Array.isArray(carr[1])) carr[1] = CalcArray(carr[1], vcoord, hcoord, vdir, hdir, addInfo, gri, parents, vars, globalVarStat);
        operator = carr[1];
        n1 = CalcArrayConvert(carr[0], operator, vcoord, hcoord, vdir, hdir, addInfo, gri, parents, vars, globalVarStat);
        if (Array.isArray(n1)) n1.unshift("@Literal");
        parents[parents.length - 1] = compendiumStructuredClone(n1);
        if (Array.isArray(n1)) n1.shift("@Literal");
        additional_args = [];
        if (typeof operator == "string" && operator[0] == "@" && operator != "@add_score" && operator != "@primesUpdate") {
            if (operator == "@repeat") { // Repeats the operations between the entry after "@repeat" and "@end-repeat". If the entry after "@repeat" is a number, that's how many times those operations are repeated (like a for loop); otherwise, it should be a CalcArray expression, and the repetition continues as long as that expression evaluates to true (like a while loop)
                if (typeof CalcArray(carr[2], vcoord, hcoord, vdir, hdir, addInfo, gri, parents, vars, globalVarStat) == "number") carr[2] = CalcArray(carr[2], vcoord, hcoord, vdir, hdir, addInfo, gri, parents, vars, globalVarStat);
                let nesting = 1;
                let position = 3;
                let nestarray = [];
                while (nesting > 0 && position < carr.length) {
                    let entry = carr[position];
                    nestarray.push(entry);
                    if (entry == "@repeat") nesting++;
                    else if (entry == "@end-repeat") nesting--;
                    else if (entry == "@end-stack") nesting = 0;
                    if (nesting == 0) nestarray.pop();
                    else position++;
                }
                while ((typeof carr[2] == "number" && carr[2] > 0) || (typeof carr[2] == "object" && CalcArray(carr[2], vcoord, hcoord, vdir, hdir, addInfo, gri, parents, vars, globalVarStat) === true)) {
                    let nestarray1 = compendiumStructuredClone(nestarray);
                    if (Array.isArray(n1)) n1.unshift("@Literal");
                    nestarray1.unshift("@var_retain", n1);
                    n1 = CalcArray(nestarray1, vcoord, hcoord, vdir, hdir, addInfo, gri, parents, vars, globalVarStat, false);
                    if (typeof carr[2] == "number") carr[2] -= 1;
                }
                to_pop = position;
            }
            else if (operator == "@if") { // The operations between the entry after "@if" and "@end_if" only occur if the entry after "@if" evaluates to true
                let nesting = 1;
                let position = 3;
                let nestarray = [];
                while (nesting > 0 && position < carr.length) {
                    let entry = carr[position];
                    nestarray.push(entry);
                    if (entry == "@if") nesting++;
                    else if (entry == "@end-if") nesting--;
                    else if (entry == "end-stack") nesting = 0;
                    if (nesting == 0) nestarray.pop();
                    else position++;
                }
                if (CalcArray(carr[2], vcoord, hcoord, vdir, hdir, addInfo, gri, parents, vars, globalVarStat) === true) {
                    if_skipped = false;
                    let nestarray1 = compendiumStructuredClone(nestarray);
                    if (Array.isArray(n1)) n1.unshift("@Literal");
                    nestarray1.unshift("@var_retain", n1);
                    n1 = CalcArray(nestarray1, vcoord, hcoord, vdir, hdir, addInfo, gri, parents, vars, globalVarStat, false);
                }
                else if_skipped = true;
                to_pop = position;
            }
            else if (operator == "@else") { // The operations between "@else" and "@end-else" only occur if an "@if" or an "@else-if" was just skipped
                let nesting = 1;
                let position = 2;
                let nestarray = [];
                while (nesting > 0 && position < carr.length) {
                    let entry = carr[position];
                    nestarray.push(entry);
                    if (entry == "@else") nesting++;
                    else if (entry == "@end-else") nesting--;
                    else if (entry == "end-stack") nesting = 0;
                    if (nesting == 0) nestarray.pop();
                    else position++;
                }
                if (if_skipped) {
                    let nestarray1 = compendiumStructuredClone(nestarray);
                    if (Array.isArray(n1)) n1.unshift("@Literal");
                    nestarray1.unshift("@var_retain", n1);
                    n1 = CalcArray(nestarray1, vcoord, hcoord, vdir, hdir, addInfo, gri, parents, vars, globalVarStat, false);
                }
                if_skipped = false;
                to_pop = position;
            }
            else if (operator == "@else-if") { // You can probably guess how this one works
                let nesting = 1;
                let position = 3;
                let nestarray = [];
                while (nesting > 0 && position < carr.length) {
                    let entry = carr[position];
                    nestarray.push(entry);
                    if (entry == "@else-if") nesting++;
                    else if (entry == "@end-else-if") nesting--;
                    else if (entry == "end-stack") nesting = 0;
                    if (nesting == 0) nestarray.pop();
                    else position++;
                }
                if (if_skipped) {
                    if (CalcArray(carr[2], vcoord, hcoord, vdir, hdir, addInfo, gri, parents, vars, globalVarStat) === true) {
                        if_skipped = false;
                        let nestarray1 = compendiumStructuredClone(nestarray);
                        if (Array.isArray(n1)) n1.unshift("@Literal");
                        nestarray1.unshift("@var_retain", n1);
                        n1 = CalcArray(nestarray1, vcoord, hcoord, vdir, hdir, addInfo, gri, parents, vars, globalVarStat, false);
                    }
                    else if_skipped = true;
                }
                to_pop = position;
            }
            else if (operator == "@edit_var") { // The entry after "@edit_var" is which variable to edit, the entry after that is what to change that variable to
                let vlocation = 0;
                vlocation = CalcArrayConvert(carr[2], "+", vcoord, hcoord, vdir, hdir, addInfo, gri, parents, vars, globalVarStat);
                n2 = CalcArrayConvert(carr[3], "=", vcoord, hcoord, vdir, hdir, addInfo, gri, parents, vars, globalVarStat);
                if (Array.isArray(n2)) n2.unshift("@Literal");
                if (vlocation % 1 == 0 && vlocation >= 0 && vlocation < vars.length) vars[vlocation] = n2;
                else if (vlocation % 1 == 0 && vlocation < 0 && vlocation >= vars.length * -1) vars[vars.length + vlocation] = n2;
                to_pop = 3;
            }
            else if (operator == "@add_var") { // Adds a new variable at the end of the variables array
                n2 = CalcArrayConvert(carr[2], "=", vcoord, hcoord, vdir, hdir, addInfo, gri, parents, vars, globalVarStat);
                if (Array.isArray(n2)) n2.unshift("@Literal");
                vars.push(n2);
                to_pop = 2;
            }
            else if (operator == "@insert_var") { // The entry after "@insert_var" is where to insert the new variable, the entry after that is the value of the new variable
                let vlocation = 0;
                vlocation = CalcArrayConvert(carr[2], "+", vcoord, hcoord, vdir, hdir, addInfo, gri, parents, vars, globalVarStat);
                n2 = CalcArrayConvert(carr[3], "=", vcoord, hcoord, vdir, hdir, addInfo, gri, parents, vars, globalVarStat);
                if (Array.isArray(n2)) n2.unshift("@Literal");
                vars.splice(vlocation, 0, n2);
                to_pop = 3;
            }
            else if (operator == "@remove_var") { // Removes the variable at the given position of the variables array
                let vlocation = 0;
                vlocation = CalcArrayConvert(carr[2], "+", vcoord, hcoord, vdir, hdir, addInfo, gri, parents, vars, globalVarStat);
                vars.splice(vlocation, 1);
                to_pop = 2;
            }
            else if (operator == "@edit_gvar") { // These next four do the same thing as the previous four, but on game_vars instead of the internal variables
                let vlocation = 0;
                vlocation = CalcArrayConvert(carr[2], "+", vcoord, hcoord, vdir, hdir, addInfo, gri, parents, vars, globalVarStat);
                n2 = CalcArrayConvert(carr[3], "=", vcoord, hcoord, vdir, hdir, addInfo, gri, parents, vars, globalVarStat);
                if (vlocation % 1 == 0 && vlocation >= 0 && vlocation < game_vars.length) game_vars[vlocation] = n2;
                else if (vlocation % 1 == 0 && vlocation < 0 && vlocation >= game_vars.length * -1) game_vars[game_vars.length + vlocation] = n2;
                to_pop = 3;
            }
            else if (operator == "@add_gvar") {
                n2 = CalcArrayConvert(carr[2], "=", vcoord, hcoord, vdir, hdir, addInfo, gri, parents, vars, globalVarStat);
                game_vars.push(n2);
                to_pop = 2;
            }
            else if (operator == "@insert_gvar") {
                let vlocation = 0;
                vlocation = CalcArrayConvert(carr[2], "+", vcoord, hcoord, vdir, hdir, addInfo, gri, parents, vars, globalVarStat);
                n2 = CalcArrayConvert(carr[3], "=", vcoord, hcoord, vdir, hdir, addInfo, gri, parents, vars, globalVarStat);
                game_vars.splice(vlocation, 0, n2);
                to_pop = 3;
            }
            else if (operator == "@remove_gvar") {
                let vlocation = 0;
                vlocation = CalcArrayConvert(carr[2], "+", vcoord, hcoord, vdir, hdir, addInfo, gri, parents, vars, globalVarStat);
                game_vars.splice(vlocation, 1);
                to_pop = 2;
            }
            else if (operator == "@edit_mvar") { // These four alter modifier_vars
                let vlocation = 0;
                vlocation = CalcArrayConvert(carr[2], "+", vcoord, hcoord, vdir, hdir, addInfo, gri, parents, vars, globalVarStat);
                n2 = CalcArrayConvert(carr[3], "=", vcoord, hcoord, vdir, hdir, addInfo, gri, parents, vars, globalVarStat);
                if (vlocation % 1 == 0 && vlocation >= 0 && vlocation < modifier_vars.length) modifier_vars[vlocation] = n2;
                else if (vlocation % 1 == 0 && vlocation < 0 && vlocation >= modifier_vars.length * -1) modifier_vars[modifier_vars.length + vlocation] = n2;
                to_pop = 3;
            }
            else if (operator == "@add_mvar") {
                n2 = CalcArrayConvert(carr[2], "=", vcoord, hcoord, vdir, hdir, addInfo, gri, parents, vars, globalVarStat);
                modifier_vars.push(n2);
                to_pop = 2;
            }
            else if (operator == "@insert_mvar") {
                let vlocation = 0;
                vlocation = CalcArrayConvert(carr[2], "+", vcoord, hcoord, vdir, hdir, addInfo, gri, parents, vars, globalVarStat);
                n2 = CalcArrayConvert(carr[3], "=", vcoord, hcoord, vdir, hdir, addInfo, gri, parents, vars, globalVarStat);
                modifier_vars.splice(vlocation, 0, n2);
                to_pop = 3;
            }
            else if (operator == "@remove_mvar") {
                let vlocation = 0;
                vlocation = CalcArrayConvert(carr[2], "+", vcoord, hcoord, vdir, hdir, addInfo, gri, parents, vars, globalVarStat);
                modifier_vars.splice(vlocation, 1);
                to_pop = 2;
            }
            else if (operator == "@edit_spawn") { // These four alter the spawning tiles
                let vlocation = 0;
                vlocation = CalcArrayConvert(carr[2], "+", vcoord, hcoord, vdir, hdir, addInfo, gri, parents, vars, globalVarStat);
                n2 = CalcArrayConvert(carr[3], "=", vcoord, hcoord, vdir, hdir, addInfo, gri, parents, vars, globalVarStat);
                if (vlocation % 1 == 0 && vlocation >= 0 && vlocation < TileSpawns.length) TileSpawns[vlocation] = n2;
                else if (vlocation % 1 == 0 && vlocation < 0 && vlocation >= TileSpawns.length * -1) TileSpawns[TileSpawns.length + vlocation] = n2;
                to_pop = 3;
            }
            else if (operator == "@add_spawn") {
                n2 = CalcArrayConvert(carr[2], "=", vcoord, hcoord, vdir, hdir, addInfo, gri, parents, vars, globalVarStat);
                TileSpawns.push(n2);
                to_pop = 2;
            }
            else if (operator == "@insert_spawn") {
                let vlocation = 0;
                vlocation = CalcArrayConvert(carr[2], "+", vcoord, hcoord, vdir, hdir, addInfo, gri, parents, vars, globalVarStat);
                n2 = CalcArrayConvert(carr[3], "=", vcoord, hcoord, vdir, hdir, addInfo, gri, parents, vars, globalVarStat);
                TileSpawns.splice(vlocation, 0, n2);
                to_pop = 3;
            }
            else if (operator == "@remove_spawn") {
                let vlocation = 0;
                vlocation = CalcArrayConvert(carr[2], "+", vcoord, hcoord, vdir, hdir, addInfo, gri, parents, vars, globalVarStat);
                TileSpawns.splice(vlocation, 1);
                to_pop = 2;
            }
            else if (operator == "@edit_forced_spawn") { // These four alter the forced spawns
                let vlocation = 0;
                vlocation = CalcArrayConvert(carr[2], "+", vcoord, hcoord, vdir, hdir, addInfo, gri, parents, vars, globalVarStat);
                n2 = CalcArrayConvert(carr[3], "=", vcoord, hcoord, vdir, hdir, addInfo, gri, parents, vars, globalVarStat);
                if (vlocation % 1 == 0 && vlocation >= 0 && vlocation < forcedSpawns.length) forcedSpawns[vlocation] = n2;
                else if (vlocation % 1 == 0 && vlocation < 0 && vlocation >= forcedSpawns.length * -1) forcedSpawns[forcedSpawns.length + vlocation] = n2;
                to_pop = 3;
            }
            else if (operator == "@add_forced_spawn") {
                n2 = CalcArrayConvert(carr[2], "=", vcoord, hcoord, vdir, hdir, addInfo, gri, parents, vars, globalVarStat);
                forcedSpawns.push(n2);
                to_pop = 2;
            }
            else if (operator == "@insert_forced_spawn") {
                let vlocation = 0;
                vlocation = CalcArrayConvert(carr[2], "+", vcoord, hcoord, vdir, hdir, addInfo, gri, parents, vars, globalVarStat);
                n2 = CalcArrayConvert(carr[3], "=", vcoord, hcoord, vdir, hdir, addInfo, gri, parents, vars, globalVarStat);
                forcedSpawns.splice(vlocation, 0, n2);
                to_pop = 3;
            }
            else if (operator == "@remove_forced_spawn") {
                let vlocation = 0;
                vlocation = CalcArrayConvert(carr[2], "+", vcoord, hcoord, vdir, hdir, addInfo, gri, parents, vars, globalVarStat);
                forcedSpawns.splice(vlocation, 1);
                to_pop = 2;
            }
            else if (operator == "@replace_tile") { // Changes a tile on the grid; the first two arguments are the coordinates of the tile, the third is the new value. The third argument can be any type so Empty and Void are accessible
                if (currentScreen == "Gameplay") {
                    let rvcoord = CalcArrayConvert(carr[2], "+", vcoord, hcoord, vdir, hdir, addInfo, gri, parents, vars, globalVarStat);
                    let rhcoord = CalcArrayConvert(carr[3], "+", vcoord, hcoord, vdir, hdir, addInfo, gri, parents, vars, globalVarStat);
                    n2 = CalcArrayConvert(carr[4], "=", vcoord, hcoord, vdir, hdir, addInfo, gri, parents, vars, globalVarStat);
                    Grid[rvcoord][rhcoord] = n2;
                }
                to_pop = 4;
            }
            else if (operator == "@run_script") {
                n2 = CalcArrayConvert(carr[2], "+", vcoord, hcoord, vdir, hdir, addInfo, gri, parents, vars, globalVarStat);
                CalcArray(scripts[n2][0], vcoord, hcoord, vdir, hdir, addInfo, gri, parents, compendiumStructuredClone(vars));
                to_pop = 2;
            }
        }
        else {
            if (pop_1_operators.indexOf(operator) > -1) {
                to_pop = 1;
                n2 = 0;
            }
            else if ((operator == "&&" && n1 === false) || (operator == "||" && n1 === true)) {
                to_pop = 2;
                n2 = n1;
            }
            else if (operator == "str_char" || operator == "arr_elem" || operator == "@add_score" || operator == "primeFactorizeB" || operator == "primeDefactorizeB") {
                to_pop = 2;
                n2 = CalcArrayConvert(carr[2], "+", vcoord, hcoord, vdir, hdir, addInfo, gri, parents, vars, globalVarStat);
            }
            else if (operator == "str_slice" || operator == "str_substr" || operator == "str_splice" || operator == "arr_splice" || operator == "arr_slice") {
                to_pop = 3;
                n2 = CalcArrayConvert(carr[2], "+", vcoord, hcoord, vdir, hdir, addInfo, gri, parents, vars, globalVarStat);
                additional_args.push(CalcArrayConvert(carr[3], "+", vcoord, hcoord, vdir, hdir, addInfo, gri, parents, vars, globalVarStat));
                if (operator == "str_splice" || operator == "arr_splice") {
                    to_pop = 4;
                    additional_args.push(CalcArrayConvert(carr[4], operator, vcoord, hcoord, vdir, hdir, addInfo, gri, parents, vars, globalVarStat));
                }
            }
            else if (operator == "str_indexOfFrom" || operator == "str_lastIndexOfFrom" || operator == "arr_indexOfFrom" || operator == "arr_lastIndexOfFrom" || operator == "announce") {
                to_pop = 2;
                n2 = CalcArrayConvert(carr[2], "=", vcoord, hcoord, vdir, hdir, addInfo, gri, parents, vars, globalVarStat);
                additional_args.push(CalcArrayConvert(carr[3], "+", vcoord, hcoord, vdir, hdir, addInfo, gri, parents, vars, globalVarStat));
            }
            else if (operator == "arr_edit_elem") {
                to_pop = 3;
                n2 = CalcArrayConvert(carr[2], "+", vcoord, hcoord, vdir, hdir, addInfo, gri, parents, vars, globalVarStat);
                additional_args.push(CalcArrayConvert(carr[3], "=", vcoord, hcoord, vdir, hdir, addInfo, gri, parents, vars, globalVarStat));
            }
            else if (operator == "arr_push" || operator == "arr_unshift" || operator == "str_indexOf" || operator == "arr_indexOf" || operator == "arr_binarySearch" || operator == "arr_binaryInsert") {
                to_pop = 2;
                n2 = CalcArrayConvert(carr[2], "=", vcoord, hcoord, vdir, hdir, addInfo, gri, parents, vars, globalVarStat);
            }
            else if (operator == "arr_sort" || operator == "arr_map" || operator == "arr_filter" || operator == "CalcArrayParent") {
                to_pop = 2;
                n2 = carr[2]; //n2 is supposed to be a valid CalcArray expression which will be evaluated by the operation, so no conversion yet
                additional_args.push([vcoord, hcoord, vdir, hdir, addInfo, gri, parents, compendiumStructuredClone(vars), globalVarStat]); //The CalcArray in operation will need these
            }
            else if (operator == "arr_reduce" || operator == "arr_reduceRight") {
                to_pop = 3;
                n2 = carr[3]; //n2 is supposed to be a valid CalcArray expression which will be evaluated by the operation, so no conversion yet
                additional_args.push([vcoord, hcoord, vdir, hdir, addInfo, gri, parents, compendiumStructuredClone(vars), globalVarStat]); //The CalcArray in operation will need these
                additional_args.push(CalcArrayConvert(carr[2], "=", vcoord, hcoord, vdir, hdir, addInfo, gri, parents, vars, globalVarStat)); //Initial value
            }
            else if (operator == "@primesUpdate" || operator == "**GB" || operator == "^GB" || operator == "**BR" || operator == "^BR" || operator == "perfectPowerFormBR") {
                to_pop = 2;
                n2 = CalcArrayConvert(carr[2], "+B", vcoord, hcoord, vdir, hdir, addInfo, gri, parents, vars, globalVarStat);
            }
            else if (operator == "basebit&B" || operator == "basebit|B" || operator == "basebit^B") {
                to_pop = 3;
                n2 = CalcArrayConvert(carr[2], "+B", vcoord, hcoord, vdir, hdir, addInfo, gri, parents, vars, globalVarStat);
                additional_args.push(CalcArrayConvert(carr[3], "+B", vcoord, hcoord, vdir, hdir, addInfo, gri, parents, vars, globalVarStat));
            }
            else if (operator == "DIVESeedUnlock") {
                to_pop = 3;
                n2 = CalcArrayConvert(carr[2], "arr_elem", vcoord, hcoord, vdir, hdir, addInfo, gri, parents, vars, globalVarStat);
                additional_args.push(CalcArrayConvert(carr[3], "+", vcoord, hcoord, vdir, hdir, addInfo, gri, parents, vars, globalVarStat));
            }
            else if (operator == "GaussianDIVESeedUnlock") {
                to_pop = 4;
                n2 = CalcArrayConvert(carr[2], "arr_elem", vcoord, hcoord, vdir, hdir, addInfo, gri, parents, vars, globalVarStat);
                additional_args.push(CalcArrayConvert(carr[3], "+", vcoord, hcoord, vdir, hdir, addInfo, gri, parents, vars, globalVarStat));
                additional_args.push(CalcArrayConvert(carr[4], "&&", vcoord, hcoord, vdir, hdir, addInfo, gri, parents, vars, globalVarStat));
            }
            else if (operator == "customDIVESeedUnlock") {
                to_pop = 11;
                n2 = CalcArrayConvert(carr[2], "=", vcoord, hcoord, vdir, hdir, addInfo, gri, parents, vars, globalVarStat);
                additional_args.push(CalcArrayConvert(carr[3], "+", vcoord, hcoord, vdir, hdir, addInfo, gri, parents, vars, globalVarStat));
                additional_args.push(carr[4], carr[5], carr[6], carr[7], carr[8], carr[9], carr[10], carr[11]); // Multiplication, division, modZero, sortFunc, coprime, one, valid, isOne
                additional_args.push([vcoord, hcoord, vdir, hdir, addInfo, gri, parents, compendiumStructuredClone(vars), globalVarStat]); //The CalcArrays in operation will need these
            }
            else if (operator == "CalcArray") {
                to_pop = 1;
                n2 = [vcoord, hcoord, vdir, hdir, addInfo, gri, parents, compendiumStructuredClone(vars), globalVarStat]; //The CalcArray in operation will need these
            }
            else if (operator == "evaluateColor") {
                to_pop = 1;
                n2 = [vcoord, hcoord, gri, compendiumStructuredClone(vars), globalVarStat]; //The CalcArray in operation will need these
            }
            else if (operator == "mergeRuleApplies" || operator == "mergeRuleApplies_nonRecursive") {
                to_pop = 2;
                n2 = CalcArrayConvert(carr[2], "+", vcoord, hcoord, vdir, hdir, addInfo, gri, parents, vars, globalVarStat);
                additional_args.push([vcoord, hcoord, vdir, hdir, addInfo, gri]); //The CalcArray in operation will need these
            }
            else {
                to_pop = 2;
                n2 = CalcArrayConvert(carr[2], operator, vcoord, hcoord, vdir, hdir, addInfo, gri, parents, vars, globalVarStat);
            }
            n1 = operation(n1, operator, n2, additional_args);
        }
        if (Array.isArray(n1)) n1.unshift("@Literal");
        carr[0] = n1;
        parents[parents.length - 1] = n1;
        carr.splice(1, to_pop);
    }
    carr[0] = CalcArrayConvert(carr[0], "=", vcoord, hcoord, vdir, hdir, addInfo, gri, parents, vars, globalVarStat);
    return carr[0];
}

function CalcArrayConvert(input, operator) { // Converts the input into a type based on the operator
    let vcoord = 0; let hcoord = 0; let vdir = 0; let hdir = 0; let addInfo = [1, Infinity, 0]; let gri = Grid; let parents = []; let vars = []; let globalVarStat = 0;
    if (arguments.length > 2) vcoord = arguments[2];
    if (arguments.length > 3) hcoord = arguments[3];
    if (arguments.length > 4) vdir = arguments[4];
    if (arguments.length > 5) hdir = arguments[5];
    if (arguments.length > 6) addInfo = arguments[6];
    if (arguments.length > 7) gri = arguments[7];
    if (arguments.length > 8) parents = arguments[8];
    if (arguments.length > 9) vars = arguments[9];
    if (arguments.length > 10) globalVarStat = arguments[10];
    let result = compendiumStructuredClone(input);
    do {
        if (Array.isArray(result)) {
            if (result[0] === "@Literal") {
                // CalcArrays assume that any arrays within them are also CalcArray expressions (making array brackets act sort of like parentheses). To get a CalcArray expression to work with an array inside it as an actual array, you have to put "@Literal" as the 0th entry of the array. CalcArray and CalcArrayString will do the rest to ensure that array stays as an actual array that doesn't actually include that "@Literal".
                for (let c = 1; c < result.length; c++) {
                    if (Array.isArray(result[c])) {
                        if (result[c][0] === "@CalcArray") {
                            result[c] = CalcArray(result[c].slice(1), vcoord, hcoord, vdir, hdir, addInfo, gri, parents, vars, globalVarStat); // Once you're in a literal array, the subarrays are considered literal too... unless their 0th entry is "@CalcArray", which indicates that, despite being inside a literal array, that subarray is to be evaluated as a CalcArray expression.
                        }
                        else {
                            result[c].unshift("@Literal");
                            result[c] = CalcArray(result[c], vcoord, hcoord, vdir, hdir, addInfo, gri, parents, vars, globalVarStat);
                        }
                    }
                }
                result = result.slice(1);
            }
            else result = CalcArray(result, vcoord, hcoord, vdir, hdir, addInfo, gri, parents, vars, globalVarStat);
        }
        if (any_operators.indexOf(operator) > -1) {
            if (typeof result == "string") result = CalcArrayString(result, vcoord, hcoord, vdir, hdir, addInfo, gri, parents, vars, globalVarStat);
        }
        else if (number_operators.indexOf(operator) > -1) {
            if (typeof result == "string") result = CalcArrayString(result, vcoord, hcoord, vdir, hdir, addInfo, gri, parents, vars, globalVarStat);
            result = Number(result);
            if (Number.isNaN(result)) result = 0;
        }
        else if (string_operators.indexOf(operator) > -1) {
            result = CalcArrayString(String(result), vcoord, hcoord, vdir, hdir, addInfo, gri, parents, vars, globalVarStat);
        }
        else if (boolean_operators.indexOf(operator) > -1) {
            if (typeof result == "string") result = CalcArrayString(result, vcoord, hcoord, vdir, hdir, addInfo, gri, parents, vars, globalVarStat);
            result = Boolean(result);
        }
        else if (array_operators.indexOf(operator) > -1) {
            if (typeof result == "string") result = CalcArrayString(result, vcoord, hcoord, vdir, hdir, addInfo, gri, parents, vars, globalVarStat);
            if (!(Array.isArray(result))) result = [result];
        }
        else if (bigint_operators.indexOf(operator) > -1) {
            if (typeof result == "string") result = CalcArrayString(result, vcoord, hcoord, vdir, hdir, addInfo, gri, parents, vars, globalVarStat);
            try {result = BigInt(result);}
            catch {
                try {result = BigInt(Math.round(result));}
                catch {result = 0n;}
            }
        }
        else if (gaussianbigint_operators.indexOf(operator) > -1) {
            if (typeof result == "string") result = CalcArrayString(result, vcoord, hcoord, vdir, hdir, addInfo, gri, parents, vars, globalVarStat);
            if (typeof result == "number" || typeof result == "bigint" || typeof result == "string" || result instanceof GaussianBigInt ||
                (Array.isArray(result) && result.length == 2 && (typeof result[0] == "number" || typeof result[0] == "bigint") && (typeof result[1] == "number" || typeof result[1] == "bigint"))
            ) {
                try {
                    result = new GaussianBigInt(result);
                }
                catch {
                    result = new GaussianBigInt(0n, 0n);
                }
            }
            else {result = new GaussianBigInt(0n, 0n);}
        }
        else if (bigrational_operators.indexOf(operator) > -1) {
            if (typeof result == "string") result = CalcArrayString(result, vcoord, hcoord, vdir, hdir, addInfo, gri, parents, vars, globalVarStat);
            if (typeof result == "number" || typeof result == "bigint" || typeof result == "string" || result instanceof BigRational ||
                (Array.isArray(result) && result.length == 2 && (typeof result[0] == "number" || typeof result[0] == "bigint") && (typeof result[1] == "number" || typeof result[1] == "bigint"))
            ) {
                try {
                    result = new BigRational(result);
                }
                catch {
                    result = new BigRational(0n, 0n);
                }
            }
            else {result = new BigRational(0n, 0n);}
        }
    } while (Array.isArray(result) && result[0] === "@Literal")
    return result;
}

function CalcArrayString(str) {
    // CalcArrays treat strings with an @ as their 0th character specially: these strings are used to indicate things, most commonly one of the values of a tile.
    let vcoord = 0; let hcoord = 0; let vdir = 0; let hdir = 0; let addInfo = [1, Infinity, 0]; let gri = Grid; let parents = []; let vars = []; let globalVarStat = 0;
    if (arguments.length > 1) vcoord = arguments[1];
    if (arguments.length > 2) hcoord = arguments[2];
    if (arguments.length > 3) vdir = arguments[3];
    if (arguments.length > 4) hdir = arguments[4];
    if (arguments.length > 5) addInfo = arguments[5];
    if (arguments.length > 6) gri = arguments[6];
    if (arguments.length > 7) parents = arguments[7];
    if (arguments.length > 8) vars = arguments[8];
    if (arguments.length > 9) globalVarStat = arguments[9];
    let result = str;
    if (str[0] != "@") return str;
    let split = str.split(" ");
    if (split.length < 3 && split[0] == "@This") { // "@This 0" refers to the 0th entry of the internal array of the tile being examined, "@This 1" is its first entry, and so on. "@This" without the number refers to the whole array of that tile.
        let gri_pos;
        if (vcoord == "None") gri_pos = gri;
        else if (hcoord == "None") gri_pos = gri[vcoord];
        else gri_pos = gri[vcoord][hcoord];
        if (split.length == 1) {
            result = compendiumStructuredClone(gri_pos);
            if (Array.isArray(result)) result.unshift("@Literal");
        }
        else {
            if (split[1] == "@VCoord") {
                return vcoord;
            }
            else if (split[1] == "@HCoord") {
                return hcoord;
            }
            else if (split[1] == "@Position") {
                return ["@Literal", vcoord, hcoord];
            }
            let tnum = Number(split[1]);
            if (!(Number.isNaN(tnum)) && tnum % 1 == 0 && tnum >= 0 && tnum < TileNumAmount) {
                if (typeof gri_pos == "string") result = gri_pos;
                else result = gri_pos[tnum];
            }
            else return str;
        }
    }
    else if (split.length < 5 && split[0] == "@Next") { // "@Next 1 0" is the 0th entry of the first "next" tile: if the movement direction is 1 tile to the left, then "@Next 1 0" is the 0th entry of the tile that's one tile to the left of the tile being examined. Primarily used in merge rules. "@Next 1" returns the entire first next tile, "@Next" returns all of the next tiles within the merge length.
        if (split.length == 1) {
            let nextv = vcoord + vdir;
            let nexth = hcoord + hdir;
            while (gri[nextv] !== undefined && gri[nextv][nexth] == "@Slippery") {
                nextv += vdir;
                nexth += hdir;
            }
            result = [];
            let tile = [];
            for (let t = 1; t < addInfo[0]; t++) {
                if (!(!(Number.isNaN(nextv)) && nextv % 1 == 0 && nextv >= 0 && nextv < height) || !(!(Number.isNaN(nexth)) && nexth % 1 == 0 && nexth >= 0 && nexth < width)) break;
                tile = compendiumStructuredClone(gri[nextv][nexth]);
                result.unshift(tile);
                nextv += vdir;
                nexth += hdir;
                while (gri[nextv] !== undefined && gri[nextv][nexth] == "@Slippery") {
                    nextv += vdir;
                    nexth += hdir;
                }
            }
            if (Array.isArray(result)) result.unshift("@Literal");
        }
        else {
            let traversed = 0;
            let distance = Math.abs(Number(split[1]));
            let sign = Math.sign(Number(split[1]));
            let nextv = vcoord;
            let nexth = hcoord;
            while (traversed < distance) {
                nextv += vdir * sign;
                nexth += hdir * sign;
                if (gri[nextv] === undefined || gri[nextv][nexth] === undefined) break;
                while (gri[nextv] !== undefined && gri[nextv][nexth] == "@Slippery") {
                    nextv += vdir * sign;
                    nexth += hdir * sign;
                }
                traversed++;
            }
            if (split.length == 2) {
                if (!(!(Number.isNaN(nextv)) && nextv % 1 == 0 && nextv >= 0 && nextv < height) || !(!(Number.isNaN(nexth)) && nexth % 1 == 0 && nexth >= 0 && nexth < width)) return str;
                result = compendiumStructuredClone(gri[nextv][nexth]);
                if (Array.isArray(result)) result.unshift("@Literal");
            }
            else {
                if (split[2] == "@VCoord") {
                    if (!(!(Number.isNaN(nextv)) && nextv % 1 == 0 && nextv >= 0 && nextv < height) || !(!(Number.isNaN(nexth)) && nexth % 1 == 0 && nexth >= 0 && nexth < width)) return str;
                    return nextv;
                }
                else if (split[2] == "@HCoord") {
                    if (!(!(Number.isNaN(nextv)) && nextv % 1 == 0 && nextv >= 0 && nextv < height) || !(!(Number.isNaN(nexth)) && nexth % 1 == 0 && nexth >= 0 && nexth < width)) return str;
                    return nexth;
                }
                else if (split[2] == "@Position") {
                    if (!(!(Number.isNaN(nextv)) && nextv % 1 == 0 && nextv >= 0 && nextv < height) || !(!(Number.isNaN(nexth)) && nexth % 1 == 0 && nexth >= 0 && nexth < width)) return str;
                    return ["@Literal", nextv, nexth];
                }
                let tnum = Number(split[2]);
                if (!(!(Number.isNaN(tnum)) && tnum % 1 == 0 && tnum >= 0 && tnum < TileNumAmount)) return str;
                if (split.length == 4) {
                    tnum = Number(split[3]);
                    if (!(!(Number.isNaN(tnum)) && tnum % 1 == 0 && tnum >= 0 && tnum < TileNumAmount)) return str;
                    let traversed = 0;
                    let distance = Math.abs(Number(split[3]));
                    let sign = Math.sign(Number(split[3]));
                    while (traversed < distance) {
                        nextv += hdir * sign;
                        nexth += -vdir * sign;
                        if (gri[nextv] === undefined || gri[nextv][nexth] === undefined) break;
                        while (gri[nextv] !== undefined && gri[nextv][nexth] == "@Slippery") {
                            nextv += hdir * sign;
                            nexth += -vdir * sign;
                        }
                        traversed++;
                    }
                }
                if (!(!(Number.isNaN(nextv)) && nextv % 1 == 0 && nextv >= 0 && nextv < height) || !(!(Number.isNaN(nexth)) && nexth % 1 == 0 && nexth >= 0 && nexth < width)) return str;
                if (typeof gri[nextv][nexth] == "string") result = gri[nextv][nexth];
                else result = gri[nextv][nexth][tnum];
            }
        }
    }
    else if (split.length < 4 && (split[0] == "@NextNE" || split[0] == "@NextFull")) { // "@NextNE 1 0" is like "@Next 1 0", but it skips over empty tiles. @NextFull skips over both empty and void tiles. Most commonly used for the purposes of using "@NextNE -1 0" to refer to the next non-empty tile BEHIND the current tile, such as preventing a two-tile merge if the tile behind the current tile would cause a three-tile merge, allowing the three-tile merge to take priority.
        let nextv = vcoord;
        let nexth = hcoord;
        if (split.length == 1) {
            let tiles_found = [];
            nextv += vdir;
            nexth += hdir;
            while ((!(Number.isNaN(nextv)) && nextv % 1 == 0 && nextv >= 0 && nextv < height) && (!(Number.isNaN(nexth)) && nexth % 1 == 0 && nexth >= 0 && nexth < width)) {
                if (gri[nextv][nexth] != "@Empty" && gri[nextv][nexth] != "@Slippery" && ((gri[nextv][nexth] != "@Void" && !gri[nextv][nexth].includes("@TemporaryHole")) || split[0] == "@NextNE")) tiles_found.push(gri[nextv][nexth]);
                nextv += vdir;
                nexth += hdir;
            }
            result = tiles_found;
        }
        else {
            let tiles_found = 0;
            while (tiles_found < Math.abs(split[1])) {
                if (split[1] < 0) {
                    nextv -= vdir;
                    nexth -= hdir;
                }
                else {
                    nextv += vdir;
                    nexth += hdir;
                }
                if (!(!(Number.isNaN(nextv)) && nextv % 1 == 0 && nextv >= 0 && nextv < height) || !(!(Number.isNaN(nexth)) && nexth % 1 == 0 && nexth >= 0 && nexth < width)) return str;
                if (gri[nextv][nexth] != "@Empty" && gri[nextv][nexth] != "@Slippery" &&  (gri[nextv][nexth] != "@Void" || split[0] == "@NextNE")) tiles_found++;
            }
            if (split.length == 2) {
                if (!(!(Number.isNaN(nextv)) && nextv % 1 == 0 && nextv >= 0 && nextv < height) || !(!(Number.isNaN(nexth)) && nexth % 1 == 0 && nexth >= 0 && nexth < width)) return str;
                result = compendiumStructuredClone(gri[nextv][nexth]);
                if (Array.isArray(result)) result.unshift("@Literal");
            }
            else {
                if (split[2] == "@VCoord") {
                    if (!(!(Number.isNaN(nextv)) && nextv % 1 == 0 && nextv >= 0 && nextv < height) || !(!(Number.isNaN(nexth)) && nexth % 1 == 0 && nexth >= 0 && nexth < width)) return str;
                    return nextv;
                }
                else if (split[2] == "@HCoord") {
                    if (!(!(Number.isNaN(nextv)) && nextv % 1 == 0 && nextv >= 0 && nextv < height) || !(!(Number.isNaN(nexth)) && nexth % 1 == 0 && nexth >= 0 && nexth < width)) return str;
                    return nexth;
                }
                else if (split[2] == "@Position") {
                    if (!(!(Number.isNaN(nextv)) && nextv % 1 == 0 && nextv >= 0 && nextv < height) || !(!(Number.isNaN(nexth)) && nexth % 1 == 0 && nexth >= 0 && nexth < width)) return str;
                    return ["@Literal", nextv, nexth];
                }
                let tnum = Number(split[2]);
                if (!(!(Number.isNaN(tnum)) && tnum % 1 == 0 && tnum >= 0 && tnum < TileNumAmount)) return str;
                if (typeof gri[nextv][nexth] == "string") result = gri[nextv][nexth];
                else result = gri[nextv][nexth][tnum];
            }
        }
    }
    else if (split.length < 5 && split[0] == "@Relative") { // "@Relative -3 1 2" is the 2nd entry of the tile that's 3 spaces up and 1 space to the right of the current tile
        let nextv = vcoord + Number(split[1]);
        let nexth = hcoord + Number(split[2]);
        if (!(!(Number.isNaN(nextv)) && nextv % 1 == 0 && nextv >= 0 && nextv < height) || !(!(Number.isNaN(nexth)) && nexth % 1 == 0 && nexth >= 0 && nexth < width)) return str;
        if (split.length == 3) {
            result = compendiumStructuredClone(gri[nextv][nexth]);
            if (Array.isArray(result)) result.unshift("@Literal");
        }
        else {
            let tnum = Number(split[3]);
            if (!(!(Number.isNaN(tnum)) && tnum % 1 == 0 && tnum >= 0 && tnum < TileNumAmount)) return str;
            if (typeof gri[nextv][nexth] == "string") result = gri[nextv][nexth];
            else result = gri[nextv][nexth][tnum];
        }
    }
    else if (split[0] == "@Grid") { // "@Grid 1 2 0" is the 0th entry of the tile in position [1, 2]. "@Grid 3 5" is the whole tile at position [3, 5], "@Grid 2" is the entire 2nd row of the grid, and "@Grid" is the whole grid, which is an array (grid) of arrays (rows) of arrays (tiles).
        result = Grid;
        for (let t = 1; t < split.length; t++) {
            if (!(Array.isArray(result))) break;
            let sn = Number(split[t]);
            if (!(!(Number.isNaN(sn)) && sn % 1 == 0 && sn >= 0)) break;
            if (result[sn] == undefined) break;
            result = result[sn];
        }
        result = compendiumStructuredClone(result);
        if (Array.isArray(result)) result.unshift("@Literal");
    }
    else if (split.length == 1 && split[0] == "@VCoord") { // Vertical coordinate of the current tile
        result = vcoord;
    }
    else if (split.length == 1 && split[0] == "@HCoord") { // Horizontal coordinate of the current tile
        result = hcoord;
    }
    else if (split.length == 1 && split[0] == "@VDir") { // Vertical movement magnitude
        result = vdir;
    }
    else if (split.length == 1 && split[0] == "@HDir") { // Horizontal movement magnitude
        result = hdir;
    }
    else if (split.length == 1 && split[0] == "@MLength") { // Length of the current merge
        result = addInfo[0];
    }
    else if (split.length == 1 && split[0] == "@SlideAmount") { // Slide amount of the movement direction
        result = addInfo[1];
    }
    else if (split.length == 1 && split[0] == "@MoveType") { // Move type of the movement direction
        result = addInfo[2];
    }
    else if (split.length == 1 && split[0] == "@TileContainer") { // Where is this tile? Usually returns the same as "@Grid", but can be different if, for example, we're looking at one of the next spawning tiles
        result = gri;
    }
    else if (split.length < 3 && split[0] == "@Parent") {  // "@Parent 0" is the first entry of the outermost CalcArray, "@Parent 1" is the first entry of the second-to-outermost CalcArray (that contains the current CalcArray), and so on. Uses .at for negative indices, so "@Parent -1" is the last entry of parents, i.e. the first entry of the current CalcArray.
        if (split.length == 1) result = parents;
        let tnum = Number(split[1]);
        let varn = parents.at(tnum);
        if (varn == undefined) return str;
        else result = CalcArray(varn, vcoord, hcoord, vdir, hdir, addInfo, gri, parents, vars, globalVarStat);
    }
    else if (split.length < 3 && split[0] == "@Var") { // "@Var 0" is the 0th variable. Also uses .at for negative indices.
        if (split.length == 1) result = vars;
        else {
            let tnum = Number(split[1]);
            let varn = vars.at(tnum);
            if (varn == undefined) return str;
            else result = varn;
        }
    }
    else if (split.length < 3 && split[0] == "@GVar") { // Like @Var, but for game_vars
        if (split.length == 1) result = game_vars;
        else {
            let tnum = Number(split[1]);
            let varn = game_vars.at(tnum);
            if (varn == undefined) return str;
            else result = varn;
        }
    }
    else if (split.length < 3 && split[0] == "@MVar") { // Like @Var, but for modifier_vars
        if (split.length == 1) result = modifier_vars;
        else {
            let tnum = Number(split[1]);
            let varn = modifier_vars.at(tnum);
            if (varn == undefined) return str;
            else result = varn;
        }
    }
    else if (split.length == 1 && split[0] == "@Score") {
        result = score;
    }
    else if (split.length == 1 && split[0] == "@Moves") {
        result = moves_so_far;
    }
    else if (split.length == 1 && split[0] == "@Merges") {
        result = merges_so_far;
    }
    else if (split.length == 1 && split[0] == "@MergeMoves") {
        result = moves_where_merged;
    }
    else if (split.length == 1 && split[0] == "@MergesBefore") {
        result = merges_before_now;
    }
    else if (split[0] == "@DiscTiles") { // "@DiscTiles 0" is the 0th discovered tile this game, "@DiscTiles 1 2" is the 2nd entry of the 1st discovered tile this game, and "@DiscTiles" is the whole array of discovered tiles
        result = discoveredTiles;
        for (let t = 1; t < split.length; t++) {
            if (!(Array.isArray(result))) break;
            let sn = Number(split[t]);
            if (!(!(Number.isNaN(sn)) && sn % 1 == 0 && sn >= 0)) break;
            if (result[sn] == undefined) break;
            result = result[sn];
        }
        result = compendiumStructuredClone(result);
        if (Array.isArray(result)) result.unshift("@Literal");
    }
    else if (split[0] == "@DiscWinning") { // Like @DiscTiles, but only including the tiles that are included in the win conditions
        result = discoveredWinning;
        for (let t = 1; t < split.length; t++) {
            if (!(Array.isArray(result))) break;
            let sn = Number(split[t]);
            if (!(!(Number.isNaN(sn)) && sn % 1 == 0 && sn >= 0)) break;
            if (result[sn] == undefined) break;
            result = result[sn];
        }
        result = compendiumStructuredClone(result);
        if (Array.isArray(result)) result.unshift("@Literal");
    }
    else if (split[0] == "@DiscLosing") { // Like @DiscTiles, but only including the tiles that are included in the loss conditions
        result = discoveredLosing;
        for (let t = 1; t < split.length; t++) {
            if (!(Array.isArray(result))) break;
            let sn = Number(split[t]);
            if (!(!(Number.isNaN(sn)) && sn % 1 == 0 && sn >= 0)) break;
            if (result[sn] == undefined) break;
            result = result[sn];
        }
        result = compendiumStructuredClone(result);
        if (Array.isArray(result)) result.unshift("@Literal");
    }
    else if (split[0] == "@NextSpawns") { // "@NextSpawns 0" is the next tile to spawn, "@NextSpawns 3 4" is the 4th entry of the 3rd tile to spawn after the next one
        result = spawnConveyor;
        for (let t = 1; t < split.length; t++) {
            if (!(Array.isArray(result))) break;
            let sn = Number(split[t]);
            if (!(!(Number.isNaN(sn)) && sn % 1 == 0 && sn >= 0)) break;
            if (result[sn] == undefined) break;
            result = result[sn];
        }
        result = compendiumStructuredClone(result);
        if (Array.isArray(result)) result.unshift("@Literal");
    }
    else if (split.length == 1 && split[0] == "@Primes") { // No need to support "@Primes 0" because there's already a CalcArray operator "prime"
        result = compendiumStructuredClone(primes);
        result.unshift("@Literal");
    }
    else return str;
    return compendiumStructuredClone(result);
}

function calcArrayReorder(arr, order) { // Changes which tiles the "@Next" strings target in accordance with the 7th entry of a MergeRule
    let vdir = 0; let hdir = 0;
    if (arguments.length > 2) vdir = arguments[2];
    if (arguments.length > 3) hdir = arguments[3];
    let carr = compendiumStructuredClone(arr);
    for (let e = 0; e < carr.length; e++) {
        let elem = carr[e];
        if (Array.isArray(elem)) elem = calcArrayReorder(elem, order, vdir, hdir);
        else if (typeof elem == "string" && elem[0] == "@") {
            let split = elem.split(" ");
            if (split.length == 2 && split[0] == "@This") {
                if (order[0] == 0) elem = "@This " + split[1];
                else elem = "@Next " + order[0] + " " + split[1];
            }
            else if (split.length == 1 && split[0] == "@This") {
                if (order[0] == 0) elem = "@This";
                else elem = "@Next " + order[0];
            }
            else if (split.length == 3 && (split[0] == "@Next" || split[0] == "@NextNE") && split[1] >= 0) {
                let position = split[1];
                elem = split[0] + " " + order[position] + " " + split[2];
            }
            else if (split.length == 2 && (split[0] == "@Next" || split[0] == "@NextNE") && split[1] >= 0) {
                let position = split[1];
                elem = split[0] + " " + order[position];
            }
            else if (split.length == 4 && split[0] == "@Relative") {
                elem = "@Relative " + (split[1] + vdir * order[0]) + " " + (split[2] + hdir * order[0]) + " " + split[3];
            }
        }
        carr[e] = elem;
    }
    return carr;
}

function calcArrayMergeOffset(arr, offset) { // Changes which tiles the "@Next" strings target in accordance with the amount of offset. Negatives become negative @NextNE's. Mainly used for custom modes.
    let vdir = 0; let hdir = 0; let original = true;
    if (arguments.length > 2) vdir = arguments[2];
    if (arguments.length > 3) hdir = arguments[3];
    if (arguments.length > 4) original = arguments[4];
    let carr = compendiumStructuredClone(arr);
    for (let e = 0; e < carr.length; e++) {
        let elem = carr[e];
        if (Array.isArray(elem)) elem = calcArrayMergeOffset(elem, offset, vdir, hdir, false);
        else if (typeof elem == "string" && elem[0] == "@") {
            let split = elem.split(" ");
            if (split.length == 2 && split[0] == "@This") {
                if (offset == 0) elem = "@This " + split[1];
                else if (offset < 0) elem = "@NextNE " + offset + " " + split[1];
                else if (offset > 0) elem = "@Next " + offset + " " + split[1];
            }
            else if (split.length == 3 && ((split[0] == "@Next" && split[1] >= 0) || (split[0] == "@NextNE" && split[1] <= 0))) {
                let position = Number(split[1]) + offset;
                if (position == 0) elem = "@This " + split[2];
                else if (position < 0) elem = "@NextNE " + position + " " + split[2];
                else if (position > 0) elem = "@Next " + position + " " + split[2];
            }
            else if (split.length == 4 && split[0] == "@Relative") {
                elem = "@Relative " + (split[1] + vdir * offset) + " " + (split[2] + hdir * offset) + " " + split[3];
            }
        }
        else if (elem == "mergeRuleApplies" || elem == "mergeRuleAppliesNonRecursive") {
            if (typeof carr[e + 1] == "number") carr[e + 1] += offset;
            else carr[e + 1] = [carr[e + 1], "+", offset]
        }
        carr[e] = elem; //Not sure why this line is needed, but it is.
    }
    return carr;
}

function removeMergeRuleApplies(rule) { // Replaces all "mergeRuleApplies" checks in an array with "false". Used for mergeRuleApplies_nonRecursive.
    rule = compendiumStructuredClone(rule);
    for (let i = rule.length - 1; i >= 0; i--) {
        if (Array.isArray(rule[i])) {
            rule[i] = removeMergeRuleApplies(rule[i]);
        }
        else if (rule[i] === "mergeRuleApplies" || rule[i] === "mergeRuleApplies_nonRecursive") {
            rule.splice(0, i + 2, false);
            break;
        }
    }
    return rule;
}

function evaluateColor(color) {
    /*
    Colors can appear in several forms in TileTypes: as a string like #f938ac, or as an array such as ["@RGBA", 255, 40, 20, 1]
    (which can come in RGBA, HSLA, or HSVA forms), and there can be gradients, which are arrays with each entry being either a color or a position in the gradient.
    */
    let vcoord = 0; let hcoord = 0; let gri = Grid; let vars = []; let globalVarStat = 0;
    if (arguments.length > 1) vcoord = arguments[1];
    if (arguments.length > 2) hcoord = arguments[2];
    if (arguments.length > 3) gri = arguments[3];
    if (arguments.length > 5) globalVarStat = arguments[5];
    if (color[0] == "@global_var_retain") globalVarStat = 1;
    else if (color[0] == "@global_var_copy") globalVarStat = -1;
    else if (color[0] == "@global_var_none") globalVarStat = 0;
    if ((arguments.length > 4 && color[0] === "@var_retain") || globalVarStat == 1) vars = arguments[4];
    else if ((arguments.length > 4 && color[0] === "@var_copy") || globalVarStat == -1) vars = compendiumStructuredClone(arguments[4]);
    if (vars === undefined) vars = [];
    if (color[0] == "@global_var_retain_inner") globalVarStat = 1;
    else if (color[0] == "@global_var_copy_inner") globalVarStat = -1;
    else if (color[0] == "@global_var_none_inner") globalVarStat = 0;
    color = compendiumStructuredClone(color);
    if (!(Array.isArray(color))) return color;
    if (color[0] === "@CalcArray") {
        color = CalcArray(color.slice(1), vcoord, hcoord, 0, 0, [1, Infinity, 0], gri, [], vars, globalVarStat);
    }
    while (color[0] === "@var_copy" || color[0] === "@var_retain" || color[0] === "@global_var_copy" || color[0] === "@global_var_retain" || color[0] == "@global_var_none" || color[0] === "@global_var_copy_inner" || color[0] === "@global_var_retain_inner" || color[0] == "@global_var_none_inner") color.shift();
    if (color[0] === "@include_gvars") {
        let newvars = compendiumStructuredClone(game_vars);
        for (let v = 0; v < newvars.length; v++) {
            newvars[v] = CalcArrayConvert(newvars[v], "=", vcoord, hcoord, 0, 0, [1, Infinity, 0], gri, [], vars, globalVarStat);
            if (Array.isArray(newvars[v])) newvars[v].unshift("@Literal");
            vars.push(newvars[v]);
        }
        color.shift();
    }
    if (color.indexOf("@end_vars") > -1) {
        let newvars = color.slice(0, color.indexOf("@end_vars"));
        for (let v = 0; v < newvars.length; v++) {
            newvars[v] = CalcArrayConvert(newvars[v], "=", vcoord, hcoord, 0, 0, [1, Infinity, 0], gri, [], vars, globalVarStat);
            if (Array.isArray(newvars[v])) newvars[v].unshift("@Literal");
            vars.push(newvars[v]);
        }
        color.splice(0, color.indexOf("@end_vars") + 1);
    }
    if (color[0] === "@HSLA") {
        let hue = CalcArray(color[1], vcoord, hcoord, 0, 0, [1, Infinity, 0], gri, [], vars, globalVarStat);
        let saturation = CalcArray(color[2], vcoord, hcoord, 0, 0, [1, Infinity, 0], gri, [], vars, globalVarStat);
        let brightness = CalcArray(color[3], vcoord, hcoord, 0, 0, [1, Infinity, 0], gri, [], vars, globalVarStat);
        let alpha = CalcArray(color[4], vcoord, hcoord, 0, 0, [1, Infinity, 0], gri, [], vars, globalVarStat);
        return "hsla(" + hue + ", " + saturation + "%, " + brightness + "%, " + alpha + ")";
    }
    else if (color[0] === "@HSVA") { //HSV to HSL conversion found on Wikipedia
        let hue = CalcArray(color[1], vcoord, hcoord, 0, 0, [1, Infinity, 0], gri, [], vars, globalVarStat);
        let HSVsaturation = CalcArray(color[2], vcoord, hcoord, 0, 0, [1, Infinity, 0], gri, [], vars, globalVarStat) / 100;
        let HSVvalue = CalcArray(color[3], vcoord, hcoord, 0, 0, [1, Infinity, 0], gri, [], vars, globalVarStat) / 100;
        let brightness = HSVvalue * (1 - (HSVsaturation / 2));
        let saturation = 0;
        if (!(brightness == 0 || brightness == 1)) saturation = (HSVvalue - brightness)/Math.min(brightness, 1 - brightness);
        brightness *= 100; saturation *= 100;
        let alpha = CalcArray(color[4], vcoord, hcoord, 0, 0, [1, Infinity, 0], gri, [], vars, globalVarStat);
        return "hsla(" + hue + ", " + saturation + "%, " + brightness + "%, " + alpha + ")"
    }
    else if (color[0] === "@RGBA") {
        let red = CalcArray(color[1], vcoord, hcoord, 0, 0, [1, Infinity, 0], gri, [], vars, globalVarStat);
        let green = CalcArray(color[2], vcoord, hcoord, 0, 0, [1, Infinity, 0], gri, [], vars, globalVarStat);
        let blue = CalcArray(color[3], vcoord, hcoord, 0, 0, [1, Infinity, 0], gri, [], vars, globalVarStat);
        let alpha = CalcArray(color[4], vcoord, hcoord, 0, 0, [1, Infinity, 0], gri, [], vars, globalVarStat);
        return "rgba(" + red + ", " + green + ", " + blue+ ", " + alpha + ")"
    }
    else if (color[0] === "@linear-gradient" || color[0] === "@radial-gradient" || color[0] === "@conic-gradient" || color[0] === "@repeating-linear-gradient" || color[0] === "@repeating-radial-gradient" || color[0] === "@repeating-conic-gradient") {
        let grad = color[0].slice(1) + "("
        let i = 1;
        while (i < color.length) {
            if (typeof color[i] == "number" || (Array.isArray(color[i]) && color[i][0] == "@CalcArrayNumber")) { // Strings and arrays in a gradient array represent colors, but numbers represent positions in the gradient...
                let position = (typeof color[i] == "number") ? color[i] : CalcArray(color[i].slice(1), vcoord, hcoord, 0, 0, [1, Infinity, 0], gri, [], vars, globalVarStat)
                if (i == 1) { // ...unless it's the very first entry after the type of gradient, in which case it's the angle of the gradient.
                    if (color[0] === "@conic-gradient" || color[0] === "@repeating-radial-gradient" || color[0] === "@repeating-conic-gradient") grad += "from "
                    grad += position;
                    grad += "deg";
                }
                else {
                    grad += " ";
                    if (hexagonal && (color[0] == "@linear-gradient" || color[0] == "@repeating-linear-gradient")) grad += (50 + ((position - 50) * Math.sqrt(3) / 2));
                    else if (hexagonal && (color[0] == "@radial-gradient" || color[0] == "@repeating-radial-gradient")) grad += (position * 0.75);
                    else grad += position;
                    if (color[0] == "@conic-gradient" || color[0] == "@repeating-conic-gradient") grad += "deg";
                    else grad += "%";
                }
            }
            else {
                if (i > 1) grad += ", ";
                grad += evaluateColor(color[i], vcoord, hcoord, gri, vars, globalVarStat);
            }
            i++;
        }
        grad += ")";
        return grad;
    }
    else if (color[0] === "@multi-gradient") { // Now each entry is itself a gradient, with multiple gradients stacked
        let result = "";
        let i = 1;
        while (i < color.length) {
            result += evaluateColor(color[i], vcoord, hcoord, gri, vars, globalVarStat);
            if (i < color.length - 1) result += ", ";
            i++;
        }
        return result;
    }
    else if (color[0] === "@rotate") {
        color[1] = CalcArray(color[1], vcoord, hcoord, 0, 0, [1, Infinity, 0], gri, [], vars, globalVarStat);
        color[2] = CalcArray(color[2], vcoord, hcoord, 0, 0, [1, Infinity, 0], gri, [], vars, globalVarStat);
        let rotated = rotateColor(color[3], color[1], color[2], vcoord, hcoord, gri, vars, globalVarStat);
        return evaluateColor(rotated, vcoord, hcoord, gri, vars, globalVarStat);
    }
    else return evaluateColor(CalcArray(color, vcoord, hcoord, 0, 0, [1, Infinity, 0], gri, [], vars, globalVarStat), vcoord, hcoord, gri, vars, globalVarStat);
}

function convertColor(col, system) { // Converts colors between systems; mostly useful because rotateColor prefers HSLA colors
    let vcoord = 0; let hcoord = 0; let gri = Grid; let vars = []; let globalVarStat = 0;
    if (arguments.length > 2) vcoord = arguments[2];
    if (arguments.length > 3) hcoord = arguments[3];
    if (arguments.length > 4) gri = arguments[4];
    if (arguments.length > 5) vars = arguments[5];
    if (arguments.length > 6) globalVarStat = arguments[6];
    let color = compendiumStructuredClone(col);
    if (Array.isArray(color) && (color[0] == "@linear-gradient" || color[0] == "@radial-gradient" || color[0] == "@conic-gradient" || color[0] == "@repeating-linear-gradient" || color[0] == "@repeating-radial-gradient" || color[0] == "@repeating-conic-gradient" || color[0] == "@multi-gradient")) {
        for (let i = 1; i < color.length; i++) {
            if (Array.isArray(color[i]) || (typeof color[i] == "string" && color[i][0] == "#")) color[i] = convertColor(color[i], system, vcoord, hcoord, gri, vars);
        }
        return color;
    }
    else {
        let colorarray = [];
        if (Array.isArray(color) && !(color[0] == "@RGBA" || color[0] == "@HSLA" || color[0] == "@HSVA")) color = evaluateColor(color, vcoord, hcoord, gri, vars, globalVarStat);
        if (Array.isArray(color) && (color[0] == "@RGBA" || color[0] == "@HSLA" || color[0] == "@HSVA")) colorarray = color;
        else if (typeof color == "string" && color[0] == "#") { //Any hex colors are converted to RGBA arrays first
            if (system == "@Hex") return color;
            if (color.length == 7 || color.length == 9) {
                let red = parseInt((color[1] + color[2]), 16);
                let green = parseInt((color[3] + color[4]), 16);
                let blue = parseInt((color[5] + color[6]), 16);
                let alpha = 1;
                if (color.length == 9) alpha = parseInt((color[7] + color[8]), 16)/255;
                colorarray = ["@RGBA", red, green, blue, alpha];
            }
            else if (color.length == 4 || color.length == 5) {
                let red = parseInt((color[1] + color[1]), 16);
                let green = parseInt((color[2] + color[2]), 16);
                let blue = parseInt((color[3] + color[3]), 16);
                let alpha = 1;
                if (color.length == 5) alpha = parseInt((color[4] + color[4]), 16)/255;
                colorarray = ["@RGBA", red, green, blue, alpha];
            }
        }
        if (system == "@Hex") {
            colorarray = convertColor(color, "@RGBA", vcoord, hcoord, gri, vars);
            let hexcode = "#";
            let currentString = "";
            currentString = Math.min(Math.max(Math.round(colorarray[1]), 0), 255).toString(16);
            if (currentString.length == 1) currentString = "0" + currentString;
            hexcode += currentString;
            currentString = Math.min(Math.max(Math.round(colorarray[2]), 0), 255).toString(16);
            if (currentString.length == 1) currentString = "0" + currentString;
            hexcode += currentString;
            currentString = Math.min(Math.max(Math.round(colorarray[3]), 0), 255).toString(16);
            if (currentString.length == 1) currentString = "0" + currentString;
            hexcode += currentString;
            if (colorarray[4] < 1) {
                currentString = Math.min(Math.max(Math.round(colorarray[4] * 255), 0), 255).toString(16);
                if (currentString.length == 1) currentString = "0" + currentString;
                hexcode += currentString;
            }
            return hexcode;
        }
        if (Array.isArray(colorarray) && (colorarray[0] == "@RGBA" || colorarray[0] == "@HSLA" || colorarray[0] == "@HSVA")) {
            let e1 = CalcArray(colorarray[1], vcoord, hcoord, 0, 0, [1, Infinity, 0], gri, [], vars, globalVarStat);
            let e2 = CalcArray(colorarray[2], vcoord, hcoord, 0, 0, [1, Infinity, 0], gri, [], vars, globalVarStat);
            let e3 = CalcArray(colorarray[3], vcoord, hcoord, 0, 0, [1, Infinity, 0], gri, [], vars, globalVarStat);
            let e4 = CalcArray(colorarray[4], vcoord, hcoord, 0, 0, [1, Infinity, 0], gri, [], vars, globalVarStat);
            //Conversion formulas are from the subpages of https://www.rapidtables.com/convert/color/
            if (colorarray[0] == "@RGBA" && system == "@HSLA") {
                let rprime = Math.min(Math.max(e1 / 255, 0), 1);
                let gprime = Math.min(Math.max(e2 / 255, 0), 1);
                let bprime = Math.min(Math.max(e3 / 255, 0), 1);
                let cmax = Math.max(rprime, gprime, bprime);
                let cmin = Math.min(rprime, gprime, bprime);
                let delta = cmax - cmin;
                let hue = 0;
                let saturation = 0;
                let lightness = (cmax + cmin) / 2;
                if (delta != 0) {
                    saturation = delta / (1 - Math.abs(lightness * 2 - 1));
                    if (cmax == rprime) hue = 60 * (((gprime - bprime) / delta + 6) % 6);
                    else if (cmax == gprime) hue = 60 * (((bprime - rprime) / delta) + 2);
                    else if (cmax == bprime) hue = 60 * (((rprime - gprime) / delta) + 4);
                }
                colorarray = ["@HSLA", hue, saturation * 100, lightness * 100, e4];
            }
            else if (colorarray[0] == "@RGBA" && system == "@HSVA") {
                let rprime = Math.min(Math.max(e1 / 255, 0), 1);
                let gprime = Math.min(Math.max(e2 / 255, 0), 1);
                let bprime = Math.min(Math.max(e3 / 255, 0), 1);
                let cmax = Math.max(rprime, gprime, bprime);
                let cmin = Math.min(rprime, gprime, bprime);
                let delta = cmax - cmin;
                let hue = 0;
                let saturation = 0;
                let value = cmax;
                if (delta != 0) {
                    saturation = delta / cmax;
                    if (cmax == rprime) hue = 60 * (((gprime - bprime) / delta + 6) % 6);
                    else if (cmax == gprime) hue = 60 * (((bprime - rprime) / delta) + 2);
                    else if (cmax == bprime) hue = 60 * (((rprime - gprime) / delta) + 4);
                }
                colorarray = ["@HSVA", hue, saturation * 100, value * 100, e4];
            }
            else if (colorarray[0] == "@HSLA" && system == "@RGBA") {
                let hue = mod(e1, 360);
                let saturation = Math.min(Math.max(e2 / 100, 0), 1);
                let lightness = Math.min(Math.max(e3 / 100, 0), 1);
                let c = saturation * (1 - Math.abs(2 * lightness - 1));
                let x = c * (1 - Math.abs(((hue / 60) % 2) - 1))
                let m = lightness - c/2;
                let r = 0; let g = 0; let b = 0;
                if (hue >= 0 && hue < 60) {r = c; g = x;}
                else if (hue >= 60 && hue < 120) {r = x; g = c;}
                else if (hue >= 120 && hue < 180) {b = x; g = c;}
                else if (hue >= 180 && hue < 240) {b = c; g = x;}
                else if (hue >= 240 && hue < 300) {b = c; r = x;}
                else if (hue >= 300 && hue < 360) {b = x; r = c;}
                colorarray = ["@RGBA", 255 * (r + m), 255 * (g + m), 255 * (b + m), e4];
            }
            else if (colorarray[0] == "@HSLA" && system == "@HSVA") {
                let hue = mod(e1, 360);
                let saturationL = Math.min(Math.max(e2 / 100, 0), 1);
                let lightness = Math.min(Math.max(e3 / 100, 0), 1);
                let value = lightness + saturationL * Math.min(lightness, 1 - lightness);
                let saturationV = 0;
                if (value != 0) saturationV = 2 * (1 - lightness/value);
                colorarray = ["@HSVA", hue, saturationV * 100, value * 100, e4];
            }
            else if (colorarray[0] == "@HSVA" && system == "@RGBA") {
                let hue = mod(e1, 360);
                let saturation = Math.min(Math.max(e2 / 100, 0), 1);
                let value = Math.min(Math.max(e3 / 100, 0), 1);
                let c = value * saturation;
                let x = c * (1 - Math.abs(((hue / 60) % 2) - 1))
                let m = value - c;
                let r = 0; let g = 0; let b = 0;
                if (hue >= 0 && hue < 60) {r = c; g = x;}
                else if (hue >= 60 && hue < 120) {r = x; g = c;}
                else if (hue >= 120 && hue < 180) {b = x; g = c;}
                else if (hue >= 180 && hue < 240) {b = c; g = x;}
                else if (hue >= 240 && hue < 300) {b = c; r = x;}
                else if (hue >= 300 && hue < 360) {b = x; r = c;}
                colorarray = ["@RGBA", 255 * (r + m), 255 * (g + m), 255 * (b + m), e4];
            }
            else if (colorarray[0] == "@HSVA" && system == "@HSLA") {
                let hue = mod(e1, 360);
                let saturationV = Math.min(Math.max(e2 / 100, 0), 1);
                let value = Math.min(Math.max(e3 / 100, 0), 1);
                let lightness = value * (1 - saturationV / 2);
                let saturationL = 0;
                if (lightness % 1 != 0) saturationL = (value - lightness)/Math.min(lightness, 1 - lightness);
                colorarray = ["@HSLA", hue, saturationL * 100, lightness * 100, e4];
            }
            else colorarray = [colorarray[0], e1, e2, e3, e4];
        }
        return colorarray;
    }
}

function rotateColor(color, degrees) { //degrees = 180 gives the complementary color
    let invertL = false; let vcoord = 0; let hcoord = 0; let gri = Grid; let vars = []; let globalVarStat = 0;
    if (arguments.length > 2) invertL = arguments[2]; // If this is true, then the lightness of the color is inverted
    if (arguments.length > 3) vcoord = arguments[3];
    if (arguments.length > 4) hcoord = arguments[4];
    if (arguments.length > 5) gri = arguments[5];
    if (arguments.length > 6) vars = arguments[6];
    if (arguments.length > 7) globalVarStat = arguments[7];
    let colorcopy = compendiumStructuredClone(color);
    if (Array.isArray(color) && (color[0] == "@linear-gradient" || color[0] == "@radial-gradient" || color[0] == "@conic-gradient" || color[0] == "@repeating-linear-gradient" || color[0] == "@repeating-radial-gradient" || color[0] == "@repeating-conic-gradient" || color[0] == "@multi-gradient")) {
        for (let i = 1; i < color.length; i++) {
            if (Array.isArray(colorcopy[i]) || (typeof colorcopy[i] == "string" && colorcopy[i][0] == "#")) colorcopy[i] = rotateColor(colorcopy[i], degrees, invertL, vcoord, hcoord, gri, vars, globalVarStat);
        }
        return colorcopy;
    }
    else {
        colorcopy = convertColor(colorcopy, "@HSLA", vcoord, hcoord, gri, vars, globalVarStat);
        colorcopy[1] += degrees;
        if (invertL) colorcopy[3] = 100 - colorcopy[3];
        return colorcopy;
    }
}

function evaluateMergeRule(rule) { // This does not actually evaluate whether a merge rule is currently applicable, it just turns the merge rule into a state such that CalcArray can do its job.
    let vcoord = 0; let hcoord = 0; let vdir = 0; let hdir = 0; let addInfo = [1, Infinity, 0]; let gri = Grid; let vars = []; let globalVarStat = 0;
    if (arguments.length > 1) vcoord = arguments[1];
    if (arguments.length > 2) hcoord = arguments[2];
    if (arguments.length > 3) vdir = arguments[3];
    if (arguments.length > 4) hdir = arguments[4];
    if (arguments.length > 5) addInfo = arguments[5];
    if (arguments.length > 6) gri = arguments[6];
    if (arguments.length > 8) globalVarStat = arguments[7];
    if (rule[0] == "@global_var_retain") globalVarStat = 1;
    else if (rule[0] == "@global_var_copy") globalVarStat = -1;
    else if (rule[0] == "@global_var_none") globalVarStat = 0;
    if ((arguments.length > 7 && rule[0] === "@var_retain") || globalVarStat == 1) vars = arguments[7];
    else if ((arguments.length > 7 && rule[0] === "@var_copy") || globalVarStat == -1) vars = compendiumStructuredClone(arguments[7]);
    if (vars === undefined) vars = [];
    if (rule[0] == "@global_var_retain_inner") globalVarStat = 1;
    else if (rule[0] == "@global_var_copy_inner") globalVarStat = -1;
    else if (rule[0] == "@global_var_none_inner") globalVarStat = 0;
    let crule = compendiumStructuredClone(rule);
    while (crule[0] === "@var_copy" || crule[0] === "@var_retain" || crule[0] === "@global_var_copy" || crule[0] === "@global_var_retain" || crule[0] == "@global_var_none" || crule[0] === "@global_var_copy_inner" || crule[0] === "@global_var_retain_inner" || crule[0] == "@global_var_none_inner") crule.shift();
    if (crule[0] === "@include_gvars") {
        let newvars = compendiumStructuredClone(game_vars);
        for (let v = 0; v < newvars.length; v++) {
            newvars[v] = CalcArrayConvert(newvars[v], "=", vcoord, hcoord, vdir, hdir, addInfo, gri, [], vars, globalVarStat);
            if (Array.isArray(newvars[v])) newvars[v].unshift("@Literal");
            vars.push(newvars[v]);
        }
        crule.shift();
    }
    if (crule.indexOf("@end_vars") > -1) {
        let newvars = crule.slice(0, crule.indexOf("@end_vars"));
        for (let v = 0; v < newvars.length; v++) {
            newvars[v] = CalcArrayConvert(newvars[v], "=", vcoord, hcoord, vdir, hdir, addInfo, gri, [], vars, globalVarStat);
            if (Array.isArray(newvars[v])) newvars[v].unshift("@Literal");
            vars.push(newvars[v]);
        }
        crule.splice(0, crule.indexOf("@end_vars") + 1);
    }
    let rlength = CalcArray(crule[0], vcoord, hcoord, vdir, hdir, addInfo, gri, [], vars, globalVarStat);
    if (typeof rlength == "number") crule[0] = rlength;
    else crule[0] = 1;
    if (crule.length == 5 || crule[5].length == 0) {
        let mergeable = [];
        for (let i = 0; i < crule[3].length; i++) mergeable.push(false);
        for (let i = crule[3].length; i < rlength; i++) mergeable.push(true);
        if (crule.length == 5) crule.push(mergeable);
        else crule[5] = mergeable;
    }
    if (crule[0] == 0) {
        if (vars.length > 0) return vars.concat("@end_vars", crule);
        else return crule;
    }
    if (crule[3].indexOf("fill") > -1) {
        let fillArray = crule[3].slice(crule[3].indexOf("fill") + 1);
        crule[3] = crule[3].slice(0, crule[3].indexOf("fill"));
        let i = 0;
        while (crule[3].length < rlength) {
            crule[3].push(fillArray[i]);
            i++;
            if (i >= fillArray.length) i = 0;
        }
    }
    if (crule.length < 8) {
        if (vars.length > 0) return vars.concat("@end_vars", crule);
        else return crule;
    }
    if (crule[6] >= rlength) {
        if (vars.length > 0) return vars.concat("@end_vars", crule);
        else return crule;
    }
    let baserule = crule[1];
    let mergereqs = ["@var_retain", baserule];
    let entry = 0;
    while (crule[6] < rlength) {
        entry++;
        crule[6] += crule[8];
        mergereqs.push("&&");
        let orders = compendiumStructuredClone(crule[7]);
        for (let e = 0; e < orders.length; e++) {
            orders[e] = CalcArray([orders[e], "*", entry, "+", e], vcoord, hcoord, vdir, hdir, [rlength, addInfo[1], addInfo[2]], gri, [], vars, globalVarStat);
            if (typeof orders[e] != "number") orders[e] = e;
        }
        mergereqs.push(calcArrayReorder(baserule, orders));
    }
    crule[1] = mergereqs;
    if (vars.length > 0) return vars.concat("@end_vars", crule);
    else return crule;
}

// More advanced number functions

function primeFactorize(num, prime_amount = Infinity, reverse = false, return_form = 0, leftover_sub1 = true) {
    try {
        num = BigInt(num);
    }
    catch {
        num = 1n;
    }
    num = abs(num);
    if (num == 0n) return [[]];
    let altPrimes;
    if (typeof prime_amount == "number") {
        altPrimes = primes.slice(0, prime_amount);
    }
    else altPrimes = prime_amount;
    let leftover = num;
    let factors = [[]];
    if (reverse) {
        if (typeof prime_amount == "number") {
            while (primes.length < prime_amount && primes[primes.length - 1] < num) primesUpdate(primes[primes.length - 1] * 2n);
            altPrimes = primes.slice(0, prime_amount);
        }
        for (let p = altPrimes.length - 1; p > -1; p--) {
            factors[0].unshift(0n);
            while (leftover % altPrimes[p] == 0n) {
                factors[0][0]++;
                leftover /= altPrimes[p];
            }
        } 
    }
    else for (let p = 0; p < altPrimes.length; p++) {
        factors[0].push(0n);
        while (leftover % altPrimes[p] == 0n) {
            factors[0][p]++;
            leftover /= altPrimes[p];
        }
        if (leftover == 1n) break;
        if (p == altPrimes.length - 1 && typeof prime_amount == "number") {
            if (prime_amount == Infinity && leftover <= altPrimes[altPrimes.length - 1] ** 2n && (return_form == 1 || return_form == 2)) break;
            primesUpdate(altPrimes[altPrimes.length - 1] * 2n);
            altPrimes = primes.slice(0, prime_amount);
        }
    }
    // Return form 0 means "list of exponents", so 84 becomes [[2, 1, 0, 1]].
    // Return form 1 means "pairs of the prime and its exponent", so 84 becomes [[[2n, 2], [3n, 1], [7n, 1]]]
    // Return form 2 means "list each prime", so 84 becomes [[2n, 2n, 3n, 7n]]
    if (return_form == 1) {
        let reformed = [];
        for (let p = 0; p < factors[0].length; p++) {
            if (factors[0][p] > 0) reformed.push([altPrimes[p], factors[0][p]]);
        }
        if (prime_amount == Infinity && leftover > 1n) {
            reformed.push([leftover, 1n]);
            leftover = 1n;
        }
        factors[0] = reformed;
    }
    else if (return_form == 2) {
        let reformed = [];
        for (let p = 0; p < factors[0].length; p++) {
            for (let e = 0; e < factors[0][p]; e++) {
                reformed.push(altPrimes[p]);
            }
        }
        if (prime_amount == Infinity && leftover > 1n) {
            reformed.push(leftover);
            leftover = 1n;
        }
        factors[0] = reformed;
    }
    if (leftover > 1n) {
        if (leftover_sub1) {
            leftover -= 1n;
            factors = factors.concat(primeFactorize(leftover, altPrimes, reverse, return_form, true));
        }
        else factors.push(leftover);
    }
    return factors;
}

function primeDefactorize(num, return_form = 0) {
    let result = 1n;
    let altPrimes = primes;
    if (arguments.length > 2) altPrimes = arguments[2];
    if (!(Array.isArray(num[0]))) num = [num];
    for (i = num.length - 1; i >= 0; i--) {
        if (Array.isArray(num[i])) {
            if (return_form == 1 || return_form == 2) {
                for (p = 0; p < num[i].length; p++) {
                    if (return_form == 1) result *= num[i][p][0] ** num[i][p][1];
                    else if (return_form == 2) result *= num[i][p];
                }
            }
            else {
                while (altPrimes.length < num[i].length) {
                    if (arguments.length <= 2) {
                        primesUpdate(primes[primes.length - 1] * 2n);
                        altPrimes = primes;
                    }
                    else throw new Error("Not enough primes provided");
                }
                for (p = 0; p < num[i].length; p++) {
                    result *= altPrimes[p] ** num[i][p];
                }
            }
            if (i > 0) result += 1n;
        }
        else result *= num[i];
    }
    return result;
}

function gaussian_primeFactorize(num, prime_amount) {
    try {
        num = new GaussianBigInt(num);
    }
    catch {
        num = new GaussianBigInt(1n, 0n);
    }
    while (gaussian_primes[gaussian_primes.length - 1].norm() < num.norm() && gaussian_primes.length < prime_amount) gaussianPrimesUpdate(gaussian_primes[gaussian_primes.length - 1].norm() * 2n);
    let leftover = num;
    let product = new GaussianBigInt(1n, 0n);
    let factors = [[]];
    for (let p = 0; p < prime_amount; p++) {
        factors[0].push(0n);
        while (leftover.mod(gaussian_primes[p]).eq([0n, 0n])) {
            factors[0][p]++;
            product = product.mul(gaussian_primes[p]);
            leftover = leftover.div(gaussian_primes[p]);
        }
        if (leftover.norm() == 1n) break;
    }
    factors.push(new GaussianBigInt(1n, 0n).div(leftover.firstQuadrantUnit()));
    leftover = leftover.toFirstQuadrant();
    if (leftover.norm() > 1n) {
        if (leftover.real > leftover.imaginary) {
            leftover.real -= 1n;
            factors.push(false);
        }
        else {
            leftover.real -= 1n;
            factors.push(true);
        }
        factors = factors.concat(gaussian_primeFactorize(leftover, prime_amount));
    }
    return factors;
}

function gaussian_primeDefactorize(num) {
    let result = new GaussianBigInt(1n, 0n);
    if (!(Array.isArray(num[0]))) num = [num, new GaussianBigInt(1n, 0n)];
    for (i = num.length - 2; i >= 0; i -= 3) {
        while (gaussian_primes.length < num[i].length) gaussianPrimesUpdate(gaussian_primes[gaussian_primes.length - 1].norm() * 2n);
        for (p = 0; p < num[i].length; p++) {
            result = result.mul(gaussian_primes[p].pow(num[i][p]));
        }
        result = result.mul(num[i + 1]);
        if (i > 0) {
            if (num[i - 1]) result.imaginary += 1n;
            else result.real += 1n;
        }
    }
    return result;
}

function listFactors(num, amountOnly = false) {
    let primeF = primeFactorize(num, Infinity, false, 1, false)[0];
    if (amountOnly) {
        let result = 1n;
        for (let f of primeF) {
            result *= (f[1] + 1n);
        }
        return result;
    }
    if (primeF.length == 0) return [1n];
    let factors = [];
    let workingF = primeF.map(f => [f[0], 0n]);
    let examined = 0;
    while (workingF[workingF.length - 1][1] <= primeF[primeF.length - 1][1]) {
        factors.push(workingF.reduce(((val, factor) => val * factor[0]**factor[1]), 1n));
        workingF[0][1] += 1n;
        examined = 0;
        while (workingF[examined][1] > primeF[examined][1] && examined < primeF.length - 1) {
            workingF[examined][1] = 0n;
            examined++;
            workingF[examined][1] += 1n;
        }
    }
    factors = factors.sort((a, b) => Number(a - b));
    return factors;
}

/**
 * Converts a bigint, string representing a bigint, or array construct representing a string of digits in a given base, into another base.
 * The array constructs take the form [base, sign, array of digits].
 * @param {bigint | string | [bigint, bigint, [bigint]]} input The input to be converted.
 * @param {bigint} outBase The base to convert the input into. If this less than 2, return a bigint.
 * @param {boolean | [string] | null} returnString The form the output is in. If this is false, an array construct is returned.
 * If this is true (and base <= 64), a string is returned. If this is an array of strings, a string is returned, using those strings as the digits.
 * If this is null, a bigint is returned, which means outBase is ignored. Default is false.
 * @param {bigint} stringInBase If the input is a string, the input doesn't know what base it's in, so this parameter is used to specify that. Default is 10n.
 */
function baseConvert(input, outBase, returnString = false, stringInBase = 10n) {
    let digits;
    if (Array.isArray(returnString) && eqPrimArrays(arrayTypes(returnString), ["string"])) digits = returnString;
    else digits = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9",
    "A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z",
    "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z",
    "+", "/"]
    let value;
    if (typeof input == "bigint") value = input;
    else if (Array.isArray(input) && input.length == 3) {
        let inBase = input[0];
        value = 0n;
        for (let d = 0; d < input[2].length; d++) {
            value *= inBase;
            value += input[2][d];
        }
    }
    else if (typeof input == "string") {
        value = 0n;
        for (let d = 0; d < input.length; d++) {
            value *= stringInBase;
            let currentDigit = digits.indexOf(input[d]);
            if (currentDigit == -1) throw new Error("Character in input string to baseConvert not in the list of digit characters")
            value += BigInt(currentDigit);
        }
    }
    if (returnString === null || outBase < 2n) return value;
    let baseArray = [];
    let sign = 1n;
    if (value < 0n) {
        sign = -1n;
        value *= -1n;
    }
    let currentDigit;
    while (value > 0n) {
        currentDigit = value % outBase;
        baseArray.push(currentDigit);
        value -= currentDigit;
        value /= outBase;
    }
    baseArray.reverse();
    if (returnString == false) return [outBase, sign, baseArray];
    if (outBase > digits.length) throw new Error("Not enough characters provided to convert to given base");
    let result = "";
    while (baseArray.length > 0) {
        result = digits[baseArray[baseArray.length - 1]] + result;
        baseArray.pop();
    }
    if (sign == -1n) result = "-" + result;
    return result;
}

/**
 * Bitwise AND, but in higher bases. Takes the minimum of each "bit" at each place value.
 */
function baseBitMin(n1, n2, base) {
    n1 = baseConvert(n1, base)[2];
    n2 = baseConvert(n2, base)[2];
    while (n1.length < n2.length) n1.unshift(0n);
    while (n2.length < n1.length) n2.unshift(0n);
    let result = [];
    for (let d = 0; d < n1.length; d++) result.push(min(n1[d], n2[d]));
    return baseConvert([base, 1n, result], 0n);
}

/**
 * Bitwise OR, but in higher bases. Takes the maximum of each "bit" at each place value.
 */
function baseBitMax(n1, n2, base) {
    n1 = baseConvert(n1, base)[2];
    n2 = baseConvert(n2, base)[2];
    while (n1.length < n2.length) n1.unshift(0n);
    while (n2.length < n1.length) n2.unshift(0n);
    let result = [];
    for (let d = 0; d < n1.length; d++) result.push(max(n1[d], n2[d]));
    return baseConvert([base, 1n, result], 0n);
}

/**
 * Bitwise XOR, but in higher bases. Adds the bits modulo the base at each place value.
 */
function baseBitModAdd(n1, n2, base) {
    n1 = baseConvert(n1, base)[2];
    n2 = baseConvert(n2, base)[2];
    while (n1.length < n2.length) n1.unshift(0n);
    while (n2.length < n1.length) n2.unshift(0n);
    let result = [];
    for (let d = 0; d < n1.length; d++) result.push((n1[d] + n2[d]) % base);
    return baseConvert([base, 1n, result], 0n);
}

/**
 * Bitwise NOT, but in higher bases. Takes the base's complement at each place value.
 */
function baseBitComplement(n1, base) {
    bc = baseConvert(n1, base);
    n1 = bc[2];
    let result = [];
    for (let d = 0; d < n1.length; d++) result.push(base - n1[d]);
    return baseConvert([base, bc[1], result], 0n);
}

//I first made the 180 and DIVE color schemes in a separate project, so some of these next few functions are pasted in from there and updated.

function HSVtoString(h, s, v) {
    return evaluateColor(["@HSVA", h, s, v, 1]);
}

function threeFactorColor(factors, scheme) {
    let invert = false; let alpha = 1;
    if (arguments.length > 2) invert = arguments[2];
    if (arguments.length > 3) alpha = arguments[3];
    factors = factors.map(x => Number(x));
    while (factors.length < 3) factors.push(0);
    if (scheme == "DIVE" || scheme == "DIVE_prime" || scheme == "DIVE_primeGrey" || scheme == "SQUARTSingle" || scheme == "SQUARTSingle_prime" || scheme == "SQUARTSingle_primeGrey") {
        let r, g, b;
        if (scheme.includes("DIVE")) {
            r = ([0, 4, 8, 10, 12, 13, 14, 15])[Math.min(factors[0], 7)] * 17;
            g = ([0, 6, 10, 13, 15])[Math.min(factors[1], 4)] * 17;
            if (scheme != "DIVE") g = ([0, 4, 8, 12, 15])[Math.min(factors[1], 4)] * 17;
            b = ([0, 8, 12, 15])[Math.min(factors[2], 3)] * 17;
        }
        else if (scheme.includes("SQUARTSingle")) {
            r = ([0, 5, 8, 11, 13, 15])[Math.min(factors[0], 5)] * 17;
            g = ([0, 8, 12, 15])[Math.min(factors[1], 3)] * 17;
            if (scheme != "SQUART") g = ([0, 5, 10, 15])[Math.min(factors[1], 3)] * 17;
            b = ([0, 9, 15])[Math.min(factors[2], 2)] * 17;
        }
        if (scheme.includes("prime")) {
            if (scheme.includes("primeGrey") && r == g && g == b) {
                r += (255 - r)/2;
                g += (255 - g)/2;
                b += (255 - b)/2;
            }
            else if (!(r == g && g == b)) {
                let brighten = 255 / Math.max(r, g, b);
                r *= brighten; g *= brighten; b *= brighten;
            }
        }
        if (invert) {
            r = 255- r;
            g = 255 - g;
            b = 255 - b;
        }
        if (alpha != 1) return "rgba(" + r + ", " + g + ", " + b + ", " + alpha + ")";
        else return "rgb(" + r + ", " + g + ", " + b + ")";
    }
    if (scheme == "180" || scheme == "3385") {
        let answer = "";
        let lightnessPow = (scheme == "3385" ? 0.75 : 0.85)
        if (factors[0] == 0 && factors[1] == 0 && factors[2] == 0) answer = HSVtoString(0, 0, 0);
        else if (factors[0] == factors[1] && factors[1] == factors[2]) answer = HSVtoString(0, 0, (lightnessPow ** (factors[0] - 1) * 100));
        else if (factors[0] >= factors[2] && factors[1] >= factors[2]) answer = HSVtoString(((factors[1] - factors[2]) / (factors[0] + factors[1] - factors[2] * 2) * 120), (0.7 ** factors[2] * 100), (lightnessPow ** (gcd((factors[0] - factors[2]), (factors[1] - factors[2])) - 1) * 100));
        else if (factors[1] >= factors[0] && factors[2] >= factors[0]) answer = HSVtoString(((factors[2] - factors[0]) / (factors[1]  + factors[2] - factors[0] * 2) * 120 + 120), (0.7 ** factors[0] * 100), (lightnessPow ** (gcd((factors[2] - factors[0]), (factors[1] - factors[0])) - 1) * 100));
        else if (factors[2] >= factors[1] && factors[0] >= factors[1]) answer = HSVtoString(((factors[0] - factors[1]) / (factors[2] + factors[0] - factors[1] * 2) * 120 + 240), (0.7 ** factors[1] * 100), (lightnessPow ** (gcd((factors[2] - factors[1]), (factors[0] - factors[1])) - 1) * 100));
        if (invert) {
            answer = answer.split(", ");
            answer[0] = "hsla(" + (Number(answer[0].slice(5)) + 180);
            answer[2] = (100 - Number(answer[2].slice(0, answer[2].length - 1))) + "%";
            answer = answer[0] + ", " + answer[1] + ", " + answer[2] + ", " + alpha + ")";
        }
        return answer;
    }
    if (scheme == "Turatin") {
        let r, g, b;
        r = 255 * (3**factors[0] - 2**factors[0])/(3**factors[0]);
        g = 255 * (3**factors[1] - 2**factors[1])/(3**factors[1]);
        b = 255 * (3**factors[2] - 2**factors[2])/(3**factors[2]);
        let col = ["@RGBA", r, g, b, alpha];
        if (invert) return evaluateColor(rotateColor(col, 240, (scheme != "LOCEF")));
        return evaluateColor(rotateColor(col, 60, (scheme == "LOCEF")));
    }
    if (scheme == "TuratinInner") {
        let r, g, b;
        r = 255 * (2**factors[0] - 1)/(2**factors[0]);
        g = 255 * (2**factors[1] - 1)/(2**factors[1]);
        b = 255 * (2**factors[2] - 1)/(2**factors[2]);
        let col = ["@RGBA", r, g, b, alpha];
        if (invert) return evaluateColor(rotateColor(col, 180, true));
        return evaluateColor(col);
    }
    if (scheme == "3307") {
        let hue, saturation, lightness;
        if (factors[0] + factors[1] + factors[2] < 5) lightness = (factors[0] + factors[1] + factors[2]) * 10;
        else lightness = 0.75**(factors[0] + factors[1] + factors[2] - 5) * -45 + 95;
        if (factors[0] == factors[1] && factors[0] == factors[2]) {
            hue = 0; saturation = 0;
        }
        else if (factors[0] >= factors[2] && factors[1] >= factors[2]) {
            hue = 30 + 120 * (factors[1] - factors[2]) / (factors[0] + factors[1] - factors[2] * 2);
            saturation = 0.7**factors[2] * 100;
        }
        else if (factors[1] >= factors[0] && factors[2] >= factors[0]) {
            hue = 150 + 120 * (factors[2] - factors[0]) / (factors[1] + factors[2] - factors[0] * 2);
            saturation = 0.7**factors[0] * 100;
        }
        else if (factors[0] >= factors[1] && factors[2] >= factors[1]) {
            hue = 270 + 120 * (factors[0] - factors[1]) / (factors[0] + factors[2] - factors[1] * 2);
            saturation = 0.7**factors[1] * 100;
        }
        else { // This case shouldn't happen
            hue = 0; saturation = 0;
        }
        if (invert) return evaluateColor(["@rotate", 180, true, ["@HSLA", hue, saturation, lightness, alpha]])
        return evaluateColor(["@HSLA", hue, saturation, lightness, alpha]);
    }
    else if (scheme == "LOCEF") {
        let hue, saturation, lightness;
        let lightnessLog = Math.log(3**factors[0] * 5**factors[1] * 7**factors[2]) / Math.log(3);
        if (lightnessLog < 4) lightness = 100 - lightnessLog * 10;
        else lightness = 0.8**(lightnessLog - 4) * 40 + 10;
        if (factors[0] == factors[1] && factors[0] == factors[2]) {
            hue = 0; saturation = 0;
        }
        else if (factors[0] >= factors[2] && factors[1] >= factors[2]) {
            hue = 60 + 120 * (factors[1] - factors[2]) / (factors[0] + factors[1] - factors[2] * 2);
            saturation = 0.7**factors[2] * 100;
        }
        else if (factors[1] >= factors[0] && factors[2] >= factors[0]) {
            hue = 180 + 120 * (factors[2] - factors[0]) / (factors[1] + factors[2] - factors[0] * 2);
            saturation = 0.7**factors[0] * 100;
        }
        else if (factors[0] >= factors[1] && factors[2] >= factors[1]) {
            hue = 300 + 120 * (factors[0] - factors[1]) / (factors[0] + factors[2] - factors[1] * 2);
            saturation = 0.7**factors[1] * 100;
        }
        else { // This case shouldn't happen
            hue = 0; saturation = 0;
        }
        if (invert) return evaluateColor(["@rotate", 180, true, ["@HSLA", hue, saturation, lightness, alpha]])
        return evaluateColor(["@HSLA", hue, saturation, lightness, alpha]);
    }
    if (scheme == "GaussianDIVE1" || scheme == "GaussianDIVE1_prime" || scheme == "GaussianDIVE1_primeGrey") {
        let r = ([0, 3, 5, 7, 8, 9, 10, 12, 13, 14, 15])[Math.min(factors[0], 10)] * 17;
        let g = ([0, 5, 9, 11, 13, 15])[Math.min(factors[1], 5)] * 17;
        let b = ([0, 5, 9, 11, 13, 15])[Math.min(factors[2], 5)] * 17;
        if (scheme != "GaussianDIVE1") {
            if (scheme == "GaussianDIVE1_primeGrey" && r == g && g == b) {
                r += (255 - r)/5;
                g += (255 - g)/5;
                b += (255 - b)/5;
            }
            else if (!(r == g && g == b)) {
                let brighten = 255 / Math.max(r, g, b);
                r *= brighten; g *= brighten; b *= brighten;
            }
        }
        if (invert) {
            r = 255- r;
            g = 255 - g;
            b = 255 - b;
        }
        let col = ["@RGBA", r, g, b, alpha];
        if (invert) return evaluateColor(rotateColor(col, 225, true));
        return evaluateColor(rotateColor(col, 45));
    }
    if (scheme == "GaussianDIVE2" || scheme == "GaussianDIVE2_prime" || scheme == "GaussianDIVE2_primeGrey") {
        let r = ([0, 6, 10, 13, 15])[Math.min(factors[0], 4)] * 17;
        let g = ([0, 4, 8, 12, 15])[Math.min(factors[1], 3)] * 17;
        let b = ([0, 4, 8, 12, 15])[Math.min(factors[2], 3)] * 17;
        if (scheme != "GaussianDIVE2") {
            if (scheme == "GaussianDIVE2_primeGrey" && r == g && g == b) {
                r += (255 - r)/5;
                g += (255 - g)/5;
                b += (255 - b)/5;
            }
            else if (!(r == g && g == b)) {
                let brighten = 255 / Math.max(r, g, b);
                r *= brighten; g *= brighten; b *= brighten;
            }
        }
        if (invert) {
            r = 255- r;
            g = 255 - g;
            b = 255 - b;
        }
        let col = ["@RGBA", r, g, b, alpha];
        if (invert) return evaluateColor(rotateColor(col, 255, true));
        return evaluateColor(rotateColor(col, 75));
    }
}

function DIVEresidueFactor(number, small_primes, total_primes) {
    while (primes.length < total_primes && primes[primes.length - 1] < abs(number)) primesUpdate(primes[primes.length - 1] * 2n);
    let result = [];
    let small_factors = primeFactorize(number, small_primes)[0];
    while (small_factors.length < 4) small_factors.push(0n);
    let residue = number / primeDefactorize(small_factors);
    if (residue == 1n) return [small_factors];
    result.push(small_factors);
    let large_factors = primeFactorize(residue, total_primes)[0];
    for (let p = 0; p < large_factors.length; p++) {
        if (large_factors[p] > 0) result.push([large_factors[p], primes[p], DIVEresidueFactor((primes[p] + 1n)/2n, small_primes, total_primes)]);
    }
    return result;
}

function DIVERenderInnerBar(factors, start, length, layer, depth, scheme = "DIVE") {
    factors = factors.map(x => Number(x));
    let alpha = 0.5 + 0.5 * layer/depth;
    let result = [];
    if (factors[3] == 0) {
        result += (threeFactorColor(factors.slice(0, 3), scheme + "_prime", false, alpha) + " " + start + "% " + (start + length) + "%");
    }
    else {
        for (let s = 0; s < factors[3] * 4 + 1; s++) {
            let mid_color = threeFactorColor(factors.slice(0, 3), scheme + "_primeGrey", false, alpha);
            let black = threeFactorColor([0, 0, 0], scheme, false, alpha);
            let white = threeFactorColor([7, 4, 3], scheme, false, alpha);
            if (s % 4 == 0) result += black;
            if (s % 4 == 1 || s % 4 == 3) result += mid_color;
            if (s % 4 == 2) result += white;
            result += " " + (start + length*s/(factors[3] * 4)) + "%";
            if (s < factors[3] * 4) result += ", ";
        }
    }
    return result;
}

function GaussianDIVEresidueFactor(number, small_primes, total_primes) {
    while (gaussian_primes.length < total_primes && gaussian_primes[gaussian_primes.length - 1].norm() < number.norm()) gaussianPrimesUpdate(gaussian_primes[gaussian_primes.length - 1].norm() * 2n);
    let result = [];
    let sfCombined = gaussian_primeFactorize(number, small_primes);
    let small_factors = sfCombined[0];
    let small_unit = sfCombined[1];
    while (small_factors.length < 6) small_factors.push(0n);
    let residue = number.div(gaussian_primeDefactorize([small_factors, [1n, 0n]]));
    if (residue.norm() == 1n) return [small_factors, small_unit];
    result.push(small_factors, small_unit);
    let large_factors = gaussian_primeFactorize(residue, total_primes)[0];
    for (let p = 0; p < large_factors.length; p++) {
        if (large_factors[p] > 0) {
            let lower = gaussian_primes[p].add([0n, 1n]).div([1n, -1n]);
            result.push([large_factors[p], gaussian_primes[p], GaussianDIVEresidueFactor(lower, small_primes, total_primes)]);
        }
    }
    return result;
}

function GaussianDIVERenderInnerBar(factors, start, length, layer, depth) {
    let alpha = 0.75 + 0.25 * layer/depth;
    let result = [];
    result += (threeFactorColor(factors.slice(0, 3), "GaussianDIVE1_prime", false, alpha) + " " + start + "%, " + threeFactorColor(factors.slice(3, 6), "GaussianDIVE2_prime", false, alpha) + " " + (start + length) + "%");
    return result;
}

function RGBtoArray(rgb) {
    rgb = rgb.slice(4, rgb.length - 1);
    rgb = rgb.split(", ");
    return rgb;
}

function ArraytoRGB(rgb) {
    let result = "rgb(";
    for (let i = 0; i < rgb.length - 1; i++) {
        result += rgb[i]; result += ", ";
    }
    result += rgb[rgb.length - 1];
    result += ")";
    return result;
}

function DIVESeedUnlock(tile, seeds, mode) {
    if (tile == 0n) return 1n;
    mode = mod(mode, 4);
    tile = abs(tile);
    seeds = compendiumStructuredClone(seeds);
    if (seeds.indexOf(1n) != -1) seeds.splice(seeds.indexOf(1n), 1);
    if (seeds.length == 0) return tile;
    if (mode == 1 || mode == 2) sortedSeeds = seeds.sort((a, b) => Number(a - b));
    else if (mode == 0) sortedSeeds = seeds.sort((a, b) => Number(b - a));
    if (mode != 1) { // Runs through each seed. Mode 0 is "largest to smallest", Mode 2 is "smallest to largest", Mode 3 is "in whatever order the seeds happen to be in"
        for (let i = 0; i < seeds.length; i++) {
            while (tile % seeds[i] == 0) tile /= seeds[i];
        }
        return tile;
    }
    else {
        // Mode 1 guarantees the minimum possible result by going through every possible combination.
        // To reduce lag, it speeds this up by finding a decently-sized set of coprime seeds - that one set can be treated as one unit in the subsequent testing, as since they're coprime, they can't affect each other, i.e. they won't "steal possibilities" from each other.
        let coprimesAndSeeds = [[], []];
        let potentialCAS = [[], []];
        let coprimeValue = 1n;
        for (let i = 0; i < seeds.length; i++) {
            potentialCAS = [[seeds[i]], []];
            coprimeValue = seeds[i];
            for (let j = (i + 1) % seeds.length; j != i; j = (j + 1) % seeds.length) {
                if (gcd(seeds[j], coprimeValue) == 1n) {
                    coprimeValue *= seeds[j];
                    potentialCAS[0].push(seeds[j])
                }
                else potentialCAS[1].push(seeds[j]);
            }
            if (potentialCAS[0].length > coprimesAndSeeds[0].length) coprimesAndSeeds = potentialCAS;
        }
        coprimesAndSeeds[0] = coprimesAndSeeds[0].sort(function(a, b){
            if (a < b) return -1;
            else if (a == b) return 0;
            else return 1;
        });
        coprimesAndSeeds[1] = coprimesAndSeeds[1].sort(function(a, b){
            if (a < b) return -1;
            else if (a == b) return 0;
            else return 1;
        });
        let coprimes = coprimesAndSeeds[0];
        let remainingSeeds = coprimesAndSeeds[1];
        let seedPowers = Array(remainingSeeds.length).fill(0n);
        let minimum = tile;
        let index = 0;
        let seededTile = tile;
        while (true) {
            for (let c = 0; c < coprimes.length; c++) {
                while (tile % coprimes[c] == 0n) tile /= coprimes[c];
            }
            if (tile < minimum) minimum = tile;
            if (remainingSeeds.length == 0) return minimum;
            tile = seededTile;
            index = 0;
            while (tile % remainingSeeds[index] != 0n) {
                tile *= remainingSeeds[index] ** seedPowers[index];
                seedPowers[index] = 0n;
                index++;
                if (index >= remainingSeeds.length) return minimum;
            }
            tile /= remainingSeeds[index];
            seededTile = tile;
            seedPowers[index] += 1n;
        }
    }
}

function GaussianDIVESeedUnlock(tile, seeds, mode, firstQuadrant) {
    if (tile.eq(0n, 0n)) return 1n;
    mode = mod(mode, 4);
    seeds = compendiumStructuredClone(seeds);
    seeds = seeds.filter(value => value.norm() > 1n);
    if (seeds.length == 0) return tile;
    if (mode == 1 || mode == 2) sortedSeeds = seeds.sort(gaussianSort);
    else if (mode == 0) sortedSeeds = seeds.sort((a, b) => gaussianSort(b, a));
    if (mode != 1) { // Runs through each seed. Mode 0 is "largest to smallest", Mode 2 is "smallest to largest", Mode 3 is "in whatever order the seeds happen to be in"
        for (let i = 0; i < seeds.length; i++) {
            while (tile.mod(seeds[i]).eq(0n, 0n)) tile = tile.div(seeds[i]);
        }
        if (firstQuadrant) tile = tile.toFirstQuadrant();
        return tile;
    }
    else {
        // Mode 1 guarantees the minimum possible result by going through every possible combination.
        // To reduce lag, it speeds this up by finding a decently-sized set of coprime seeds - that one set can be treated as one unit in the subsequent testing, as since they're coprime, they can't affect each other, i.e. they won't "steal possibilities" from each other.
        let coprimesAndSeeds = [[], []];
        let potentialCAS = [[], []];
        let coprimeValue = new GaussianBigInt(1n, 0n);
        for (let i = 0; i < seeds.length; i++) {
            potentialCAS = [[seeds[i]], []];
            coprimeValue = seeds[i];
            for (let j = (i + 1) % seeds.length; j != i; j = (j + 1) % seeds.length) {
                if (seeds[j].gcd(coprimeValue).norm() == 1n) {
                    coprimeValue = coprimeValue.mul(seeds[j]);
                    potentialCAS[0].push(seeds[j])
                }
                else potentialCAS[1].push(seeds[j]);
            }
            if (potentialCAS[0].length > coprimesAndSeeds[0].length) coprimesAndSeeds = potentialCAS;
        }
        coprimesAndSeeds[0] = coprimesAndSeeds[0].sort(gaussianSort);
        coprimesAndSeeds[1] = coprimesAndSeeds[1].sort(gaussianSort);
        let coprimes = coprimesAndSeeds[0];
        let remainingSeeds = coprimesAndSeeds[1];
        let seedPowers = Array(remainingSeeds.length).fill(0n);
        let minimum = compendiumStructuredClone(tile);
        let index = 0;
        let seededTile = compendiumStructuredClone(tile);
        while (true) {
            for (let c = 0; c < coprimes.length; c++) {
                while (tile.mod(coprimes[c]).eq(0n, 0n)) tile = tile.div(coprimes[c]);
            }
            if (tile.norm() < minimum.norm()) minimum = compendiumStructuredClone(tile);
            if (remainingSeeds.length == 0) {
                if (firstQuadrant) minimum = minimum.toFirstQuadrant();
                return minimum;
            }
            tile = compendiumStructuredClone(seededTile);
            index = 0;
            while (tile.mod(remainingSeeds[index]).neq(0n, 0n)) {
                tile = tile.mul(remainingSeeds[index].pow(seedPowers[index]));
                seedPowers[index] = 0n;
                index++;
                if (index >= remainingSeeds.length) {
                    if (firstQuadrant) minimum = minimum.toFirstQuadrant();
                    return minimum;
                }
            }
            tile = tile.div(remainingSeeds[index]);
            seededTile = tile;
            seedPowers[index] += 1n;
        }
    }
}

function customDIVESeedUnlock(tile, seeds, mode, multiplication, division, modZero, sortFunc, coprime, one, valid = (value) => true, isOne = ((value) => eqPrimArrays(value, one))) {
    if (!valid(tile)) return one;
    mode = mod(mode, 4);
    seeds = compendiumStructuredClone(seeds).filter(t => !isOne(t));
    if (seeds.length == 0) return tile;
    if (mode == 1 || mode == 2) sortedSeeds = seeds.sort((a, b) => sortFunc(a, b));
    else if (mode == 0) sortedSeeds = seeds.sort((a, b) => sortFunc(b, a));
    if (mode != 1) { // Runs through each seed. Mode 0 is "largest to smallest", Mode 2 is "smallest to largest", Mode 3 is "in whatever order the seeds happen to be in"
        for (let i = 0; i < seeds.length; i++) {
            while (modZero(tile, seeds[i])) {
                tile = division(tile, seeds[i]);
            }
        }
        return tile;
    }
    else {
        // Mode 1 guarantees the minimum possible result by going through every possible combination.
        // To reduce lag, it speeds this up by finding a decently-sized set of coprime seeds - that one set can be treated as one unit in the subsequent testing, as since they're coprime, they can't affect each other, i.e. they won't "steal possibilities" from each other.
        let coprimesAndSeeds = [[], []];
        let potentialCAS = [[], []];
        let coprimeValue = one;
        for (let i = 0; i < seeds.length; i++) {
            potentialCAS = [[seeds[i]], []];
            coprimeValue = seeds[i];
            for (let j = (i + 1) % seeds.length; j != i; j = (j + 1) % seeds.length) {
                if (coprime(seeds[j], coprimeValue)) {
                    coprimeValue = multiplication(coprimeValue, seeds[j]);
                    potentialCAS[0].push(seeds[j])
                }
                else potentialCAS[1].push(seeds[j]);
            }
            if (potentialCAS[0].length > coprimesAndSeeds[0].length) coprimesAndSeeds = potentialCAS;
        }
        coprimesAndSeeds[0] = coprimesAndSeeds[0].sort((a, b) => sortFunc(a, b));
        coprimesAndSeeds[1] = coprimesAndSeeds[1].sort((a, b) => sortFunc(a, b));
        let coprimes = coprimesAndSeeds[0];
        let remainingSeeds = coprimesAndSeeds[1];
        let seedPowers = Array(remainingSeeds.length).fill(0n);
        let minimum = tile;
        let index = 0;
        let seededTile = tile;
        while (true) {
            for (let c = 0; c < coprimes.length; c++) {
                while (modZero(tile, coprimes[c])) tile = division(tile, coprimes[c]);
            }
            if (sortFunc(tile, minimum) < 0) minimum = tile;
            if (remainingSeeds.length == 0) return minimum;
            tile = seededTile;
            index = 0;
            while (!modZero(tile, remainingSeeds[index])) {
                for (let pow = 0; pow < seedPowers[index]; pow++) tile = multiplication(tile, remainingSeeds[index]);
                seedPowers[index] = 0n;
                index++;
                if (index >= remainingSeeds.length) return minimum;
            }
            tile = division(tile, remainingSeeds[index]);
            seededTile = tile;
            seedPowers[index] += 1n;
        }
    }
}

//Gameplay
function refillSpawnConveyor() { // This function ensures that nextTiles is always full. spawnConveyor always has at least 1 tile in it, and it can have more if nextTiles is above 1.
    for (let s = 0; s < spawnConveyor.length; s++) {
        if (spawnConveyor[s] == "@Empty") {
            let weighttotal = 0;
            let cSpawns = compendiumStructuredClone(TileSpawns);
            for (let p of cSpawns) {
                if (Array.isArray(p[1])) p[1] = CalcArray(p[1]);
                weighttotal += p[1]; // weighttotal is the sum of the spawn chances of each tile
            }
            let randnum = getRndFloat(0, weighttotal);
            let spawnedtile = "@Empty";
            let entry = 0;
            TileDecider: { // Chooses which tile we're spawning
                while (entry < cSpawns.length) {
                    randnum -= cSpawns[entry][1];
                    if (randnum <= 0) {
                        spawnedtile = compendiumStructuredClone(cSpawns[entry][0]);
                        break TileDecider;
                    }
                    entry++;
                }
            }
            if (spawnedtile == "Box") { // If the tile we landed on is a spawn box, choose a tile from the box at random
                if (SpawnBoxes[entry].length == 0) refillSpawnBox(entry);
                let itemindex = getRndInteger(0, SpawnBoxes[entry].length - 1);
                spawnedtile = SpawnBoxes[entry][itemindex];
                SpawnBoxes[entry].splice(itemindex, 1);
                if (SpawnBoxes[entry].length == 0) refillSpawnBox(entry);
            }
            if (spawnedtile[0] == "@CalcArray") spawnedtile = CalcArray(spawnedtile.slice(1));
            if (Array.isArray(spawnedtile)) {
                for (let i = 0; i < spawnedtile.length; i++) {
                    if (Array.isArray(spawnedtile[i])) spawnedtile[i] = CalcArray(spawnedtile[i]); //If a spawned tile's entries are themselves arrays, assume those entries are CalcArray expressions
                }
            }
            spawnConveyor[s] = compendiumStructuredClone(spawnedtile);
        }
    }
}

function spawnConveyorSelect() { // Takes the 0th entry of spawnConveyor and returns it, pushes the rest of the entries to the previous entry (thus closer to spawning), and refills the conveyor
    refillSpawnConveyor();
    let spawnedtile = compendiumStructuredClone(spawnConveyor[0]);
    for (let s = 0; s < spawnConveyor.length - 1; s++) spawnConveyor[s] = compendiumStructuredClone(spawnConveyor[s + 1]);
    spawnConveyor[spawnConveyor.length - 1] = "@Empty";
    if (nextTiles > 0) refillSpawnConveyor(); //If there are no visible next tiles, then spawnConveyor should only be refilled when it's time to spawn a tile, as otherwise changes to TileSpawns would be delayed by a turn.
    return spawnedtile;
}

function RandomTiles(amount, vdir, hdir) { // This is what spawns the random tiles. amount is the amount of tiles to spawn. vdir and hdir are the directions of the previous move, which we need if spawnLocation is Edge.
    let addInfo = [1, Infinity, 0];
    if (arguments.length > 3) addInfo = arguments[3];
    let TileChoices = [];
    let spawnedTiles = [];
    if (spawnLocation == "Edge" && (vdir != 0 || hdir != 0)) {
        let iterations = 0;
        let edgefound = false;
        Edge_Finder: {
            while (!edgefound) {
                if (vdir < 0 && hdir == 0) {
                    for (let column = 0; column < width; column++) {
                        TileChoices.push([height - 1 - iterations, column]);
                    }
                }
                else if (vdir > 0 && hdir == 0) {
                    for (let column = 0; column < width; column++) {
                        TileChoices.push([iterations, column]);
                    }
                }
                else if (vdir == 0 && hdir < 0) {
                    for (let row = 0; row < height; row++) {
                        TileChoices.push([row, width - 1 - iterations]);
                    }
                }
                else if (vdir == 0 && hdir > 0) {
                    for (let row = 0; row < height; row++) {
                        TileChoices.push([row, iterations]);
                    }
                }
                else if (vdir < 0 && hdir < 0) {
                    let row = height - 1 - iterations;
                    let column = width - 1;
                    for (let i = 0; i <= iterations; i++) {
                        TileChoices.push([row, column]);
                        row++;
                        column--;
                    }
                }
                else if (vdir > 0 && hdir < 0) {
                    let row = 0;
                    let column = width - 1 - iterations;
                    for (let i = 0; i <= iterations; i++) {
                        TileChoices.push([row, column]);
                        row++;
                        column++;
                    }
                }
                else if (vdir < 0 && hdir > 0) {
                    let row = height - 1 - iterations;
                    let column = 0;
                    for (let i = 0; i <= iterations; i++) {
                        TileChoices.push([row, column]);
                        row++;
                        column++;
                    }
                }
                else if (vdir > 0 && hdir > 0) {
                    let row = 0;
                    let column = iterations;
                    for (let i = 0; i <= iterations; i++) {
                        TileChoices.push([row, column]);
                        row++;
                        column--;
                    }
                }
                for (let t = 0; t < TileChoices.length; t++) {
                    if (Grid[TileChoices[t][0]][TileChoices[t][1]] != "@Void") {edgefound = true; break Edge_Finder;}
                }
                iterations++;
            }
        }
    }
    else {
        for (let row = 0; row < height; row++) {
            for (let column = 0; column < width; column++) {
                TileChoices.push([row, column]);
            }
        }
    }
    let spawned = 0;
    spawningRandomTiles: {
        while (spawned < amount && TileChoices.length > 0) {
            //Which tile is being spawned in?
            let found = false;
            let choice = 0;
            let row = 0;
            let column = 0;
            while (!found) {
                choice = getRndInteger(0, TileChoices.length - 1);
                row = TileChoices[choice][0];
                column = TileChoices[choice][1];
                if (Grid[row][column] == "@Empty") found = true;
                else {
                    TileChoices.splice(choice, 1);
                    if (TileChoices.length == 0) {
                        displayGrid();
                        break spawningRandomTiles;
                    }
                }
            }
            //What tile is spawning there?
            let spawnedtile = spawnConveyorSelect();
            //Do the spawning
            Grid[row][column] = compendiumStructuredClone(spawnedtile);
            spawnedTiles.push(compendiumStructuredClone(spawnedtile))
            spawned++;
            TileChoices.splice(choice, 1);
        }
    }
    tileDiscoveryCheck();
    displayGrid();
    return spawnedTiles;
}

function refillSpawnBox(entry) { // When a spawn box is empty, this function refills it.
    let j = 2;
    while (j < TileSpawns[entry].length) {
        if ((j < TileSpawns[entry].length - 1) && (typeof TileSpawns[entry][j + 1] === "number")) {
            for (let k = 0; k < TileSpawns[entry][j + 1]; k++) SpawnBoxes[entry].push(compendiumStructuredClone(TileSpawns[entry][j]));
            j += 2;
        }
        else {
            SpawnBoxes[entry].push(compendiumStructuredClone(TileSpawns[entry][j]));
            j += 1;
        }
    }
}

function forcedSpawnTiles(timing, vdir, hdir) {
    let addInfo = [1, Infinity, 0];
    if (arguments.length > 3) addInfo = arguments[3];
    let spawnedTiles = [];
    let tilesToSpawn = [];
    let gameOverPossible = [];
    for (let f = 0; f < forcedSpawns.length; f++) {
        if (CalcArray(forcedSpawns[f][0], 0, 0, vdir, hdir, addInfo) === true && forcedSpawns[f][1] == timing) {
            for (let t = 3; t < forcedSpawns[f].length; t++) {
                tilesToSpawn.push(forcedSpawns[f][t]);
                gameOverPossible.push(forcedSpawns[f][2]);
            }
        }
    }
    if (tilesToSpawn.length > 0) {
        let TileChoices = [];
        // if (spawnLocation == "Edge" && (vdir != 0 || hdir != 0)) {
        //     let iterations = 0;
        //     let edgefound = false;
        //     Edge_Finder: {
        //         while (!edgefound) {
        //             if (vdir < 0 && hdir == 0) {
        //                 for (let column = 0; column < width; column++) {
        //                     TileChoices.push([height - 1 - iterations, column]);
        //                 }
        //             }
        //             else if (vdir > 0 && hdir == 0) {
        //                 for (let column = 0; column < width; column++) {
        //                     TileChoices.push([iterations, column]);
        //                 }
        //             }
        //             else if (vdir == 0 && hdir < 0) {
        //                 for (let row = 0; row < height; row++) {
        //                     TileChoices.push([row, width - 1 - iterations]);
        //                 }
        //             }
        //             else if (vdir == 0 && hdir > 0) {
        //                 for (let row = 0; row < height; row++) {
        //                     TileChoices.push([row, iterations]);
        //                 }
        //             }
        //             else if (vdir < 0 && hdir < 0) {
        //                 let row = height - 1 - iterations;
        //                 let column = width - 1;
        //                 for (let i = 0; i <= iterations; i++) {
        //                     TileChoices.push([row, column]);
        //                     row++;
        //                     column--;
        //                 }
        //             }
        //             else if (vdir > 0 && hdir < 0) {
        //                 let row = 0;
        //                 let column = width - 1 - iterations;
        //                 for (let i = 0; i <= iterations; i++) {
        //                     TileChoices.push([row, column]);
        //                     row++;
        //                     column++;
        //                 }
        //             }
        //             else if (vdir < 0 && hdir > 0) {
        //                 let row = height - 1 - iterations;
        //                 let column = 0;
        //                 for (let i = 0; i <= iterations; i++) {
        //                     TileChoices.push([row, column]);
        //                     row++;
        //                     column++;
        //                 }
        //             }
        //             else if (vdir > 0 && hdir > 0) {
        //                 let row = 0;
        //                 let column = iterations;
        //                 for (let i = 0; i <= iterations; i++) {
        //                     TileChoices.push([row, column]);
        //                     row++;
        //                     column--;
        //                 }
        //             }
        //             for (let t = 0; t < TileChoices.length; t++) {
        //                 if (Grid[TileChoices[t][0]][TileChoices[t][1]] != "@Void") {edgefound = true; break Edge_Finder;}
        //             }
        //             iterations++;
        //         }
        //     }
        // }
        // else {
        for (let row = 0; row < height; row++) {
            for (let column = 0; column < width; column++) {
                TileChoices.push([row, column]);
            }
        }
        // }
        SpawningForcedTiles: {
            while (tilesToSpawn.length > 0 && TileChoices.length > 0) {
                //Which tile is being spawned in?
                let found = false;
                let choice = 0;
                let row = 0;
                let column = 0;
                while (!found) {
                    choice = getRndInteger(0, TileChoices.length - 1);
                    row = TileChoices[choice][0];
                    column = TileChoices[choice][1];
                    if (Grid[row][column] == "@Empty") found = true;
                    else {
                        TileChoices.splice(choice, 1);
                        if (TileChoices.length == 0) {
                            displayGrid();
                            break SpawningForcedTiles;
                        }
                    }
                }
                //Do the spawning
                Grid[row][column] = compendiumStructuredClone(tilesToSpawn[0]);
                spawnedTiles.push(compendiumStructuredClone(tilesToSpawn[0]))
                TileChoices.splice(choice, 1);
                tilesToSpawn.shift();
                gameOverPossible.shift();
            }
        }
        if (gameOverPossible.indexOf(true) > -1) won = -2; // You lose!
        tileDiscoveryCheck();
        displayGrid();
        return spawnedTiles;
    }
    else return [];
}

function mergeRuleApplies(rule, vcoord, hcoord, vdir, hdir) { // Tests whether a given merge rule can be used. Returns an array with two entries: the first is the permutation of the rule that can be used if there is one, false if there isn't. The second is the variables.
    let addInfo = [Infinity, 0]; let gri = Grid; let offset = 0; let overflowSafe = true;
    if (arguments.length > 5) addInfo = arguments[5];
    if (arguments.length > 6) gri = arguments[6]; // If we're looking at a grid that isn't the regular Grid, this specifies what the grid is
    if (arguments.length > 7) offset = arguments[7];
    if (arguments.length > 8) overflowSafe = arguments[8];
    let checkedrule = compendiumStructuredClone(rule);
    let result = false;
    let vars = [];
    let mlength = checkedrule[0];
    if (checkedrule[0] === "@include_gvars") mlength = checkedrule[1];
    if (checkedrule.indexOf("@end_vars") > -1) mlength = checkedrule[checkedrule.indexOf("@end_vars") + 1];
    if (checkedrule[0] === "@include_gvars") {
        let newvars = compendiumStructuredClone(game_vars);
        for (let v = 0; v < newvars.length; v++) {
            newvars[v] = CalcArrayConvert(newvars[v], "=", vcoord, hcoord, vdir, hdir, [mlength, addInfo[0], addInfo[1]], gri, [], vars);
            if (Array.isArray(newvars[v])) newvars[v].unshift("@Literal");
            vars.push(newvars[v]);
        }
        checkedrule.shift();
    }
    if (checkedrule.indexOf("@end_vars") > -1) {
        let newvars = checkedrule.slice(0, checkedrule.indexOf("@end_vars"));
        for (let v = 0; v < newvars.length; v++) {
            newvars[v] = CalcArrayConvert(newvars[v], "=", vcoord, hcoord, vdir, hdir, [mlength, addInfo[0], addInfo[1]], gri, [], vars);
            if (Array.isArray(newvars[v])) newvars[v].unshift("@Literal");
            vars.push(newvars[v]);
        }
        checkedrule.splice(0, checkedrule.indexOf("@end_vars") + 1);
    }
    checkedrule = evaluateMergeRule(checkedrule, vcoord, hcoord, vdir, hdir, [mlength, addInfo[0], addInfo[1]], gri, vars);
    mlength = checkedrule[0];
    if (mlength == 0) mlength = 1;
    for (let p = 0; p < mlength; p++) {
        let position = p + offset;
        let checkedspace;
        if (position == 0) checkedspace = "@This";
        else if (position > 0) checkedspace = "@Next " + position;
        else if (position < 0) checkedspace = "@NextNE " + position;
        checkedspace = CalcArray(checkedspace, vcoord, hcoord, vdir, hdir, [mlength, addInfo[0], addInfo[1]], gri, [], vars);
        if ((checkedspace === undefined || typeof checkedspace == "string" || checkedspace === false) && position >= 0) return [false, vars, -1, [], 0];
    }
    if ((Array.isArray(checkedrule[2]) && checkedrule[2][0] != "@CheckStart" && checkedrule[2][0] != "@CheckEnd")) {
        let testing = calcArrayMergeOffset(checkedrule, offset, vdir, hdir)
        checkedrule[2] = CalcArray(testing[2], vcoord, hcoord, vdir, hdir, [testing[0], addInfo[0], addInfo[1]], gri, [], vars);
    }
    if (checkedrule[2] === true) {
        let testing = calcArrayMergeOffset(checkedrule, offset, vdir, hdir);
        if (CalcArray(testing[1], vcoord, hcoord, vdir, hdir, [testing[0], addInfo[0], addInfo[1]], gri, [], vars) === true) {
            result = testing;
        }
    }
    else { // If the 2nd entry is false, we need to look at every permutation of the merge rule, which grows factorially with the length of the rule, to see if any permutation evaluates to true
        if (Array.isArray(checkedrule[2]) && checkedrule[2][0] === "@CheckStart") {
            let testing = calcArrayMergeOffset(checkedrule, offset, vdir, hdir);
            if (!CalcArray(testing[2].slice(1), vcoord, hcoord, vdir, hdir, [testing[0], addInfo[0], addInfo[1]], gri, [], vars)) return [false, vars, -1, [], 0];
        }
        let arrangements = orders(mlength);
        for (let permu = 0; permu < arrangements.length; permu++) {
            let testing = calcArrayMergeOffset(calcArrayReorder(checkedrule, arrangements[permu], vdir, hdir), offset, vdir, hdir);
            if (CalcArray(testing[1], vcoord, hcoord, vdir, hdir, [testing[0], addInfo[0], addInfo[1]], gri, [], vars) === true) {
                if (Array.isArray(checkedrule[2]) && checkedrule[2][0] === "@CheckEnd") {
                    if (!CalcArray(testing[2].slice(1), vcoord, hcoord, vdir, hdir, [testing[0], addInfo[0], addInfo[1]], gri, [], vars)) return [false, vars, -1, [], 0];
                }
                result = testing;
                break;
            }
        }
    }
    let validMergeModifiers = ["@MergeReverseStart", "@MergeOverflowEmpty", "@MergeOverflowSlot", "@MergeOverflowOverwrite"];
    let reverseMergePosition = false;
    let overflowType = 0;
    if (result) { // Find the positions of the output tiles. Nowhere where calcArrayMergeOffset is used has outputs, so I'll ignore that here
        let varcopy = compendiumStructuredClone(vars); // These checks shouldn't influence the variables returned
        while (validMergeModifiers.indexOf(checkedrule[3][0]) != -1) {
            let mergeModifier = checkedrule[3].shift();
            if (mergeModifier == "@MergeReverseStart") {
                reverseMergePosition = !reverseMergePosition;
            }
            if (mergeModifier == "@MergeOverflowEmpty") {
                overflowType = 0;
            }
            if (mergeModifier == "@MergeOverflowSlot") {
                overflowType = 1;
            }
            if (mergeModifier == "@MergeOverflowOverwrite") {
                overflowType = 2;
            }
        }
        let vcoordMM, hcoordMM;
        vcoordMM = vcoord;
        hcoordMM = hcoord;
        if (checkedrule[3].length > mlength && overflowSafe) { // Check to make sure overflow is allowed. Only do this here for CalcArray calls of MergeRuleApplies, not for MoveHandler, as MoveHandler has to do this part itself for known merge results to work
            let newPosition;
            for (let i = mlength; i < checkedrule[3].length; i++) {
                newPosition = CalcArray([(overflowType == 1 ? "@NextFull " : "@Next ") + (reverseMergePosition ? 1 : -1) + " @Position"], vcoordMM, hcoordMM, vdir, hdir);
                if (newPosition === undefined || typeof newPosition == "string" || newPosition === false) return [false, vars, -1, [], 0];
                [vcoordMM, hcoordMM] = newPosition;
                if ((gri[vcoordMM][hcoordMM] !== "@Empty" && overflowType == 0) || gri[vcoordMM][hcoordMM] === "@Void" || gri[vcoordMM][hcoordMM].includes("@TemporaryHole")) return [false, vars, -1, [], 0];
            }
        }
    }
    return [result, vars, mlength, overflowType, reverseMergePosition];
}

async function MoveHandler(direction_num) {
    /*
    This is probably the second most important function here (I'd say CalcArray is the most important), as this function is what performs moves,
    which are, y'know, how the game is played. MoveHandler is asynchronous so that the delay function can be used for tile animations, but since it sets
    inputAvailable to false for the duration of the move, you can't do other things during a move.
    */
    let manual = true;
    if (arguments.length > 1) manual = arguments[1];
    let direction = [];
    if (manual) direction = directions[direction_num][0];
    else direction = auto_directions[direction_num][0];
    let vdir = direction[0];
    let hdir = direction[1];
    let slideAmount = direction[2];
    let moveType = 0;
    if (direction.length > 3) moveType = direction[3];
    let manualStrength = [1, true, true, true];
    /*
        This array of four entries distinguishes manual and automatic moves.
        If manualStrength[0] is 1, it's a manual move. Only these will trigger automatic moves from them, and only these increment manual_moves_so_far.
        If manualStrength[0] is 0, it's an automatic move.
        If manualStrength[0] is -1, it's an automatic move that counts as part of the manual move that triggered it, which means moves_so_far doesn't increment, tiles don't spawn, and so on.
        manualStrength[1] is whether merges can occur, manualStrength[2] is whether length-0 merges can occur, and manualStrength[3] is whether scripts that execute at the beginning or end of a move (BeginTurn, EndMovement, EndTurn, etc.) execute or not.
    */
    if (direction.length > 4) manualStrength = direction[4];
    if (direction.length > 5) {
        let probability = direction[5];
        if (Math.random() * 100 > probability) return false;
    }
    if (manualStrength[3]) executeScripts("BeginTurn", 0, 0, vdir, hdir, [1, slideAmount, moveType]);
    if (manual) inputAvailable = false;
    displayButtons(false);
    let movementOccurred = false; // If this is still false by the end of the move, then a move hasn't actually occured, so mark the direction as not available and don't spawn more tiles.
    let mergeCount = 0; // How many merges have occurred this move?
    let TileOrder = []; // When moving upwards, tiles closest to the top move first, and similarly for the other directions. Vertical outweighs horizontal, though that choice is arbitrary
    let stillMoving = []; // Which tiles in TileOrder are still moving?
    let mergeable = []; // Which tiles in TileOrder haven't merged already?
    if (manualStrength[0] == 1) {
        for (let a = 0; a < auto_directions.length; a++) {
            if (auto_directions[a][1] == "Before" && (auto_directions[a].length < 3 || CalcArray(auto_directions[a][2], 0, 0, vdir, hdir, [1, slideAmount, moveType]) === true)) {
                let subMoved = await MoveHandler(a, false);
                if (subMoved) movementOccurred = true;
            }
        }
    }
    if ((vdir == 0 && hdir == 0) || slideAmount == 0) { // If both movement magnitudes are zero, this move is just staying still and letting new tiles spawn
        for (let row = 0; row < height; row++) {
            for (let column = 0; column < width; column++) {
                TileOrder.push([row, column]);
                stillMoving.push(true);
                mergeable.push(true);
            }
        }
        for (let row = 0; row < height; row++) {
            for (let column = 0; column < width; column++) {
                if (Grid[row][column] == "@Empty") {
                    movementOccurred = true;
                    executeScripts("StayStill", 0, 0, vdir, hdir, [1, slideAmount, moveType]);
                    break;
                }
            }
        }
    }
    else {
        if (vdir < 0) {
            for (let row = 0; row < height; row++) {
                for (let column = 0; column < width; column++) {
                    TileOrder.push([row, column]);
                    stillMoving.push(true);
                    mergeable.push(true);
                }
            }
        }
        else if (vdir > 0) {
            for (let row = height - 1; row >= 0; row--) {
                for (let column = 0; column < width; column++) {
                    TileOrder.push([row, column]);
                    stillMoving.push(true);
                    mergeable.push(true);
                }
            }
        }
        else if (hdir < 0) {
            for (let column = 0; column < width; column++) {
                for (let row = 0; row < height; row++) {
                    TileOrder.push([row, column]);
                    stillMoving.push(true);
                    mergeable.push(true);
                }
            }
        }
        else if (hdir > 0) {
            for (let column = width - 1; column >= 0; column--) {
                for (let row = 0; row < height; row++) {
                    TileOrder.push([row, column]);
                    stillMoving.push(true);
                    mergeable.push(true);
                }
            }
        }
        let slides = 0; // How many times have all the tiles gone through the movement process? If this value reaches SlideAmount, end the move early.
        let endScriptsChecked = false;
        while ((stillMoving.indexOf(true) > -1 || !endScriptsChecked) && slides < slideAmount) {
            let oldStillMoving = compendiumStructuredClone(stillMoving); // oldStillMoving is used for animation purposes
            for (let position of TileOrder) {
                let index = indexOfPrimArray(position, TileOrder);
                if (!(stillMoving[index])) continue;
                let tile = Grid[position[0]][position[1]];
                let paramV = CalcArray(movementParameters[0], position[0], position[1], vdir, hdir, [1, slideAmount, moveType]);
                let paramH = CalcArray(movementParameters[1], position[0], position[1], vdir, hdir, [1, slideAmount, moveType]);
                let paramSlide = CalcArray(movementParameters[2], position[0], position[1], vdir, hdir, [1, slideAmount, moveType]);
                if ((paramV == 0 && paramH == 0) || slides >= paramSlide) { stillMoving[index] = false; oldStillMoving[index] = false; continue; }
                let nextpositions = [];
                let nextindices = [];
                let nexttiles = [];
                let finding_positions = true;
                while (finding_positions) {
                    if (nextpositions.length == 0) nextpositions.push(compendiumStructuredClone(position));
                    else nextpositions.push(compendiumStructuredClone(nextpositions[nextpositions.length - 1]));
                    nextpositions[nextpositions.length - 1][0] += paramV;
                    nextpositions[nextpositions.length - 1][1] += paramH;
                    while (indexOfPrimArray(nextpositions[nextpositions.length - 1], TileOrder) != -1 && Grid[nextpositions[nextpositions.length - 1][0]][nextpositions[nextpositions.length - 1][1]] == "@Slippery") {
                        nextpositions[nextpositions.length - 1][0] += paramV;
                        nextpositions[nextpositions.length - 1][1] += paramH;
                    }
                    if (indexOfPrimArray(nextpositions[nextpositions.length - 1], TileOrder) == -1) {
                        nextpositions.pop();
                        finding_positions = false;
                    }
                    else {
                        nextindices.push(indexOfPrimArray([nextpositions[nextpositions.length - 1][0], nextpositions[nextpositions.length - 1][1]], TileOrder));
                        nexttiles.push(Grid[nextpositions[nextpositions.length - 1][0]][nextpositions[nextpositions.length - 1][1]]);
                    }
                }
                if (tile == "@Empty" || tile == "@Void" || tile.includes("@TemporaryHole") || tile == "@Slippery") {
                    stillMoving[index] = false; oldStillMoving[index] = false; continue;
                }
                else if (nexttiles[0] == "@Empty") { // If the tile ahead of the currently-examined tile is empty, the tile moves
                    Grid[nextpositions[0][0]][nextpositions[0][1]] = compendiumStructuredClone(Grid[position[0]][position[1]]);
                    Grid[position[0]][position[1]] = "@Empty";
                    stillMoving[index] = false;
                    stillMoving[nextindices[0]] = true;
                    movementOccurred = true;
                    if (manualStrength[3]) executeScripts("TileMove", position[0], position[1], paramV, paramH, [1, paramSlide, moveType]);
                }
                else if ((mergeable[index] || multiMerge) && manualStrength[1]) { // Checking for an applicable merge rule, and applying it if one is found. Earlier entries in MergeRules take priority over later ones.
                    let rule = false;
                    let vars = [];
                    let outputpositions = [];
                    let mlength, overflowType, reverseMergePosition;
                    let mergeResults = [];
                    let [checkedTiles, backTiles, frontTiles] = [[], [], []];
                    let knownMergeIndex = -2;
                    let rulesToCheck = MergeRules; // This will be changed to only contain the correct rule if a known merge rule is found
                    if (mergeResultKnownLevel > 0) {
                        checkedTiles = [];
                        checkedTiles.push(compendiumStructuredClone(Grid[position[0]][position[1]]));
                        let index = 0;
                        while (checkedTiles.length < knownMergeMaxLength && index < nexttiles.length) {
                            if (mergeable[nextindices[index]] === false) break;
                            checkedTiles.push(compendiumStructuredClone(Grid[nextpositions[index][0]][nextpositions[index][1]]));
                            index++;
                        }
                        if (checkedTiles.length == knownMergeMaxLength) {
                            while (frontTiles.length < knownMergeLookbackDistance - 1 && index < nexttiles.length) {
                                frontTiles.push(compendiumStructuredClone(Grid[nextpositions[index][0]][nextpositions[index][1]]));
                                index++;
                            }
                        }
                        index = -1;
                        while (backTiles.length < knownMergeLookbackDistance) {
                            let BTposition = CalcArray(["@NextNE " + index + " @Position"], position[0], position[1], paramV, paramH, [rule[0], paramSlide, moveType], Grid, [], vars);
                            if (indexOfPrimArray(BTposition, TileOrder) == -1) break;
                            backTiles.push(compendiumStructuredClone(Grid[BTposition[0]][BTposition[1]]));
                            index++;
                        }
                        knownMergeIndex = indexOfPrimArray([checkedTiles, backTiles, frontTiles], knownMergeResultInputs);
                        if (knownMergeIndex > -1) {
                            let output = knownMergeResultOutputs[knownMergeIndex];
                            if (output[0] > -1) rulesToCheck = [[[output[0], [true], true, output[1], output[2], output[3]], [], output[0], 0, 0]];
                            else rulesToCheck = [[false]];
                        }
                    }
                    MergeCheck: for (let m = 0; m < rulesToCheck.length; m++) {
                        let applies = (knownMergeIndex > -1) ? rulesToCheck[0] : mergeRuleApplies(rulesToCheck[m], position[0], position[1], paramV, paramH, [paramSlide, moveType], Grid, 0);
                        if (applies[0] !== false && applies[0][0] != 0) {
                            for (let p = applies[0][0] - 1; p >= 0; p--) { // The merge has only been found if all the tiles in the merge are still capable of merging
                                if ((mergeable[nextindices[p - 1]] === false || mergeable[index] === false) && !multiMerge) {
                                    continue MergeCheck;
                                }
                            }
                            [rule, vars, mlength, overflowType, reverseMergePosition] = applies;
                            let vcoordMM, hcoordMM;
                            vcoordMM = position[0];
                            hcoordMM = position[1];
                            outputpositions = [];
                            let mergeResultRules = compendiumStructuredClone(rule[3]);
                            let validMergeModifiers = ["@MergeReverseStart", "@MergeOverflowEmpty", "@MergeOverflowSlot", "@MergeOverflowOverwrite"];
                            while (validMergeModifiers.indexOf(mergeResultRules[0]) != -1) {
                                let mergeModifier = mergeResultRules.shift();
                                if (mergeModifier == "@MergeReverseStart") {
                                    reverseMergePosition = !reverseMergePosition;
                                }
                                if (mergeModifier == "@MergeOverflowEmpty") {
                                    overflowType = 0;
                                }
                                if (mergeModifier == "@MergeOverflowSlot") {
                                    overflowType = 1;
                                }
                                if (mergeModifier == "@MergeOverflowOverwrite") {
                                    overflowType = 2;
                                }
                            }
                            if (mergeResultRules[0] == "@CalcArray") mergeResultRules = CalcArray(mergeResults.slice(1), position[0], position[1], paramV, paramH, [rule[0], paramSlide, moveType], Grid, [], vars);
                            for (let i = 0; i < mlength; i++) {
                                if (i > 0) {
                                    [vcoordMM, hcoordMM] = CalcArray(["@Next 1 @Position"], vcoordMM, hcoordMM, paramV, paramH);
                                }
                                outputpositions.push([vcoordMM, hcoordMM]);
                            }
                            if (!reverseMergePosition) {
                                outputpositions.reverse();
                                [vcoordMM, hcoordMM] = outputpositions[outputpositions.length - 1];
                            }
                            if (mergeResultRules.length > mlength) { // Check if overflow is allowed
                                let newPosition;
                                for (let i = mlength; i < mergeResultRules.length; i++) {
                                    newPosition = CalcArray([(overflowType == 1 ? "@NextFull " : "@Next ") + (reverseMergePosition ? 1 : -1) + " @Position"], vcoordMM, hcoordMM, paramV, paramH);
                                    if (newPosition === undefined || typeof newPosition == "string" || newPosition === false) continue MergeCheck;
                                    [vcoordMM, hcoordMM] = newPosition;
                                    if ((Grid[vcoordMM][hcoordMM] !== "@Empty" && overflowType == 0) || Grid[vcoordMM][hcoordMM] === "@Void" || Grid[vcoordMM][hcoordMM].includes("@TemporaryHole")) continue MergeCheck;
                                    outputpositions.push([vcoordMM, hcoordMM]);
                                }
                            }
                            if (overflowType != 0) console.log(outputpositions);
                            for (let e = 0; e < mergeResultRules.length; e++) {
                                if (mergeResultRules[e][0] == "@CalcArray") mergeResultRules[e] = CalcArray(mergeResultRules[e].slice(1), position[0], position[1], paramV, paramH, [rule[0], paramSlide, moveType], Grid, [], vars);
                                let newarray = [];
                                for (let tentry of mergeResultRules[e]) {newarray.push((knownMergeIndex > -1) ? tentry : CalcArray(tentry, position[0], position[1], paramV, paramH, [rule[0], paramSlide, moveType], Grid, [], vars));}
                                if (typeof newarray == "boolean") newarray = "@Empty";
                                mergeResults.push(newarray);
                            }
                            break MergeCheck;
                        }
                    }
                    if (rule === false && mergeResultKnownLevel > 0 && knownMergeIndex == -1) {
                        knownMergeResultInputs.push([checkedTiles, backTiles, frontTiles]);
                        knownMergeResultOutputs.push([-1, [], 0, []])
                    }
                    if (rule !== false) { // If we found a rule, it's time to do the merge
                        Merge: {
                            let preMergeGrid = compendiumStructuredClone(Grid);
                            for (let entry = 0; entry < outputpositions.length || entry < rule[0]; entry++) {
                                let examinedposition = outputpositions[entry];
                                let examinedindex = indexOfPrimArray(examinedposition, TileOrder);
                                if (entry < mergeResults.length) {
                                    Grid[examinedposition[0]][examinedposition[1]] = mergeResults[entry];
                                    mergeable[examinedindex] = rule[5][entry];
                                    oldStillMoving[examinedindex] = !(rule[5][entry]);
                                }
                                else {
                                    Grid[examinedposition[0]][examinedposition[1]] = "@Empty";
                                    mergeable[examinedindex] = rule[5][entry];
                                    oldStillMoving[examinedindex] = true;
                                }
                            }
                            merges_so_far++;
                            oldStillMoving[nextindices[rule[0] - 2]] = false;
                            let scoreAdd = CalcArrayConvert(CalcArray(rule[4], position[0], position[1], paramV, paramH, [rule[0], paramSlide, moveType], preMergeGrid, [], vars), "+", position[0], position[1], paramV, paramH, [rule[0], paramSlide, moveType], preMergeGrid, [], vars)
                            score += scoreAdd;
                            if (mergeResultKnownLevel > 0 && knownMergeIndex == -1) {
                                knownMergeResultInputs.push([checkedTiles, backTiles, frontTiles]);
                                let overflowArray;
                                if (overflowType == 1) overflowArray = ["@MergeOverflowSlot"];
                                else if (overflowType == 2) overflowArray = ["@MergeOverflowOverwrite"];
                                else overflowArray = [];
                                knownMergeResultOutputs.push([rule[0], overflowArray.concat((reverseMergePosition ? ["@MergeStartReverse"] : []), mergeResults), scoreAdd, rule[5]])
                            }
                            executeScripts("Merge", position[0], position[1], paramV, paramH, [rule[0], paramSlide], Grid, [], vars.concat(["@Literal"].concat(mergeResults)));
                            tileDiscoveryCheck();
                            movementOccurred = true;
                            mergeCount++;
                            for (let t = 0; t < stillMoving.length; t++) stillMoving[t] = true;
                        }
                    }
                    else {
                        stillMoving[index] = false; oldStillMoving[index] = false;
                    }
                }
                else {
                    stillMoving[index] = false; oldStillMoving[index] = false;
                }
            }
            if (modifiers[16] > 0) { // Movement animation
                let frames = 10 / modifiers[16];
                frames = Math.ceil(40 / modifiers[16] / Math.max(width / (hexagonal ? 2 : 1), height) * Math.max(Math.abs(vdir), Math.abs(hdir / (hexagonal ? 2 : 1))));
                for (let f = 1; f <= frames; f++) {
                    for (let i = 0; i < TileOrder.length; i++) {
                        if (oldStillMoving[i]) {
                            let paramV = CalcArray(movementParameters[0], TileOrder[i][0], TileOrder[i][1], vdir, hdir, [1, slideAmount, moveType]);
                            let paramH = CalcArray(movementParameters[1], TileOrder[i][0], TileOrder[i][1], vdir, hdir, [1, slideAmount, moveType]);
                            let tID = "Tile_" + TileOrder[i][0] + "_" + TileOrder[i][1];
                            document.getElementById(tID).style.setProperty("left", (100 / frames * f * paramH * (hexagonal ? Math.sqrt(3) / 4 : 1)) + "%");
                            document.getElementById(tID).style.setProperty("top", (100 / frames * f * paramV  * (hexagonal ? 0.75 : 1)) + "%");
                        }
                    }
                    await delay(0);
                }
            }
            slides++;
            executeScripts("MoveIteration", 0, 0, vdir, hdir, [1, slideAmount, moveType]);
            if (modifiers[16] > 0 || stillMoving.indexOf(true) == -1) displayGrid();
            if (stillMoving.indexOf(true) == -1) {
                if (!endScriptsChecked) {
                    if (executeScripts("PossibleEnd", 0, 0, vdir, hdir, [1, slideAmount, moveType]) > 0) { for (let t = 0; t < stillMoving.length; t++) stillMoving[t] = true; }
                    endScriptsChecked = true;
                }
            }
            else endScriptsChecked = false;
        }
    }
    if (manualStrength[0] == 1) {
        for (let a = 0; a < auto_directions.length; a++) {
            if (auto_directions[a][1] == "Between" && (auto_directions[a].length < 3 || CalcArray(auto_directions[a][2], 0, 0, vdir, hdir, [1, slideAmount, moveType]) === true)) {
                let subMoved = await MoveHandler(a, false);
                if (subMoved) movementOccurred = true;
            }
        }
    }
    if (movementOccurred) {
        executeScripts("EndMovementDirection", 0, 0, vdir, hdir, [1, slideAmount, moveType]);
        if (manualStrength[3]) executeScripts("EndMovement", 0, 0, vdir, hdir, [1, slideAmount, moveType]);
        if (manual) {
            for (let d = 0; d < directionsAvailable.length; d++) {directionsAvailable[d] = true;} //For unknown reasons, a for-of loop refuses to work here
        }
        if (manualStrength[2]) {
            for (let position of TileOrder) {
                if (Grid[position[0]][position[1]].includes("@TemporaryHole")) {
                    let THNum = Number(Grid[position[0]][position[1]].slice(15)) - 1;
                    if (THNum > 0) Grid[position[0]][position[1]] = "@TemporaryHole " + THNum;
                    else Grid[position[0]][position[1]] = "@Empty";
                }
                if (Grid[position[0]][position[1]] == "@Empty" || Grid[position[0]][position[1]] == "@Void" || Grid[position[0]][position[1]].includes("@TemporaryHole") || Grid[position[0]][position[1]] == "@Slippery") continue;
                ZeroMergeCheck:
                for (let m = 0; m < MergeRules.length; m++) {
                    /*
                    This checks for merge rules of length 0, which are a special case: merge rules of length 0 are effects that are applied to a single tile
                    at the end of the move. Each length 0 merge rule is only checked once per tile per move. For example, Isotopic 256 uses length-0 merge rules
                    to decrease the radioactivity counters of radioactive tiles.
                    I'm not going to bother adding knownMergeResult support for these.
                    */
                    let rule = false;
                    if (typeof MergeRules[m][0] === "number" && MergeRules[m][0] !== 0) continue ZeroMergeCheck;
                    let applies = mergeRuleApplies(MergeRules[m], position[0], position[1], vdir, hdir, [slideAmount, moveType], Grid, 0);
                    let outputpositions, mlength, overflowType, reverseMergePosition;
                    let mergeResults = [];
                    if (applies[0] !== false && applies[0][0] == 0) {
                        [rule, vars, mlength, overflowType, reverseMergePosition] = applies;
                        mlength = 1;
                        let vcoordMM, hcoordMM;
                        vcoordMM = position[0];
                        hcoordMM = position[1];
                        outputpositions = [];
                        let mergeResultRules = compendiumStructuredClone(rule[3]);
                        let validMergeModifiers = ["@MergeReverseStart", "@MergeOverflowEmpty", "@MergeOverflowSlot", "@MergeOverflowOverwrite"];
                        while (validMergeModifiers.indexOf(mergeResultRules[0]) != -1) {
                            let mergeModifier = mergeResultRules.shift();
                            if (mergeModifier == "@MergeReverseStart") {
                                reverseMergePosition = !reverseMergePosition;
                            }
                            if (mergeModifier == "@MergeOverflowEmpty") {
                                overflowType = 0;
                            }
                            if (mergeModifier == "@MergeOverflowSlot") {
                                overflowType = 1;
                            }
                            if (mergeModifier == "@MergeOverflowOverwrite") {
                                overflowType = 2;
                            }
                        }
                        if (mergeResultRules[0] == "@CalcArray") mergeResultRules = CalcArray(mergeResults.slice(1), position[0], position[1], vdir, hdir, [rule[0], slideAmount, moveType], Grid, [], vars);
                        for (let i = 0; i < mlength; i++) {
                            if (i > 0) {
                                [vcoordMM, hcoordMM] = CalcArray(["@Next 1 @Position"], vcoordMM, hcoordMM, vdir, hdir);
                            }
                            outputpositions.push([vcoordMM, hcoordMM]);
                        }
                        if (!reverseMergePosition) {
                            outputpositions.reverse();
                            [vcoordMM, hcoordMM] = outputpositions[outputpositions.length - 1];
                        }
                        if (mergeResultRules.length > mlength) { // Check if overflow is allowed
                            let newPosition;
                            for (let i = mlength; i < mergeResultRules.length; i++) {
                                newPosition = CalcArray([(overflowType == 1 ? "@NextFull " : "@Next ") + (reverseMergePosition ? 1 : -1) + " @Position"], vcoordMM, hcoordMM, vdir, hdir);
                                if (newPosition === undefined || typeof newPosition == "string" || newPosition === false) continue ZeroMergeCheck;
                                [vcoordMM, hcoordMM] = newPosition;
                                if ((Grid[vcoordMM][hcoordMM] !== "@Empty" && overflowType == 0) || Grid[vcoordMM][hcoordMM] === "@Void" || Grid[vcoordMM][hcoordMM].includes("@TemporaryHole")) continue ZeroMergeCheck;
                                outputpositions.push([vcoordMM, hcoordMM]);
                            }
                        }
                        for (let e = 0; e < mergeResultRules.length; e++) {
                            if (mergeResultRules[e][0] == "@CalcArray") mergeResultRules[e] = CalcArray(mergeResultRules[e].slice(1), position[0], position[1], vdir, hdir, [rule[0], slideAmount, moveType], Grid, [], vars);
                            let newarray = [];
                            for (let tentry of mergeResultRules[e]) {newarray.push(CalcArray(tentry, position[0], position[1], vdir, hdir, [rule[0], slideAmount, moveType], Grid, [], vars));}
                            if (typeof newarray == "boolean") newarray = "@Empty";
                            mergeResults.push(newarray);
                        }
                    }
                    if (rule !== false) {
                        let preMergeGrid = compendiumStructuredClone(Grid);
                        for (let entry = 0; entry < outputpositions.length || entry < rule[0]; entry++) {
                            let examinedposition = outputpositions[entry];
                            if (entry < rule[3].length) {
                                Grid[examinedposition[0]][examinedposition[1]] = mergeResults[entry];
                            }
                            else {
                                Grid[examinedposition[0]][examinedposition[1]] = "@Empty";
                            }
                        }
                        score += CalcArrayConvert(CalcArray(rule[4], position[0], position[1], vdir, hdir, [rule[0], slideAmount, moveType], preMergeGrid, [], vars), "+", position[0], position[1], vdir, hdir, [rule[0], slideAmount, moveType], preMergeGrid, [], vars);
                        executeScripts("ZeroMerge", position[0], position[1], vdir, hdir, [rule[0], slideAmount], preMergeGrid, [], vars);
                        tileDiscoveryCheck();
                    }
                }
            }
        }
        if (manualStrength[0] > -1) moves_so_far++;
        if (manualStrength[0] == 1) manual_moves_so_far++;
        if (mergeCount > 0) { // Transferring the merges done this move into Merges Before This Move
            if (manualStrength[0] > -1) moves_where_merged++;
            merges_before_now += mergeCount;
        }
        if (CalcArray(spawnConditions) === true && manualStrength[0] > -1) {
            if (manualStrength[3]) executeScripts("PreSpawn", 0, 0, vdir, hdir, [1, slideAmount, moveType]);
            let spawnedTiles = [];
            spawnedTiles = spawnedTiles.concat(
                forcedSpawnTiles("BeforeSpawns", vdir, hdir, [1, slideAmount, moveType]),
                RandomTiles(randomTileAmount, vdir, hdir, [1, slideAmount, moveType]),
                forcedSpawnTiles("AfterSpawns", vdir, hdir, [1, slideAmount, moveType]),
            );
            if (manualStrength[3]) executeScripts("PostSpawn", 0, 0, vdir, hdir, [1, slideAmount, moveType], Grid, [], [spawnedTiles]);
        }
        if (manualStrength[3]) executeScripts("EndTurn", 0, 0, vdir, hdir, [1, slideAmount, moveType]);
    }
    else {
        if (manual) directionsAvailable[direction_num] = false; // Marks the direction as not available if the move failed
    }
    if (manualStrength[0] == 1) {
        for (let a = 0; a < auto_directions.length; a++) {
            if (auto_directions[a][1] == "After" && (auto_directions[a].length < 3 || CalcArray(auto_directions[a][2], 0, 0, vdir, hdir, [1, slideAmount, moveType]) === true)) {
                let subMoved = await MoveHandler(a, false);
                if (subMoved) movementOccurred = true;
            }
        }
    }
    tileDiscoveryCheck();
    let victory = winCheck();
    if (directionsAvailable.indexOf(true) == -1 && manualStrength[0] > -1) {
        if (!possibleOverChecked && executeScripts("PossibleOver", 0, 0, vdir, hdir, [1, slideAmount, moveType]) > 0) {
            for (let d = 0; d < directionsAvailable.length; d++) {directionsAvailable[d] = true;}
            possibleOverChecked = true;
            if (manualStrength[3] && manualStrength[0] == 1) executeScripts("TrueEndTurn", 0, 0, vdir, hdir, [1, slideAmount, moveType]);
            displayButtons(true);
            inputAvailable = true;
        }
        else {
            executeScripts("TrueEndTurn", 0, 0, vdir, hdir, [1, slideAmount, moveType]);
            executeScripts("GameOver", 0, 0, vdir, hdir, [1, slideAmount, moveType]);
            GameOver();
        }
    }
    else {
        if ((victory == 1 || (victory == 2 && winPriority)) && manualStrength[0] > -1) {
            executeScripts("TrueEndTurn", 0, 0, vdir, hdir, [1, slideAmount, moveType]);
            executeScripts("Victory", 0, 0, vdir, hdir, [1, slideAmount, moveType]);
            winScreen();
        }
        else if ((victory == -1 || (victory == 2 && !winPriority)) && manualStrength[0] > -1) {
            executeScripts("TrueEndTurn", 0, 0, vdir, hdir, [1, slideAmount, moveType]);
            executeScripts("GameOver", 0, 0, vdir, hdir, [1, slideAmount, moveType]);
            GameOver();
        }
        else if (manual) {
            if (manualStrength[3] && manualStrength[0] == 1) executeScripts("TrueEndTurn", 0, 0, vdir, hdir, [1, slideAmount, moveType]);
            displayButtons(true);
            inputAvailable = true;
        }
    }
    displayGrid();
    if (tileDisplayKnownLevel < 2) {
        knownTileDisplayArrays = [];
        knownTileDisplayNodes = [];
    }
    else if (tileDisplayKnownLevel == 2) {
        let flatGrid = Grid.flat(1);
        for (let index = 0; index < knownTileDisplayArrays.length; index++) {
            if (indexOfPrimArray(knownTileDisplayArrays[index][0], flatGrid) == -1 && indexOfPrimArray(knownTileDisplayArrays[index][0], spawnConveyor) == -1) {
                knownTileDisplayArrays.splice(index, 1);
                knownTileDisplayNodes.splice(index, 1);
                index--;
            }
        }
    }
    if (mergeResultKnownLevel < 2) {
        knownTileDisplayArrays = [];
        knownTileDisplayNodes = [];
    }
    else if (mergeResultKnownLevel == 2) {
        let flatGrid = Grid.flat(1);
        MRLoop:
        for (let index = 0; index < knownMergeResultInputs.length; index++) {
            let flatInputs = knownMergeResultInputs[index].flat(1);
            for (let input = 0; input < flatInputs.length; input++) {
                if (indexOfPrimArray(flatInputs[input], flatGrid) == -1) {
                    knownMergeResultInputs.splice(index, 1);
                    knownMergeResultOutputs.splice(index, 1);
                    index--;
                    continue MRLoop;
                }
            }
        }
    }
    return movementOccurred;
}

function tileDiscoveryCheck() { // Adds newly-discovered tiles into discoveredTiles if there are any
    for (let row = 0; row < height; row++) {
        for (let column = 0; column < width; column++) {
            if (indexOfPrimArray(Grid[row][column], discoveredTiles) == -1 && !(Grid[row][column] == "@Empty" || Grid[row][column] == "@Void"))
                discoveredTiles.push(Grid[row][column]);
        }
    }
}

function winCheck() { // Adds newly-discovered winning tiles into discoveredWinning if there are any, and checks to see if the game has been won; likewise for discoveredLosing. Returns 0 if neither, returns 1 if won, returns -1 if lost, and returns 2 if both
    let checkWin = false;
    let checkLose = false;
    for (let row = 0; row < height; row++) {
        for (let column = 0; column < width; column++) {
            if (indexOfPrimArray(Grid[row][column], discoveredWinning) == -1) {
                let winnum = 0;
                let winfound = false;
                while ((!winfound) && winnum < winConditions.length) {
                    if (eqPrimArrays(winConditions[winnum], Grid[row][column]) || (CalcArray(winConditions[winnum], row, column) === true)) winfound = true;
                    else winnum++;
                }
                if (winfound) {
                    discoveredWinning.push(Grid[row][column]);
                }
            }
        }
    }
    for (let row = 0; row < height; row++) {
        for (let column = 0; column < width; column++) {
            if (indexOfPrimArray(Grid[row][column], discoveredLosing) == -1) {
                let losenum = 0;
                let losefound = false;
                while ((!losefound) && losenum < loseConditions.length) {
                    if (eqPrimArrays(loseConditions[losenum], Grid[row][column]) || (CalcArray(loseConditions[losenum], row, column) === true)) losefound = true;
                    else losenum++;
                }
                if (losefound) {
                    discoveredLosing.push(Grid[row][column]);
                }
            }
        }
    }
    if (won != -1 && won != -3) {
        if (won >= 0) won = discoveredWinning.length;
        if (typeof winRequirement == "number" && discoveredWinning.length >= winRequirement) checkWin = true;
        if (typeof winRequirement != "number" && CalcArray(winRequirement) === true) checkWin = true;
    }
    if (won == -2 || won == -3) checkLose = true;
    if (typeof loseRequirement == "number" && discoveredLosing.length >= loseRequirement) checkLose = true;
    if (typeof loseRequirement != "number" && CalcArray(loseRequirement) === true) checkLose = true;
    if (checkWin && checkLose) return 2;
    else if (checkWin && !checkLose) return 1;
    else if (!checkWin && checkLose) return -1;
    else return 0;
}

function executeScripts(type) { //Runs the scripts of that type, and returns the amount of scripts that were run
    let vcoord = 0; let hcoord = 0; let vdir = 0; let hdir = 0; let addInfo = [1, Infinity, 0]; let gri = Grid; let parents = []; let vars = [];
    if (arguments.length > 1) vcoord = arguments[1];
    if (arguments.length > 2) hcoord = arguments[2];
    if (arguments.length > 3) vdir = arguments[3];
    if (arguments.length > 4) hdir = arguments[4];
    if (arguments.length > 5) addInfo = arguments[5];
    if (arguments.length > 6) gri = arguments[6];
    if (arguments.length > 7) parents = arguments[7];
    if (arguments.length > 8) vars = arguments[8];
    let srun = 0; // How many scripts have been run this call
    for (let i = 0; i < scripts.length; i++) {
        if (scripts[i][1] == type) {
            CalcArray(scripts[i][0], vcoord, hcoord, vdir, hdir, addInfo, gri, parents, compendiumStructuredClone(vars));
            srun++;
        }
    }
    return srun;
    /*
    List of script types:
        BeginTurn: Executes at the beginning of each turn
        EndTurn: Executes at the end of each turn
        StayStill: Executes before EndMovement scripts on a staying still movement (vdir and hdir are both 0 and/or slideAmount is 0)
        MoveIteration: Executes after each "slide", i.e. after every tile that's going to move moves one move in the direction of movement
        TileMove: Executes whenever a tile moves
        Merge: Executes whenever a merge occurs (not including length-0 merges). If @var_retain or @var_copy is included, then the variables of the merge rule are included, and one more variable comes after them, that being an array of the tiles resulting from the merge.
        EndMovement: Executes when the movement of that turn finishes, but before length-0 merges
        EndMovementDirection: Executes right before the EndMovement scripts; unlike the EndMovement scripts, these can trigger even on automatic moves that don't trigger beginning/end scripts
        PossibleEnd: Executes when the movement of that turn is about to finish; if there are any of these scripts, the end of the turn is postponed in case tiles can still move after the script (the turn then ends if no tiles move directly afterwards)
        PreSpawn: Executes right before the new random tiles spawn; will not execute if spawnConditions evaluates to false this turn
        PostSpawn: Executes right after the new random tiles spawn; will not execute if spawnConditions evaluates to false this turn. For these scripts, if @var_retain or @var_copy is included, "@Var 0" is an array of the tiles that were just spawned.
        ZeroMerge: Executes whenever a length-0 merge occurs
        PossibleOver: Executes when it's about to be Game Over: if there are any of these scripts, the Game Over is postponed in case it's not quite game over yet (but if there are still no moves left, then it's game over for real)
        Victory: Executes upon winning (right before the win screen pops up)
        GameOver: Executes upon Game Over (right before the Game Over screen pops up)
        TrueEndTurn: Executes at the very end of the turn, after all the win condition stuff is checked (but before Victory or GameOver scripts).
        None: Is not triggered automatically, but can still be called directly in CalcArray expressions (this is true of any type that aren't the ones listed above, but "None" is the recommended way to denote this)
    */
}


//Endgame
async function GameOver() {
    displayGrid();
    currentScreen = "Game Over";
    document.getElementById("game_over_screen").style.setProperty("opacity", 0);
    document.getElementById("game_over_screen").style.setProperty("display", "flex");
    let frames = 100;
    if (modifiers[16] > 0) {
        frames = 100/modifiers[16];
        for (let f = 0; f < frames; f++) {
            document.getElementById("game_over_screen").style.setProperty("opacity", f / frames);
            await delay(2);
        }
    }
    document.getElementById("game_over_screen").style.setProperty("opacity", 1);
    displayButtons(false);
    inputAvailable = true;
}

async function winScreen() {
    displayGrid();
    currentScreen = "Win";
    document.getElementById("win_screen").style.setProperty("opacity", 0);
    document.getElementById("win_screen").style.setProperty("display", "flex");
    if (postgameAllowed) {
        document.getElementById("win_again").style.setProperty("display", "flex");
        document.getElementById("win_continue").style.setProperty("display", "flex");
        document.getElementById("lone_win_again").style.setProperty("display", "none");
    }
    else {
        document.getElementById("win_again").style.setProperty("display", "none");
        document.getElementById("win_continue").style.setProperty("display", "none");
        document.getElementById("lone_win_again").style.setProperty("display", "flex");
    }
    let frames = 100;
    if (modifiers[16] > 0) {
        frames = 100/modifiers[16];
        for (let f = 0; f < frames; f++) {
            document.getElementById("win_screen").style.setProperty("opacity", f / frames);
            await delay(2);
        }
    }
    document.getElementById("win_screen").style.setProperty("opacity", 1);
    inputAvailable = true;
}

async function PlayAgain() {
    inputAvailable = false;
    document.getElementById("game_over_screen").style.setProperty("opacity", 0);
    document.getElementById("game_over_screen").style.setProperty("display", "none");
    document.getElementById("win_screen").style.setProperty("opacity", 0);
    document.getElementById("win_screen").style.setProperty("display", "none");
    for (let d = 0; d < directionsAvailable.length; d++) directionsAvailable[d] = true;
    possibleOverChecked = false;
    score = 0;
    won = 0;
    moves_so_far = 0;
    merges_so_far = 0;
    moves_where_merged = 0;
    merges_before_now = 0;
    discoveredTiles = [];
    discoveredWinning = [];
    discoveredLosing = [];
    knownTileDisplayArrays = [];
    knownTileDisplayNodes = [];
    knownMergeResultInputs = [];
    knownMergeResultOutputs = [];
    Grid = compendiumStructuredClone(startingGrid);
    loadResettingModifiers();
    currentScreen = "Gameplay";
    TileSpawns = compendiumStructuredClone(startTileSpawns);
    game_vars = compendiumStructuredClone(start_game_vars);
    modifier_vars = compendiumStructuredClone(start_modifier_vars);
    spawnConveyor = [];
    for (let i = 0; i < Math.max(nextTiles, 1); i++) spawnConveyor.push("@Empty");
    refillSpawnConveyor();
    forcedSpawnTiles("BeforeSpawns", 0, 0);
    RandomTiles(startTileAmount, 0, 0);
    forcedSpawnTiles("AfterSpawns", 0, 0);
    displayButtons(true);
    inputAvailable = true;
}

//Custom Mode

async function displayCustomMode(subscreen, vars) {
    for (let c of document.getElementById("custom_mode").children) c.style.setProperty("display", "none");
    for (let c of document.getElementById("customMode_pageLine").children) c.style.setProperty("display", "none");
    document.getElementById("customMode_pageLine").style.setProperty("display", "flex");
    document.getElementById("customError").style.setProperty("display", "none");
    if (subscreen == "Opening") {
        document.getElementById("customModeOpening").style.setProperty("display", "block");
        document.getElementById("customMode_return").style.setProperty("display", "flex");
        document.documentElement.style.setProperty("background-image", "linear-gradient(#ea48ec, #5223c9, #ea48ec)");
    }
    else if (subscreen == "SpawningTiles") {
        document.getElementById("customModeSpawningTiles").style.setProperty("display", "block");
        document.documentElement.style.setProperty("background-image", "linear-gradient(#ba00e4, #98ff8f, #ba00e4)");
        document.getElementById("customMode_quit").style.setProperty("display", "flex");
        document.getElementById("customMode_nextPage").style.setProperty("display", "flex");
        if (customSpawningTiles[0]) {
            document.getElementById("customBoxSpawnOff").style.setProperty("display", "none");
            document.getElementById("customBoxSpawnOn").style.setProperty("display", "inline-flex");
        }
        else {
            document.getElementById("customBoxSpawnOff").style.setProperty("display", "inline-flex");
            document.getElementById("customBoxSpawnOn").style.setProperty("display", "none");
        }
        while (document.getElementById("customSpawnBox").childElementCount > customSpawningTiles.length - 1) {
            document.getElementById("customSpawnBox").removeChild(document.getElementById("customSpawnBox").lastElementChild);
        }
        while (document.getElementById("customSpawnBox").childElementCount < customSpawningTiles.length - 1) {
            let spawnNum = document.getElementById("customSpawnBox").childElementCount + 1;
            let newElem = document.getElementById("customSpawnTemplate").cloneNode(true);
            newElem.id = "customSpawn_" + spawnNum;
            newElem.children[0].children[0].innerHTML = "Tile #" + spawnNum + ":";
            newElem.children[0].children[1].id = "customSpawn_valueForm_" + spawnNum;
            newElem.children[0].children[1].firstElementChild.id = "customSpawn_valuechange_" + spawnNum;
            newElem.children[0].children[1].firstElementChild.name = "customSpawn_valuechange_" + spawnNum;
            newElem.children[2].children[0].id = "customSpawn_chanceText_" + spawnNum;
            newElem.children[2].children[1].id = "customSpawn_chanceForm_" + spawnNum;
            newElem.children[2].children[1].firstElementChild.id = "customSpawn_chancechange_" + spawnNum;
            newElem.children[2].children[1].firstElementChild.name = "customSpawn_chancechange_" + spawnNum;
            newElem.children[4].id = "customSpawn_removeSpawn_" + spawnNum;
            newElem.children[0].children[1].firstElementChild.addEventListener("change", function() {
                let v = Number(this.value);
                if (isFinite(v)) customSpawningTiles[spawnNum][0] = v;
                displayCustomMode(subscreen, screenVars);
            })
            newElem.children[2].children[1].firstElementChild.addEventListener("change", function() {
                let v = Number(this.value);
                if (isFinite(v) && v >= 0 && (v % 1 == 0 || !customSpawningTiles[0])) customSpawningTiles[spawnNum][1] = v;
                displayCustomMode(subscreen, screenVars);
            })
            newElem.children[4].addEventListener("click", function() {
                customSpawningTiles.splice(spawnNum, 1);
                displayCustomMode(subscreen, screenVars);
            })
            document.getElementById("customSpawnBox").appendChild(newElem);
        }
        for (let i = 1; i < customSpawningTiles.length; i++) {
            if (customSpawningTiles[0]) {
                document.getElementById("customSpawn_chanceText_" + i).innerHTML = "Amount in Box:";
            }
            else {
                document.getElementById("customSpawn_chanceText_" + i).innerHTML = "Spawn Chance:";
            }
            document.getElementById("customSpawn_valuechange_" + i).value = customSpawningTiles[i][0];
            document.getElementById("customSpawn_chancechange_" + i).value = customSpawningTiles[i][1];
        }
    }
    else if (subscreen == "Merges") {
        document.getElementById("customModeMerges").style.setProperty("display", "block");
        document.documentElement.style.setProperty("background-image", "linear-gradient(#ba00e4, #ffd68f, #ba00e4)");
        document.getElementById("customMode_previousPage").style.setProperty("display", "flex");
        document.getElementById("customMode_nextPage").style.setProperty("display", "flex");
        // Add and remove merge buttons
        if (customMerges.length > 1) {
            document.getElementById("customMerges_selection_previous").style.setProperty("display", "inline-block");
            document.getElementById("customMerges_selection_next").style.setProperty("display", "inline-block");
        }
        else {
            document.getElementById("customMerges_selection_previous").style.setProperty("display", "none");
            document.getElementById("customMerges_selection_next").style.setProperty("display", "none");
        }
        if (customMerges.length > 0) {
            document.getElementById("customMerges_selection_counter").innerHTML = "Merge " + (screenVars[0] + 1) + " / " + customMerges.length;
            document.getElementById("customMerges_removeMerge").style.setProperty("display", "inline-flex");
            document.getElementById("customMerges_shownMergeContainer").style.setProperty("display", "block");
            // Restrictions
            if (customMerges[screenVars[0]][0] == 1) {
                document.getElementById("customMerges_minMax").style.setProperty("display", "block");
                document.getElementById("customMerges_modulo").style.setProperty("display", "block");
                document.getElementById("customMerges_allowedValues").style.setProperty("display", "none");
                if (customMerges[screenVars[0]][1][0] == -Infinity) {
                    document.getElementById("customMerges_minimumInput").value = "";
                }
                else document.getElementById("customMerges_minimumInput").value = customMerges[screenVars[0]][1][0];
                if (customMerges[screenVars[0]][1][1] == Infinity) {
                    document.getElementById("customMerges_maximumInput").value = "";
                }
                else document.getElementById("customMerges_maximumInput").value = customMerges[screenVars[0]][1][1];
                document.getElementById("customMerges_moduloInput1").value = customMerges[screenVars[0]][1][2];
                document.getElementById("customMerges_moduloInput2").value = customMerges[screenVars[0]][1][3];
            }
            else {
                document.getElementById("customMerges_minMax").style.setProperty("display", "none");
                document.getElementById("customMerges_modulo").style.setProperty("display", "none");
                document.getElementById("customMerges_allowedValues").style.setProperty("display", "block");
                while (document.getElementById("customMerges_allowedValues").childElementCount - 3 > customMerges[screenVars[0]][1].length) {
                    document.getElementById("customMerges_allowedValues").removeChild(document.getElementById("customMerges_allowedValues").lastElementChild);
                }
                while (document.getElementById("customMerges_allowedValues").childElementCount - 3 <= customMerges[screenVars[0]][1].length) {
                    let valueNum = document.getElementById("customMerges_allowedValues").childElementCount - 2;
                    let newElem = document.getElementById("customMerges_allowedNForm0").cloneNode(true);
                    newElem.id = "customMerges_allowedNForm" + valueNum;
                    newElem.firstElementChild.id = "customMerges_allowedNInput" + valueNum;
                    newElem.firstElementChild.name = "customMerges_allowedNInput" + valueNum;
                    newElem.firstElementChild.addEventListener("change", function() {
                        let v = Number(this.value);
                        if (this.value == "") v = NaN;
                        // let idNum = this.id.slice(26);
                        if (v % 1 == 0 && isFinite(v)) {
                            if (valueNum > customMerges[screenVars[0]][1].length) customMerges[screenVars[0]][1].push(v);
                            else customMerges[screenVars[0]][1][valueNum - 1] = v;
                        }
                        else {
                            if (valueNum <= customMerges[screenVars[0]][1].length) customMerges[screenVars[0]][1] = customMerges[screenVars[0]][1].slice(0, valueNum - 1);
                        }
                        displayCustomMode(subscreen, screenVars);
                    })
                    document.getElementById("customMerges_allowedValues").appendChild(newElem);
                }
                for (let i = 1; i <= customMerges[screenVars[0]][1].length; i++) {
                    document.getElementById("customMerges_allowedNInput" + i).value = customMerges[screenVars[0]][1][i - 1];
                }
            }
            // Inputs
            while (document.getElementById("customMerges_inputLine").childElementCount - 2 > customMerges[screenVars[0]][2].length) {
                document.getElementById("customMerges_inputLine").removeChild(document.getElementById("customMerges_inputLine").lastElementChild);
            }
            while (document.getElementById("customMerges_inputLine").childElementCount - 2 < customMerges[screenVars[0]][2].length) {
                let inputNum = document.getElementById("customMerges_inputLine").childElementCount - 1;
                let newElem = document.getElementById("customMerges_input0").cloneNode(true);
                newElem.id = "customMerges_input" + inputNum;
                newElem.children[0].children[0].id = "customMerges_input" + inputNum + "_minus";
                newElem.children[0].children[1].id = "customMerges_input" + inputNum + "_counter";
                newElem.children[0].children[2].id = "customMerges_input" + inputNum + "_plus";
                newElem.children[1].children[0].id = "customMerges_changeInputForm" + inputNum
                newElem.children[1].children[1].id = "customMerges_removeInput" + inputNum;
                newElem.children[0].children[0].addEventListener("click", function(){
                    if (getComputedStyle(this).getPropertyValue("opacity") != 0) customMerges[screenVars[0]][2][inputNum - 1][1]--;
                    displayCustomMode(subscreen, screenVars);
                });
                newElem.children[0].children[2].addEventListener("click", function(){
                    if (getComputedStyle(this).getPropertyValue("opacity") != 0) customMerges[screenVars[0]][2][inputNum - 1][1]++;
                    displayCustomMode(subscreen, screenVars);
                });
                newElem.children[1].children[0].addEventListener("click", function(){
                    customMerges[screenVars[0]][2][inputNum - 1][0] = !customMerges[screenVars[0]][2][inputNum - 1][0];
                    customMerges[screenVars[0]][2][inputNum - 1][1] = Math.max(Math.abs(customMerges[screenVars[0]][2][inputNum - 1][1]), 1) * (customMerges[screenVars[0]][2][inputNum - 1][0] ? -1 : 1)
                    displayCustomMode(subscreen, screenVars);
                });
                newElem.children[1].children[1].addEventListener("click", function(){
                    customMerges[screenVars[0]][2].splice(inputNum - 1, 1);
                    displayCustomMode(subscreen, screenVars);
                });
                document.getElementById("customMerges_inputLine").appendChild(newElem);
            }
            for (let i = 1; i <= customMerges[screenVars[0]][2].length; i++) {
                if (customMerges[screenVars[0]][2][i - 1][0]) {
                    if (customMerges[screenVars[0]][2][i - 1][1] == 0) document.getElementById("customMerges_input" + i + "_counter").innerHTML = "Tile n";
                    else if (customMerges[screenVars[0]][2][i - 1][1] < 0) document.getElementById("customMerges_input" + i + "_counter").innerHTML = "Tile n - " + (customMerges[screenVars[0]][2][i - 1][1] * -1);
                    else document.getElementById("customMerges_input" + i + "_counter").innerHTML = "Tile n + " + customMerges[screenVars[0]][2][i - 1][1];
                }
                else document.getElementById("customMerges_input" + i + "_counter").innerHTML = "Tile " + customMerges[screenVars[0]][2][i - 1][1];
                if (!(customMerges[screenVars[0]][2][i - 1][0]) && customMerges[screenVars[0]][2][i - 1][1] <= 1) document.getElementById("customMerges_input" + i + "_minus").style.setProperty("opacity", "0");
                else document.getElementById("customMerges_input" + i + "_minus").style.setProperty("opacity", "1");
                // if ((customMerges[screenVars[0]][2][i - 1][0]) && customMerges[screenVars[0]][2][i - 1][1] >= 0) document.getElementById("customMerges_input" + i + "_plus").style.setProperty("opacity", "0");
                document.getElementById("customMerges_input" + i + "_plus").style.setProperty("opacity", "1");
            }
            if (customMerges[screenVars[0]][4]) {
                document.getElementById("customMerges_orderedMergeOff").style.setProperty("display", "none");
                document.getElementById("customMerges_orderedMergeOn").style.setProperty("display", "inline-flex");
            }
            else {
                document.getElementById("customMerges_orderedMergeOff").style.setProperty("display", "inline-flex");
                document.getElementById("customMerges_orderedMergeOn").style.setProperty("display", "none");
            }
            // Output
            if (customMerges[screenVars[0]][3].length == 1) {
                document.getElementById("customMerges_output").style.setProperty("display", "flex");
                document.getElementById("customMerges_noOutput").style.setProperty("display", "none");
                document.getElementById("customMerges_addOutputTile").style.setProperty("display", "none");
                let outputTile = customMerges[screenVars[0]][3][0]
                if (outputTile[0]) {
                    if (outputTile[1] == 0) document.getElementById("customMerges_output_counter").innerHTML = "Tile n";
                    else if (outputTile[1] < 0) document.getElementById("customMerges_output_counter").innerHTML = "Tile n - " + (outputTile[1] * -1);
                    else document.getElementById("customMerges_output_counter").innerHTML = "Tile n + " + outputTile[1];
                }
                else document.getElementById("customMerges_output_counter").innerHTML = "Tile " + outputTile[1];
                if (!(outputTile[0]) && outputTile[1] <= 1) document.getElementById("customMerges_output_minus").style.setProperty("opacity", "0");
                else document.getElementById("customMerges_output_minus").style.setProperty("opacity", "1");
                document.getElementById("customMerges_output_plus").style.setProperty("opacity", "1");
            }
            else {
                document.getElementById("customMerges_output").style.setProperty("display", "none");
                document.getElementById("customMerges_noOutput").style.setProperty("display", "block");
                document.getElementById("customMerges_addOutputTile").style.setProperty("display", "inline-flex");
            }
        }
        else {
            document.getElementById("customMerges_selection_counter").innerHTML = "No merges have been added yet."
            document.getElementById("customMerges_removeMerge").style.setProperty("display", "none");
            document.getElementById("customMerges_shownMergeContainer").style.setProperty("display", "none");
        }
    }
    else if (subscreen == "ConsistencyCheck") {
        // screenVars = [true, false, 1000, 1e12, 0, [], [], false, ""];
        document.getElementById("customModeConsistencyCheck").style.setProperty("display", "block");
        document.documentElement.style.setProperty("background-image", "linear-gradient(#ba00e4, #ffb38f, #ba00e4)");
        let CGTIndex = function(n){
            return customGeneratedTiles.map(entry => entry[0]).indexOf(n);
        }
        if (screenVars[1]) {
            document.getElementById("customMode_consistency_notRunning").style.setProperty("display", "none");
            document.getElementById("customMode_consistency_Running").style.setProperty("display", "block");
        }
        else {
            document.getElementById("customMode_consistency_notRunning").style.setProperty("display", "block");
            document.getElementById("customMode_consistency_Running").style.setProperty("display", "none");
            document.getElementById("customMode_previousPage").style.setProperty("display", "flex");
            document.getElementById("customMode_nextPage").style.setProperty("display", "flex");
            if (!screenVars[0]) {
                document.getElementById("customMode_consistentSoFar").style.setProperty("display", "none");
                document.getElementById("customMode_consistencyRun").style.setProperty("display", "none");
                document.getElementById("customMode_inconsistentText").style.setProperty("display", "block");
                let inconsistencyString = "An inconsistency was found at Tile #" + screenVars[6][0] + 
                ", which was determined to be both " + screenVars[6][1][1];
                inconsistencyString += " (";
                if (screenVars[6][1][2] == "Spawning") {
                    inconsistencyString += "Spawning Tile"
                }
                else {
                    let inputN = screenVars[6][1][2];
                    inconsistencyString += customGeneratedTiles[CGTIndex(inputN)][1];
                    let merge = customMerges[screenVars[6][1][3]];
                    for (let o = 0; o < merge[2].length; o++) {
                        inconsistencyString += " + ";
                        let otherN;
                        if (merge[2][o][0]) otherN = inputN + merge[2][o][1];
                        else otherN = merge[2][o][1] - 1;
                        inconsistencyString += customGeneratedTiles[CGTIndex(otherN)][1];
                    }
                }
                inconsistencyString += ") and " + screenVars[6][2][0] + " (";
                if (screenVars[6][2][2] == "Spawning") {
                    inconsistencyString += "Spawning Tile";
                }
                else {
                    inputN = screenVars[6][2][1];
                    inconsistencyString += customGeneratedTiles[CGTIndex(inputN)][1];
                    merge = customMerges[screenVars[6][2][2]];
                    for (let o = 0; o < merge[2].length; o++) {
                        inconsistencyString += " + ";
                        let otherN;
                        if (merge[2][o][0]) otherN = inputN + merge[2][o][1];
                        else otherN = merge[2][o][1];
                        inconsistencyString += customGeneratedTiles[CGTIndex(otherN)][1];
                    }
                }
                inconsistencyString += "). You may continue making this mode if you wish, but if you do, it will be possible for the same tile to have different numbers."
                document.getElementById("customMode_inconsistentText").innerHTML = inconsistencyString;
            }
            else {
                document.getElementById("customMode_consistentSoFar").style.setProperty("display", "block");
                document.getElementById("customMode_consistencyRun").style.setProperty("display", "flex");
                document.getElementById("customMode_inconsistentText").style.setProperty("display", "none");
                document.getElementById("customMode_consistencyTiles_input").value = screenVars[2];
                document.getElementById("customMode_consistencySize_input").value = screenVars[3];
            }
            if (customGeneratedTiles.length > 0) {
                document.getElementById("customMode_consistencyView").style.setProperty("display", "flex");
            }
            else {
                document.getElementById("customMode_consistencyView").style.setProperty("display", "none");
            }
            if (screenVars[7]) {
                document.getElementById("customMode_consistencyView").innerHTML = "Hide Generated Tiles";
                document.getElementById("customMode_consistencyTileList").style.setProperty("display", "block");
                if (screenVars[8] == "") {
                    for (let n = 0; n < customGeneratedTiles.length; n++) {
                        screenVars[8] += "Tile #" + customGeneratedTiles[n][0] + " is " + customGeneratedTiles[n][1];
                        if (customGeneratedTiles[n][2] == "Spawning") screenVars[8] += " (Spawning Tile)";
                        else {
                            screenVars[8] += " (";
                            let inputN = customGeneratedTiles[n][2];
                            screenVars[8] += customGeneratedTiles[CGTIndex(inputN)][1];
                            let merge = customMerges[customGeneratedTiles[n][3]];
                            for (let o = 0; o < merge[2].length; o++) {
                                screenVars[8] += " + ";
                                let otherN;
                                if (merge[2][o][0]) otherN = inputN + merge[2][o][1];
                                else otherN = merge[2][o][1];
                                screenVars[8] += customGeneratedTiles[CGTIndex(otherN)][1];
                            }
                            screenVars[8] += ")";
                        }
                        if (n < customGeneratedTiles.length - 1) screenVars[8] += "<br>";
                    }
                    document.getElementById("customMode_consistencyTileList").innerHTML = screenVars[8];
                }
            }
            else {
                document.getElementById("customMode_consistencyView").innerHTML = "Show Generated Tiles";
                document.getElementById("customMode_consistencyTileList").style.setProperty("display", "none");
            }
        }
    }
    else if (subscreen == "Colors") {
        document.getElementById("customModeTileColors").style.setProperty("display", "block");
        document.documentElement.style.setProperty("background-image", "linear-gradient(#ba00e4, #ff8fa9, #ba00e4)");
        document.getElementById("customMode_previousPage").style.setProperty("display", "flex");
        document.getElementById("customMode_nextPage").style.setProperty("display", "flex");
        // Add and remove color rule buttons
        if (customColors.length > 1) {
            document.getElementById("customColors_selection_previous").style.setProperty("display", "inline-block");
            document.getElementById("customColors_selection_next").style.setProperty("display", "inline-block");
        }
        else {
            document.getElementById("customColors_selection_previous").style.setProperty("display", "none");
            document.getElementById("customColors_selection_next").style.setProperty("display", "none");
        }
        if (customColors.length > 0) {
            document.getElementById("customColors_selection_counter").innerHTML = "Color Rule " + (screenVars[0] + 1) + " / " + customColors.length;
            document.getElementById("customColors_removeColorRule").style.setProperty("display", "inline-flex");
            document.getElementById("customColors_shownColorContainer").style.setProperty("display", "block");
            // Restrictions
            if (customColors[screenVars[0]][0] == 1) {
                document.getElementById("customColors_minMax").style.setProperty("display", "block");
                document.getElementById("customColors_modulo").style.setProperty("display", "block");
                document.getElementById("customColors_allowedValues").style.setProperty("display", "none");
                if (customColors[screenVars[0]][1][0] == -Infinity) {
                    document.getElementById("customColors_minimumInput").value = ""
                }
                else document.getElementById("customColors_minimumInput").value = customColors[screenVars[0]][1][0];
                if (customColors[screenVars[0]][1][1] == Infinity) {
                    document.getElementById("customColors_maximumInput").value = "";
                }
                else document.getElementById("customColors_maximumInput").value = customColors[screenVars[0]][1][1];
                document.getElementById("customColors_moduloInput1").value = customColors[screenVars[0]][1][2];
                document.getElementById("customColors_moduloInput2").value = customColors[screenVars[0]][1][3];
            }
            else {
                document.getElementById("customColors_minMax").style.setProperty("display", "none");
                document.getElementById("customColors_modulo").style.setProperty("display", "none");
                document.getElementById("customColors_allowedValues").style.setProperty("display", "block");
                while (document.getElementById("customColors_allowedValues").childElementCount - 3 > customColors[screenVars[0]][1].length) {
                    document.getElementById("customColors_allowedValues").removeChild(document.getElementById("customColors_allowedValues").lastElementChild);
                }
                while (document.getElementById("customColors_allowedValues").childElementCount - 3 <= customColors[screenVars[0]][1].length) {
                    let valueNum = document.getElementById("customColors_allowedValues").childElementCount - 2;
                    let newElem = document.getElementById("customColors_allowedNForm0").cloneNode(true);
                    newElem.id = "customColors_allowedNForm" + valueNum;
                    newElem.firstElementChild.id = "customColors_allowedNInput" + valueNum;
                    newElem.firstElementChild.name = "customColors_allowedNInput" + valueNum;
                    newElem.firstElementChild.addEventListener("change", function() {
                        let v = Number(this.value);
                        if (this.value == "") v = NaN;
                        // let idNum = this.id.slice(26);
                        if (v % 1 == 0 && isFinite(v)) {
                            if (valueNum > customColors[screenVars[0]][1].length) customColors[screenVars[0]][1].push(v);
                            else customColors[screenVars[0]][1][valueNum - 1] = v;
                        }
                        else {
                            if (valueNum <= customColors[screenVars[0]][1].length) customColors[screenVars[0]][1] = customColors[screenVars[0]][1].slice(0, valueNum - 1);
                        }
                        displayCustomMode(subscreen, screenVars);
                    })
                    document.getElementById("customColors_allowedValues").appendChild(newElem);
                }
                for (let i = 1; i <= customColors[screenVars[0]][1].length; i++) {
                    document.getElementById("customColors_allowedNInput" + i).value = customColors[screenVars[0]][1][i - 1];
                }
            }
            // Gradient Selection
            let gradient = customColors[screenVars[0]][2];
            let gradientCurrent = gradient[screenVars[1]];
            document.getElementById("customColors_gradientSelection_counter").innerHTML = "Gradient Entry " + (screenVars[1] + 1) + " / " + gradient.length;
            if (gradient.length > 1) {
                document.getElementById("customColors_removeGradientEntry").style.setProperty("display", "inline-flex");
                document.getElementById("customColors_gradientSelection_previous").style.setProperty("display", "inline-block");
                document.getElementById("customColors_gradientSelection_next").style.setProperty("display", "inline-block");
            }
            else {
                document.getElementById("customColors_removeGradientEntry").style.setProperty("display", "none");
                document.getElementById("customColors_gradientSelection_previous").style.setProperty("display", "none");
                document.getElementById("customColors_gradientSelection_next").style.setProperty("display", "none");
            }
            if (customColors[screenVars[0]][4][0] == "@linear-gradient") {
                document.getElementById("customColors_gradientType").style.setProperty("background-image", "linear-gradient(#ff00ff, #00a2ff)");
                document.getElementById("customColors_gradientType").innerHTML = "Gradient Type: Linear";
                document.getElementById("customColors_gradientDirection").style.setProperty("display", "inline-block");
                document.getElementById("customColors_gradientDirectionInput").value = customColors[screenVars[0]][4][1];
                document.getElementById("customColors_gradientDirectionText").innerHTML = "Gradient Direction:";
                document.getElementById("customColors_gradientPositionUnit").innerHTML = "%";
            }
            else if (customColors[screenVars[0]][4][0] == "@radial-gradient") {
                document.getElementById("customColors_gradientType").style.setProperty("background-image", "radial-gradient(#ff00ff, #00a2ff)");
                document.getElementById("customColors_gradientType").innerHTML = "Gradient Type: Radial";
                document.getElementById("customColors_gradientDirection").style.setProperty("display", "none");
                document.getElementById("customColors_gradientPositionUnit").innerHTML = "%";
            }
            else if (customColors[screenVars[0]][4][0] == "@conic-gradient") {
                document.getElementById("customColors_gradientType").style.setProperty("background-image", "conic-gradient(#ff00ff, #00a2ff, #ff00ff)");
                document.getElementById("customColors_gradientType").innerHTML = "Gradient Type: Conic";
                document.getElementById("customColors_gradientDirection").style.setProperty("display", "inline-block");
                document.getElementById("customColors_gradientDirectionInput").innerHTML = customColors[screenVars[0]][4][1];
                document.getElementById("customColors_gradientDirectionText").innerHTML = "Gradient Start:";
                document.getElementById("customColors_gradientPositionUnit").innerHTML = "&#176;";
            }
            document.getElementById("customColors_gradientPositionInput").value = customColors[screenVars[0]][3][screenVars[1]];
            // Starting Color
            document.getElementById("customColors_visibleColor").style.setProperty("background-color", evaluateColor(gradient[screenVars[1]].slice(0, 5)))
            document.getElementById("customColors_hexFormInput").value = convertColor(gradient[screenVars[1]].slice(0, 5), "@Hex");
            document.getElementById("customColors_startTileInput").value = gradientCurrent[5];
            document.getElementById("customColors_startColor1Input").value = gradientCurrent[1];
            document.getElementById("customColors_startColor2Input").value = gradientCurrent[2];
            document.getElementById("customColors_startColor3Input").value = gradientCurrent[3];
            document.getElementById("customColors_startColor1_p").innerHTML = gradientCurrent[0][1] + " = ";
            document.getElementById("customColors_startColor2_p").innerHTML = gradientCurrent[0][2] + " = ";
            document.getElementById("customColors_startColor3_p").innerHTML = gradientCurrent[0][3] + " = ";
            // Color Increments
            document.getElementById("customColors_increment1_1Input").value = gradientCurrent[7];
            if (gradientCurrent[6]) {
                document.getElementById("customColors_increment1_1p").innerHTML = gradientCurrent[0][1] + "'s distance from";
                document.getElementById("customColors_increment1_2").style.setProperty("display", "block");
                document.getElementById("customColors_increment1_2Input").value = gradientCurrent[8];
            }
            else {
                document.getElementById("customColors_increment1_1p").innerHTML = gradientCurrent[0][1] + " increases by";
                document.getElementById("customColors_increment1_2").style.setProperty("display", "none");
            }
            document.getElementById("customColors_increment2_1Input").value = gradientCurrent[10];
            if (gradientCurrent[9]) {
                document.getElementById("customColors_increment2_1p").innerHTML = gradientCurrent[0][2] + "'s distance from";
                document.getElementById("customColors_increment2_2").style.setProperty("display", "block");
                document.getElementById("customColors_increment2_2Input").value = gradientCurrent[11];
            }
            else {
                document.getElementById("customColors_increment2_1p").innerHTML = gradientCurrent[0][2] + " increases by";
                document.getElementById("customColors_increment2_2").style.setProperty("display", "none");
            }
            document.getElementById("customColors_increment3_1Input").value = gradientCurrent[13];
            if (gradientCurrent[12]) {
                document.getElementById("customColors_increment3_1p").innerHTML = gradientCurrent[0][3] + "'s distance from";
                document.getElementById("customColors_increment3_2").style.setProperty("display", "block");
                document.getElementById("customColors_increment3_2Input").value = gradientCurrent[14];
            }
            else {
                document.getElementById("customColors_increment3_1p").innerHTML = gradientCurrent[0][3] + " increases by";
                document.getElementById("customColors_increment3_2").style.setProperty("display", "none");
            }
            // Starting Text Color
            gradientCurrent = customColors[screenVars[0]][5];
            document.getElementById("customColors_visibleColorText").style.setProperty("background-color", evaluateColor(gradientCurrent.slice(0, 5)))
            document.getElementById("customColors_hexFormInputText").value = convertColor(gradientCurrent.slice(0, 5), "@Hex");
            document.getElementById("customColors_startTileInputText").value = gradientCurrent[5];
            document.getElementById("customColors_startColor1InputText").value = gradientCurrent[1];
            document.getElementById("customColors_startColor2InputText").value = gradientCurrent[2];
            document.getElementById("customColors_startColor3InputText").value = gradientCurrent[3];
            document.getElementById("customColors_startColor4InputText").value = gradientCurrent[4];
            document.getElementById("customColors_startColor1_pText").innerHTML = gradientCurrent[0][1] + " = ";
            document.getElementById("customColors_startColor2_pText").innerHTML = gradientCurrent[0][2] + " = ";
            document.getElementById("customColors_startColor3_pText").innerHTML = gradientCurrent[0][3] + " = ";
            document.getElementById("customColors_startColor4_pText").innerHTML = " = ";
            // Text Color Increments
            document.getElementById("customColors_increment1_1InputText").value = gradientCurrent[7];
            if (gradientCurrent[6]) {
                document.getElementById("customColors_increment1_1pText").innerHTML = gradientCurrent[0][1] + "'s distance from";
                document.getElementById("customColors_increment1_2Text").style.setProperty("display", "block");
                document.getElementById("customColors_increment1_2InputText").value = gradientCurrent[8];
            }
            else {
                document.getElementById("customColors_increment1_1pText").innerHTML = gradientCurrent[0][1] + " increases by";
                document.getElementById("customColors_increment1_2Text").style.setProperty("display", "none");
            }
            document.getElementById("customColors_increment2_1InputText").value = gradientCurrent[10];
            if (gradientCurrent[9]) {
                document.getElementById("customColors_increment2_1pText").innerHTML = gradientCurrent[0][2] + "'s distance from";
                document.getElementById("customColors_increment2_2Text").style.setProperty("display", "block");
                document.getElementById("customColors_increment2_2InputText").value = gradientCurrent[11];
            }
            else {
                document.getElementById("customColors_increment2_1pText").innerHTML = gradientCurrent[0][2] + " increases by";
                document.getElementById("customColors_increment2_2Text").style.setProperty("display", "none");
            }
            document.getElementById("customColors_increment3_1InputText").value = gradientCurrent[13];
            if (gradientCurrent[12]) {
                document.getElementById("customColors_increment3_1pText").innerHTML = gradientCurrent[0][3] + "'s distance from";
                document.getElementById("customColors_increment3_2Text").style.setProperty("display", "block");
                document.getElementById("customColors_increment3_2InputText").value = gradientCurrent[14];
            }
            else {
                document.getElementById("customColors_increment3_1pText").innerHTML = gradientCurrent[0][3] + " increases by";
                document.getElementById("customColors_increment3_2Text").style.setProperty("display", "none");
            }
            document.getElementById("customColors_increment4_1InputText").value = gradientCurrent[16];
            if (gradientCurrent[15]) {
                document.getElementById("customColors_increment4_1pText").innerHTML = "'s distance from";
                document.getElementById("customColors_increment4_2Text").style.setProperty("display", "block");
                document.getElementById("customColors_increment4_2InputText").value = gradientCurrent[17];
            }
            else {
                document.getElementById("customColors_increment4_1pText").innerHTML = " increases by";
                document.getElementById("customColors_increment4_2Text").style.setProperty("display", "none");
            }
        }
        else {
            document.getElementById("customColors_selection_counter").innerHTML = "No color rules have been added yet."
            document.getElementById("customColors_removeColorRule").style.setProperty("display", "none");
            document.getElementById("customColors_shownColorContainer").style.setProperty("display", "none");
        }
    }
    else if (subscreen == "Background") {
        document.getElementById("customModeBackgroundColors").style.setProperty("display", "block");
        document.documentElement.style.setProperty("background-image", "linear-gradient(#ba00e4, #8f8fff, #ba00e4)");
        document.getElementById("customMode_previousPage").style.setProperty("display", "flex");
        document.getElementById("customMode_nextPage").style.setProperty("display", "flex");
        if (screenVars[0] == 0) document.getElementById("customBackground_selection_title").innerHTML = "Background";
        else if (screenVars[0] == 1) document.getElementById("customBackground_selection_title").innerHTML = "Rules Screen Background";
        else if (screenVars[0] == 2) document.getElementById("customBackground_selection_title").innerHTML = "Empty Tiles";
        else if (screenVars[0] == 3) document.getElementById("customBackground_selection_title").innerHTML = "Space Between Tiles";
        else if (screenVars[0] == 4) document.getElementById("customBackground_selection_title").innerHTML = "In-Game Text";
        let gradient = customBackground[screenVars[0]];
        let gradientCurrent = gradient[3][screenVars[1]];
        if (screenVars[0] > 1) document.getElementById("customBackgroundGradientStuff").style.setProperty("display", "none");
        else {
            document.getElementById("customBackgroundGradientStuff").style.setProperty("display", "block");
            // Gradient Selection
            document.getElementById("customBackground_gradientSelection_counter").innerHTML = "Gradient Entry " + (screenVars[1] + 1) + " / " + gradient[3].length;
            if (gradient[3].length > 1) {
                document.getElementById("customBackground_removeGradientEntry").style.setProperty("display", "inline-flex");
                document.getElementById("customBackground_gradientSelection_previous").style.setProperty("display", "inline-block");
                document.getElementById("customBackground_gradientSelection_next").style.setProperty("display", "inline-block");
            }
            else {
                document.getElementById("customBackground_removeGradientEntry").style.setProperty("display", "none");
                document.getElementById("customBackground_gradientSelection_previous").style.setProperty("display", "none");
                document.getElementById("customBackground_gradientSelection_next").style.setProperty("display", "none");
            }
            if (customBackground[screenVars[0]][0] == "@linear-gradient") {
                document.getElementById("customBackground_gradientType").style.setProperty("background-image", "linear-gradient(#ff00ff, #00a2ff)");
                document.getElementById("customBackground_gradientType").innerHTML = "Gradient Type: Linear";
                document.getElementById("customBackground_gradientDirection").style.setProperty("display", "inline-block");
                document.getElementById("customBackground_gradientDirectionInput").value = customBackground[screenVars[0]][1];
                document.getElementById("customBackground_gradientDirectionText").innerHTML = "Gradient Direction:";
                document.getElementById("customBackground_gradientPositionUnit").innerHTML = "%";
            }
            else if (customBackground[screenVars[0]][0] == "@radial-gradient") {
                document.getElementById("customBackground_gradientType").style.setProperty("background-image", "radial-gradient(#ff00ff, #00a2ff)");
                document.getElementById("customBackground_gradientType").innerHTML = "Gradient Type: Radial";
                document.getElementById("customBackground_gradientDirection").style.setProperty("display", "none");
                document.getElementById("customBackground_gradientPositionUnit").innerHTML = "%";
            }
            else if (customBackground[screenVars[0]][0] == "@conic-gradient") {
                document.getElementById("customBackground_gradientType").style.setProperty("background-image", "conic-gradient(#ff00ff, #00a2ff, #ff00ff)");
                document.getElementById("customBackground_gradientType").innerHTML = "Gradient Type: Conic";
                document.getElementById("customBackground_gradientDirection").style.setProperty("display", "inline-block");
                document.getElementById("customBackground_gradientDirectionInput").innerHTML = customBackground[screenVars[0]][1];
                document.getElementById("customBackground_gradientDirectionText").innerHTML = "Gradient Start:";
                document.getElementById("customBackground_gradientPositionUnit").innerHTML = "&#176;";
            }
            document.getElementById("customBackground_gradientPositionInput").value = customBackground[screenVars[0]][2][screenVars[1]];
        }
        // Starting Color
        document.getElementById("customBackground_visibleColor").style.setProperty("background-color", evaluateColor(gradientCurrent.slice(0, 5)));
        document.getElementById("customBackground_hexFormInput").value = convertColor(gradientCurrent.slice(0, 5), "@Hex");
        document.getElementById("customBackground_startColor1Input").value = gradientCurrent[1];
        document.getElementById("customBackground_startColor2Input").value = gradientCurrent[2];
        document.getElementById("customBackground_startColor3Input").value = gradientCurrent[3];
        document.getElementById("customBackground_startColor1_p").innerHTML = gradientCurrent[0][1] + " = ";
        document.getElementById("customBackground_startColor2_p").innerHTML = gradientCurrent[0][2] + " = ";
        document.getElementById("customBackground_startColor3_p").innerHTML = gradientCurrent[0][3] + " = ";
    }
    else if (subscreen == "Other") {
        document.getElementById("customModeOtherScreen").style.setProperty("display", "block");
        document.documentElement.style.setProperty("background-image", "linear-gradient(#ba00e4, #8fe9ff, #ba00e4)");
        document.getElementById("customMode_previousPage").style.setProperty("display", "flex");
        document.getElementById("customMode_nextPage").style.setProperty("display", "flex");
        // Win Conditions
        while (document.getElementById("customOther_winConditionList").childElementCount - 2 > customWins.length) {
            document.getElementById("customOther_winConditionList").removeChild(document.getElementById("customOther_winConditionList").lastElementChild);
        }
        while (document.getElementById("customOther_winConditionList").childElementCount - 2 < customWins.length) {
            let valueNum = document.getElementById("customOther_winConditionList").childElementCount - 1;
            let newElem = document.getElementById("customOther_winForm0").cloneNode(true);
            newElem.id = "customOther_winForm" + valueNum;
            newElem.firstElementChild.id = "customOther_winInput" + valueNum;
            newElem.firstElementChild.name = "customOther_winInput" + valueNum;
            newElem.firstElementChild.addEventListener("change", function() {
                let v = Number(this.value);
                if (this.value == "") v = NaN;
                // let idNum = this.id.slice(26);
                if (v % 1 == 0 && isFinite(v)) {
                    if (valueNum > customWins.length - 1) customWins.push(v);
                    else customWins[valueNum] = v;
                }
                else {
                    if (valueNum <= customWins.length) customWins = customWins.slice(0, valueNum);
                    if (customWins[0] > customWins.length - 1) customWins[0] = customWins.length - 1;
                }
                displayCustomMode(subscreen, screenVars);
            })
            document.getElementById("customOther_winConditionList").appendChild(newElem);
        }
        for (let i = 1; i < customWins.length; i++) {
            document.getElementById("customOther_winInput" + i).value = customWins[i];
        }
        document.getElementById("customOther_winInput" + customWins.length).value = "";
        if (customWins[0] == 0) document.getElementById("customOther_winConditionAmount_counter").innerHTML = "N/A";
        else document.getElementById("customOther_winConditionAmount_counter").innerHTML = customWins[0];
        if (customWins[0] < 1) document.getElementById("customOther_winConditionAmount_minus").style.setProperty("display", "none");
        else document.getElementById("customOther_winConditionAmount_minus").style.setProperty("display", "block");
        if (customWins[0] >= customWins.length - 1) document.getElementById("customOther_winConditionAmount_plus").style.setProperty("display", "none");
        else document.getElementById("customOther_winConditionAmount_plus").style.setProperty("display", "block");
        // Lose Conditions
        while (document.getElementById("customOther_loseConditionList").childElementCount - 2 > customLosses.length) {
            document.getElementById("customOther_loseConditionList").removeChild(document.getElementById("customOther_loseConditionList").lastElementChild);
        }
        while (document.getElementById("customOther_loseConditionList").childElementCount - 2 < customLosses.length) {
            let valueNum = document.getElementById("customOther_loseConditionList").childElementCount - 1;
            let newElem = document.getElementById("customOther_loseForm0").cloneNode(true);
            newElem.id = "customOther_loseForm" + valueNum;
            newElem.firstElementChild.id = "customOther_loseInput" + valueNum;
            newElem.firstElementChild.name = "customOther_loseInput" + valueNum;
            newElem.firstElementChild.addEventListener("change", function() {
                let v = Number(this.value);
                if (this.value == "") v = NaN;
                // let idNum = this.id.slice(26);
                if (v % 1 == 0 && isFinite(v)) {
                    if (valueNum > customLosses.length - 1) customLosses.push(v);
                    else customLosses[valueNum] = v;
                }
                else {
                    if (valueNum <= customLosses.length) customLosses = customLosses.slice(0, valueNum);
                    if (customLosses[0] > customLosses.length - 1) customLosses[0] = customLosses.length - 1;
                }
                displayCustomMode(subscreen, screenVars);
            })
            document.getElementById("customOther_loseConditionList").appendChild(newElem);
        }
        for (let i = 1; i < customLosses.length; i++) {
            document.getElementById("customOther_loseInput" + i).value = customLosses[i];
        }
        document.getElementById("customOther_loseInput" + customLosses.length).value = "";
        if (customLosses[0] == 0) document.getElementById("customOther_loseConditionAmount_counter").innerHTML = "N/A";
        else document.getElementById("customOther_loseConditionAmount_counter").innerHTML = customLosses[0];
        if (customLosses[0] < 1) document.getElementById("customOther_loseConditionAmount_minus").style.setProperty("display", "none");
        else document.getElementById("customOther_loseConditionAmount_minus").style.setProperty("display", "block");
        if (customLosses[0] >= customLosses.length - 1) document.getElementById("customOther_loseConditionAmount_plus").style.setProperty("display", "none");
        else document.getElementById("customOther_loseConditionAmount_plus").style.setProperty("display", "block");
        // Rules Text
        document.getElementById("customOther_rulesHeadingInput").value = he.decode(customRulesText[0]);
        document.getElementById("customOther_rulesTitleInput").value = he.decode(customRulesText[1]);
        document.getElementById("customOther_rulesDescriptionInput").value = he.decode(customRulesText[2]);
        // Default Grid Size
        if (customRulesText[3] == 0) {
            customRulesText[3] = 3;
            for (let m = 0; m < customMerges.length; m++) {
                customRulesText[3] = max(customRulesText[3], customMerges[m][2].length + 3);
            }
        }
        document.getElementById("customOther_defaultSize_counter").innerHTML = customRulesText[3];
        if (customRulesText[3] < 2) document.getElementById("customOther_defaultSize_minus").style.setProperty("display", "none");
        else document.getElementById("customOther_defaultSize_minus").style.setProperty("display", "block");
        document.getElementById("customOther_defaultSize_plus").style.setProperty("display", "block");
    }
}

async function customConsistencyCheck() {
    // screenVars = [true, false, 1000, 1e12, 0, [], [], false, ""];
    if (customGeneratedTiles.length < customSpawningTiles.length + 1) {
        customGeneratedTiles = [];
        for (let s = 1; s < customSpawningTiles.length; s++) {
            if (customSpawningTiles[s][1] != 0) {
                customGeneratedTiles.push([s, customSpawningTiles[s][0], "Spawning"]);
                for (let m = 0; m < customMerges.length; m++) screenVars[5].push([s, m]);
            }
        }
    }
    let waitlist = [];
    let endLoop = false;
    CustomConsistency_EntireLoop: while (!endLoop) {
        endLoop = true;
        screenVars[5] = screenVars[5].concat(waitlist);
        waitlist = [];
        CustomConsistency_TileLoop:
        while (screenVars[5].length > 0) {
            let n = screenVars[5][0][0];
            let m = screenVars[5][0][1];
            let CGTIndex = function(n){
                return customGeneratedTiles.map(entry => entry[0]).indexOf(n);
            }
            if (customMerges[m][3].length == 0) {
                screenVars[5].shift(); continue CustomConsistency_TileLoop;
            }
            if (CGTIndex(n) === -1 || Math.abs(customGeneratedTiles[CGTIndex(n)][1]) > screenVars[3] || customGeneratedTiles.length >= screenVars[2]) {
                waitlist.push([n, m])
                n++; screenVars[5].shift(); continue CustomConsistency_TileLoop;
            }
            if ((customMerges[m][0] == 0 && customMerges[m][1].includes(n)) || (customMerges[m][0] == 1 && n >= customMerges[m][1][0] && n <= customMerges[m][1][1] && mod(n, customMerges[m][1][3]) == customMerges[m][1][2])) {
                let result = customGeneratedTiles[CGTIndex(n)][1];
                for (let input = 0; input < customMerges[m][2].length; input++) {
                    let inputN;
                    if (customMerges[m][2][input][0] == true) inputN = n + customMerges[m][2][input][1];
                    else inputN = customMerges[m][2][input][1];
                    if (CGTIndex(inputN) === -1) {
                        waitlist.push([n, m]);
                        screenVars[5].shift(); continue CustomConsistency_TileLoop;
                    }
                    result += customGeneratedTiles[CGTIndex(inputN)][1];
                }
                let outputN;
                if (customMerges[m][3][0][0] == true) outputN = n + customMerges[m][3][0][1];
                else outputN = customMerges[m][3][0][1];
                if (CGTIndex(outputN) === -1) {
                    binaryInsert(customGeneratedTiles, [outputN, result, n, m], function(a, b){
                        if (a[0] < b[0]) return -1;
                        else if (a[0] > b[0]) return 1;
                        else if (a[0] == b[0]) return 0;
                        else return NaN;
                    });
                    endLoop = false;
                    for (let m = 0; m < customMerges.length; m++) screenVars[5].push([outputN, m]);
                }
                else if (customGeneratedTiles[CGTIndex(outputN)][1] != result) {
                    screenVars[0] = false;
                    screenVars[6] = [outputN, customGeneratedTiles[CGTIndex(outputN)], [result, n, m]];
                    break CustomConsistency_EntireLoop;
                }
            }
            screenVars[5].shift();
        }
    }
    screenVars[5] = screenVars[5].concat(waitlist);
    screenVars[4] = screenVars[2];
    screenVars[8] = "";
}

// function customMergeSubset(mergeS, mergeL) { // Checks two custom mode merges to see if the smaller one is a "subset" of the bigger one, such as 1+1 being a subset of 1+1+1.
//     // Returns "false" if the smaller one is not a subset of the larger one, returns "true" if the smaller one is a subset of the larger one, and returns an array of numbers if the subset only happens at certain values of n
//     if (mergeS.length > mergeL.length) return false;
//     mergeS = compendiumStructuredClone(mergeS);
//     mergeL = compendiumStructuredClone(mergeL);
//     // First, get rid of any fixed-number inputs they have in common
//     for (let sIndex = 0; sIndex < mergeS[2].length; sIndex++) {
//         if (!mergeS[2][sIndex][0]) {
//             let lIndex = indexOfPrimArray(mergeS[2][sIndex], mergeL[2]);
//             if (lIndex != -1) {
//                 mergeS[2].splice(sIndex, 1);
//                 mergeL[2].splice(lIndex, 1);
//                 sIndex--;
//             }
//         }
//     }
//     let sHasFixed = false;
//     for (let i = 0; i < mergeS[2].length; i++) {
//         if (!mergeS[2][i][0]) {
//             sHasFixed = true;
//             break;
//         }
//     }
//     let lHasFixed = false;
//     for (let i = 0; i < mergeL[2].length; i++) {
//         if (!mergeL[2][i][0]) {
//             lHasFixed = true;
//             break;
//         }
//     }
//     if (sHasFixed && lHasFixed) return false; // If there's a mismatch in fixed-number inputs, the two merges can never line up
//     if (!sHasFixed && !lHasFixed) {
//         // If both merges have only variable inputs remaining, we can just pair those off
//         if (!mergeS[4] && !mergeL[4]) {
//             for (let sIndex = 0; sIndex < mergeS[2].length; sIndex++) {
//                 let lIndex = indexOfPrimArray(mergeS[2][sIndex], mergeL[2]);
//                 if (lIndex != -1) {
//                     mergeS[2].splice(sIndex, 1);
//                     mergeL[2].splice(lIndex, 1);
//                     sIndex--;
//                 }
//             }
//         }
//         else if (mergeS[4] && !mergeL[4]) {
//             for (let sIndex = 0; sIndex < mergeS[2].length; sIndex++) {
//                 let lIndex = indexOfPrimArray(mergeS[2][sIndex], mergeL[2]);
//                 if (lIndex != -1) {
//                     mergeS[2].splice(sIndex, 1);
//                     mergeL[2].splice(lIndex, 1);
//                     sIndex--;
//                 }
//                 else return false;
//             }
//         }
//         else if (!mergeS[4] && mergeL[4]) {
//             for (let lIndex = 0; lIndex < mergeS[2].length; lIndex++) {
//                 let sIndex = indexOfPrimArray(mergeL[2][lIndex], mergeS[2]);
//                 if (sIndex != -1) {
//                     mergeS[2].splice(sIndex, 1);
//                     mergeL[2].splice(lIndex, 1);
//                     lIndex--;
//                 }
//                 else return false;
//             }
//         }
//         else if (mergeS[4] && mergeL[4]) {
//             while (mergeS[2].length > 0 && mergeL[2].length > 0) {
//                 if (eqPrimArrays(mergeS[2][0], mergeL[2][0])) {
//                     mergeS[2].shift();
//                     mergeL[2].shift();
//                 }
//                 else return false;
//             }
//         }
//         if (mergeS[2].length == 0) return true;
//         else return false;
//     }
//     // If only one merge has fixed inputs remaining, we need to instantiate possible values for n and test each one
//     let successes = [];
//     let valuesToTest = [];
//     if (mergeS[2][0][0] == false && mergeL[2][0][0] == true) {
//         sIndex = 0;
//         while (sIndex < mergeS[2].length) {
//             if (mergeS[2][sIndex][0] == false) {
//                 for (lIndex = 0; lIndex < mergeL[2].length; lIndex++) {
//                     if (mergeL[2][lIndex][0] == true && !valuesToTest.includes(mergeS[2][sIndex][1] - mergeL[2][lIndex][1])) valuesToTest.push(mergeS[2][sIndex][1] - mergeL[2][lIndex][1]);
//                 }
//             }
//             sIndex++;
//         }
//     }
//     else if (mergeS[2][0][0] == true && mergeL[2][0][0] == false) {
//         lIndex = 0;
//         while (lIndex < mergeL[2].length) {
//             if (mergeL[2][lIndex][0] == false) {
//                 for (sIndex = 0; sIndex < mergeS[2].length; sIndex++) {
//                     if (mergeS[2][sIndex][0] == true && !valuesToTest.includes(mergeL[2][lIndex][1] - mergeS[2][sIndex][1])) valuesToTest.push(mergeL[2][lIndex][1] - mergeS[2][sIndex][1]);
//                 }
//             }
//             lIndex++;
//         }
//     }
//     for (let v = 0; v < valuesToTest.length; v++) {
//         let vt = valuesToTest[v];
//         if (mergeS[0] == 0 && !mergeS[1].includes(vt)) {
//             valuesToTest.splice(v, 1);
//             v--;
//         }
//         else if (mergeS[0] == 1 && (vt < mergeS[1][0] || vt > mergeS[1][1] || vt % mergeS[1][3] != mergeS[1][2])) {
//             valuesToTest.splice(v, 1);
//             v--;
//         }
//         else if (mergeL[0] == 0 && !mergeL[1].includes(vt)) {
//             valuesToTest.splice(v, 1);
//             v--;
//         }
//         else if (mergeL[0] == 1 && (vt < mergeL[1][0] || vt > mergeL[1][1] || vt % mergeL[1][3] != mergeL[1][2])) {
//             valuesToTest.splice(v, 1);
//             v--;
//         }
//     }
//     for (let v = 0; v < valuesToTest.length; v++) {
//         let vt = valuesToTest[v];
//         let testS = compendiumStructuredClone(mergeS[2]);
//         let testL = compendiumStructuredClone(mergeL[2]);
//         testS = testS.map(function(entry){
//             if (entry[0] == false) return entry;
//             else return [false, vt + entry[1]];
//         });
//         testL = testL.map(function(entry){
//             if (entry[0] == false) return entry;
//             else return [false, vt + entry[1]];
//         });
//         // sIndex = 0;
//         // lIndex = 0;
//         // while (sIndex < testS.length && lIndex < testL.length) {
//         //     if (testS[sIndex][1] == testL[lIndex][1]) {
//         //         testS.splice(sIndex, 1);
//         //         testL.splice(lIndex, 1);
//         //     }
//         //     else if (testS[sIndex][1] < testL[lIndex][1]) sIndex++;
//         //     else lIndex++;
//         // }
//         if (!mergeS[4] && !mergeL[4]) {
//             for (let sIndex = 0; sIndex < testS.length; sIndex++) {
//                 let lIndex = indexOfPrimArray(testS[sIndex], testL);
//                 if (lIndex != -1) {
//                     testS.splice(sIndex, 1);
//                     testL.splice(lIndex, 1);
//                     sIndex--;
//                 }
//             }
//         }
//         else if (mergeS[4] && !mergeL[4]) {
//             for (let sIndex = 0; sIndex < testS.length; sIndex++) {
//                 let lIndex = indexOfPrimArray(testS[sIndex], testL);
//                 if (lIndex != -1) {
//                     testS.splice(sIndex, 1);
//                     testL.splice(lIndex, 1);
//                     sIndex--;
//                 }
//                 else return false;
//             }
//         }
//         else if (!mergeS[4] && mergeL[4]) {
//             for (let lIndex = 0; lIndex < testS.length; lIndex++) {
//                 let sIndex = indexOfPrimArray(testL[lIndex], testS);
//                 if (sIndex != -1) {
//                     testS.splice(sIndex, 1);
//                     testL.splice(lIndex, 1);
//                     lIndex--;
//                 }
//                 else return false;
//             }
//         }
//         else if (mergeS[4] && mergeL[4]) {
//             while (testS.length > 0 && testL.length > 0) {
//                 if (eqPrimArrays(testS[0], testL[0])) {
//                     testS.shift();
//                     testL.shift();
//                 }
//                 else return false;
//             }
//         }
//         if (testS.length == 0) successes.push(valuesToTest[v]);
//     }
//     if (successes.length == 0) return false;
//     else return successes;
// }

function customMergeSubset(mergeS, mergeL) { // Checks two custom mode merges to see if the smaller one could potentially be a "subset" of the bigger one, such as 1+1 being a subset of 1+1+1.
    let inputsS = [[true, 0]].concat(mergeS[2]);
    let inputsL = [[true, 0]].concat(mergeL[2]);
    if (inputsL.length <= inputsS.length) return false;
    if (mergeS[1].length == 0 || mergeL[1].length == 0) return false; // One of the merges is impossible so don't bother
    // First, eliminate any matching constant terms
    ConstantMatchLoop:
    for (let sIndex = 0; sIndex < inputsS.length; sIndex++) {
        for (let lIndex = 0; lIndex < inputsL.length; lIndex++) {
            if (inputsS[sIndex][0] == false && inputsL[lIndex][0] == false && inputsS[sIndex][1] == inputsL[lIndex][1]) {
                inputsS.splice(sIndex, 1);
                inputsL.splice(lIndex, 1);
                lIndex = 0;
                if (inputsS.length == 0) return true;
                if (sIndex >= inputsS.length) break ConstantMatchLoop;
            }
        }
    }
    // Go through each pair of one tile from each merge and see if, when those two tiles are the same, a subset exists
    for (let sIndex = 0; sIndex < inputsS.length; sIndex++) {
        FocusLoop:
        for (let lIndex = 0; lIndex < inputsL.length; lIndex++) {
            // Choose values for the two n's so that inputsS[sIndex] and inputsL[lIndex] are the same
            let nS, nL;
            if (inputsS[sIndex][0] == false && inputsL[lIndex][0] == false) {
                // If both are constant-term, they can't be the same since we eliminated the matching constant-terms earlier
                continue FocusLoop;
            }
            else if (inputsS[sIndex][0] == false) {
                // If only one is constant-term, then the value for the other one is already decided...
                nL = inputsS[sIndex][1] - inputsL[lIndex][1];
                if ((mergeL[0] == 0 && mergeL[1].indexOf(nL) == -1) || (mergeL[0] == 1 && (nL < mergeL[1][0] || nL > mergeL[1][1] || mod(nL, mergeL[1][3]) != mergeL[1][2]))) continue FocusLoop;
                // ...but we've gained no information on the one that had a constant term, so set it to something arbitrary but valid
                if (mergeS[0] == 0) nS = mergeS[1][0];
                else if (mergeS[0] == 1) {
                    if (mergeS[1][0] == -Infinity && mergeS[1][1] == Infinity) nS = mergeS[1][2];
                    else if (mergeS[1][0] == -Infinity) {
                        nS = mergeS[1][1];
                        let modDistance = mod(nS, mergeS[1][3]) - mergeS[1][2];
                        if (modDistance < 0) modDistance += mergeS[1][3];
                        nS -= modDistance;
                        if (nS < mergeS[1][0]) continue FocusLoop; // No allowed value exists
                    }
                    else {
                        nS = mergeS[1][0];
                        let modDistance = mergeS[1][2] - mod(nS, mergeS[1][3]);
                        if (modDistance < 0) modDistance += mergeS[1][3];
                        nS += modDistance;
                        if (nS > mergeS[1][1]) continue FocusLoop; // No allowed value exists
                    }
                }
            }
            else if (inputsL[lIndex][0] == false) {
                // If only one is constant-term, then the value for the other one is already decided...
                nS = inputsL[lIndex][1] - inputsS[sIndex][1];
                if ((mergeS[0] == 0 && mergeS[1].indexOf(nS) == -1) || (mergeS[0] == 1 && (nS < mergeS[1][0] || nS > mergeS[1][1] || mod(nS, mergeS[1][3]) != mergeS[1][2]))) continue FocusLoop;
                // ...but we've gained no information on the one that had a constant term, so set it to something arbitrary but valid
                if (mergeL[0] == 0) nL = mergeL[1][0];
                else if (mergeL[0] == 1) {
                    if (mergeL[1][0] == -Infinity && mergeL[1][1] == Infinity) nL = mergeL[1][2];
                    else if (mergeL[1][0] == -Infinity) {
                        nL = mergeL[1][1];
                        let modDistance = mod(nL, mergeS[1][3]) - mergeL[1][2];
                        if (modDistance < 0) modDistance += mergeL[1][3];
                        nL -= modDistance;
                        if (nL < mergeS[1][0]) continue FocusLoop; // No allowed value exists
                    }
                    else {
                        nL = mergeL[1][0];
                        let modDistance = mergeL[1][2] - mod(nL, mergeL[1][3]);
                        if (modDistance < 0) modDistance += mergeL[1][3];
                        nL += modDistance;
                        if (nL > mergeS[1][1]) continue FocusLoop; // No allowed value exists
                    }
                }
            }
            else {
                // Neither is constant-term, so we need to find an example that works for both of them.
                // If at least one of them has a specific list of n's, we just need to look through that list and see if the other one allows the value corresponding to that n that matches those two tiles
                if (mergeS[0] == 0) {
                    for (let nIndex = 0; nIndex < mergeS[1].length; nIndex++) {
                        nS = mergeS[1][nIndex] - inputsS[sIndex][1];
                        nL = mergeS[1][nIndex] - inputsL[lIndex][1];
                        if ((mergeL[0] == 0 && mergeL[1].indexOf(nL) != -1) || (mergeL[0] == 1 && nL >= mergeL[1][0] && nL <= mergeL[1][1] && mod(nL, mergeL[1][3]) == mergeL[1][2])) {
                            break;
                        }
                        else {
                            nS = undefined; nL = undefined;
                        }
                    }
                    if (nS === undefined) continue FocusLoop;
                }
                else if (mergeL[0] == 0) {
                    for (let nIndex = 0; nIndex < mergeL[1].length; nIndex++) {
                        nS = mergeL[1][nIndex] - inputsS[sIndex][1];
                        nL = mergeL[1][nIndex] - inputsL[lIndex][1];
                        if ((mergeS[0] == 0 && mergeS[1].indexOf(nS) != -1) || (mergeS[0] == 1 && nS >= mergeS[1][0] && nS <= mergeS[1][1] && mod(nS, mergeS[1][3]) == mergeS[1][2])) {
                            break;
                        }
                        else {
                            nS = undefined; nL = undefined;
                        }
                    }
                    if (nS === undefined) continue FocusLoop;
                }
                else {
                    // If we get here, they both have min/max/mod restrictions, so combine their inequalities and moduluses into a combined restriction on what the value could be
                    let restrictionS = compendiumStructuredClone(mergeS[1]);
                    let restrictionL = compendiumStructuredClone(mergeL[1]);
                    restrictionS[0] += inputsS[sIndex][1];
                    restrictionS[1] += inputsS[sIndex][1];
                    restrictionS[2] += inputsS[sIndex][1];
                    restrictionS[2] = mod(restrictionS[2], restrictionS[3]);
                    restrictionL[0] += inputsL[lIndex][1];
                    restrictionL[1] += inputsL[lIndex][1];
                    restrictionL[2] += inputsL[lIndex][1];
                    restrictionL[2] = mod(restrictionL[2], restrictionL[3]);
                    let comboRestriction = [];
                    comboRestriction.push(Math.max(restrictionS[0], restrictionL[0]));
                    comboRestriction.push(Math.min(restrictionS[1], restrictionL[1]));
                    if (comboRestriction[0] > comboRestriction[1]) continue FocusLoop;
                    let comboMod = moduloCombine(restrictionS.slice(2, 4), restrictionL.slice(2, 4));
                    if (comboMod === false) continue FocusLoop;
                    comboRestriction.push(...comboMod);
                    // Now that we have our restriction, choose a value that's allowed
                    let nVal;
                    if (comboRestriction[0] == -Infinity && comboRestriction[1] == Infinity) nVal = comboRestriction[2];
                    else if (comboRestriction[0] == -Infinity) {
                        nVal = comboRestriction[1];
                        let modDistance = mod(nVal, comboRestriction[3]) - comboRestriction[2];
                        if (modDistance < 0) modDistance += comboRestriction[3];
                        nVal -= modDistance;
                        if (nVal < comboRestriction[0]) continue FocusLoop; // No allowed value exists
                    }
                    else {
                        nVal = comboRestriction[0];
                        let modDistance = comboRestriction[2] - mod(nVal, comboRestriction[3]);
                        if (modDistance < 0) modDistance += comboRestriction[3];
                        nVal += modDistance;
                        if (nVal > comboRestriction[1]) continue FocusLoop; // No allowed value exists
                    }
                    nS = nVal - inputsS[sIndex][1];
                    nL = nVal - inputsL[lIndex][1];
                }
            }
            // We've now chosen our n for each merge, so substitute those in
            let mappedInputsS = compendiumStructuredClone(inputsS).map(input => ((input[0] == false) ? input[1] : nS + input[1]));
            let mappedInputsL = compendiumStructuredClone(inputsL).map(input => ((input[0] == false) ? input[1] : nL + input[1]));
            let uneditedMIS = compendiumStructuredClone(mappedInputsS);
            let uneditedMIL = compendiumStructuredClone(mappedInputsL);
            // And see if we can find a subset
            for (let inputIndex = 0; inputIndex < mappedInputsL.length; inputIndex++) {
                if (mappedInputsS.at(-1) == mappedInputsL[inputIndex]) {
                    mappedInputsL.splice(inputIndex, 1);
                    inputIndex = -1;
                    mappedInputsS.pop();
                    if (mappedInputsS.length == 0) { // Subset found!
                        return true;
                    }
                }
            }
        }
    }
    return false;
}

function makeCustomModePlayable() { // Creates and loads a playable mode out of the custom mode settings.
    TileNumAmount = 2;
    // Spawning tiles
    startTileSpawns = [];
    for (let s = 1; s < customSpawningTiles.length; s++) {
        startTileSpawns.push([[s, customSpawningTiles[s][0]], customSpawningTiles[s][1]]);
    };
    if (customSpawningTiles[0]) startTileSpawns = [["Box", 1].concat(startTileSpawns.flat(1))];
    // Merges
    MergeRules = [];
    knownMergeMaxLength = 1;
    knownMergeLookbackDistance = 0;
    for (let m = 0; m < customMerges.length; m++) {
        let thisCM = customMerges[m];
        let newRule = [];
        newRule.push(thisCM[2].length + 1);
        knownMergeMaxLength = Math.max(knownMergeMaxLength, thisCM[2].length + 1);
        if (newRule[0] == 1) {
            newRule[0] = 0;
        }
        let outerCondition = [];
        let condition = [];
        if (thisCM[4]) {
            if (thisCM[0] == 0) {
                if (thisCM[0].length == 0) continue; // This merge cannot be done, so no reason to put it into MergeRules
                let orChain = [];
                for (let val = 0; val < thisCM[1].length; val++) {
                    orChain.push(["@This 0", "=", thisCM[1][val]]);
                    if (val < thisCM[1].length - 1) orChain.push("||");
                }
                condition.push(orChain);
            }
            else {
                condition.push(["@This 0", ">=", thisCM[1][0]], "&&", ["@This 0", "<=", thisCM[1][1]], "&&", ["@This 0", "mod", thisCM[1][3], "=", thisCM[1][2]])
            }
            for (let tile = 0; tile < thisCM[2].length; tile++) {
                if (!thisCM[2][tile][0]) condition.push("&&", [("@Next " + (tile + 1) + " 0"), "=", thisCM[2][tile][1]])
                else condition.push("&&", ["@This 0", "+", thisCM[2][tile][1], "=", ("@Next " + (tile + 1) + " 0")])
            }
        }
        else {
            outerCondition.push("@global_var_retain");
            let nextArray = ["@Literal", "@This 0"];
            for (let next = 1; next <= thisCM[2].length; next++) {
                nextArray.push("@Next " + next + " 0");
            }
            outerCondition.push(
                0, -1, nextArray, false, m, 0, true, "@end_vars", 0,
                "@repeat", ["@Var 1", "<", thisCM[2].length, "&&", ["@Var 3", "!"]],
                "@edit_var", 1, ["@Var 1", "+", 1], "@edit_var", 0, ["@Var 2", "arr_elem", "@Var 1", "CalcArray"], "@if",
            );
            if (thisCM[0] == 0) {
                if (thisCM[0].length == 0) continue; // This merge cannot be done, so no reason to put it into MergeRules
                let orChain = [];
                for (let val = 0; val < thisCM[1].length; val++) {
                    orChain.push(["@Var 0", "=", thisCM[1][val]]);
                    if (val < thisCM[1].length - 1) orChain.push("||");
                }
                condition.push(orChain);
            }
            else {
                condition.push(["@Var 0", ">=", thisCM[1][0]], "&&", ["@Var 0", "<=", thisCM[1][1]], "&&", ["@Var 0", "mod", thisCM[1][3], "=", thisCM[1][2]])
            }
            let nArray = ["@Literal", "@Var 0"];
            for (let tile = 0; tile < thisCM[2].length; tile++) {
                if (thisCM[2][tile][0]) nArray.push(["@Var 0", "+", thisCM[2][tile][1]]);
                else nArray.push(thisCM[2][tile][1]);
            }
            condition.push("&&", [["@Var 2", "arr_map", ["@Var -1", "CalcArray"]], "arr_eqRearrange", [nArray, "arr_map", ["@Var -1", "CalcArray"]]]);
        }
        for (let p = 0; p < m; p++) {
            let prevRule = customMerges[p];
            if (prevRule[2].length == 0 || thisCM[2].length >= prevRule[2].length) continue;
            if (customMergeSubset(thisCM, prevRule)) {
                condition.push("&&", [0, "@edit_var", 5, 0, "@repeat", ["@Var 5", ">", thisCM[2].length - prevRule[2].length, "&&", "@Var 6"], "@edit_var", 5, ["@Var 5", "-", 1], "@edit_var", 6, [p, "mergeRuleApplies_nonRecursive", "@Var 5", "!"], "2nd", "@Var 6"]);
                knownMergeLookbackDistance = Math.max(knownMergeLookbackDistance, prevRule[2].length - thisCM[2].length);
            }
        }
        if (thisCM[4]) {
            newRule.push(condition);
        }
        else {
            outerCondition.push(condition, "@edit_var", 3, true, "@end-if", "@end-repeat", "2nd", "@Var 3")
            newRule.push(outerCondition);
        }
        newRule.push(true);
        if (thisCM[3].length == 0) {
            newRule.push([], 0);
        }
        else {
            let outputArray = [];
            outputArray.push(thisCM[3][0][0] ? ["@var_retain", (thisCM[4] ? "@This 0" : "@Var 0"), "+", thisCM[3][0][1]] : thisCM[3][0][1]);
            let outputSum = ["@This 1"];
            for (let next = 0; next < thisCM[2].length; next++) outputSum.push("+", "@Next " + (next + 1) + " 1");
            outputArray.push(outputSum);
            newRule.push([outputArray], (thisCM[2].length == 0 ? 0 : outputSum.concat(["abs"])));
        }
        MergeRules.push(newRule);
    }
    // Colors
    TileTypes = [];
    for (let c = 0; c < customColors.length; c++) {
        let thisCC = customColors[c];
        let newType = [];
        let condition = [];
        if (thisCC[0] == 0) {
            if (thisCC[1].length == 0) continue; // This tile type is never valid, so no reason to put it into TileTypes
            let orChain = [];
            for (let val = 0; val < thisCC[1].length; val++) {
                orChain.push(["@This 0", "=", thisCC[1][val]]);
                if (val < thisCC[0].length - 1) orChain.push("||");
            }
            condition.push(orChain);
        }
        else {
            condition.push(["@This 0", ">=", thisCC[1][0]], "&&", ["@This 0", "<=", thisCC[1][1]], "&&", ["@This 0", "mod", thisCC[1][3], "=", thisCC[1][2]])
        }
        newType.push(condition, ["@This 1"]);
        let gradientArray = [];
        let gradientOrder = thisCC[3].map((value, index) => [value, index]).sort((a, b) => (a[0] - b[0]));
        for (let entry = 0; entry < thisCC[2].length; entry++) {
            let currentEntry = thisCC[2][gradientOrder[entry][1]];
            let entryArray = [];
            entryArray.push(currentEntry[0]);
            if (currentEntry[6]) {
                entryArray.push([currentEntry[8], "^", ["@This 0", "-", currentEntry[5]], "*", (currentEntry[1] - currentEntry[7]), "+", currentEntry[7]]);
            }
            else {
                entryArray.push(["@This 0", "-", currentEntry[5], "*", currentEntry[7], "+", currentEntry[1]]);
            }
            if (currentEntry[9]) {
                entryArray.push([currentEntry[11], "^", ["@This 0", "-", currentEntry[5]], "*", (currentEntry[2] - currentEntry[10]), "+", currentEntry[10]]);
            }
            else {
                entryArray.push(["@This 0", "-", currentEntry[5], "*", currentEntry[10], "+", currentEntry[2]]);
            }
            if (currentEntry[12]) {
                entryArray.push([currentEntry[14], "^", ["@This 0", "-", currentEntry[5]], "*", (currentEntry[3] - currentEntry[13]), "+", currentEntry[13]]);
            }
            else {
                entryArray.push(["@This 0", "-", currentEntry[5], "*", currentEntry[13], "+", currentEntry[3]]);
            }
            if (currentEntry[15]) {
                entryArray.push([currentEntry[17], "^", ["@This 0", "-", currentEntry[5]], "*", (currentEntry[4] - currentEntry[16]), "+", currentEntry[16]]);
            }
            else {
                entryArray.push(["@This 0", "-", currentEntry[5], "*", currentEntry[16], "+", currentEntry[4]]);
            }
            gradientArray.push(entryArray, thisCC[3][gradientOrder[entry][1]]);
        }
        if (gradientArray.length == 2) gradientArray = gradientArray[0];
        else gradientArray.unshift(...thisCC[4]);
        newType.push(gradientArray);
        let textArray = [];
        textArray.push(thisCC[5][0]);
        if (thisCC[5][6]) {
            textArray.push([thisCC[5][8], "^", ["@This 0", "-", thisCC[5][5]], "*", (thisCC[5][1] - thisCC[5][7]), "+", thisCC[5][7]]);
        }
        else {
            textArray.push(["@This 0", "-", thisCC[5][5], "*", thisCC[5][7], "+", thisCC[5][1]]);
        }
        if (thisCC[5][9]) {
            textArray.push([thisCC[5][11], "^", ["@This 0", "-", thisCC[5][5]], "*", (thisCC[5][2] - thisCC[5][10]), "+", thisCC[5][10]]);
        }
        else {
            textArray.push(["@This 0", "-", thisCC[5][5], "*", thisCC[5][10], "+", thisCC[5][2]]);
        }
        if (thisCC[5][12]) {
            textArray.push([thisCC[5][14], "^", ["@This 0", "-", thisCC[5][5]], "*", (thisCC[5][3] - thisCC[5][13]), "+", thisCC[5][13]]);
        }
        else {
            textArray.push(["@This 0", "-", thisCC[5][5], "*", thisCC[5][13], "+", thisCC[5][3]]);
        }
        if (thisCC[5][15]) {
            textArray.push([thisCC[5][17], "^", ["@This 0", "-", thisCC[5][5]], "*", (thisCC[5][4] - thisCC[5][16]), "+", thisCC[5][16]]);
        }
        else {
            textArray.push(["@This 0", "-", thisCC[5][5], "*", thisCC[5][16], "+", thisCC[5][4]]);
        }
        newType.push(textArray);
        TileTypes.push(newType);
    }
    TileTypes.push([true, "@This 1", "#000000", "#ffffff"])
    // Background
    let gradientArray = [];
    let gradientOrder = customBackground[0][2].map((value, index) => [value, index]).sort((a, b) => (a[0] - b[0]));
    for (let entry = 0; entry < customBackground[0][3].length; entry++) {
        gradientArray.push(customBackground[0][3][gradientOrder[entry][1]], customBackground[0][2][gradientOrder[entry][1]]);
    }
    if (gradientArray.length == 2) gradientArray = gradientArray[0];
    else {
        if (customBackground[0][0] != "@radial-gradient") gradientArray.unshift(customBackground[0][1]);
        gradientArray.unshift(customBackground[0][0]);
    }
    document.documentElement.style.setProperty("--background-color", evaluateColor(gradientArray));
    gradientArray = [];
    gradientOrder = customBackground[1][2].map((value, index) => [value, index]).sort((a, b) => (a[0] - b[0]));
    for (let entry = 0; entry < customBackground[1][3].length; entry++) {
        gradientArray.push(customBackground[1][3][gradientOrder[entry][1]], customBackground[1][2][gradientOrder[entry][1]]);
    }
    if (gradientArray.length == 2) {
        gradientArray = [gradientArray[0], gradientArray[0]]
    }
    if (customBackground[1][0] != "@radial-gradient") gradientArray.unshift(customBackground[1][1]);
    gradientArray.unshift(customBackground[1][0]);
    document.documentElement.style.setProperty("background-image", evaluateColor(gradientArray));
    document.documentElement.style.setProperty("--tile-color", evaluateColor(customBackground[2][3][0]));
    document.documentElement.style.setProperty("--grid-color", evaluateColor(customBackground[3][3][0]));
    document.documentElement.style.setProperty("--text-color", evaluateColor(customBackground[4][3][0]));
    // Other Stuff
    winConditions = [];
    if (customWins[0] == 0) {
        winRequirement = false;
    }
    else {
        for (let w = 1; w < customWins.length; w++) winConditions.push([["@This 0", "=", customWins[w]]]);
        winRequirement = customWins[0];
    }
    loseConditions = [];
    if (customLosses[0] == 0) {
        loseRequirement = false;
    }
    else {
        for (let w = 1; w < customLosses.length; w++) loseConditions.push([["@This 0", "=", customLosses[w]]]);
        loseRequirement = customLosses[0];
    }
    let spawningString = "Spawning tiles: ";
    if (customSpawningTiles[0]) spawningString = 'Spawning tiles pull from a "box" that starts with: '
    for (let s = 1; s < customSpawningTiles.length; s++) {
        if (customSpawningTiles[s][1] != 0) {
            if (spawningString[spawningString.length - 2] != ":") spawningString += ", ";
            spawningString += customSpawningTiles[s][0] + (customSpawningTiles[0] ? " with amount " : " with chance ") + customSpawningTiles[s][1];
        }
    }
    displayRules("rules_text", ["h2", customRulesText[0]], ["h1", customRulesText[1]], ["p", customRulesText[2]], ["p", spawningString]);
    displayRules("gm_rules_text", ["h2", customRulesText[0]], ["h1", customRulesText[1]], ["p", customRulesText[2]], ["p", spawningString]);
    // Interacting Negatives and Tricolor Tiles
    mode_vars = [false, 0];
    for (let s = 0; s < customSpawningTiles.length; s++) {
        if (customSpawningTiles[s][0] < 0) {
            mode_vars[0] = true;
            break;
        }
    }
    if (customMerges.length > 0) {
        mode_vars[1] = customMerges[0][2].length;
        for (let m = 1; m < customMerges.length; m++) {
            let nextLength = customMerges[m][2].length;
            if (nextLength != mode_vars[1]) {
                mode_vars[1] = 0;
                break;
            }
        }
        if (mode_vars[1] != 1 && mode_vars[1] != 2) mode_vars[1] = 0;
    }
}

//Save codes

function SCstringify(input) { // My version of BigInts-compatible JSON.stringify, converting 100n into "@BigInt 100", which fits for this project because @ is the "this string is special" character for CalcArrays. Also allows infinities.
    return JSON.stringify(input, function(key, value) {
        if (typeof value == "bigint") return "@BigInt " + String(value);
        else if (value instanceof GaussianBigInt) return "@GaussianBigInt " + String(value.real) + " " + String(value.imaginary);
        else if (value instanceof BigRational) return "@BigRational " + String(value.numerator) + " " + String(value.denominator);
        else if (value == Infinity) return "@Infinity";
        else if (value == -Infinity) return "@-Infinity";
        else return value;
    })
}

function SCparse(input) { // Undoes SCstringify
    return JSON.parse(input, function(key, value) {
        if (typeof value == "string" && value.substring(0, 8) == "@BigInt ") return BigInt(value.substring(8));
        else if (typeof value == "string" && value.substring(0, 16) == "@GaussianBigInt ") {
            let split = value.substring(16).split(" ");
            output(split[0]);
            output(split[1])
            return new GaussianBigInt(BigInt(split[0]), BigInt(split[1]))
        }
        else if (typeof value == "string" && value.substring(0, 13) == "@BigRational ") {
            let split = value.substring(13).split(" ");
            output(split[0]);
            output(split[1])
            return new BigRational(BigInt(split[0]), BigInt(split[1]))
        }
        else if (value == "@Infinity") return Infinity;
        else if (value == "@-Infinity") return -Infinity;
        else return value;
    })
}

function compendiumStructuredClone(input) { // A version of structuredClone that doesn't destroy GaussianBigInts and BigRationals, albeit at the cost of losing the ability to handle circular references
    if (input instanceof GaussianBigInt) return new GaussianBigInt(input);
    if (input instanceof BigRational) return new BigRational(input);
    else if (Array.isArray(input)) {
        let result = [];
        for (let e of input) {
            result.push(compendiumStructuredClone(e));
        }
        return result;
    }
    else return structuredClone(input);
}

function updateAtSign(array, version) { // Version 1.1 added @ to the front of Empty, Void, and color evaluation starts like HSLA and linear-gradient; this function updates the array it's given accordingly.
    deepArrayReplace("Empty", "@Empty", array);
    deepArrayReplace("Void", "@Void", array);
    deepArrayReplace("HSLA", "@HSLA", array);
    deepArrayReplace("RGBA", "@RGBA", array);
    deepArrayReplace("HSVA", "@HSVA", array);
    deepArrayReplace("linear-gradient", "@linear-gradient", array);
    deepArrayReplace("repeating-linear-gradient", "@repeating-linear-gradient", array);
    deepArrayReplace("radial-gradient", "@radial-gradient", array);
    deepArrayReplace("repeating-radial-gradient", "@repeating-radial-gradient", array);
    deepArrayReplace("conic-gradient", "@conic-gradient", array);
    deepArrayReplace("repeating-conic-gradient", "@repeating-conic-gradient", array);
    deepArrayReplace("multi-gradient", "@multi-gradient", array);
}

function exportSave(midgame) { // A save code where midgame = true saves a game in progress, a save code where midgame = false saves a gamemode. Mode save codes are currently unused in the project itself, but if you code your own 2048 mode using the 2048 Power Compendium's code, you can save it as a code and play it in the game
    try {
        let SaveCode = "";
        if (midgame) SaveCode = "@2048PowCompGame|";
        else SaveCode = "@2048PowCompMode|";
        SaveCode += "2.1.13|"
        SaveCode += window.btoa(String(width));
        SaveCode += "|";
        SaveCode += window.btoa(String(height));
        SaveCode += "|";
        SaveCode += window.btoa(SCstringify(startingGrid));
        SaveCode += "|";
        SaveCode += window.btoa(SCstringify(directions));
        SaveCode += "|";
        SaveCode += window.btoa(SCstringify(auto_directions));
        SaveCode += "|";
        SaveCode += window.btoa(SCstringify(movementParameters));
        SaveCode += "|";
        SaveCode += window.btoa(String(TileNumAmount));
        SaveCode += "|";
        SaveCode += window.btoa(SCstringify(TileTypes));
        SaveCode += "|";
        SaveCode += window.btoa(SCstringify(MergeRules));
        SaveCode += "|";
        SaveCode += window.btoa(SCstringify(startTileSpawns));
        SaveCode += "|";
        SaveCode += window.btoa(SCstringify(forcedSpawns));
        SaveCode += "|";
        SaveCode += window.btoa(SCstringify(winConditions));
        SaveCode += "|";
        SaveCode += window.btoa(SCstringify(winRequirement));
        SaveCode += "|";
        SaveCode += window.btoa(SCstringify(loseConditions));
        SaveCode += "|";
        SaveCode += window.btoa(SCstringify(loseRequirement));
        SaveCode += "|";
        SaveCode += window.btoa(SCstringify(winPriority));
        SaveCode += "|";
        SaveCode += window.btoa(SCstringify(postgameAllowed));
        SaveCode += "|";
        SaveCode += window.btoa(SCstringify(statBoxes));
        SaveCode += "|";
        SaveCode += window.btoa(getComputedStyle(document.documentElement).getPropertyValue("--background-color"));
        SaveCode += "|";
        SaveCode += window.btoa(getComputedStyle(document.documentElement).getPropertyValue("--grid-color"));
        SaveCode += "|";
        SaveCode += window.btoa(getComputedStyle(document.documentElement).getPropertyValue("--tile-color"));
        SaveCode += "|";
        SaveCode += window.btoa(getComputedStyle(document.documentElement).getPropertyValue("--text-color"));
        SaveCode += "|";
        SaveCode += window.btoa(he.encode(document.getElementById("rules_text").innerHTML));
        SaveCode += "|";
        SaveCode += window.btoa(SCstringify(multiMerge));
        SaveCode += "|";
        SaveCode += window.btoa(String(spawnLocation));
        SaveCode += "|";
        SaveCode += window.btoa(String(startTileAmount));
        SaveCode += "|";
        SaveCode += window.btoa(String(randomTileAmount));
        SaveCode += "|";
        SaveCode += window.btoa(SCstringify(spawnConditions));
        SaveCode += "|";
        SaveCode += window.btoa(String(nextTiles));
        SaveCode += "|";
        SaveCode += window.btoa(SCstringify(start_game_vars));
        SaveCode += "|";
        SaveCode += window.btoa(SCstringify(start_modifier_vars));
        SaveCode += "|";
        SaveCode += window.btoa(SCstringify(scripts));
        SaveCode += "|";
        SaveCode += window.btoa(SCstringify(hexagonal));
        SaveCode += "|";
        SaveCode += window.btoa(SCstringify(hiddenTileText));
        SaveCode += "|";
        SaveCode += window.btoa(String(tileDisplayKnownLevel));
        SaveCode += "|";
        SaveCode += window.btoa(String(mergeResultKnownLevel));
        SaveCode += "|";
        SaveCode += window.btoa(String(knownMergeLookbackDistance));
        SaveCode += "|";
        if (midgame) {
            SaveCode += window.btoa(SCstringify(Grid));
            SaveCode += "|";
            SaveCode += window.btoa(String(score));
            SaveCode += "|";
            SaveCode += window.btoa(String(won));
            SaveCode += "|";
            SaveCode += window.btoa(SCstringify(directionsAvailable));
            SaveCode += "|";
            SaveCode += window.btoa(SCstringify(TileSpawns));
            SaveCode += "|";
            SaveCode += window.btoa(SCstringify(SpawnBoxes));
            SaveCode += "|";
            SaveCode += window.btoa(SCstringify(spawnConveyor));
            SaveCode += "|";
            SaveCode += window.btoa(SCstringify(discoveredTiles));
            SaveCode += "|";
            SaveCode += window.btoa(SCstringify(discoveredWinning));
            SaveCode += "|";
            SaveCode += window.btoa(SCstringify(discoveredLosing));
            SaveCode += "|";
            SaveCode += window.btoa(String(moves_so_far));
            SaveCode += "|";
            SaveCode += window.btoa(String(manual_moves_so_far));
            SaveCode += "|";
            SaveCode += window.btoa(String(merges_so_far));
            SaveCode += "|";
            SaveCode += window.btoa(String(moves_where_merged));
            SaveCode += "|";
            SaveCode += window.btoa(String(merges_before_now));
            SaveCode += "|";
            SaveCode += window.btoa(SCstringify(game_vars));
            SaveCode += "|";
            SaveCode += window.btoa(SCstringify(modifier_vars));
            SaveCode += "|";
            SaveCode += window.btoa(SCstringify(possibleOverChecked));
            SaveCode += "|";
        }
        document.getElementById("save_code_box").value = SaveCode;
    }
    catch (error) {
        document.getElementById("save_code_box").value = "There was an error with exporting your save code: " + error.message;
    }
}

function exportCustomSave() {
    try {
        let SaveCode = "@2048PowCompCustom|2.0|";
        SaveCode += window.btoa(SCstringify(customSpawningTiles));
        SaveCode += "|";
        SaveCode += window.btoa(SCstringify(customMerges));
        SaveCode += "|";
        SaveCode += window.btoa(SCstringify(customColors));
        SaveCode += "|";
        SaveCode += window.btoa(SCstringify(customBackground));
        SaveCode += "|";
        SaveCode += window.btoa(SCstringify(customWins));
        SaveCode += "|";
        SaveCode += window.btoa(SCstringify(customLosses));
        SaveCode += "|";
        SaveCode += window.btoa(SCstringify(customRulesText));
        SaveCode += "|";
        document.getElementById("save_code_box").value = SaveCode;
    }
    catch {
        document.getElementById("save_code_box").value = "There was an error with exporting your save code.";
    }
}

function exportModifiersSave() {
    try {
        let SaveCode = "@2048PowCompModifiers|2.1|";
        SaveCode += window.btoa(SCstringify(modifiers.slice(0, 16).concat(modifiers.slice(17)))); // Animation speed is not saved
        SaveCode += "|";
        SaveCode += window.btoa(SCstringify(auto_directions));
        SaveCode += "|";
        if (modifiers[5] == "Custom") {
            SaveCode += window.btoa(SCstringify(width));
            SaveCode += "|";
            SaveCode += window.btoa(SCstringify(height));
            SaveCode += "|";
            SaveCode += window.btoa(SCstringify(hexagonal));
            SaveCode += "|";
            SaveCode += window.btoa(SCstringify(startingGrid));
            SaveCode += "|";
            SaveCode += window.btoa(SCstringify(directions));
            SaveCode += "|";
        }
        document.getElementById("save_code_box").value = SaveCode;
    }
    catch {
        document.getElementById("save_code_box").value = "There was an error with exporting your save code.";
    }
}

// let modifiers = [Infinity, 1, 2, false, "All", "Square", 0, 0, 0, 0, "Orthogonal", false, false, "None", 0, "Regular", 1, 0, 0, 1, false, false, 1, 1, false, 0, 1, 1, 0];
//     /*
//     modifiers[0] corresponds to SlideAmount, modifiers[1] corresponds to randomTileAmount, modifiers[2] corresponds to startTileAmount, modifiers[3] corresponds
//     to multiMerge, and modifiers[4] corresponds to spawnLocation. modifiers[5] changes the shape of the grid, and modifiers[6] through modifiers[9] are used as size
//     variables for alternate grid shapes. modifiers[10] controls the available directions, modifiers[11] is whether you can stay still as a move, modifiers[12] is the
//     toggle for Garbage 0s, modifiers[13] is the toggle for Negative Tiles, modifiers[14] corresponds to nextTiles, modifiers[15] is the toggle for SimpleSpawns,
//     modifiers[16] is the animation speed, modifiers[17] adds holes to the grid, modifiers[18] adds box tiles to the grid, modifiers[19] changes how many turns
//     there are between each tile spawning (which is done by changing spawnConditions), modifiers[20] is whether it takes two moves in the same direction to merge,
//     modifiers[21] corresponds to hiddenTileText, modifiers[22] and modifiers[23] are the ratio of positive to negative tile spawn chances when Negative Tiles is on,
//     modifiers[24] is the toggle for Tricolor Tiles, modifiers[25], modifiers[26], and modifiers[27] are the amount per spawn, interval between spawns, and lifespan (respectively) of Temporary Holes,
//     and modifiers[28] adds slippery tiles to the grid.
//     */

let validSaveCodeVersions = ["1.0", "1.1", "1.2", "1.3", "1.4", "1.5", "1.5.1", "2.0", "2.1", "2.1.4", "2.1.13"];

function importSave(code) {
    try {
        let coderesults = [];
        let codebits = code.split("|");
        if (codebits[0] == "@2048PowCompGame" || codebits[0] == "@2048PowCompMode") {
            if (validSaveCodeVersions.indexOf(codebits[1]) > 0) {
                coderesults.push(Number(window.atob(codebits[2]))); //coderesults[0] is width
                if (isNaN(coderesults[0]) || coderesults[0] < 1 || (coderesults[0] % 1) != 0) throw "Invalid width";
                coderesults.push(Number(window.atob(codebits[3]))); //coderesults[1] is height
                if (isNaN(coderesults[1]) || coderesults[1] < 1 || (coderesults[1] % 1) != 0) throw "Invalid height";
                coderesults.push(SCparse(window.atob(codebits[4]))); //coderesults[2] is startingGrid
                coderesults.push(SCparse(window.atob(codebits[5]))); //coderesults[3] is directions
                coderesults.push(SCparse(window.atob(codebits[6]))); //coderesults[4] is auto_directions
                coderesults.push(SCparse(window.atob(codebits[7]))); //coderesults[5] is movementParameters
                coderesults.push(Number(window.atob(codebits[8]))); //coderesults[6] is TileNumAmount
                if (isNaN(coderesults[6]) || coderesults[6] < 1 || (coderesults[6] % 1) != 0) throw "Invalid amount of tile tier numbers";
                coderesults.push(SCparse(window.atob(codebits[9]))); //coderesults[7] is TileTypes
                coderesults.push(SCparse(window.atob(codebits[10]))); //coderesults[8] is MergeRules
                coderesults.push(SCparse(window.atob(codebits[11]))); //coderesults[9] is startTileSpawns
                coderesults.push(SCparse(window.atob(codebits[12]))); //coderesults[10] is forcedSpawns
                coderesults.push(SCparse(window.atob(codebits[13]))); //coderesults[11] is winConditions
                coderesults.push(SCparse(window.atob(codebits[14]))); //coderesults[12] is winRequirement
                coderesults.push(SCparse(window.atob(codebits[15]))); //coderesults[13] is loseConditions
                coderesults.push(SCparse(window.atob(codebits[16]))); //coderesults[14] is loseRequirement
                coderesults.push(SCparse(window.atob(codebits[17]))); //coderesults[15] is winPriority
                coderesults.push(SCparse(window.atob(codebits[18]))); //coderesults[16] is postgameAllowed
                coderesults.push(SCparse(window.atob(codebits[19]))); //coderesults[17] is statBoxes
                coderesults.push(window.atob(codebits[20])); //coderesults[18] is --background-color
                coderesults.push(window.atob(codebits[21])); //coderesults[19] is --grid-color
                coderesults.push(window.atob(codebits[22])); //coderesults[20] is --tile-color
                coderesults.push(window.atob(codebits[23])); //coderesults[21] is --text-color
                //coderesults[22] is the rules text
                if (validSaveCodeVersions.indexOf(codebits[1]) > 8) coderesults.push(he.decode(window.atob(codebits[24])));
                else coderesults.push(window.atob(codebits[24]));
                coderesults.push(SCparse(window.atob(codebits[25]))); //coderesults[23] is multiMerge
                coderesults.push(window.atob(codebits[26])); //coderesults[24] is spawnLocation
                coderesults.push(Number(window.atob(codebits[27]))); //coderesults[25] is startTileAmount
                coderesults.push(Number(window.atob(codebits[28]))); //coderesults[26] is randomTileAmount
                coderesults.push(SCparse(window.atob(codebits[29]))); //coderesults[27] is spawnConditions
                coderesults.push(Number(window.atob(codebits[30]))); //coderesults[28] is nextTiles
                coderesults.push(SCparse(window.atob(codebits[31]))); //coderesults[29] is start_game_vars
                coderesults.push(SCparse(window.atob(codebits[32]))); //coderesults[30] is start_modifier_vars
                coderesults.push(SCparse(window.atob(codebits[33]))); //coderesults[31] is scripts
                if (validSaveCodeVersions.indexOf(codebits[1]) > 3) {
                    coderesults.push(SCparse(window.atob(codebits[34]))); //coderesults[32] is hexagonal
                    coderesults.push(SCparse(window.atob(codebits[35]))); //coderesults[33] is hiddenTileText
                }
                if (validSaveCodeVersions.indexOf(codebits[1]) > 9) {
                    coderesults.push(Number(window.atob(codebits[36]))); //coderesults[34] is tileDisplayKnownLevel
                    coderesults.push(Number(window.atob(codebits[37]))); //coderesults[35] is mergeResultKnownLevel
                    coderesults.push(Number(window.atob(codebits[38]))); //coderesults[36] is knownMergeLookbackDistance
                }
                if (codebits[0] == "@2048PowCompGame") {
                    let midgameStart;
                    if (validSaveCodeVersions.indexOf(codebits[1]) > 9) midgameStart = 39;
                    else if (validSaveCodeVersions.indexOf(codebits[1]) > 3) midgameStart = 36;
                    else midgameStart = 34;
                    coderesults.push(SCparse(window.atob(codebits[midgameStart]))); //coderesults[midgameStart] is Grid
                    coderesults.push(Number(window.atob(codebits[midgameStart + 1]))); //coderesults[midgameStart + 1] is score
                    coderesults.push(Number(window.atob(codebits[midgameStart + 2]))); //coderesults[midgameStart + 2] is won
                    coderesults.push(SCparse(window.atob(codebits[midgameStart + 3]))); //coderesults[midgameStart + 3] is directionsAvailable
                    coderesults.push(SCparse(window.atob(codebits[midgameStart + 4]))); //coderesults[midgameStart + 4] is TileSpawns
                    coderesults.push(SCparse(window.atob(codebits[midgameStart + 5]))); //coderesults[midgameStart + 5] is SpawnBoxes
                    coderesults.push(SCparse(window.atob(codebits[midgameStart + 6]))); //coderesults[midgameStart + 6] is spawnConveyor
                    coderesults.push(SCparse(window.atob(codebits[midgameStart + 7]))); //coderesults[midgameStart + 7] is discoveredTiles
                    coderesults.push(SCparse(window.atob(codebits[midgameStart + 8]))); //coderesults[midgameStart + 8] is discoveredWinning
                    coderesults.push(SCparse(window.atob(codebits[midgameStart + 9]))); //coderesults[midgameStart + 9] is discoveredLosing
                    coderesults.push(Number(window.atob(codebits[midgameStart + 10]))); //coderesults[midgameStart + 10] is moves_so_far
                    coderesults.push(Number(window.atob(codebits[midgameStart + 11]))); //coderesults[midgameStart + 11] is manual_moves_so_far
                    coderesults.push(Number(window.atob(codebits[midgameStart + 12]))); //coderesults[midgameStart + 12] is merges_so_far
                    coderesults.push(Number(window.atob(codebits[midgameStart + 13]))); //coderesults[midgameStart + 13] is moves_where_merged
                    coderesults.push(Number(window.atob(codebits[midgameStart + 14]))); //coderesults[midgameStart + 14] is merges_before_now
                    coderesults.push(SCparse(window.atob(codebits[midgameStart + 15]))); //coderesults[midgameStart + 15] is game_vars
                    coderesults.push(SCparse(window.atob(codebits[midgameStart + 16]))); //coderesults[midgameStart + 16] is modifier_vars
                    coderesults.push(SCparse(window.atob(codebits[midgameStart + 17]))); //coderesults[midgameStart + 17] is possibleOverChecked
                }
                //If we've gotten this far, the import is a success, so it's time to do the actual importing
                width = coderesults[0];
                height = coderesults[1];
                startingGrid = coderesults[2];
                directions = coderesults[3];
                auto_directions = coderesults[4];
                movementParameters = coderesults[5];
                TileNumAmount = coderesults[6];
                TileTypes = coderesults[7];
                MergeRules = coderesults[8];
                startTileSpawns = coderesults[9];
                forcedSpawns = coderesults[10];
                winConditions = coderesults[11];
                winRequirement = coderesults[12];
                loseConditions = coderesults[13];
                loseRequirement = coderesults[14];
                winPriority = coderesults[15];
                postgameAllowed = coderesults[16];
                statBoxes = coderesults[17];
                document.documentElement.style.setProperty("--background-color", coderesults[18]);
                document.documentElement.style.setProperty("--grid-color", coderesults[19]);
                document.documentElement.style.setProperty("--tile-color", coderesults[20]);
                document.documentElement.style.setProperty("--text-color", coderesults[21]);
                if (codebits[0] == "@2048PowCompGame" && !coderesults[22].includes("<p>This game was resumed from a save code.</p>")) coderesults[22] += "<p>This game was resumed from a save code.</p>";
                document.getElementById("rules_text").innerHTML = coderesults[22];
                multiMerge = coderesults[23];
                spawnLocation = coderesults[24];
                startTileAmount = coderesults[25];
                randomTileAmount = coderesults[26];
                spawnConditions = coderesults[27];
                nextTiles = coderesults[28];
                start_game_vars = coderesults[29];
                start_modifier_vars = coderesults[30];
                scripts = coderesults[31];
                if (validSaveCodeVersions.indexOf(codebits[1]) > 3) {
                    hexagonal = coderesults[32];
                    hiddenTileText = coderesults[33];
                }
                else {
                    hexagonal = false;
                    hiddenTileText = false;
                }
                if (validSaveCodeVersions.indexOf(codebits[1]) > 9) {
                    tileDisplayKnownLevel = coderesults[34];
                    mergeResultKnownLevel = coderesults[35];
                    knownMergeLookbackDistance = coderesults[36];
                }
                else {
                    tileDisplayKnownLevel = 2;
                    mergeResultKnownLevel = 0;
                }
                gamemode = 0;
                startGame();
                if (codebits[0] == "@2048PowCompGame") {
                    let midgameStart;
                    if (validSaveCodeVersions.indexOf(codebits[1]) > 9) midgameStart = 37;
                    else if (validSaveCodeVersions.indexOf(codebits[1]) > 3) midgameStart = 34;
                    else midgameStart = 32;
                    Grid = coderesults[midgameStart];
                    score = coderesults[midgameStart + 1];
                    won = coderesults[midgameStart + 2];
                    directionsAvailable = coderesults[midgameStart + 3];
                    TileSpawns = coderesults[midgameStart + 4];
                    SpawnBoxes = coderesults[midgameStart + 5];
                    spawnConveyor = coderesults[midgameStart + 6];
                    discoveredTiles = coderesults[midgameStart + 7];
                    discoveredWinning = coderesults[midgameStart + 8];
                    discoveredLosing = coderesults[midgameStart + 9];
                    moves_so_far = coderesults[midgameStart + 10];
                    manual_moves_so_far = coderesults[midgameStart + 11];
                    merges_so_far = coderesults[midgameStart + 12];
                    moves_where_merged = coderesults[midgameStart + 13];
                    merges_before_now = coderesults[midgameStart + 14];
                    game_vars = coderesults[midgameStart + 15];
                    modifier_vars = coderesults[midgameStart + 16];
                    possibleOverChecked = coderesults[midgameStart + 17];
                    displayGrid();
                    displayButtons(true);
                }
    
            }
            else if (codebits[1] == "1.0") {
                coderesults.push(Number(window.atob(codebits[2]))); //coderesults[0] is width
                if (isNaN(coderesults[0]) || coderesults[0] < 1 || (coderesults[0] % 1) != 0) throw "Invalid width";
                coderesults.push(Number(window.atob(codebits[3]))); //coderesults[1] is height
                if (isNaN(coderesults[1]) || coderesults[1] < 1 || (coderesults[1] % 1) != 0) throw "Invalid height";
                coderesults.push(Number(window.atob(codebits[4]))); //coderesults[2] is TileNumAmount
                if (isNaN(coderesults[2]) || coderesults[2] < 1 || (coderesults[2] % 1) != 0) throw "Invalid amount of tile tier numbers";
                coderesults.push(JSON.parse(window.atob(codebits[5]))); //coderesults[3] is TileTypes
                coderesults.push(JSON.parse(window.atob(codebits[6]))); //coderesults[4] is MergeRules
                coderesults.push(JSON.parse(window.atob(codebits[7]))); //coderesults[5] is TileSpawns
                coderesults.push(JSON.parse(window.atob(codebits[8]))); //coderesults[6] is startingGrid
                coderesults.push(JSON.parse(window.atob(codebits[9]))); //coderesults[7] is winConditions
                coderesults.push(Number(window.atob(codebits[10]))); //coderesults[8] is winRequirement
                coderesults.push(Number(window.atob(codebits[11]))); //coderesults[9] is slideAmount
                if (codebits[12] == "t") coderesults.push(true); //coderesults[10] is multiMerge
                else if (codebits[12] == "f") coderesults.push(false);
                else throw "Invalid multiMerge";
                coderesults.push(window.atob(codebits[13])); //coderesults[11] is --background-color
                coderesults.push(window.atob(codebits[14])); //coderesults[12] is --grid-color
                coderesults.push(window.atob(codebits[15])); //coderesults[13] is --tile-color
                coderesults.push(window.atob(codebits[16])); //coderesults[14] is --text-color
                coderesults.push(window.atob(codebits[17])); //coderesults[15] is the rules text
                if (codebits[18] == "t") coderesults.push(true); //coderesults[16] is whether the amount of discovered tiles is displayed
                else if (codebits[18] == "f") coderesults.push(false);
                else throw "Invalid discovered display";
                if (codebits[19] == "t") coderesults.push(true); //coderesults[17] is whether the amount of winning tiles is displayed
                else if (codebits[19] == "f") coderesults.push(false);
                else throw "Invalid winning display";
                coderesults.push(window.atob(codebits[20])); //coderesults[18] is spawnLocation
                coderesults.push(Number(window.atob(codebits[21]))); //coderesults[19] is startTileAmount
                coderesults.push(Number(window.atob(codebits[22]))); //coderesults[20] is randomTileAmount
                coderesults.push(JSON.parse(window.atob(codebits[23]))); //coderesults[21] is directions
                coderesults.push(Number(window.atob(codebits[24]))); //coderesults[22] is nextTiles
                if (codebits[25] == "t") coderesults.push(true); //coderesults[23] is whether the amount of moves so far is displayed
                else if (codebits[25] == "f") coderesults.push(false);
                else throw "Invalid moves display";
                if (codebits[26] == "t") coderesults.push(true); //coderesults[24] is whether the amount of merges so far is displayed
                else if (codebits[26] == "f") coderesults.push(false);
                else throw "Invalid moves display";
                coderesults.push(JSON.parse(window.atob(codebits[27]))); //coderesults[25] is game_vars
                coderesults.push(JSON.parse(window.atob(codebits[28]))); //coderesults[26] is spawnConditions
                if (codebits[0] == "@2048PowCompGame") {
                    coderesults.push(JSON.parse(window.atob(codebits[29]))); //coderesults[27] is Grid
                    coderesults.push(Number(window.atob(codebits[30]))); //coderesults[28] is score
                    coderesults.push(Number(window.atob(codebits[31]))); //coderesults[29] is won
                    coderesults.push(JSON.parse(window.atob(codebits[32]))); //coderesults[30] is discoveredTiles
                    coderesults.push(JSON.parse(window.atob(codebits[33]))); //coderesults[31] is discoveredWinning
                    coderesults.push(JSON.parse(window.atob(codebits[34]))); //coderesults[32] is SpawnBoxes
                    coderesults.push(JSON.parse(window.atob(codebits[35]))); //coderesults[33] is directionsAvailable
                    coderesults.push(JSON.parse(window.atob(codebits[36]))); //coderesults[34] is spawnConveyor
                    coderesults.push(Number(window.atob(codebits[37]))); //coderesults[35] is moves_so_far
                    coderesults.push(Number(window.atob(codebits[38]))); //coderesults[36] is merges_so_far
                    coderesults.push(Number(window.atob(codebits[39]))); //coderesults[37] is moves_where_merged
                    coderesults.push(Number(window.atob(codebits[40]))); //coderesults[38] is merges_before_now
                }
                //If we've gotten this far, the import is a success, so it's time to do the actual importing
                width = coderesults[0];
                height = coderesults[1];
                TileNumAmount = coderesults[2];
                TileTypes = coderesults[3];
                for (let t = 0; t < TileTypes.length; t++) {
                    if (TileTypes[t].length > 4) TileTypes[t].splice(4, 0, "none");
                    if (TileTypes[t].length > 7) for (let i = 7; i < TileTypes[t].length; i++) TileTypes[t][i].unshift("Innerscript");
                }
                updateAtSign(TileTypes, 1.0);
                MergeRules = coderesults[4];
                updateAtSign(MergeRules, 1.0);
                startTileSpawns = coderesults[5];
                startingGrid = coderesults[6];
                updateAtSign(startingGrid, 1.0);
                winConditions = coderesults[7];
                winRequirement = coderesults[8];
                multiMerge = coderesults[10];
                document.documentElement.style.setProperty("--background-color", coderesults[11]);
                document.documentElement.style.setProperty("--grid-color", coderesults[12]);
                document.documentElement.style.setProperty("--tile-color", coderesults[13]);
                document.documentElement.style.setProperty("--text-color", coderesults[14]);
                if (codebits[0] == "@2048PowCompGame" && !coderesults[15].includes("<p>This game was resumed from a save code.</p>")) coderesults[15] += "<p>This game was resumed from a save code.</p>";
                document.getElementById("rules_text").innerHTML = coderesults[15];
                statBoxes = [];
                if (coderesults[23]) statBoxes.push(["Moves", "@Moves"]);
                if (coderesults[16]) statBoxes.push(["Discovered Tiles", ["@DiscTiles", "arr_length"]]);
                statBoxes.push(["Score", "@Score"]);
                if (coderesults[17]) statBoxes.push(["Discovered Winning Tiles", ["@DiscWinning", "arr_length"]]);
                if (coderesults[24]) statBoxes.push(["Merges", "@Merges"]);
                spawnLocation = coderesults[18];
                startTileAmount = coderesults[19];
                randomTileAmount = coderesults[20];
                directions = coderesults[21];
                for (let d = 0; d < directions.length; d++) {
                    directions[d][0].push(coderesults[9], 0, [1, true, true, true]);
                    directions[d].splice(3, 0, directions[d][2]);
                }
                nextTiles = coderesults[22];
                start_game_vars = coderesults[25];
                spawnConditions = coderesults[26];
                scripts = [];
                loseConditions = [];
                loseRequirement = false;
                winPriority = true;
                postgameAllowed = true;
                auto_directions = [];
                start_modifier_vars = [];
                forcedSpawns = [];
                hexagonal = false;
                hiddenTileText = false;
                tileDisplayKnownLevel = 2;
                mergeResultKnownLevel = 0;
                gamemode = 0;
                startGame();
                if (codebits[0] == "@2048PowCompGame") {
                    Grid = coderesults[27];
                    updateAtSign(Grid, 1.0);
                    score = coderesults[28];
                    won = coderesults[29];
                    discoveredTiles = coderesults[30];
                    discoveredWinning = coderesults[31];
                    SpawnBoxes = coderesults[32];
                    directionsAvailable = coderesults[33];
                    spawnConveyor = coderesults[34];
                    moves_so_far = coderesults[35];
                    merges_so_far = coderesults[36];
                    moves_where_merged = coderesults[37];
                    merges_before_now = coderesults[38];
                    discoveredLosing = [];
                    manual_moves_so_far = moves_so_far;
                    possibleOverChecked = false;
                    displayGrid();
                    displayButtons(true);
                }
            }
            else throw "Invalid update";
        }
        else if (codebits[0] == "@2048PowCompCustom") {
            if (codebits[1] == "2.0") {
                coderesults.push(SCparse(window.atob(codebits[2]))); //coderesults[0] is customSpawningTiles
                coderesults.push(SCparse(window.atob(codebits[3]))); //coderesults[1] is customMerges
                coderesults.push(SCparse(window.atob(codebits[4]))); //coderesults[2] is customColors
                coderesults.push(SCparse(window.atob(codebits[5]))); //coderesults[3] is customBackground
                coderesults.push(SCparse(window.atob(codebits[6]))); //coderesults[4] is customWins
                coderesults.push(SCparse(window.atob(codebits[7]))); //coderesults[5] is customLosses
                coderesults.push(SCparse(window.atob(codebits[8]))); //coderesults[6] is customRulesText
                //If we've gotten this far, the import is a success, so it's time to do the actual importing
                customSpawningTiles = coderesults[0];
                if (typeof customSpawningTiles[0] != "boolean") customSpawningTiles.unshift(false);
                customMerges = coderesults[1];
                for (let m = 0; m < customMerges.length; m++) {
                    if (customMerges[m][4] === undefined) customMerges[m][4] = false;
                }
                customColors = coderesults[2];
                customBackground = coderesults[3];
                customWins = coderesults[4];
                customLosses = coderesults[5];
                customRulesText = coderesults[6];
                if (customRulesText[3] == undefined) customRulesText[3] = 0;
                if (subScreen == "CustomImport") switchScreen("CustomMode", "SpawningTiles");
                else loadMode(-1);
            }
            else throw "Invalid update";
        }
        else if (codebits[0] == "@2048PowCompModifiers") {
            if (codebits[1] == "2.1") {
                coderesults.push(SCparse(window.atob(codebits[2]))); //coderesults[0] is modifiers
                coderesults.push(SCparse(window.atob(codebits[3]))); //coderesults[1] is auto_directions
                if (coderesults[0][5] === "Custom") {
                    coderesults.push(SCparse(window.atob(codebits[4]))); //coderesults[2] is width
                    coderesults.push(SCparse(window.atob(codebits[5]))); //coderesults[3] is height
                    coderesults.push(SCparse(window.atob(codebits[6]))); //coderesults[4] is hexagonal
                    coderesults.push(SCparse(window.atob(codebits[7]))); //coderesults[5] is startingGrid
                    coderesults.push(SCparse(window.atob(codebits[8]))); //coderesults[6] is directions
                }
                //If we've gotten this far, the import is a success, so it's time to do the actual importing
                let animSpeed = modifiers[16]
                modifiers = coderesults[0];
                modifiers.splice(16, 0, animSpeed); // Reinsert animation speed into the modifiers
                auto_directions = coderesults[1];
                if (modifiers[5] == "Custom") {
                    width = coderesults[2];
                    height = coderesults[3];
                    hexagonal = coderesults[4];
                    createCustomGrid();
                    startingGrid = coderesults[5];
                    directions = coderesults[6];
                    for (let t of document.getElementById("modifiers_customGrid").children) {
                        displayCustomTile(t);
                    }
                }
                switchScreen("Modifiers", 1);
            }
            else throw "Invalid update";
        }
        else throw "Invalid save code type";
    }
    catch (err) {
        if (typeof err == "object") {
            document.getElementById("save_code_box").value = "There was an error with importing your save code: " + err.name + " " + err.message;
        }
        else document.getElementById("save_code_box").value = "There was an error with importing your save code: " + err;
    }
}

function displaySaveCodeMode(screen, mode) {
    if (screen == "Save Code") {
        document.getElementById("save_code_button_container_1").style.setProperty("display", "flex");
        document.getElementById("save_code_button_container_custom").style.setProperty("display", "none");
        if (mode == -1) {
            document.getElementById("save_code_return_game").style.setProperty("display", "none");
            document.getElementById("save_code_return_menu").style.setProperty("display", "inline-block");
            document.getElementById("save_code_import").style.setProperty("display", "inline-block");
            document.getElementById("save_code_type").style.setProperty("display", "none");
            displayRules("save_code_heading", ["h2", "Import Save Code"], ["p", 'Paste your save code in the text box below, then click "Import Save Code" to resume your saved game.']);
        }
        else {
            document.getElementById("save_code_return_game").style.setProperty("display", "inline-block");
            document.getElementById("save_code_return_menu").style.setProperty("display", "none");
            document.getElementById("save_code_import").style.setProperty("display", "none");
            document.getElementById("save_code_type").style.setProperty("display", "inline-block");
            if (mode == 0) {
                document.getElementById("save_code_type").innerHTML = "Code Type: In-Progress Game";
                displayRules("save_code_heading", ["h2", "Export Save Code"], ["p", 'Copy this save code, then if you want to resume your game at a later time, click the "Resumed Saved Game" button on the menu and paste the code there.']);
            }
            else if (mode == 1) {
                document.getElementById("save_code_type").innerHTML = "Code Type: New Game with Same Settings";
                displayRules("save_code_heading", ["h2", "Export Save Code"], ["p", 'Copy this save code, then if you want to start a new game of this mode (with the current modifiers) at a later time, click the "Resumed Saved Game" button on the menu and paste the code there.']);
            }
        }
    }
    else if (screen == "Custom Mode") {
        if (mode == -1) {
            document.getElementById("save_code_button_container_1").style.setProperty("display", "flex");
            document.getElementById("save_code_button_container_custom").style.setProperty("display", "none");
            document.getElementById("save_code_return_game").style.setProperty("display", "none");
            document.getElementById("save_code_return_menu").style.setProperty("display", "inline-block");
            document.getElementById("save_code_import").style.setProperty("display", "inline-block");
            document.getElementById("save_code_type").style.setProperty("display", "none");
            displayRules("save_code_heading", ["h2", "Import Custom Game Save Code"], ["p", 'Paste your save code in the text box below, then click "Import Save Code" to view and alter that Custom Mode\'s settings.']);
        }
        else {
            document.getElementById("save_code_button_container_1").style.setProperty("display", "none");
            document.getElementById("save_code_button_container_custom").style.setProperty("display", "flex");
            document.getElementById("save_code_type").style.setProperty("display", "none");
            displayRules("save_code_heading", ["h2", "Custom Mode Finished!"], ["p", 'Here\'s the save code that contains this Custom Mode! Copy this save code, then if you want to play this mode at a later time, click the "Resumed Saved Game" button on the menu and paste the code there.']);
        }
    }
    else if (screen == "Modifiers") {
        document.getElementById("save_code_button_container_1").style.setProperty("display", "flex");
        document.getElementById("save_code_button_container_custom").style.setProperty("display", "none");
        document.getElementById("save_code_return_game").style.setProperty("display", "none");
        document.getElementById("save_code_return_menu").style.setProperty("display", "inline-block");
        document.getElementById("save_code_import").style.setProperty("display", "inline-block");
        document.getElementById("save_code_type").style.setProperty("display", "none");
        displayRules("save_code_heading", ["h2", "Modifiers Save Code"], ["p", 'This save code contains your current modifiers settings. Copy this save code, then paste it in back here later if you want to restore these settings.']);
    }
}

// Some secret stuff

function OSTDEUpdate(index) {
    if (otherSecretStats[2] == index || index <= 0) {
        otherSecretStats[2] = 0;
        otherSecretStats[3] = 0;
    }
    else {
        otherSecretStats[3]++;
        otherSecretStats[2] = index;
    }
    if (otherSecretStats[3] == 10) {
        otherSecretStats[2] = 0;
        otherSecretStats[3] = 0;
        secretsFound[3] = true;
        otherSecretStats[1] = !otherSecretStats[1];
        if (otherSecretStats[1]) {
            document.getElementById("menu_tile_37").style.setProperty("background-color", "#000000");
            document.getElementById("menu_tile_37").style.setProperty("background-image", "linear-gradient( #ba1aff, #5405ff");
            document.getElementById("menu_tile_37").style.setProperty("--tile_font_size", 3.2);
            document.getElementById("menu_tile_37").innerHTML = "839,808";
            document.getElementById("menu_tile_71").style.setProperty("background-color", "#000000");
            document.getElementById("menu_tile_71").style.setProperty("background-image", "linear-gradient( #50b300, #ae6e04)");
            document.getElementById("menu_tile_71").style.setProperty("--tile_font_size", 3.2);
            document.getElementById("menu_tile_71").innerHTML = "145.965";
        }
        else {
            document.getElementById("menu_tile_37").style.setProperty("background-color", "#af8c00");
            document.getElementById("menu_tile_37").style.setProperty("background-image", "none");
            document.getElementById("menu_tile_37").style.setProperty("--tile_font_size", 3);
            document.getElementById("menu_tile_37").innerHTML = "2216.838";
            document.getElementById("menu_tile_71").style.setProperty("background-color", "#000000");
            document.getElementById("menu_tile_71").style.setProperty("background-image", "linear-gradient( #d6fb00, #f54a00)");
            document.getElementById("menu_tile_71").style.setProperty("--tile_font_size", 2.8);
            document.getElementById("menu_tile_71").innerHTML = "3,188,646";
        }
    }
}

let tileViewerOrder = ["Wildcard 2048", "mod 27", "1321", "180", "DIVE", "2295", "3069", "Odds-Only 3069", "SQUART", "Turatin", "3307", "Bitwise 2048", "SCAPRIM", "1845", "3385", "LOCEF", "TRIGAT", "Gaussian DIVE"]

function displayViewerTile() {
    knownTileDisplayArrays = [];
    knownTileDisplayNodes = [];
    if (subScreen == "Gaussian DIVE") {
        document.getElementById("viewer_number").style.setProperty("display", "none");
        document.getElementById("viewer_gaussian_number").style.setProperty("display", "block");
        document.getElementById("viewer_gaussian_real_change").value = screenVars[0].real;
        document.getElementById("viewer_gaussian_imaginary_change").value = screenVars[0].imaginary;
        document.getElementById("viewer_gaussian_number_i").innerHTML = "i";
    }
    else {
        document.getElementById("viewer_number").style.setProperty("display", "block");
        document.getElementById("viewer_gaussian_number").style.setProperty("display", "none");
        document.getElementById("viewer_number_change").value = screenVars[0];
    }
    if (hexagonal) {
        document.getElementById("viewer_tile").classList.add("hexagon_clip");
    }
    else document.getElementById("viewer_tile").classList.remove("hexagon_clip");
    document.getElementById("viewer_WildcardText_button").style.setProperty("display", "none");
    document.getElementById("viewer_primes").style.setProperty("display", "none");
    document.getElementById("viewer_base").style.setProperty("display", "none");
    document.getElementById("tile_viewer_scheme").innerHTML = "Color Scheme: " + subScreen;
    if (subScreen == "Wildcard 2048") {
        document.getElementById("tile_viewer_scheme").style.setProperty("color", "#f2b179");
        document.getElementById("viewer_tile").style.setProperty("border-color", "#ece0c2");
        document.getElementById("viewer_WildcardText_button").style.setProperty("display", "block");
        if (screenVars[1]) {
            document.getElementById("viewer_WildcardText_button").innerHTML = "The text on the tile shows all the possibilities.";
            document.getElementById("viewer_WildcardText_button").style.setProperty("background-color", "#c8b68b");
            document.getElementById("viewer_WildcardText_button").style.setProperty("color", "#ffeb3b");
            document.getElementById("viewer_WildcardText_button").style.setProperty("border-color", "#ffeb3b");
        }
        else {
            document.getElementById("viewer_WildcardText_button").innerHTML = "The text on the tile is just the number.";
            document.getElementById("viewer_WildcardText_button").style.setProperty("background-color", "#eb85ff");
            document.getElementById("viewer_WildcardText_button").style.setProperty("color", "#ff5238");
            document.getElementById("viewer_WildcardText_button").style.setProperty("border-color", "#ff5238");
        }
    }
    else if (subScreen == "mod 27") {
        document.getElementById("tile_viewer_scheme").style.setProperty("color", "#d5b5c5");
        document.getElementById("viewer_tile").style.setProperty("border-color", "#c3ed8f");
    }
    else if (subScreen == "1321") {
        document.getElementById("tile_viewer_scheme").style.setProperty("color", "#deeedd");
        document.getElementById("viewer_tile").style.setProperty("border-color", "#94ac93");
    }
    else if (subScreen == "180") {
        document.getElementById("tile_viewer_scheme").style.setProperty("color", "#ffff4d");
        document.getElementById("viewer_tile").style.setProperty("border-color", "#ece0c2");
        document.getElementById("viewer_primes").style.setProperty("display", "block");
        document.getElementById("viewer_primes_change").value = screenVars[1];
    }
    else if (subScreen == "DIVE") {
        document.getElementById("tile_viewer_scheme").style.setProperty("color", "#468");
        document.getElementById("viewer_tile").style.setProperty("border-color", "#9ec3e7");
        document.getElementById("viewer_primes").style.setProperty("display", "block");
        document.getElementById("viewer_primes_change").value = screenVars[1];
    }
    else if (subScreen == "2295") {
        document.getElementById("tile_viewer_scheme").style.setProperty("color", "#f480ff");
        document.getElementById("viewer_tile").style.setProperty("border-color", "#4bcd76");
    }
    else if (subScreen == "3069") {
        document.getElementById("tile_viewer_scheme").style.setProperty("color", "#2e338f");
        document.getElementById("viewer_tile").style.setProperty("border-color", "#793bb6");
        document.getElementById("viewer_primes").style.setProperty("display", "block");
        document.getElementById("viewer_primes_change").value = screenVars[1];
    }
    else if (subScreen == "Odds-Only 3069") {
        document.getElementById("tile_viewer_scheme").style.setProperty("color", "#e1904e");
        document.getElementById("viewer_tile").style.setProperty("border-color", "#eece68");
        document.getElementById("viewer_primes").style.setProperty("display", "block");
        document.getElementById("viewer_primes_change").value = screenVars[1];
    }
    else if (subScreen == "SQUART") {
        document.getElementById("tile_viewer_scheme").style.setProperty("color", "#c4690e");
        document.getElementById("viewer_tile").style.setProperty("border-color", "#c38d47");
        document.getElementById("viewer_primes").style.setProperty("display", "block");
        document.getElementById("viewer_primes_change").value = screenVars[1];
    }
    else if (subScreen == "Turatin") {
        document.getElementById("tile_viewer_scheme").style.setProperty("color", "#d4ff55");
        document.getElementById("viewer_tile").style.setProperty("border-color", "#a7ff55");
    }
    else if (subScreen == "3307") {
        document.getElementById("tile_viewer_scheme").style.setProperty("color", "#b0579e");
        document.getElementById("viewer_tile").style.setProperty("border-color", "#852c8d");
    }
    else if (subScreen == "Bitwise 2048") {
        document.getElementById("tile_viewer_scheme").style.setProperty("color", "#00bee4");
        document.getElementById("viewer_tile").style.setProperty("border-color", "#177f94");
        document.getElementById("viewer_base").style.setProperty("display", "block");
        document.getElementById("viewer_base_change").value = screenVars[1];
    }
    else if (subScreen == "SCAPRIM") {
        document.getElementById("tile_viewer_scheme").style.setProperty("color", " #00bb60");
        document.getElementById("viewer_tile").style.setProperty("border-color", "#baffdd");
        document.getElementById("viewer_primes").style.setProperty("display", "block");
        document.getElementById("viewer_primes_change").value = screenVars[1];
    }
    else if (subScreen == "1845") {
        document.getElementById("tile_viewer_scheme").style.setProperty("color", "#7dc7ff");
        document.getElementById("viewer_tile").style.setProperty("border-color", "#bae1ff");
        document.getElementById("viewer_primes").style.setProperty("display", "block");
        document.getElementById("viewer_primes_change").value = screenVars[1];
    }
    else if (subScreen == "3385") {
        document.getElementById("tile_viewer_scheme").style.setProperty("color", "#7e5bee");
        document.getElementById("viewer_tile").style.setProperty("border-color", "#a391e0");
        document.getElementById("viewer_primes").style.setProperty("display", "block");
        document.getElementById("viewer_primes_change").value = screenVars[1];
    }
    else if (subScreen == "LOCEF") {
        document.getElementById("tile_viewer_scheme").style.setProperty("color", "#c163ff");
        document.getElementById("viewer_tile").style.setProperty("border-color", "#5b00aa");
        document.getElementById("viewer_primes").style.setProperty("display", "block");
        document.getElementById("viewer_primes_change").value = screenVars[1];
    }
    else if (subScreen == "Gaussian DIVE") {
        document.getElementById("tile_viewer_scheme").style.setProperty("color", "#694f00");
        document.getElementById("viewer_tile").style.setProperty("border-color", "#7a5c00");
        document.getElementById("viewer_primes").style.setProperty("display", "block");
        document.getElementById("viewer_primes_change").value = screenVars[1];
        document.getElementById("viewer_WildcardText_button").style.setProperty("display", "none");
    }
    else {
        document.getElementById("tile_viewer_scheme").style.setProperty("color", "#000000");
        document.getElementById("viewer_tile").style.setProperty("border-color", "#000000");
    }
    displayTile("Viewer", document.getElementById("viewer_tile"), "None", "None", [screenVars[0]], [true, "@This 0", "@ColorScheme", subScreen, ["@This 0", screenVars[1]]]);
    if (screenVars[2]) {
        document.getElementById("tile_viewer_previous").style.setProperty("display", "inline-block");
        document.getElementById("tile_viewer_next").style.setProperty("display", "inline-block");
        document.getElementById("viewer_tile_text").style.setProperty("display", "block");
        document.getElementById("viewer_hideNumber").innerHTML = "Hide Number";
        document.getElementById("viewer_hideNumber").style.setProperty("background-color", "#230039");
        document.getElementById("viewer_hideNumber").style.setProperty("color", "#8100d1");
        document.getElementById("viewer_hideNumber").style.setProperty("border-color", "#c363ff");
    }
    else {
        document.getElementById("tile_viewer_previous").style.setProperty("display", "none");
        document.getElementById("tile_viewer_next").style.setProperty("display", "none");
        document.getElementById("viewer_tile_text").style.setProperty("display", "none");
        document.getElementById("viewer_number").style.setProperty("display", "none");
        document.getElementById("viewer_number").style.setProperty("display", "none");
        document.getElementById("viewer_gaussian_number").style.setProperty("display", "none");
        document.getElementById("viewer_WildcardText_button").style.setProperty("display", "none");
        document.getElementById("viewer_primes").style.setProperty("display", "none");
        document.getElementById("viewer_base").style.setProperty("display", "none");
        document.getElementById("viewer_hideNumber").innerHTML = "Show Number";
        document.getElementById("viewer_hideNumber").style.setProperty("background-color", "#ffe9d3");
        document.getElementById("viewer_hideNumber").style.setProperty("color", "#ffb469");
        document.getElementById("viewer_hideNumber").style.setProperty("border-color", "#be5f00");
    }
}

function changeViewerScheme(increment) {
    let index = tileViewerOrder.indexOf(subScreen);
    let oldSubScreen = subScreen;
    subScreen = tileViewerOrder[mod((index + increment), tileViewerOrder.length)];
    index = mod(index + increment, tileViewerOrder.length)
    if (subScreen == "Gaussian DIVE" && !secretsFound[1]) subScreen = tileViewerOrder[mod((index + increment), tileViewerOrder.length)];
    let oldtype = 0;
    if (oldSubScreen == "Gaussian DIVE") oldtype = 1;
    let newtype = 0;
    if (subScreen == "Gaussian DIVE") newtype = 1;
    if (oldtype != newtype) {
        let transition = [0n, 0n];
        if (oldtype == 0) transition = [screenVars[0], 0n];
        else if (oldtype == 1) transition = [screenVars[0].real, screenVars[0].imaginary];
        if (newtype == 0) screenVars[0] = transition[0];
        else if (newtype == 1) screenVars[0] = new GaussianBigInt(transition);
    }
    if (subScreen == "Wildcard 2048") {
        screenVars[1] = true;
    }
    else if (subScreen == "180") {
        screenVars[1] = 48;
    }
    else if (subScreen == "mod 27") {
        screenVars[1] = 180;
    }
    else if (subScreen == "1321") {
        screenVars[1] = 1;
    }
    else if (subScreen == "DIVE" || subScreen == "SQUART" || subScreen == "3385" || subScreen == "LOCEF") {
        screenVars[1] = 168;
    }
    else if (subScreen == "3069" || subScreen == "Odds-Only 3069") {
        screenVars[1] = 96;
    }
    else if (subScreen == "Bitwise 2048") {
        screenVars[1] = 2;
    }
    else if (subScreen == "SCAPRIM") {
        screenVars[1] = Infinity;
    }
    else if (subScreen == "1845") {
        screenVars[1] = 1229;
    }
    else if (subScreen == "Gaussian DIVE") {
        screenVars[1] = 1232;
    }
    switchScreen("Tile Viewer", subScreen);
}

//Testing
function output(output) { //Outputs whatever text is given as a new paragraph on the document
    let literal = false;
    if (arguments.length > 1) literal = arguments[1];
    let testP = document.createElement("p");
    if (literal) {
        let textT = document.createTextNode(boxArrayString(output));
        testP.appendChild(textT);
    }
    else testP.innerHTML = boxArrayString(output);
    testP.classList.add("output");
    document.body.appendChild(testP);
}

function boxArrayString(arr) { // Turns an array into a string, but with brackets around it
    let narr = compendiumStructuredClone(arr);
    if (Array.isArray(narr)) {
        for (let e = 0; e < narr.length; e++) narr[e] = boxArrayString(narr[e]);
        return "[" + narr + "]";
    }
    else return String(arr);
}

let dualTileArray = [
    ["@global_var_retain", ["@Literal"], "arr_push", [["@Var -2", "arr_elem", 0], "*B", ["@Var -1", "arr_elem", 0]], "arr_push", [["@Var -2", "arr_elem", 1], "*B", ["@Var -1", "arr_elem", 1]]],
    ["@global_var_retain", ["@Literal"], "arr_push", [["@Var -2", "arr_elem", 0], "/B", ["@Var -1", "arr_elem", 0]], "arr_push", [["@Var -2", "arr_elem", 1], "/B", ["@Var -1", "arr_elem", 1]]],
    ["@global_var_retain", [["@Var -2", "arr_elem", 0], "modB", ["@Var -1", "arr_elem", 0], "=", 0n], "&&", [["@Var -2", "arr_elem", 1], "modB", ["@Var -1", "arr_elem", 1], "=", 0n]],
    ["@global_var_retain", [0, "@if", [[["@Var -2", "arr_elem", 0], "*B", ["@Var -2", "arr_elem", 1]], "!=", [["@Var -1", "arr_elem", 0], "*B", ["@Var -1", "arr_elem", 1]]], "2nd", [["@Var -2", "arr_elem", 0], "*B", ["@Var -2", "arr_elem", 1]], "-B", [["@Var -1", "arr_elem", 0], "*B", ["@Var -1", "arr_elem", 1]], "Number", "@end-if", "@else-if", [[["@Var -2", "arr_elem", 0], "+B", ["@Var -2", "arr_elem", 1]], "!=", [["@Var -1", "arr_elem", 0], "+B", ["@Var -1", "arr_elem", 1]]], "2nd", [["@Var -2", "arr_elem", 0], "+B", ["@Var -2", "arr_elem", 1]], "-B", [["@Var -1", "arr_elem", 0], "+B", ["@Var -1", "arr_elem", 1]], "Number", "@end-else-if", "@else", "2nd", [["@Var -2", "arr_elem", 0], "-", ["@Var -1", "arr_elem", 0]], "@end-else"]],
    ["@global_var_retain", [["@Var -2", "arr_elem", 0], "gcdB", ["@Var -1", "arr_elem", 0], "=", 1n], "&&", [["@Var -2", "arr_elem", 1], "gcdB", ["@Var -1", "arr_elem", 1], "=", 1n]],
    ["@Literal", 1n, 1n],
    ["@global_var_retain", ["@Var -1", "arr_elem", 0, ">=", 1n], "&&", ["@Var -1", "arr_elem", 1, ">=", 1n]],
    ["@global_var_retain", ["@Var -1", "arr_elem", 0, "=", 1n], "&&", ["@Var -1", "arr_elem", 1, "=", 1n]]
];